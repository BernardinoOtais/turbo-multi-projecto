
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Bm
 * 
 */
export type Bm = $Result.DefaultSelection<Prisma.$BmPayload>
/**
 * Model BmFioComposicao
 * 
 */
export type BmFioComposicao = $Result.DefaultSelection<Prisma.$BmFioComposicaoPayload>
/**
 * Model BmIdBmComposicao
 * 
 */
export type BmIdBmComposicao = $Result.DefaultSelection<Prisma.$BmIdBmComposicaoPayload>
/**
 * Model BmMalhas
 * 
 */
export type BmMalhas = $Result.DefaultSelection<Prisma.$BmMalhasPayload>
/**
 * Model BmMalhasFio
 * 
 */
export type BmMalhasFio = $Result.DefaultSelection<Prisma.$BmMalhasFioPayload>
/**
 * Model BmMalhasFioMovimentos
 * 
 */
export type BmMalhasFioMovimentos = $Result.DefaultSelection<Prisma.$BmMalhasFioMovimentosPayload>
/**
 * Model BmMateriais
 * 
 */
export type BmMateriais = $Result.DefaultSelection<Prisma.$BmMateriaisPayload>
/**
 * Model BmMateriaisComposicao
 * 
 */
export type BmMateriaisComposicao = $Result.DefaultSelection<Prisma.$BmMateriaisComposicaoPayload>
/**
 * Model BmMateriaisFio
 * 
 */
export type BmMateriaisFio = $Result.DefaultSelection<Prisma.$BmMateriaisFioPayload>
/**
 * Model BmMaterialGrupo
 * 
 */
export type BmMaterialGrupo = $Result.DefaultSelection<Prisma.$BmMaterialGrupoPayload>
/**
 * Model BmMaterialGrupoFio
 * 
 */
export type BmMaterialGrupoFio = $Result.DefaultSelection<Prisma.$BmMaterialGrupoFioPayload>
/**
 * Model BmMaterialSubGrupo
 * 
 */
export type BmMaterialSubGrupo = $Result.DefaultSelection<Prisma.$BmMaterialSubGrupoPayload>
/**
 * Model BmMaterialSubGrupoFio
 * 
 */
export type BmMaterialSubGrupoFio = $Result.DefaultSelection<Prisma.$BmMaterialSubGrupoFioPayload>
/**
 * Model BmMovimentosLotes
 * 
 */
export type BmMovimentosLotes = $Result.DefaultSelection<Prisma.$BmMovimentosLotesPayload>
/**
 * Model BmOp
 * 
 */
export type BmOp = $Result.DefaultSelection<Prisma.$BmOpPayload>
/**
 * Model BmOpFaturado
 * 
 */
export type BmOpFaturado = $Result.DefaultSelection<Prisma.$BmOpFaturadoPayload>
/**
 * Model BmOpsPorMalha
 * 
 */
export type BmOpsPorMalha = $Result.DefaultSelection<Prisma.$BmOpsPorMalhaPayload>
/**
 * Model BmOpsPorMalhaFio
 * 
 */
export type BmOpsPorMalhaFio = $Result.DefaultSelection<Prisma.$BmOpsPorMalhaFioPayload>
/**
 * Model BmTc
 * 
 */
export type BmTc = $Result.DefaultSelection<Prisma.$BmTcPayload>
/**
 * Model DataCamiao
 * 
 */
export type DataCamiao = $Result.DefaultSelection<Prisma.$DataCamiaoPayload>
/**
 * Model DataEnvio
 * 
 */
export type DataEnvio = $Result.DefaultSelection<Prisma.$DataEnvioPayload>
/**
 * Model Fornecedor
 * 
 */
export type Fornecedor = $Result.DefaultSelection<Prisma.$FornecedorPayload>
/**
 * Model Livre
 * 
 */
export type Livre = $Result.DefaultSelection<Prisma.$LivrePayload>
/**
 * Model Op
 * 
 */
export type Op = $Result.DefaultSelection<Prisma.$OpPayload>
/**
 * Model OrcamentoLivre
 * 
 */
export type OrcamentoLivre = $Result.DefaultSelection<Prisma.$OrcamentoLivrePayload>
/**
 * Model OrcamentoLivreLinhas
 * 
 */
export type OrcamentoLivreLinhas = $Result.DefaultSelection<Prisma.$OrcamentoLivreLinhasPayload>
/**
 * Model OrcamentoOp
 * 
 */
export type OrcamentoOp = $Result.DefaultSelection<Prisma.$OrcamentoOpPayload>
/**
 * Model OrcamentoOpLinhas
 * 
 */
export type OrcamentoOpLinhas = $Result.DefaultSelection<Prisma.$OrcamentoOpLinhasPayload>
/**
 * Model Papeis
 * 
 */
export type Papeis = $Result.DefaultSelection<Prisma.$PapeisPayload>
/**
 * Model Planeamento
 * 
 */
export type Planeamento = $Result.DefaultSelection<Prisma.$PlaneamentoPayload>
/**
 * Model ServicosEscolhidosLivre
 * 
 */
export type ServicosEscolhidosLivre = $Result.DefaultSelection<Prisma.$ServicosEscolhidosLivrePayload>
/**
 * Model ServicosEscolhidosLivreOrigem
 * 
 */
export type ServicosEscolhidosLivreOrigem = $Result.DefaultSelection<Prisma.$ServicosEscolhidosLivreOrigemPayload>
/**
 * Model ServicosEscolhidosOp
 * 
 */
export type ServicosEscolhidosOp = $Result.DefaultSelection<Prisma.$ServicosEscolhidosOpPayload>
/**
 * Model ServicosEscolhidosOpOrigem
 * 
 */
export type ServicosEscolhidosOpOrigem = $Result.DefaultSelection<Prisma.$ServicosEscolhidosOpOrigemPayload>
/**
 * Model sysdiagrams
 * 
 */
export type sysdiagrams = $Result.DefaultSelection<Prisma.$sysdiagramsPayload>
/**
 * Model Tc
 * 
 */
export type Tc = $Result.DefaultSelection<Prisma.$TcPayload>
/**
 * Model TcCompraConteudo
 * 
 */
export type TcCompraConteudo = $Result.DefaultSelection<Prisma.$TcCompraConteudoPayload>
/**
 * Model TcCompraConteudoEntrada
 * 
 */
export type TcCompraConteudoEntrada = $Result.DefaultSelection<Prisma.$TcCompraConteudoEntradaPayload>
/**
 * Model TcCompraConteudoEntradaFaturada
 * 
 */
export type TcCompraConteudoEntradaFaturada = $Result.DefaultSelection<Prisma.$TcCompraConteudoEntradaFaturadaPayload>
/**
 * Model TcOp
 * 
 */
export type TcOp = $Result.DefaultSelection<Prisma.$TcOpPayload>
/**
 * Model TcOpCompra
 * 
 */
export type TcOpCompra = $Result.DefaultSelection<Prisma.$TcOpCompraPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserPapeis
 * 
 */
export type UserPapeis = $Result.DefaultSelection<Prisma.$UserPapeisPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bms
 * const bms = await prisma.bm.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bms
   * const bms = await prisma.bm.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.bm`: Exposes CRUD operations for the **Bm** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bms
    * const bms = await prisma.bm.findMany()
    * ```
    */
  get bm(): Prisma.BmDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmFioComposicao`: Exposes CRUD operations for the **BmFioComposicao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmFioComposicaos
    * const bmFioComposicaos = await prisma.bmFioComposicao.findMany()
    * ```
    */
  get bmFioComposicao(): Prisma.BmFioComposicaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmIdBmComposicao`: Exposes CRUD operations for the **BmIdBmComposicao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmIdBmComposicaos
    * const bmIdBmComposicaos = await prisma.bmIdBmComposicao.findMany()
    * ```
    */
  get bmIdBmComposicao(): Prisma.BmIdBmComposicaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMalhas`: Exposes CRUD operations for the **BmMalhas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMalhas
    * const bmMalhas = await prisma.bmMalhas.findMany()
    * ```
    */
  get bmMalhas(): Prisma.BmMalhasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMalhasFio`: Exposes CRUD operations for the **BmMalhasFio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMalhasFios
    * const bmMalhasFios = await prisma.bmMalhasFio.findMany()
    * ```
    */
  get bmMalhasFio(): Prisma.BmMalhasFioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMalhasFioMovimentos`: Exposes CRUD operations for the **BmMalhasFioMovimentos** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMalhasFioMovimentos
    * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.findMany()
    * ```
    */
  get bmMalhasFioMovimentos(): Prisma.BmMalhasFioMovimentosDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMateriais`: Exposes CRUD operations for the **BmMateriais** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMateriais
    * const bmMateriais = await prisma.bmMateriais.findMany()
    * ```
    */
  get bmMateriais(): Prisma.BmMateriaisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMateriaisComposicao`: Exposes CRUD operations for the **BmMateriaisComposicao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMateriaisComposicaos
    * const bmMateriaisComposicaos = await prisma.bmMateriaisComposicao.findMany()
    * ```
    */
  get bmMateriaisComposicao(): Prisma.BmMateriaisComposicaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMateriaisFio`: Exposes CRUD operations for the **BmMateriaisFio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMateriaisFios
    * const bmMateriaisFios = await prisma.bmMateriaisFio.findMany()
    * ```
    */
  get bmMateriaisFio(): Prisma.BmMateriaisFioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMaterialGrupo`: Exposes CRUD operations for the **BmMaterialGrupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMaterialGrupos
    * const bmMaterialGrupos = await prisma.bmMaterialGrupo.findMany()
    * ```
    */
  get bmMaterialGrupo(): Prisma.BmMaterialGrupoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMaterialGrupoFio`: Exposes CRUD operations for the **BmMaterialGrupoFio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMaterialGrupoFios
    * const bmMaterialGrupoFios = await prisma.bmMaterialGrupoFio.findMany()
    * ```
    */
  get bmMaterialGrupoFio(): Prisma.BmMaterialGrupoFioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMaterialSubGrupo`: Exposes CRUD operations for the **BmMaterialSubGrupo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMaterialSubGrupos
    * const bmMaterialSubGrupos = await prisma.bmMaterialSubGrupo.findMany()
    * ```
    */
  get bmMaterialSubGrupo(): Prisma.BmMaterialSubGrupoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMaterialSubGrupoFio`: Exposes CRUD operations for the **BmMaterialSubGrupoFio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMaterialSubGrupoFios
    * const bmMaterialSubGrupoFios = await prisma.bmMaterialSubGrupoFio.findMany()
    * ```
    */
  get bmMaterialSubGrupoFio(): Prisma.BmMaterialSubGrupoFioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmMovimentosLotes`: Exposes CRUD operations for the **BmMovimentosLotes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmMovimentosLotes
    * const bmMovimentosLotes = await prisma.bmMovimentosLotes.findMany()
    * ```
    */
  get bmMovimentosLotes(): Prisma.BmMovimentosLotesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmOp`: Exposes CRUD operations for the **BmOp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmOps
    * const bmOps = await prisma.bmOp.findMany()
    * ```
    */
  get bmOp(): Prisma.BmOpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmOpFaturado`: Exposes CRUD operations for the **BmOpFaturado** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmOpFaturados
    * const bmOpFaturados = await prisma.bmOpFaturado.findMany()
    * ```
    */
  get bmOpFaturado(): Prisma.BmOpFaturadoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmOpsPorMalha`: Exposes CRUD operations for the **BmOpsPorMalha** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmOpsPorMalhas
    * const bmOpsPorMalhas = await prisma.bmOpsPorMalha.findMany()
    * ```
    */
  get bmOpsPorMalha(): Prisma.BmOpsPorMalhaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmOpsPorMalhaFio`: Exposes CRUD operations for the **BmOpsPorMalhaFio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmOpsPorMalhaFios
    * const bmOpsPorMalhaFios = await prisma.bmOpsPorMalhaFio.findMany()
    * ```
    */
  get bmOpsPorMalhaFio(): Prisma.BmOpsPorMalhaFioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bmTc`: Exposes CRUD operations for the **BmTc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BmTcs
    * const bmTcs = await prisma.bmTc.findMany()
    * ```
    */
  get bmTc(): Prisma.BmTcDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataCamiao`: Exposes CRUD operations for the **DataCamiao** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataCamiaos
    * const dataCamiaos = await prisma.dataCamiao.findMany()
    * ```
    */
  get dataCamiao(): Prisma.DataCamiaoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dataEnvio`: Exposes CRUD operations for the **DataEnvio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataEnvios
    * const dataEnvios = await prisma.dataEnvio.findMany()
    * ```
    */
  get dataEnvio(): Prisma.DataEnvioDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fornecedor`: Exposes CRUD operations for the **Fornecedor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fornecedors
    * const fornecedors = await prisma.fornecedor.findMany()
    * ```
    */
  get fornecedor(): Prisma.FornecedorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.livre`: Exposes CRUD operations for the **Livre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Livres
    * const livres = await prisma.livre.findMany()
    * ```
    */
  get livre(): Prisma.LivreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.op`: Exposes CRUD operations for the **Op** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ops
    * const ops = await prisma.op.findMany()
    * ```
    */
  get op(): Prisma.OpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orcamentoLivre`: Exposes CRUD operations for the **OrcamentoLivre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrcamentoLivres
    * const orcamentoLivres = await prisma.orcamentoLivre.findMany()
    * ```
    */
  get orcamentoLivre(): Prisma.OrcamentoLivreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orcamentoLivreLinhas`: Exposes CRUD operations for the **OrcamentoLivreLinhas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrcamentoLivreLinhas
    * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.findMany()
    * ```
    */
  get orcamentoLivreLinhas(): Prisma.OrcamentoLivreLinhasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orcamentoOp`: Exposes CRUD operations for the **OrcamentoOp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrcamentoOps
    * const orcamentoOps = await prisma.orcamentoOp.findMany()
    * ```
    */
  get orcamentoOp(): Prisma.OrcamentoOpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orcamentoOpLinhas`: Exposes CRUD operations for the **OrcamentoOpLinhas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrcamentoOpLinhas
    * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.findMany()
    * ```
    */
  get orcamentoOpLinhas(): Prisma.OrcamentoOpLinhasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.papeis`: Exposes CRUD operations for the **Papeis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Papeis
    * const papeis = await prisma.papeis.findMany()
    * ```
    */
  get papeis(): Prisma.PapeisDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.planeamento`: Exposes CRUD operations for the **Planeamento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Planeamentos
    * const planeamentos = await prisma.planeamento.findMany()
    * ```
    */
  get planeamento(): Prisma.PlaneamentoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicosEscolhidosLivre`: Exposes CRUD operations for the **ServicosEscolhidosLivre** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicosEscolhidosLivres
    * const servicosEscolhidosLivres = await prisma.servicosEscolhidosLivre.findMany()
    * ```
    */
  get servicosEscolhidosLivre(): Prisma.ServicosEscolhidosLivreDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicosEscolhidosLivreOrigem`: Exposes CRUD operations for the **ServicosEscolhidosLivreOrigem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicosEscolhidosLivreOrigems
    * const servicosEscolhidosLivreOrigems = await prisma.servicosEscolhidosLivreOrigem.findMany()
    * ```
    */
  get servicosEscolhidosLivreOrigem(): Prisma.ServicosEscolhidosLivreOrigemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicosEscolhidosOp`: Exposes CRUD operations for the **ServicosEscolhidosOp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicosEscolhidosOps
    * const servicosEscolhidosOps = await prisma.servicosEscolhidosOp.findMany()
    * ```
    */
  get servicosEscolhidosOp(): Prisma.ServicosEscolhidosOpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicosEscolhidosOpOrigem`: Exposes CRUD operations for the **ServicosEscolhidosOpOrigem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicosEscolhidosOpOrigems
    * const servicosEscolhidosOpOrigems = await prisma.servicosEscolhidosOpOrigem.findMany()
    * ```
    */
  get servicosEscolhidosOpOrigem(): Prisma.ServicosEscolhidosOpOrigemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sysdiagrams`: Exposes CRUD operations for the **sysdiagrams** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sysdiagrams
    * const sysdiagrams = await prisma.sysdiagrams.findMany()
    * ```
    */
  get sysdiagrams(): Prisma.sysdiagramsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tc`: Exposes CRUD operations for the **Tc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tcs
    * const tcs = await prisma.tc.findMany()
    * ```
    */
  get tc(): Prisma.TcDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tcCompraConteudo`: Exposes CRUD operations for the **TcCompraConteudo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TcCompraConteudos
    * const tcCompraConteudos = await prisma.tcCompraConteudo.findMany()
    * ```
    */
  get tcCompraConteudo(): Prisma.TcCompraConteudoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tcCompraConteudoEntrada`: Exposes CRUD operations for the **TcCompraConteudoEntrada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TcCompraConteudoEntradas
    * const tcCompraConteudoEntradas = await prisma.tcCompraConteudoEntrada.findMany()
    * ```
    */
  get tcCompraConteudoEntrada(): Prisma.TcCompraConteudoEntradaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tcCompraConteudoEntradaFaturada`: Exposes CRUD operations for the **TcCompraConteudoEntradaFaturada** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TcCompraConteudoEntradaFaturadas
    * const tcCompraConteudoEntradaFaturadas = await prisma.tcCompraConteudoEntradaFaturada.findMany()
    * ```
    */
  get tcCompraConteudoEntradaFaturada(): Prisma.TcCompraConteudoEntradaFaturadaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tcOp`: Exposes CRUD operations for the **TcOp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TcOps
    * const tcOps = await prisma.tcOp.findMany()
    * ```
    */
  get tcOp(): Prisma.TcOpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tcOpCompra`: Exposes CRUD operations for the **TcOpCompra** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TcOpCompras
    * const tcOpCompras = await prisma.tcOpCompra.findMany()
    * ```
    */
  get tcOpCompra(): Prisma.TcOpCompraDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPapeis`: Exposes CRUD operations for the **UserPapeis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPapeis
    * const userPapeis = await prisma.userPapeis.findMany()
    * ```
    */
  get userPapeis(): Prisma.UserPapeisDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.3.1
   * Query Engine version: acc0b9dd43eb689cbd20c9470515d719db10d0b0
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Bm: 'Bm',
    BmFioComposicao: 'BmFioComposicao',
    BmIdBmComposicao: 'BmIdBmComposicao',
    BmMalhas: 'BmMalhas',
    BmMalhasFio: 'BmMalhasFio',
    BmMalhasFioMovimentos: 'BmMalhasFioMovimentos',
    BmMateriais: 'BmMateriais',
    BmMateriaisComposicao: 'BmMateriaisComposicao',
    BmMateriaisFio: 'BmMateriaisFio',
    BmMaterialGrupo: 'BmMaterialGrupo',
    BmMaterialGrupoFio: 'BmMaterialGrupoFio',
    BmMaterialSubGrupo: 'BmMaterialSubGrupo',
    BmMaterialSubGrupoFio: 'BmMaterialSubGrupoFio',
    BmMovimentosLotes: 'BmMovimentosLotes',
    BmOp: 'BmOp',
    BmOpFaturado: 'BmOpFaturado',
    BmOpsPorMalha: 'BmOpsPorMalha',
    BmOpsPorMalhaFio: 'BmOpsPorMalhaFio',
    BmTc: 'BmTc',
    DataCamiao: 'DataCamiao',
    DataEnvio: 'DataEnvio',
    Fornecedor: 'Fornecedor',
    Livre: 'Livre',
    Op: 'Op',
    OrcamentoLivre: 'OrcamentoLivre',
    OrcamentoLivreLinhas: 'OrcamentoLivreLinhas',
    OrcamentoOp: 'OrcamentoOp',
    OrcamentoOpLinhas: 'OrcamentoOpLinhas',
    Papeis: 'Papeis',
    Planeamento: 'Planeamento',
    ServicosEscolhidosLivre: 'ServicosEscolhidosLivre',
    ServicosEscolhidosLivreOrigem: 'ServicosEscolhidosLivreOrigem',
    ServicosEscolhidosOp: 'ServicosEscolhidosOp',
    ServicosEscolhidosOpOrigem: 'ServicosEscolhidosOpOrigem',
    sysdiagrams: 'sysdiagrams',
    Tc: 'Tc',
    TcCompraConteudo: 'TcCompraConteudo',
    TcCompraConteudoEntrada: 'TcCompraConteudoEntrada',
    TcCompraConteudoEntradaFaturada: 'TcCompraConteudoEntradaFaturada',
    TcOp: 'TcOp',
    TcOpCompra: 'TcOpCompra',
    User: 'User',
    UserPapeis: 'UserPapeis'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "bm" | "bmFioComposicao" | "bmIdBmComposicao" | "bmMalhas" | "bmMalhasFio" | "bmMalhasFioMovimentos" | "bmMateriais" | "bmMateriaisComposicao" | "bmMateriaisFio" | "bmMaterialGrupo" | "bmMaterialGrupoFio" | "bmMaterialSubGrupo" | "bmMaterialSubGrupoFio" | "bmMovimentosLotes" | "bmOp" | "bmOpFaturado" | "bmOpsPorMalha" | "bmOpsPorMalhaFio" | "bmTc" | "dataCamiao" | "dataEnvio" | "fornecedor" | "livre" | "op" | "orcamentoLivre" | "orcamentoLivreLinhas" | "orcamentoOp" | "orcamentoOpLinhas" | "papeis" | "planeamento" | "servicosEscolhidosLivre" | "servicosEscolhidosLivreOrigem" | "servicosEscolhidosOp" | "servicosEscolhidosOpOrigem" | "sysdiagrams" | "tc" | "tcCompraConteudo" | "tcCompraConteudoEntrada" | "tcCompraConteudoEntradaFaturada" | "tcOp" | "tcOpCompra" | "user" | "userPapeis"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Bm: {
        payload: Prisma.$BmPayload<ExtArgs>
        fields: Prisma.BmFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload>
          }
          findFirst: {
            args: Prisma.BmFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload>
          }
          findMany: {
            args: Prisma.BmFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload>[]
          }
          create: {
            args: Prisma.BmCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload>
          }
          createMany: {
            args: Prisma.BmCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload>
          }
          update: {
            args: Prisma.BmUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload>
          }
          deleteMany: {
            args: Prisma.BmDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmPayload>
          }
          aggregate: {
            args: Prisma.BmAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBm>
          }
          groupBy: {
            args: Prisma.BmGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmCountArgs<ExtArgs>
            result: $Utils.Optional<BmCountAggregateOutputType> | number
          }
        }
      }
      BmFioComposicao: {
        payload: Prisma.$BmFioComposicaoPayload<ExtArgs>
        fields: Prisma.BmFioComposicaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmFioComposicaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmFioComposicaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload>
          }
          findFirst: {
            args: Prisma.BmFioComposicaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmFioComposicaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload>
          }
          findMany: {
            args: Prisma.BmFioComposicaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload>[]
          }
          create: {
            args: Prisma.BmFioComposicaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload>
          }
          createMany: {
            args: Prisma.BmFioComposicaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmFioComposicaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload>
          }
          update: {
            args: Prisma.BmFioComposicaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload>
          }
          deleteMany: {
            args: Prisma.BmFioComposicaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmFioComposicaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmFioComposicaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmFioComposicaoPayload>
          }
          aggregate: {
            args: Prisma.BmFioComposicaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmFioComposicao>
          }
          groupBy: {
            args: Prisma.BmFioComposicaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmFioComposicaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmFioComposicaoCountArgs<ExtArgs>
            result: $Utils.Optional<BmFioComposicaoCountAggregateOutputType> | number
          }
        }
      }
      BmIdBmComposicao: {
        payload: Prisma.$BmIdBmComposicaoPayload<ExtArgs>
        fields: Prisma.BmIdBmComposicaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmIdBmComposicaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmIdBmComposicaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload>
          }
          findFirst: {
            args: Prisma.BmIdBmComposicaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmIdBmComposicaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload>
          }
          findMany: {
            args: Prisma.BmIdBmComposicaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload>[]
          }
          create: {
            args: Prisma.BmIdBmComposicaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload>
          }
          createMany: {
            args: Prisma.BmIdBmComposicaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmIdBmComposicaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload>
          }
          update: {
            args: Prisma.BmIdBmComposicaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload>
          }
          deleteMany: {
            args: Prisma.BmIdBmComposicaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmIdBmComposicaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmIdBmComposicaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmIdBmComposicaoPayload>
          }
          aggregate: {
            args: Prisma.BmIdBmComposicaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmIdBmComposicao>
          }
          groupBy: {
            args: Prisma.BmIdBmComposicaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmIdBmComposicaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmIdBmComposicaoCountArgs<ExtArgs>
            result: $Utils.Optional<BmIdBmComposicaoCountAggregateOutputType> | number
          }
        }
      }
      BmMalhas: {
        payload: Prisma.$BmMalhasPayload<ExtArgs>
        fields: Prisma.BmMalhasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMalhasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMalhasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload>
          }
          findFirst: {
            args: Prisma.BmMalhasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMalhasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload>
          }
          findMany: {
            args: Prisma.BmMalhasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload>[]
          }
          create: {
            args: Prisma.BmMalhasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload>
          }
          createMany: {
            args: Prisma.BmMalhasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMalhasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload>
          }
          update: {
            args: Prisma.BmMalhasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload>
          }
          deleteMany: {
            args: Prisma.BmMalhasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMalhasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMalhasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasPayload>
          }
          aggregate: {
            args: Prisma.BmMalhasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMalhas>
          }
          groupBy: {
            args: Prisma.BmMalhasGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMalhasGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMalhasCountArgs<ExtArgs>
            result: $Utils.Optional<BmMalhasCountAggregateOutputType> | number
          }
        }
      }
      BmMalhasFio: {
        payload: Prisma.$BmMalhasFioPayload<ExtArgs>
        fields: Prisma.BmMalhasFioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMalhasFioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMalhasFioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload>
          }
          findFirst: {
            args: Prisma.BmMalhasFioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMalhasFioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload>
          }
          findMany: {
            args: Prisma.BmMalhasFioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload>[]
          }
          create: {
            args: Prisma.BmMalhasFioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload>
          }
          createMany: {
            args: Prisma.BmMalhasFioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMalhasFioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload>
          }
          update: {
            args: Prisma.BmMalhasFioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload>
          }
          deleteMany: {
            args: Prisma.BmMalhasFioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMalhasFioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMalhasFioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioPayload>
          }
          aggregate: {
            args: Prisma.BmMalhasFioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMalhasFio>
          }
          groupBy: {
            args: Prisma.BmMalhasFioGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMalhasFioGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMalhasFioCountArgs<ExtArgs>
            result: $Utils.Optional<BmMalhasFioCountAggregateOutputType> | number
          }
        }
      }
      BmMalhasFioMovimentos: {
        payload: Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>
        fields: Prisma.BmMalhasFioMovimentosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMalhasFioMovimentosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMalhasFioMovimentosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload>
          }
          findFirst: {
            args: Prisma.BmMalhasFioMovimentosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMalhasFioMovimentosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload>
          }
          findMany: {
            args: Prisma.BmMalhasFioMovimentosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload>[]
          }
          create: {
            args: Prisma.BmMalhasFioMovimentosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload>
          }
          createMany: {
            args: Prisma.BmMalhasFioMovimentosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMalhasFioMovimentosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload>
          }
          update: {
            args: Prisma.BmMalhasFioMovimentosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload>
          }
          deleteMany: {
            args: Prisma.BmMalhasFioMovimentosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMalhasFioMovimentosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMalhasFioMovimentosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMalhasFioMovimentosPayload>
          }
          aggregate: {
            args: Prisma.BmMalhasFioMovimentosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMalhasFioMovimentos>
          }
          groupBy: {
            args: Prisma.BmMalhasFioMovimentosGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMalhasFioMovimentosGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMalhasFioMovimentosCountArgs<ExtArgs>
            result: $Utils.Optional<BmMalhasFioMovimentosCountAggregateOutputType> | number
          }
        }
      }
      BmMateriais: {
        payload: Prisma.$BmMateriaisPayload<ExtArgs>
        fields: Prisma.BmMateriaisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMateriaisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMateriaisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload>
          }
          findFirst: {
            args: Prisma.BmMateriaisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMateriaisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload>
          }
          findMany: {
            args: Prisma.BmMateriaisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload>[]
          }
          create: {
            args: Prisma.BmMateriaisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload>
          }
          createMany: {
            args: Prisma.BmMateriaisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMateriaisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload>
          }
          update: {
            args: Prisma.BmMateriaisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload>
          }
          deleteMany: {
            args: Prisma.BmMateriaisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMateriaisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMateriaisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisPayload>
          }
          aggregate: {
            args: Prisma.BmMateriaisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMateriais>
          }
          groupBy: {
            args: Prisma.BmMateriaisGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMateriaisGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMateriaisCountArgs<ExtArgs>
            result: $Utils.Optional<BmMateriaisCountAggregateOutputType> | number
          }
        }
      }
      BmMateriaisComposicao: {
        payload: Prisma.$BmMateriaisComposicaoPayload<ExtArgs>
        fields: Prisma.BmMateriaisComposicaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMateriaisComposicaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMateriaisComposicaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload>
          }
          findFirst: {
            args: Prisma.BmMateriaisComposicaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMateriaisComposicaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload>
          }
          findMany: {
            args: Prisma.BmMateriaisComposicaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload>[]
          }
          create: {
            args: Prisma.BmMateriaisComposicaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload>
          }
          createMany: {
            args: Prisma.BmMateriaisComposicaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMateriaisComposicaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload>
          }
          update: {
            args: Prisma.BmMateriaisComposicaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload>
          }
          deleteMany: {
            args: Prisma.BmMateriaisComposicaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMateriaisComposicaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMateriaisComposicaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisComposicaoPayload>
          }
          aggregate: {
            args: Prisma.BmMateriaisComposicaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMateriaisComposicao>
          }
          groupBy: {
            args: Prisma.BmMateriaisComposicaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMateriaisComposicaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMateriaisComposicaoCountArgs<ExtArgs>
            result: $Utils.Optional<BmMateriaisComposicaoCountAggregateOutputType> | number
          }
        }
      }
      BmMateriaisFio: {
        payload: Prisma.$BmMateriaisFioPayload<ExtArgs>
        fields: Prisma.BmMateriaisFioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMateriaisFioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMateriaisFioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload>
          }
          findFirst: {
            args: Prisma.BmMateriaisFioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMateriaisFioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload>
          }
          findMany: {
            args: Prisma.BmMateriaisFioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload>[]
          }
          create: {
            args: Prisma.BmMateriaisFioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload>
          }
          createMany: {
            args: Prisma.BmMateriaisFioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMateriaisFioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload>
          }
          update: {
            args: Prisma.BmMateriaisFioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload>
          }
          deleteMany: {
            args: Prisma.BmMateriaisFioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMateriaisFioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMateriaisFioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMateriaisFioPayload>
          }
          aggregate: {
            args: Prisma.BmMateriaisFioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMateriaisFio>
          }
          groupBy: {
            args: Prisma.BmMateriaisFioGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMateriaisFioGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMateriaisFioCountArgs<ExtArgs>
            result: $Utils.Optional<BmMateriaisFioCountAggregateOutputType> | number
          }
        }
      }
      BmMaterialGrupo: {
        payload: Prisma.$BmMaterialGrupoPayload<ExtArgs>
        fields: Prisma.BmMaterialGrupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMaterialGrupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMaterialGrupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload>
          }
          findFirst: {
            args: Prisma.BmMaterialGrupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMaterialGrupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload>
          }
          findMany: {
            args: Prisma.BmMaterialGrupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload>[]
          }
          create: {
            args: Prisma.BmMaterialGrupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload>
          }
          createMany: {
            args: Prisma.BmMaterialGrupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMaterialGrupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload>
          }
          update: {
            args: Prisma.BmMaterialGrupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload>
          }
          deleteMany: {
            args: Prisma.BmMaterialGrupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMaterialGrupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMaterialGrupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoPayload>
          }
          aggregate: {
            args: Prisma.BmMaterialGrupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMaterialGrupo>
          }
          groupBy: {
            args: Prisma.BmMaterialGrupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialGrupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMaterialGrupoCountArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialGrupoCountAggregateOutputType> | number
          }
        }
      }
      BmMaterialGrupoFio: {
        payload: Prisma.$BmMaterialGrupoFioPayload<ExtArgs>
        fields: Prisma.BmMaterialGrupoFioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMaterialGrupoFioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMaterialGrupoFioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload>
          }
          findFirst: {
            args: Prisma.BmMaterialGrupoFioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMaterialGrupoFioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload>
          }
          findMany: {
            args: Prisma.BmMaterialGrupoFioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload>[]
          }
          create: {
            args: Prisma.BmMaterialGrupoFioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload>
          }
          createMany: {
            args: Prisma.BmMaterialGrupoFioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMaterialGrupoFioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload>
          }
          update: {
            args: Prisma.BmMaterialGrupoFioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload>
          }
          deleteMany: {
            args: Prisma.BmMaterialGrupoFioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMaterialGrupoFioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMaterialGrupoFioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialGrupoFioPayload>
          }
          aggregate: {
            args: Prisma.BmMaterialGrupoFioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMaterialGrupoFio>
          }
          groupBy: {
            args: Prisma.BmMaterialGrupoFioGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialGrupoFioGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMaterialGrupoFioCountArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialGrupoFioCountAggregateOutputType> | number
          }
        }
      }
      BmMaterialSubGrupo: {
        payload: Prisma.$BmMaterialSubGrupoPayload<ExtArgs>
        fields: Prisma.BmMaterialSubGrupoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMaterialSubGrupoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMaterialSubGrupoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload>
          }
          findFirst: {
            args: Prisma.BmMaterialSubGrupoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMaterialSubGrupoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload>
          }
          findMany: {
            args: Prisma.BmMaterialSubGrupoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload>[]
          }
          create: {
            args: Prisma.BmMaterialSubGrupoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload>
          }
          createMany: {
            args: Prisma.BmMaterialSubGrupoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMaterialSubGrupoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload>
          }
          update: {
            args: Prisma.BmMaterialSubGrupoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload>
          }
          deleteMany: {
            args: Prisma.BmMaterialSubGrupoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMaterialSubGrupoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMaterialSubGrupoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoPayload>
          }
          aggregate: {
            args: Prisma.BmMaterialSubGrupoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMaterialSubGrupo>
          }
          groupBy: {
            args: Prisma.BmMaterialSubGrupoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialSubGrupoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMaterialSubGrupoCountArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialSubGrupoCountAggregateOutputType> | number
          }
        }
      }
      BmMaterialSubGrupoFio: {
        payload: Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>
        fields: Prisma.BmMaterialSubGrupoFioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMaterialSubGrupoFioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMaterialSubGrupoFioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload>
          }
          findFirst: {
            args: Prisma.BmMaterialSubGrupoFioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMaterialSubGrupoFioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload>
          }
          findMany: {
            args: Prisma.BmMaterialSubGrupoFioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload>[]
          }
          create: {
            args: Prisma.BmMaterialSubGrupoFioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload>
          }
          createMany: {
            args: Prisma.BmMaterialSubGrupoFioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMaterialSubGrupoFioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload>
          }
          update: {
            args: Prisma.BmMaterialSubGrupoFioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload>
          }
          deleteMany: {
            args: Prisma.BmMaterialSubGrupoFioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMaterialSubGrupoFioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMaterialSubGrupoFioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMaterialSubGrupoFioPayload>
          }
          aggregate: {
            args: Prisma.BmMaterialSubGrupoFioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMaterialSubGrupoFio>
          }
          groupBy: {
            args: Prisma.BmMaterialSubGrupoFioGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialSubGrupoFioGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMaterialSubGrupoFioCountArgs<ExtArgs>
            result: $Utils.Optional<BmMaterialSubGrupoFioCountAggregateOutputType> | number
          }
        }
      }
      BmMovimentosLotes: {
        payload: Prisma.$BmMovimentosLotesPayload<ExtArgs>
        fields: Prisma.BmMovimentosLotesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmMovimentosLotesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmMovimentosLotesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload>
          }
          findFirst: {
            args: Prisma.BmMovimentosLotesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmMovimentosLotesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload>
          }
          findMany: {
            args: Prisma.BmMovimentosLotesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload>[]
          }
          create: {
            args: Prisma.BmMovimentosLotesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload>
          }
          createMany: {
            args: Prisma.BmMovimentosLotesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmMovimentosLotesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload>
          }
          update: {
            args: Prisma.BmMovimentosLotesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload>
          }
          deleteMany: {
            args: Prisma.BmMovimentosLotesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmMovimentosLotesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmMovimentosLotesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmMovimentosLotesPayload>
          }
          aggregate: {
            args: Prisma.BmMovimentosLotesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmMovimentosLotes>
          }
          groupBy: {
            args: Prisma.BmMovimentosLotesGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmMovimentosLotesGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmMovimentosLotesCountArgs<ExtArgs>
            result: $Utils.Optional<BmMovimentosLotesCountAggregateOutputType> | number
          }
        }
      }
      BmOp: {
        payload: Prisma.$BmOpPayload<ExtArgs>
        fields: Prisma.BmOpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmOpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmOpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload>
          }
          findFirst: {
            args: Prisma.BmOpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmOpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload>
          }
          findMany: {
            args: Prisma.BmOpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload>[]
          }
          create: {
            args: Prisma.BmOpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload>
          }
          createMany: {
            args: Prisma.BmOpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmOpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload>
          }
          update: {
            args: Prisma.BmOpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload>
          }
          deleteMany: {
            args: Prisma.BmOpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmOpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmOpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpPayload>
          }
          aggregate: {
            args: Prisma.BmOpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmOp>
          }
          groupBy: {
            args: Prisma.BmOpGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmOpGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmOpCountArgs<ExtArgs>
            result: $Utils.Optional<BmOpCountAggregateOutputType> | number
          }
        }
      }
      BmOpFaturado: {
        payload: Prisma.$BmOpFaturadoPayload<ExtArgs>
        fields: Prisma.BmOpFaturadoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmOpFaturadoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmOpFaturadoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload>
          }
          findFirst: {
            args: Prisma.BmOpFaturadoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmOpFaturadoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload>
          }
          findMany: {
            args: Prisma.BmOpFaturadoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload>[]
          }
          create: {
            args: Prisma.BmOpFaturadoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload>
          }
          createMany: {
            args: Prisma.BmOpFaturadoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmOpFaturadoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload>
          }
          update: {
            args: Prisma.BmOpFaturadoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload>
          }
          deleteMany: {
            args: Prisma.BmOpFaturadoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmOpFaturadoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmOpFaturadoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpFaturadoPayload>
          }
          aggregate: {
            args: Prisma.BmOpFaturadoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmOpFaturado>
          }
          groupBy: {
            args: Prisma.BmOpFaturadoGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmOpFaturadoGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmOpFaturadoCountArgs<ExtArgs>
            result: $Utils.Optional<BmOpFaturadoCountAggregateOutputType> | number
          }
        }
      }
      BmOpsPorMalha: {
        payload: Prisma.$BmOpsPorMalhaPayload<ExtArgs>
        fields: Prisma.BmOpsPorMalhaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmOpsPorMalhaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmOpsPorMalhaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload>
          }
          findFirst: {
            args: Prisma.BmOpsPorMalhaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmOpsPorMalhaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload>
          }
          findMany: {
            args: Prisma.BmOpsPorMalhaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload>[]
          }
          create: {
            args: Prisma.BmOpsPorMalhaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload>
          }
          createMany: {
            args: Prisma.BmOpsPorMalhaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmOpsPorMalhaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload>
          }
          update: {
            args: Prisma.BmOpsPorMalhaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload>
          }
          deleteMany: {
            args: Prisma.BmOpsPorMalhaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmOpsPorMalhaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmOpsPorMalhaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaPayload>
          }
          aggregate: {
            args: Prisma.BmOpsPorMalhaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmOpsPorMalha>
          }
          groupBy: {
            args: Prisma.BmOpsPorMalhaGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmOpsPorMalhaGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmOpsPorMalhaCountArgs<ExtArgs>
            result: $Utils.Optional<BmOpsPorMalhaCountAggregateOutputType> | number
          }
        }
      }
      BmOpsPorMalhaFio: {
        payload: Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>
        fields: Prisma.BmOpsPorMalhaFioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmOpsPorMalhaFioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmOpsPorMalhaFioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload>
          }
          findFirst: {
            args: Prisma.BmOpsPorMalhaFioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmOpsPorMalhaFioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload>
          }
          findMany: {
            args: Prisma.BmOpsPorMalhaFioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload>[]
          }
          create: {
            args: Prisma.BmOpsPorMalhaFioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload>
          }
          createMany: {
            args: Prisma.BmOpsPorMalhaFioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmOpsPorMalhaFioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload>
          }
          update: {
            args: Prisma.BmOpsPorMalhaFioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload>
          }
          deleteMany: {
            args: Prisma.BmOpsPorMalhaFioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmOpsPorMalhaFioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmOpsPorMalhaFioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmOpsPorMalhaFioPayload>
          }
          aggregate: {
            args: Prisma.BmOpsPorMalhaFioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmOpsPorMalhaFio>
          }
          groupBy: {
            args: Prisma.BmOpsPorMalhaFioGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmOpsPorMalhaFioGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmOpsPorMalhaFioCountArgs<ExtArgs>
            result: $Utils.Optional<BmOpsPorMalhaFioCountAggregateOutputType> | number
          }
        }
      }
      BmTc: {
        payload: Prisma.$BmTcPayload<ExtArgs>
        fields: Prisma.BmTcFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BmTcFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BmTcFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload>
          }
          findFirst: {
            args: Prisma.BmTcFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BmTcFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload>
          }
          findMany: {
            args: Prisma.BmTcFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload>[]
          }
          create: {
            args: Prisma.BmTcCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload>
          }
          createMany: {
            args: Prisma.BmTcCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BmTcDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload>
          }
          update: {
            args: Prisma.BmTcUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload>
          }
          deleteMany: {
            args: Prisma.BmTcDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BmTcUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BmTcUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BmTcPayload>
          }
          aggregate: {
            args: Prisma.BmTcAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBmTc>
          }
          groupBy: {
            args: Prisma.BmTcGroupByArgs<ExtArgs>
            result: $Utils.Optional<BmTcGroupByOutputType>[]
          }
          count: {
            args: Prisma.BmTcCountArgs<ExtArgs>
            result: $Utils.Optional<BmTcCountAggregateOutputType> | number
          }
        }
      }
      DataCamiao: {
        payload: Prisma.$DataCamiaoPayload<ExtArgs>
        fields: Prisma.DataCamiaoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataCamiaoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataCamiaoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload>
          }
          findFirst: {
            args: Prisma.DataCamiaoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataCamiaoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload>
          }
          findMany: {
            args: Prisma.DataCamiaoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload>[]
          }
          create: {
            args: Prisma.DataCamiaoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload>
          }
          createMany: {
            args: Prisma.DataCamiaoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataCamiaoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload>
          }
          update: {
            args: Prisma.DataCamiaoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload>
          }
          deleteMany: {
            args: Prisma.DataCamiaoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataCamiaoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataCamiaoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataCamiaoPayload>
          }
          aggregate: {
            args: Prisma.DataCamiaoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataCamiao>
          }
          groupBy: {
            args: Prisma.DataCamiaoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataCamiaoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataCamiaoCountArgs<ExtArgs>
            result: $Utils.Optional<DataCamiaoCountAggregateOutputType> | number
          }
        }
      }
      DataEnvio: {
        payload: Prisma.$DataEnvioPayload<ExtArgs>
        fields: Prisma.DataEnvioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataEnvioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataEnvioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload>
          }
          findFirst: {
            args: Prisma.DataEnvioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataEnvioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload>
          }
          findMany: {
            args: Prisma.DataEnvioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload>[]
          }
          create: {
            args: Prisma.DataEnvioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload>
          }
          createMany: {
            args: Prisma.DataEnvioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DataEnvioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload>
          }
          update: {
            args: Prisma.DataEnvioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload>
          }
          deleteMany: {
            args: Prisma.DataEnvioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataEnvioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataEnvioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataEnvioPayload>
          }
          aggregate: {
            args: Prisma.DataEnvioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataEnvio>
          }
          groupBy: {
            args: Prisma.DataEnvioGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataEnvioGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataEnvioCountArgs<ExtArgs>
            result: $Utils.Optional<DataEnvioCountAggregateOutputType> | number
          }
        }
      }
      Fornecedor: {
        payload: Prisma.$FornecedorPayload<ExtArgs>
        fields: Prisma.FornecedorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FornecedorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FornecedorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          findFirst: {
            args: Prisma.FornecedorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FornecedorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          findMany: {
            args: Prisma.FornecedorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>[]
          }
          create: {
            args: Prisma.FornecedorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          createMany: {
            args: Prisma.FornecedorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FornecedorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          update: {
            args: Prisma.FornecedorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          deleteMany: {
            args: Prisma.FornecedorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FornecedorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FornecedorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FornecedorPayload>
          }
          aggregate: {
            args: Prisma.FornecedorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFornecedor>
          }
          groupBy: {
            args: Prisma.FornecedorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FornecedorGroupByOutputType>[]
          }
          count: {
            args: Prisma.FornecedorCountArgs<ExtArgs>
            result: $Utils.Optional<FornecedorCountAggregateOutputType> | number
          }
        }
      }
      Livre: {
        payload: Prisma.$LivrePayload<ExtArgs>
        fields: Prisma.LivreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LivreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LivreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload>
          }
          findFirst: {
            args: Prisma.LivreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LivreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload>
          }
          findMany: {
            args: Prisma.LivreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload>[]
          }
          create: {
            args: Prisma.LivreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload>
          }
          createMany: {
            args: Prisma.LivreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LivreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload>
          }
          update: {
            args: Prisma.LivreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload>
          }
          deleteMany: {
            args: Prisma.LivreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LivreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LivreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LivrePayload>
          }
          aggregate: {
            args: Prisma.LivreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLivre>
          }
          groupBy: {
            args: Prisma.LivreGroupByArgs<ExtArgs>
            result: $Utils.Optional<LivreGroupByOutputType>[]
          }
          count: {
            args: Prisma.LivreCountArgs<ExtArgs>
            result: $Utils.Optional<LivreCountAggregateOutputType> | number
          }
        }
      }
      Op: {
        payload: Prisma.$OpPayload<ExtArgs>
        fields: Prisma.OpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload>
          }
          findFirst: {
            args: Prisma.OpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload>
          }
          findMany: {
            args: Prisma.OpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload>[]
          }
          create: {
            args: Prisma.OpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload>
          }
          createMany: {
            args: Prisma.OpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload>
          }
          update: {
            args: Prisma.OpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload>
          }
          deleteMany: {
            args: Prisma.OpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OpPayload>
          }
          aggregate: {
            args: Prisma.OpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOp>
          }
          groupBy: {
            args: Prisma.OpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OpCountArgs<ExtArgs>
            result: $Utils.Optional<OpCountAggregateOutputType> | number
          }
        }
      }
      OrcamentoLivre: {
        payload: Prisma.$OrcamentoLivrePayload<ExtArgs>
        fields: Prisma.OrcamentoLivreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrcamentoLivreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrcamentoLivreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload>
          }
          findFirst: {
            args: Prisma.OrcamentoLivreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrcamentoLivreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload>
          }
          findMany: {
            args: Prisma.OrcamentoLivreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload>[]
          }
          create: {
            args: Prisma.OrcamentoLivreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload>
          }
          createMany: {
            args: Prisma.OrcamentoLivreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrcamentoLivreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload>
          }
          update: {
            args: Prisma.OrcamentoLivreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload>
          }
          deleteMany: {
            args: Prisma.OrcamentoLivreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrcamentoLivreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrcamentoLivreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivrePayload>
          }
          aggregate: {
            args: Prisma.OrcamentoLivreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrcamentoLivre>
          }
          groupBy: {
            args: Prisma.OrcamentoLivreGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoLivreGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrcamentoLivreCountArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoLivreCountAggregateOutputType> | number
          }
        }
      }
      OrcamentoLivreLinhas: {
        payload: Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>
        fields: Prisma.OrcamentoLivreLinhasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrcamentoLivreLinhasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrcamentoLivreLinhasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload>
          }
          findFirst: {
            args: Prisma.OrcamentoLivreLinhasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrcamentoLivreLinhasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload>
          }
          findMany: {
            args: Prisma.OrcamentoLivreLinhasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload>[]
          }
          create: {
            args: Prisma.OrcamentoLivreLinhasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload>
          }
          createMany: {
            args: Prisma.OrcamentoLivreLinhasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrcamentoLivreLinhasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload>
          }
          update: {
            args: Prisma.OrcamentoLivreLinhasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload>
          }
          deleteMany: {
            args: Prisma.OrcamentoLivreLinhasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrcamentoLivreLinhasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrcamentoLivreLinhasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoLivreLinhasPayload>
          }
          aggregate: {
            args: Prisma.OrcamentoLivreLinhasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrcamentoLivreLinhas>
          }
          groupBy: {
            args: Prisma.OrcamentoLivreLinhasGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoLivreLinhasGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrcamentoLivreLinhasCountArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoLivreLinhasCountAggregateOutputType> | number
          }
        }
      }
      OrcamentoOp: {
        payload: Prisma.$OrcamentoOpPayload<ExtArgs>
        fields: Prisma.OrcamentoOpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrcamentoOpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrcamentoOpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload>
          }
          findFirst: {
            args: Prisma.OrcamentoOpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrcamentoOpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload>
          }
          findMany: {
            args: Prisma.OrcamentoOpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload>[]
          }
          create: {
            args: Prisma.OrcamentoOpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload>
          }
          createMany: {
            args: Prisma.OrcamentoOpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrcamentoOpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload>
          }
          update: {
            args: Prisma.OrcamentoOpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload>
          }
          deleteMany: {
            args: Prisma.OrcamentoOpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrcamentoOpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrcamentoOpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpPayload>
          }
          aggregate: {
            args: Prisma.OrcamentoOpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrcamentoOp>
          }
          groupBy: {
            args: Prisma.OrcamentoOpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoOpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrcamentoOpCountArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoOpCountAggregateOutputType> | number
          }
        }
      }
      OrcamentoOpLinhas: {
        payload: Prisma.$OrcamentoOpLinhasPayload<ExtArgs>
        fields: Prisma.OrcamentoOpLinhasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrcamentoOpLinhasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrcamentoOpLinhasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload>
          }
          findFirst: {
            args: Prisma.OrcamentoOpLinhasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrcamentoOpLinhasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload>
          }
          findMany: {
            args: Prisma.OrcamentoOpLinhasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload>[]
          }
          create: {
            args: Prisma.OrcamentoOpLinhasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload>
          }
          createMany: {
            args: Prisma.OrcamentoOpLinhasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrcamentoOpLinhasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload>
          }
          update: {
            args: Prisma.OrcamentoOpLinhasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload>
          }
          deleteMany: {
            args: Prisma.OrcamentoOpLinhasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrcamentoOpLinhasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrcamentoOpLinhasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrcamentoOpLinhasPayload>
          }
          aggregate: {
            args: Prisma.OrcamentoOpLinhasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrcamentoOpLinhas>
          }
          groupBy: {
            args: Prisma.OrcamentoOpLinhasGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoOpLinhasGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrcamentoOpLinhasCountArgs<ExtArgs>
            result: $Utils.Optional<OrcamentoOpLinhasCountAggregateOutputType> | number
          }
        }
      }
      Papeis: {
        payload: Prisma.$PapeisPayload<ExtArgs>
        fields: Prisma.PapeisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PapeisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PapeisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload>
          }
          findFirst: {
            args: Prisma.PapeisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PapeisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload>
          }
          findMany: {
            args: Prisma.PapeisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload>[]
          }
          create: {
            args: Prisma.PapeisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload>
          }
          createMany: {
            args: Prisma.PapeisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PapeisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload>
          }
          update: {
            args: Prisma.PapeisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload>
          }
          deleteMany: {
            args: Prisma.PapeisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PapeisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PapeisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PapeisPayload>
          }
          aggregate: {
            args: Prisma.PapeisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePapeis>
          }
          groupBy: {
            args: Prisma.PapeisGroupByArgs<ExtArgs>
            result: $Utils.Optional<PapeisGroupByOutputType>[]
          }
          count: {
            args: Prisma.PapeisCountArgs<ExtArgs>
            result: $Utils.Optional<PapeisCountAggregateOutputType> | number
          }
        }
      }
      Planeamento: {
        payload: Prisma.$PlaneamentoPayload<ExtArgs>
        fields: Prisma.PlaneamentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlaneamentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlaneamentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload>
          }
          findFirst: {
            args: Prisma.PlaneamentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlaneamentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload>
          }
          findMany: {
            args: Prisma.PlaneamentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload>[]
          }
          create: {
            args: Prisma.PlaneamentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload>
          }
          createMany: {
            args: Prisma.PlaneamentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PlaneamentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload>
          }
          update: {
            args: Prisma.PlaneamentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload>
          }
          deleteMany: {
            args: Prisma.PlaneamentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlaneamentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PlaneamentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlaneamentoPayload>
          }
          aggregate: {
            args: Prisma.PlaneamentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlaneamento>
          }
          groupBy: {
            args: Prisma.PlaneamentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlaneamentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlaneamentoCountArgs<ExtArgs>
            result: $Utils.Optional<PlaneamentoCountAggregateOutputType> | number
          }
        }
      }
      ServicosEscolhidosLivre: {
        payload: Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>
        fields: Prisma.ServicosEscolhidosLivreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicosEscolhidosLivreFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicosEscolhidosLivreFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload>
          }
          findFirst: {
            args: Prisma.ServicosEscolhidosLivreFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicosEscolhidosLivreFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload>
          }
          findMany: {
            args: Prisma.ServicosEscolhidosLivreFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload>[]
          }
          create: {
            args: Prisma.ServicosEscolhidosLivreCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload>
          }
          createMany: {
            args: Prisma.ServicosEscolhidosLivreCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicosEscolhidosLivreDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload>
          }
          update: {
            args: Prisma.ServicosEscolhidosLivreUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload>
          }
          deleteMany: {
            args: Prisma.ServicosEscolhidosLivreDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicosEscolhidosLivreUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicosEscolhidosLivreUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivrePayload>
          }
          aggregate: {
            args: Prisma.ServicosEscolhidosLivreAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicosEscolhidosLivre>
          }
          groupBy: {
            args: Prisma.ServicosEscolhidosLivreGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosLivreGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicosEscolhidosLivreCountArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosLivreCountAggregateOutputType> | number
          }
        }
      }
      ServicosEscolhidosLivreOrigem: {
        payload: Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>
        fields: Prisma.ServicosEscolhidosLivreOrigemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicosEscolhidosLivreOrigemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicosEscolhidosLivreOrigemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload>
          }
          findFirst: {
            args: Prisma.ServicosEscolhidosLivreOrigemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicosEscolhidosLivreOrigemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload>
          }
          findMany: {
            args: Prisma.ServicosEscolhidosLivreOrigemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload>[]
          }
          create: {
            args: Prisma.ServicosEscolhidosLivreOrigemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload>
          }
          createMany: {
            args: Prisma.ServicosEscolhidosLivreOrigemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicosEscolhidosLivreOrigemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload>
          }
          update: {
            args: Prisma.ServicosEscolhidosLivreOrigemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload>
          }
          deleteMany: {
            args: Prisma.ServicosEscolhidosLivreOrigemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicosEscolhidosLivreOrigemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicosEscolhidosLivreOrigemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosLivreOrigemPayload>
          }
          aggregate: {
            args: Prisma.ServicosEscolhidosLivreOrigemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicosEscolhidosLivreOrigem>
          }
          groupBy: {
            args: Prisma.ServicosEscolhidosLivreOrigemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosLivreOrigemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicosEscolhidosLivreOrigemCountArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosLivreOrigemCountAggregateOutputType> | number
          }
        }
      }
      ServicosEscolhidosOp: {
        payload: Prisma.$ServicosEscolhidosOpPayload<ExtArgs>
        fields: Prisma.ServicosEscolhidosOpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicosEscolhidosOpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicosEscolhidosOpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload>
          }
          findFirst: {
            args: Prisma.ServicosEscolhidosOpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicosEscolhidosOpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload>
          }
          findMany: {
            args: Prisma.ServicosEscolhidosOpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload>[]
          }
          create: {
            args: Prisma.ServicosEscolhidosOpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload>
          }
          createMany: {
            args: Prisma.ServicosEscolhidosOpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicosEscolhidosOpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload>
          }
          update: {
            args: Prisma.ServicosEscolhidosOpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload>
          }
          deleteMany: {
            args: Prisma.ServicosEscolhidosOpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicosEscolhidosOpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicosEscolhidosOpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpPayload>
          }
          aggregate: {
            args: Prisma.ServicosEscolhidosOpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicosEscolhidosOp>
          }
          groupBy: {
            args: Prisma.ServicosEscolhidosOpGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosOpGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicosEscolhidosOpCountArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosOpCountAggregateOutputType> | number
          }
        }
      }
      ServicosEscolhidosOpOrigem: {
        payload: Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>
        fields: Prisma.ServicosEscolhidosOpOrigemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicosEscolhidosOpOrigemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicosEscolhidosOpOrigemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload>
          }
          findFirst: {
            args: Prisma.ServicosEscolhidosOpOrigemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicosEscolhidosOpOrigemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload>
          }
          findMany: {
            args: Prisma.ServicosEscolhidosOpOrigemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload>[]
          }
          create: {
            args: Prisma.ServicosEscolhidosOpOrigemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload>
          }
          createMany: {
            args: Prisma.ServicosEscolhidosOpOrigemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicosEscolhidosOpOrigemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload>
          }
          update: {
            args: Prisma.ServicosEscolhidosOpOrigemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload>
          }
          deleteMany: {
            args: Prisma.ServicosEscolhidosOpOrigemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicosEscolhidosOpOrigemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicosEscolhidosOpOrigemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicosEscolhidosOpOrigemPayload>
          }
          aggregate: {
            args: Prisma.ServicosEscolhidosOpOrigemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicosEscolhidosOpOrigem>
          }
          groupBy: {
            args: Prisma.ServicosEscolhidosOpOrigemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosOpOrigemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicosEscolhidosOpOrigemCountArgs<ExtArgs>
            result: $Utils.Optional<ServicosEscolhidosOpOrigemCountAggregateOutputType> | number
          }
        }
      }
      sysdiagrams: {
        payload: Prisma.$sysdiagramsPayload<ExtArgs>
        fields: Prisma.sysdiagramsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sysdiagramsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sysdiagramsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findFirst: {
            args: Prisma.sysdiagramsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sysdiagramsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          findMany: {
            args: Prisma.sysdiagramsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>[]
          }
          create: {
            args: Prisma.sysdiagramsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          createMany: {
            args: Prisma.sysdiagramsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sysdiagramsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          update: {
            args: Prisma.sysdiagramsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          deleteMany: {
            args: Prisma.sysdiagramsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sysdiagramsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sysdiagramsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sysdiagramsPayload>
          }
          aggregate: {
            args: Prisma.SysdiagramsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSysdiagrams>
          }
          groupBy: {
            args: Prisma.sysdiagramsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sysdiagramsCountArgs<ExtArgs>
            result: $Utils.Optional<SysdiagramsCountAggregateOutputType> | number
          }
        }
      }
      Tc: {
        payload: Prisma.$TcPayload<ExtArgs>
        fields: Prisma.TcFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TcFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TcFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload>
          }
          findFirst: {
            args: Prisma.TcFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TcFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload>
          }
          findMany: {
            args: Prisma.TcFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload>[]
          }
          create: {
            args: Prisma.TcCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload>
          }
          createMany: {
            args: Prisma.TcCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TcDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload>
          }
          update: {
            args: Prisma.TcUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload>
          }
          deleteMany: {
            args: Prisma.TcDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TcUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TcUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcPayload>
          }
          aggregate: {
            args: Prisma.TcAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTc>
          }
          groupBy: {
            args: Prisma.TcGroupByArgs<ExtArgs>
            result: $Utils.Optional<TcGroupByOutputType>[]
          }
          count: {
            args: Prisma.TcCountArgs<ExtArgs>
            result: $Utils.Optional<TcCountAggregateOutputType> | number
          }
        }
      }
      TcCompraConteudo: {
        payload: Prisma.$TcCompraConteudoPayload<ExtArgs>
        fields: Prisma.TcCompraConteudoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TcCompraConteudoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TcCompraConteudoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload>
          }
          findFirst: {
            args: Prisma.TcCompraConteudoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TcCompraConteudoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload>
          }
          findMany: {
            args: Prisma.TcCompraConteudoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload>[]
          }
          create: {
            args: Prisma.TcCompraConteudoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload>
          }
          createMany: {
            args: Prisma.TcCompraConteudoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TcCompraConteudoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload>
          }
          update: {
            args: Prisma.TcCompraConteudoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload>
          }
          deleteMany: {
            args: Prisma.TcCompraConteudoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TcCompraConteudoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TcCompraConteudoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoPayload>
          }
          aggregate: {
            args: Prisma.TcCompraConteudoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTcCompraConteudo>
          }
          groupBy: {
            args: Prisma.TcCompraConteudoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TcCompraConteudoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TcCompraConteudoCountArgs<ExtArgs>
            result: $Utils.Optional<TcCompraConteudoCountAggregateOutputType> | number
          }
        }
      }
      TcCompraConteudoEntrada: {
        payload: Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>
        fields: Prisma.TcCompraConteudoEntradaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TcCompraConteudoEntradaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TcCompraConteudoEntradaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload>
          }
          findFirst: {
            args: Prisma.TcCompraConteudoEntradaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TcCompraConteudoEntradaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload>
          }
          findMany: {
            args: Prisma.TcCompraConteudoEntradaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload>[]
          }
          create: {
            args: Prisma.TcCompraConteudoEntradaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload>
          }
          createMany: {
            args: Prisma.TcCompraConteudoEntradaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TcCompraConteudoEntradaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload>
          }
          update: {
            args: Prisma.TcCompraConteudoEntradaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload>
          }
          deleteMany: {
            args: Prisma.TcCompraConteudoEntradaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TcCompraConteudoEntradaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TcCompraConteudoEntradaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaPayload>
          }
          aggregate: {
            args: Prisma.TcCompraConteudoEntradaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTcCompraConteudoEntrada>
          }
          groupBy: {
            args: Prisma.TcCompraConteudoEntradaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TcCompraConteudoEntradaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TcCompraConteudoEntradaCountArgs<ExtArgs>
            result: $Utils.Optional<TcCompraConteudoEntradaCountAggregateOutputType> | number
          }
        }
      }
      TcCompraConteudoEntradaFaturada: {
        payload: Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>
        fields: Prisma.TcCompraConteudoEntradaFaturadaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TcCompraConteudoEntradaFaturadaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TcCompraConteudoEntradaFaturadaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload>
          }
          findFirst: {
            args: Prisma.TcCompraConteudoEntradaFaturadaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TcCompraConteudoEntradaFaturadaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload>
          }
          findMany: {
            args: Prisma.TcCompraConteudoEntradaFaturadaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload>[]
          }
          create: {
            args: Prisma.TcCompraConteudoEntradaFaturadaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload>
          }
          createMany: {
            args: Prisma.TcCompraConteudoEntradaFaturadaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TcCompraConteudoEntradaFaturadaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload>
          }
          update: {
            args: Prisma.TcCompraConteudoEntradaFaturadaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload>
          }
          deleteMany: {
            args: Prisma.TcCompraConteudoEntradaFaturadaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TcCompraConteudoEntradaFaturadaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TcCompraConteudoEntradaFaturadaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload>
          }
          aggregate: {
            args: Prisma.TcCompraConteudoEntradaFaturadaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTcCompraConteudoEntradaFaturada>
          }
          groupBy: {
            args: Prisma.TcCompraConteudoEntradaFaturadaGroupByArgs<ExtArgs>
            result: $Utils.Optional<TcCompraConteudoEntradaFaturadaGroupByOutputType>[]
          }
          count: {
            args: Prisma.TcCompraConteudoEntradaFaturadaCountArgs<ExtArgs>
            result: $Utils.Optional<TcCompraConteudoEntradaFaturadaCountAggregateOutputType> | number
          }
        }
      }
      TcOp: {
        payload: Prisma.$TcOpPayload<ExtArgs>
        fields: Prisma.TcOpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TcOpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TcOpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload>
          }
          findFirst: {
            args: Prisma.TcOpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TcOpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload>
          }
          findMany: {
            args: Prisma.TcOpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload>[]
          }
          create: {
            args: Prisma.TcOpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload>
          }
          createMany: {
            args: Prisma.TcOpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TcOpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload>
          }
          update: {
            args: Prisma.TcOpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload>
          }
          deleteMany: {
            args: Prisma.TcOpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TcOpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TcOpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpPayload>
          }
          aggregate: {
            args: Prisma.TcOpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTcOp>
          }
          groupBy: {
            args: Prisma.TcOpGroupByArgs<ExtArgs>
            result: $Utils.Optional<TcOpGroupByOutputType>[]
          }
          count: {
            args: Prisma.TcOpCountArgs<ExtArgs>
            result: $Utils.Optional<TcOpCountAggregateOutputType> | number
          }
        }
      }
      TcOpCompra: {
        payload: Prisma.$TcOpCompraPayload<ExtArgs>
        fields: Prisma.TcOpCompraFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TcOpCompraFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TcOpCompraFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload>
          }
          findFirst: {
            args: Prisma.TcOpCompraFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TcOpCompraFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload>
          }
          findMany: {
            args: Prisma.TcOpCompraFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload>[]
          }
          create: {
            args: Prisma.TcOpCompraCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload>
          }
          createMany: {
            args: Prisma.TcOpCompraCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TcOpCompraDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload>
          }
          update: {
            args: Prisma.TcOpCompraUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload>
          }
          deleteMany: {
            args: Prisma.TcOpCompraDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TcOpCompraUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TcOpCompraUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TcOpCompraPayload>
          }
          aggregate: {
            args: Prisma.TcOpCompraAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTcOpCompra>
          }
          groupBy: {
            args: Prisma.TcOpCompraGroupByArgs<ExtArgs>
            result: $Utils.Optional<TcOpCompraGroupByOutputType>[]
          }
          count: {
            args: Prisma.TcOpCompraCountArgs<ExtArgs>
            result: $Utils.Optional<TcOpCompraCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserPapeis: {
        payload: Prisma.$UserPapeisPayload<ExtArgs>
        fields: Prisma.UserPapeisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPapeisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPapeisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload>
          }
          findFirst: {
            args: Prisma.UserPapeisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPapeisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload>
          }
          findMany: {
            args: Prisma.UserPapeisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload>[]
          }
          create: {
            args: Prisma.UserPapeisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload>
          }
          createMany: {
            args: Prisma.UserPapeisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserPapeisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload>
          }
          update: {
            args: Prisma.UserPapeisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload>
          }
          deleteMany: {
            args: Prisma.UserPapeisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPapeisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserPapeisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPapeisPayload>
          }
          aggregate: {
            args: Prisma.UserPapeisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPapeis>
          }
          groupBy: {
            args: Prisma.UserPapeisGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPapeisGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPapeisCountArgs<ExtArgs>
            result: $Utils.Optional<UserPapeisCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    bm?: BmOmit
    bmFioComposicao?: BmFioComposicaoOmit
    bmIdBmComposicao?: BmIdBmComposicaoOmit
    bmMalhas?: BmMalhasOmit
    bmMalhasFio?: BmMalhasFioOmit
    bmMalhasFioMovimentos?: BmMalhasFioMovimentosOmit
    bmMateriais?: BmMateriaisOmit
    bmMateriaisComposicao?: BmMateriaisComposicaoOmit
    bmMateriaisFio?: BmMateriaisFioOmit
    bmMaterialGrupo?: BmMaterialGrupoOmit
    bmMaterialGrupoFio?: BmMaterialGrupoFioOmit
    bmMaterialSubGrupo?: BmMaterialSubGrupoOmit
    bmMaterialSubGrupoFio?: BmMaterialSubGrupoFioOmit
    bmMovimentosLotes?: BmMovimentosLotesOmit
    bmOp?: BmOpOmit
    bmOpFaturado?: BmOpFaturadoOmit
    bmOpsPorMalha?: BmOpsPorMalhaOmit
    bmOpsPorMalhaFio?: BmOpsPorMalhaFioOmit
    bmTc?: BmTcOmit
    dataCamiao?: DataCamiaoOmit
    dataEnvio?: DataEnvioOmit
    fornecedor?: FornecedorOmit
    livre?: LivreOmit
    op?: OpOmit
    orcamentoLivre?: OrcamentoLivreOmit
    orcamentoLivreLinhas?: OrcamentoLivreLinhasOmit
    orcamentoOp?: OrcamentoOpOmit
    orcamentoOpLinhas?: OrcamentoOpLinhasOmit
    papeis?: PapeisOmit
    planeamento?: PlaneamentoOmit
    servicosEscolhidosLivre?: ServicosEscolhidosLivreOmit
    servicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemOmit
    servicosEscolhidosOp?: ServicosEscolhidosOpOmit
    servicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemOmit
    sysdiagrams?: sysdiagramsOmit
    tc?: TcOmit
    tcCompraConteudo?: TcCompraConteudoOmit
    tcCompraConteudoEntrada?: TcCompraConteudoEntradaOmit
    tcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaOmit
    tcOp?: TcOpOmit
    tcOpCompra?: TcOpCompraOmit
    user?: UserOmit
    userPapeis?: UserPapeisOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BmCountOutputType
   */

  export type BmCountOutputType = {
    BmMalhas: number
    BmOp: number
    BmTc: number
  }

  export type BmCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhas?: boolean | BmCountOutputTypeCountBmMalhasArgs
    BmOp?: boolean | BmCountOutputTypeCountBmOpArgs
    BmTc?: boolean | BmCountOutputTypeCountBmTcArgs
  }

  // Custom InputTypes
  /**
   * BmCountOutputType without action
   */
  export type BmCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmCountOutputType
     */
    select?: BmCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmCountOutputType without action
   */
  export type BmCountOutputTypeCountBmMalhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasWhereInput
  }

  /**
   * BmCountOutputType without action
   */
  export type BmCountOutputTypeCountBmOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpWhereInput
  }

  /**
   * BmCountOutputType without action
   */
  export type BmCountOutputTypeCountBmTcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmTcWhereInput
  }


  /**
   * Count Type BmMalhasCountOutputType
   */

  export type BmMalhasCountOutputType = {
    BmIdBmComposicao: number
    BmMalhasFio: number
    BmOpsPorMalha: number
  }

  export type BmMalhasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmIdBmComposicao?: boolean | BmMalhasCountOutputTypeCountBmIdBmComposicaoArgs
    BmMalhasFio?: boolean | BmMalhasCountOutputTypeCountBmMalhasFioArgs
    BmOpsPorMalha?: boolean | BmMalhasCountOutputTypeCountBmOpsPorMalhaArgs
  }

  // Custom InputTypes
  /**
   * BmMalhasCountOutputType without action
   */
  export type BmMalhasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasCountOutputType
     */
    select?: BmMalhasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMalhasCountOutputType without action
   */
  export type BmMalhasCountOutputTypeCountBmIdBmComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmIdBmComposicaoWhereInput
  }

  /**
   * BmMalhasCountOutputType without action
   */
  export type BmMalhasCountOutputTypeCountBmMalhasFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasFioWhereInput
  }

  /**
   * BmMalhasCountOutputType without action
   */
  export type BmMalhasCountOutputTypeCountBmOpsPorMalhaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpsPorMalhaWhereInput
  }


  /**
   * Count Type BmMalhasFioCountOutputType
   */

  export type BmMalhasFioCountOutputType = {
    BmFioComposicao: number
    BmOpsPorMalhaFio: number
  }

  export type BmMalhasFioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmFioComposicao?: boolean | BmMalhasFioCountOutputTypeCountBmFioComposicaoArgs
    BmOpsPorMalhaFio?: boolean | BmMalhasFioCountOutputTypeCountBmOpsPorMalhaFioArgs
  }

  // Custom InputTypes
  /**
   * BmMalhasFioCountOutputType without action
   */
  export type BmMalhasFioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioCountOutputType
     */
    select?: BmMalhasFioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMalhasFioCountOutputType without action
   */
  export type BmMalhasFioCountOutputTypeCountBmFioComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmFioComposicaoWhereInput
  }

  /**
   * BmMalhasFioCountOutputType without action
   */
  export type BmMalhasFioCountOutputTypeCountBmOpsPorMalhaFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpsPorMalhaFioWhereInput
  }


  /**
   * Count Type BmMateriaisCountOutputType
   */

  export type BmMateriaisCountOutputType = {
    BmMalhas: number
  }

  export type BmMateriaisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhas?: boolean | BmMateriaisCountOutputTypeCountBmMalhasArgs
  }

  // Custom InputTypes
  /**
   * BmMateriaisCountOutputType without action
   */
  export type BmMateriaisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisCountOutputType
     */
    select?: BmMateriaisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMateriaisCountOutputType without action
   */
  export type BmMateriaisCountOutputTypeCountBmMalhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasWhereInput
  }


  /**
   * Count Type BmMateriaisComposicaoCountOutputType
   */

  export type BmMateriaisComposicaoCountOutputType = {
    BmFioComposicao: number
    BmIdBmComposicao: number
  }

  export type BmMateriaisComposicaoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmFioComposicao?: boolean | BmMateriaisComposicaoCountOutputTypeCountBmFioComposicaoArgs
    BmIdBmComposicao?: boolean | BmMateriaisComposicaoCountOutputTypeCountBmIdBmComposicaoArgs
  }

  // Custom InputTypes
  /**
   * BmMateriaisComposicaoCountOutputType without action
   */
  export type BmMateriaisComposicaoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicaoCountOutputType
     */
    select?: BmMateriaisComposicaoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMateriaisComposicaoCountOutputType without action
   */
  export type BmMateriaisComposicaoCountOutputTypeCountBmFioComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmFioComposicaoWhereInput
  }

  /**
   * BmMateriaisComposicaoCountOutputType without action
   */
  export type BmMateriaisComposicaoCountOutputTypeCountBmIdBmComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmIdBmComposicaoWhereInput
  }


  /**
   * Count Type BmMateriaisFioCountOutputType
   */

  export type BmMateriaisFioCountOutputType = {
    BmMalhasFio: number
  }

  export type BmMateriaisFioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhasFio?: boolean | BmMateriaisFioCountOutputTypeCountBmMalhasFioArgs
  }

  // Custom InputTypes
  /**
   * BmMateriaisFioCountOutputType without action
   */
  export type BmMateriaisFioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFioCountOutputType
     */
    select?: BmMateriaisFioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMateriaisFioCountOutputType without action
   */
  export type BmMateriaisFioCountOutputTypeCountBmMalhasFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasFioWhereInput
  }


  /**
   * Count Type BmMaterialGrupoCountOutputType
   */

  export type BmMaterialGrupoCountOutputType = {
    BmMateriais: number
  }

  export type BmMaterialGrupoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriais?: boolean | BmMaterialGrupoCountOutputTypeCountBmMateriaisArgs
  }

  // Custom InputTypes
  /**
   * BmMaterialGrupoCountOutputType without action
   */
  export type BmMaterialGrupoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoCountOutputType
     */
    select?: BmMaterialGrupoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMaterialGrupoCountOutputType without action
   */
  export type BmMaterialGrupoCountOutputTypeCountBmMateriaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMateriaisWhereInput
  }


  /**
   * Count Type BmMaterialGrupoFioCountOutputType
   */

  export type BmMaterialGrupoFioCountOutputType = {
    BmMateriaisFio: number
  }

  export type BmMaterialGrupoFioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriaisFio?: boolean | BmMaterialGrupoFioCountOutputTypeCountBmMateriaisFioArgs
  }

  // Custom InputTypes
  /**
   * BmMaterialGrupoFioCountOutputType without action
   */
  export type BmMaterialGrupoFioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFioCountOutputType
     */
    select?: BmMaterialGrupoFioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMaterialGrupoFioCountOutputType without action
   */
  export type BmMaterialGrupoFioCountOutputTypeCountBmMateriaisFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMateriaisFioWhereInput
  }


  /**
   * Count Type BmMaterialSubGrupoCountOutputType
   */

  export type BmMaterialSubGrupoCountOutputType = {
    BmMateriais: number
  }

  export type BmMaterialSubGrupoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriais?: boolean | BmMaterialSubGrupoCountOutputTypeCountBmMateriaisArgs
  }

  // Custom InputTypes
  /**
   * BmMaterialSubGrupoCountOutputType without action
   */
  export type BmMaterialSubGrupoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoCountOutputType
     */
    select?: BmMaterialSubGrupoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMaterialSubGrupoCountOutputType without action
   */
  export type BmMaterialSubGrupoCountOutputTypeCountBmMateriaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMateriaisWhereInput
  }


  /**
   * Count Type BmMaterialSubGrupoFioCountOutputType
   */

  export type BmMaterialSubGrupoFioCountOutputType = {
    BmMateriaisFio: number
  }

  export type BmMaterialSubGrupoFioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriaisFio?: boolean | BmMaterialSubGrupoFioCountOutputTypeCountBmMateriaisFioArgs
  }

  // Custom InputTypes
  /**
   * BmMaterialSubGrupoFioCountOutputType without action
   */
  export type BmMaterialSubGrupoFioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFioCountOutputType
     */
    select?: BmMaterialSubGrupoFioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmMaterialSubGrupoFioCountOutputType without action
   */
  export type BmMaterialSubGrupoFioCountOutputTypeCountBmMateriaisFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMateriaisFioWhereInput
  }


  /**
   * Count Type BmOpCountOutputType
   */

  export type BmOpCountOutputType = {
    BmOpFaturado: number
    BmOpsPorMalha: number
  }

  export type BmOpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmOpFaturado?: boolean | BmOpCountOutputTypeCountBmOpFaturadoArgs
    BmOpsPorMalha?: boolean | BmOpCountOutputTypeCountBmOpsPorMalhaArgs
  }

  // Custom InputTypes
  /**
   * BmOpCountOutputType without action
   */
  export type BmOpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpCountOutputType
     */
    select?: BmOpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmOpCountOutputType without action
   */
  export type BmOpCountOutputTypeCountBmOpFaturadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpFaturadoWhereInput
  }

  /**
   * BmOpCountOutputType without action
   */
  export type BmOpCountOutputTypeCountBmOpsPorMalhaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpsPorMalhaWhereInput
  }


  /**
   * Count Type BmOpsPorMalhaCountOutputType
   */

  export type BmOpsPorMalhaCountOutputType = {
    BmMovimentosLotes: number
    BmOpsPorMalhaFio: number
  }

  export type BmOpsPorMalhaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMovimentosLotes?: boolean | BmOpsPorMalhaCountOutputTypeCountBmMovimentosLotesArgs
    BmOpsPorMalhaFio?: boolean | BmOpsPorMalhaCountOutputTypeCountBmOpsPorMalhaFioArgs
  }

  // Custom InputTypes
  /**
   * BmOpsPorMalhaCountOutputType without action
   */
  export type BmOpsPorMalhaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaCountOutputType
     */
    select?: BmOpsPorMalhaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmOpsPorMalhaCountOutputType without action
   */
  export type BmOpsPorMalhaCountOutputTypeCountBmMovimentosLotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMovimentosLotesWhereInput
  }

  /**
   * BmOpsPorMalhaCountOutputType without action
   */
  export type BmOpsPorMalhaCountOutputTypeCountBmOpsPorMalhaFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpsPorMalhaFioWhereInput
  }


  /**
   * Count Type BmOpsPorMalhaFioCountOutputType
   */

  export type BmOpsPorMalhaFioCountOutputType = {
    BmMalhasFioMovimentos: number
  }

  export type BmOpsPorMalhaFioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhasFioMovimentos?: boolean | BmOpsPorMalhaFioCountOutputTypeCountBmMalhasFioMovimentosArgs
  }

  // Custom InputTypes
  /**
   * BmOpsPorMalhaFioCountOutputType without action
   */
  export type BmOpsPorMalhaFioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFioCountOutputType
     */
    select?: BmOpsPorMalhaFioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BmOpsPorMalhaFioCountOutputType without action
   */
  export type BmOpsPorMalhaFioCountOutputTypeCountBmMalhasFioMovimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasFioMovimentosWhereInput
  }


  /**
   * Count Type FornecedorCountOutputType
   */

  export type FornecedorCountOutputType = {
    Planeamento: number
  }

  export type FornecedorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planeamento?: boolean | FornecedorCountOutputTypeCountPlaneamentoArgs
  }

  // Custom InputTypes
  /**
   * FornecedorCountOutputType without action
   */
  export type FornecedorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FornecedorCountOutputType
     */
    select?: FornecedorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FornecedorCountOutputType without action
   */
  export type FornecedorCountOutputTypeCountPlaneamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaneamentoWhereInput
  }


  /**
   * Count Type LivreCountOutputType
   */

  export type LivreCountOutputType = {
    ServicosEscolhidosLivre: number
  }

  export type LivreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServicosEscolhidosLivre?: boolean | LivreCountOutputTypeCountServicosEscolhidosLivreArgs
  }

  // Custom InputTypes
  /**
   * LivreCountOutputType without action
   */
  export type LivreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LivreCountOutputType
     */
    select?: LivreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LivreCountOutputType without action
   */
  export type LivreCountOutputTypeCountServicosEscolhidosLivreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosLivreWhereInput
  }


  /**
   * Count Type OpCountOutputType
   */

  export type OpCountOutputType = {
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp: number
  }

  export type OpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: boolean | OpCountOutputTypeCountServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpArgs
  }

  // Custom InputTypes
  /**
   * OpCountOutputType without action
   */
  export type OpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OpCountOutputType
     */
    select?: OpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OpCountOutputType without action
   */
  export type OpCountOutputTypeCountServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosOpWhereInput
  }


  /**
   * Count Type OrcamentoLivreCountOutputType
   */

  export type OrcamentoLivreCountOutputType = {
    OrcamentoLivreLinhas: number
  }

  export type OrcamentoLivreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrcamentoLivreLinhas?: boolean | OrcamentoLivreCountOutputTypeCountOrcamentoLivreLinhasArgs
  }

  // Custom InputTypes
  /**
   * OrcamentoLivreCountOutputType without action
   */
  export type OrcamentoLivreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreCountOutputType
     */
    select?: OrcamentoLivreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrcamentoLivreCountOutputType without action
   */
  export type OrcamentoLivreCountOutputTypeCountOrcamentoLivreLinhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrcamentoLivreLinhasWhereInput
  }


  /**
   * Count Type OrcamentoLivreLinhasCountOutputType
   */

  export type OrcamentoLivreLinhasCountOutputType = {
    ServicosEscolhidosLivreOrigem: number
  }

  export type OrcamentoLivreLinhasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServicosEscolhidosLivreOrigem?: boolean | OrcamentoLivreLinhasCountOutputTypeCountServicosEscolhidosLivreOrigemArgs
  }

  // Custom InputTypes
  /**
   * OrcamentoLivreLinhasCountOutputType without action
   */
  export type OrcamentoLivreLinhasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhasCountOutputType
     */
    select?: OrcamentoLivreLinhasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrcamentoLivreLinhasCountOutputType without action
   */
  export type OrcamentoLivreLinhasCountOutputTypeCountServicosEscolhidosLivreOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosLivreOrigemWhereInput
  }


  /**
   * Count Type OrcamentoOpCountOutputType
   */

  export type OrcamentoOpCountOutputType = {
    OrcamentoOpLinhas: number
  }

  export type OrcamentoOpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrcamentoOpLinhas?: boolean | OrcamentoOpCountOutputTypeCountOrcamentoOpLinhasArgs
  }

  // Custom InputTypes
  /**
   * OrcamentoOpCountOutputType without action
   */
  export type OrcamentoOpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpCountOutputType
     */
    select?: OrcamentoOpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrcamentoOpCountOutputType without action
   */
  export type OrcamentoOpCountOutputTypeCountOrcamentoOpLinhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrcamentoOpLinhasWhereInput
  }


  /**
   * Count Type OrcamentoOpLinhasCountOutputType
   */

  export type OrcamentoOpLinhasCountOutputType = {
    ServicosEscolhidosOpOrigem: number
  }

  export type OrcamentoOpLinhasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServicosEscolhidosOpOrigem?: boolean | OrcamentoOpLinhasCountOutputTypeCountServicosEscolhidosOpOrigemArgs
  }

  // Custom InputTypes
  /**
   * OrcamentoOpLinhasCountOutputType without action
   */
  export type OrcamentoOpLinhasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhasCountOutputType
     */
    select?: OrcamentoOpLinhasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrcamentoOpLinhasCountOutputType without action
   */
  export type OrcamentoOpLinhasCountOutputTypeCountServicosEscolhidosOpOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosOpOrigemWhereInput
  }


  /**
   * Count Type PapeisCountOutputType
   */

  export type PapeisCountOutputType = {
    UserPapeis: number
  }

  export type PapeisCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserPapeis?: boolean | PapeisCountOutputTypeCountUserPapeisArgs
  }

  // Custom InputTypes
  /**
   * PapeisCountOutputType without action
   */
  export type PapeisCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PapeisCountOutputType
     */
    select?: PapeisCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PapeisCountOutputType without action
   */
  export type PapeisCountOutputTypeCountUserPapeisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPapeisWhereInput
  }


  /**
   * Count Type PlaneamentoCountOutputType
   */

  export type PlaneamentoCountOutputType = {
    DataCamiao: number
    DataEnvio: number
    Livre: number
    Op: number
  }

  export type PlaneamentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DataCamiao?: boolean | PlaneamentoCountOutputTypeCountDataCamiaoArgs
    DataEnvio?: boolean | PlaneamentoCountOutputTypeCountDataEnvioArgs
    Livre?: boolean | PlaneamentoCountOutputTypeCountLivreArgs
    Op?: boolean | PlaneamentoCountOutputTypeCountOpArgs
  }

  // Custom InputTypes
  /**
   * PlaneamentoCountOutputType without action
   */
  export type PlaneamentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlaneamentoCountOutputType
     */
    select?: PlaneamentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlaneamentoCountOutputType without action
   */
  export type PlaneamentoCountOutputTypeCountDataCamiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataCamiaoWhereInput
  }

  /**
   * PlaneamentoCountOutputType without action
   */
  export type PlaneamentoCountOutputTypeCountDataEnvioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataEnvioWhereInput
  }

  /**
   * PlaneamentoCountOutputType without action
   */
  export type PlaneamentoCountOutputTypeCountLivreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivreWhereInput
  }

  /**
   * PlaneamentoCountOutputType without action
   */
  export type PlaneamentoCountOutputTypeCountOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpWhereInput
  }


  /**
   * Count Type ServicosEscolhidosLivreCountOutputType
   */

  export type ServicosEscolhidosLivreCountOutputType = {
    ServicosEscolhidosLivreOrigem: number
  }

  export type ServicosEscolhidosLivreCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServicosEscolhidosLivreOrigem?: boolean | ServicosEscolhidosLivreCountOutputTypeCountServicosEscolhidosLivreOrigemArgs
  }

  // Custom InputTypes
  /**
   * ServicosEscolhidosLivreCountOutputType without action
   */
  export type ServicosEscolhidosLivreCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreCountOutputType
     */
    select?: ServicosEscolhidosLivreCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicosEscolhidosLivreCountOutputType without action
   */
  export type ServicosEscolhidosLivreCountOutputTypeCountServicosEscolhidosLivreOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosLivreOrigemWhereInput
  }


  /**
   * Count Type ServicosEscolhidosOpCountOutputType
   */

  export type ServicosEscolhidosOpCountOutputType = {
    ServicosEscolhidosOpOrigem: number
  }

  export type ServicosEscolhidosOpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ServicosEscolhidosOpOrigem?: boolean | ServicosEscolhidosOpCountOutputTypeCountServicosEscolhidosOpOrigemArgs
  }

  // Custom InputTypes
  /**
   * ServicosEscolhidosOpCountOutputType without action
   */
  export type ServicosEscolhidosOpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpCountOutputType
     */
    select?: ServicosEscolhidosOpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServicosEscolhidosOpCountOutputType without action
   */
  export type ServicosEscolhidosOpCountOutputTypeCountServicosEscolhidosOpOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosOpOrigemWhereInput
  }


  /**
   * Count Type TcCountOutputType
   */

  export type TcCountOutputType = {
    TcOp: number
  }

  export type TcCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcOp?: boolean | TcCountOutputTypeCountTcOpArgs
  }

  // Custom InputTypes
  /**
   * TcCountOutputType without action
   */
  export type TcCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCountOutputType
     */
    select?: TcCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TcCountOutputType without action
   */
  export type TcCountOutputTypeCountTcOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcOpWhereInput
  }


  /**
   * Count Type TcCompraConteudoCountOutputType
   */

  export type TcCompraConteudoCountOutputType = {
    TcCompraConteudoEntrada: number
  }

  export type TcCompraConteudoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudoEntrada?: boolean | TcCompraConteudoCountOutputTypeCountTcCompraConteudoEntradaArgs
  }

  // Custom InputTypes
  /**
   * TcCompraConteudoCountOutputType without action
   */
  export type TcCompraConteudoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoCountOutputType
     */
    select?: TcCompraConteudoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TcCompraConteudoCountOutputType without action
   */
  export type TcCompraConteudoCountOutputTypeCountTcCompraConteudoEntradaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoEntradaWhereInput
  }


  /**
   * Count Type TcCompraConteudoEntradaCountOutputType
   */

  export type TcCompraConteudoEntradaCountOutputType = {
    TcCompraConteudoEntradaFaturada: number
  }

  export type TcCompraConteudoEntradaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudoEntradaFaturada?: boolean | TcCompraConteudoEntradaCountOutputTypeCountTcCompraConteudoEntradaFaturadaArgs
  }

  // Custom InputTypes
  /**
   * TcCompraConteudoEntradaCountOutputType without action
   */
  export type TcCompraConteudoEntradaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaCountOutputType
     */
    select?: TcCompraConteudoEntradaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TcCompraConteudoEntradaCountOutputType without action
   */
  export type TcCompraConteudoEntradaCountOutputTypeCountTcCompraConteudoEntradaFaturadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoEntradaFaturadaWhereInput
  }


  /**
   * Count Type TcOpCountOutputType
   */

  export type TcOpCountOutputType = {
    TcCompraConteudo: number
    TcCompraConteudoEntrada: number
    TcCompraConteudoEntradaFaturada: number
    TcOpCompra: number
  }

  export type TcOpCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudo?: boolean | TcOpCountOutputTypeCountTcCompraConteudoArgs
    TcCompraConteudoEntrada?: boolean | TcOpCountOutputTypeCountTcCompraConteudoEntradaArgs
    TcCompraConteudoEntradaFaturada?: boolean | TcOpCountOutputTypeCountTcCompraConteudoEntradaFaturadaArgs
    TcOpCompra?: boolean | TcOpCountOutputTypeCountTcOpCompraArgs
  }

  // Custom InputTypes
  /**
   * TcOpCountOutputType without action
   */
  export type TcOpCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCountOutputType
     */
    select?: TcOpCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TcOpCountOutputType without action
   */
  export type TcOpCountOutputTypeCountTcCompraConteudoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoWhereInput
  }

  /**
   * TcOpCountOutputType without action
   */
  export type TcOpCountOutputTypeCountTcCompraConteudoEntradaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoEntradaWhereInput
  }

  /**
   * TcOpCountOutputType without action
   */
  export type TcOpCountOutputTypeCountTcCompraConteudoEntradaFaturadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoEntradaFaturadaWhereInput
  }

  /**
   * TcOpCountOutputType without action
   */
  export type TcOpCountOutputTypeCountTcOpCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcOpCompraWhereInput
  }


  /**
   * Count Type TcOpCompraCountOutputType
   */

  export type TcOpCompraCountOutputType = {
    TcCompraConteudo: number
  }

  export type TcOpCompraCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudo?: boolean | TcOpCompraCountOutputTypeCountTcCompraConteudoArgs
  }

  // Custom InputTypes
  /**
   * TcOpCompraCountOutputType without action
   */
  export type TcOpCompraCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompraCountOutputType
     */
    select?: TcOpCompraCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TcOpCompraCountOutputType without action
   */
  export type TcOpCompraCountOutputTypeCountTcCompraConteudoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    DataCamiao: number
    DataEnvio: number
    Livre: number
    Op: number
    Planeamento: number
    UserPapeis: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DataCamiao?: boolean | UserCountOutputTypeCountDataCamiaoArgs
    DataEnvio?: boolean | UserCountOutputTypeCountDataEnvioArgs
    Livre?: boolean | UserCountOutputTypeCountLivreArgs
    Op?: boolean | UserCountOutputTypeCountOpArgs
    Planeamento?: boolean | UserCountOutputTypeCountPlaneamentoArgs
    UserPapeis?: boolean | UserCountOutputTypeCountUserPapeisArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataCamiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataCamiaoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDataEnvioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataEnvioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLivreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivreWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPlaneamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaneamentoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUserPapeisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPapeisWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Bm
   */

  export type AggregateBm = {
    _count: BmCountAggregateOutputType | null
    _min: BmMinAggregateOutputType | null
    _max: BmMaxAggregateOutputType | null
  }

  export type BmMinAggregateOutputType = {
    idBm: string | null
    composicao: string | null
    fechado: boolean | null
    CreatedAt: Date | null
  }

  export type BmMaxAggregateOutputType = {
    idBm: string | null
    composicao: string | null
    fechado: boolean | null
    CreatedAt: Date | null
  }

  export type BmCountAggregateOutputType = {
    idBm: number
    composicao: number
    fechado: number
    CreatedAt: number
    _all: number
  }


  export type BmMinAggregateInputType = {
    idBm?: true
    composicao?: true
    fechado?: true
    CreatedAt?: true
  }

  export type BmMaxAggregateInputType = {
    idBm?: true
    composicao?: true
    fechado?: true
    CreatedAt?: true
  }

  export type BmCountAggregateInputType = {
    idBm?: true
    composicao?: true
    fechado?: true
    CreatedAt?: true
    _all?: true
  }

  export type BmAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bm to aggregate.
     */
    where?: BmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bms to fetch.
     */
    orderBy?: BmOrderByWithRelationInput | BmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bms
    **/
    _count?: true | BmCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMaxAggregateInputType
  }

  export type GetBmAggregateType<T extends BmAggregateArgs> = {
        [P in keyof T & keyof AggregateBm]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBm[P]>
      : GetScalarType<T[P], AggregateBm[P]>
  }




  export type BmGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmWhereInput
    orderBy?: BmOrderByWithAggregationInput | BmOrderByWithAggregationInput[]
    by: BmScalarFieldEnum[] | BmScalarFieldEnum
    having?: BmScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmCountAggregateInputType | true
    _min?: BmMinAggregateInputType
    _max?: BmMaxAggregateInputType
  }

  export type BmGroupByOutputType = {
    idBm: string
    composicao: string
    fechado: boolean
    CreatedAt: Date
    _count: BmCountAggregateOutputType | null
    _min: BmMinAggregateOutputType | null
    _max: BmMaxAggregateOutputType | null
  }

  type GetBmGroupByPayload<T extends BmGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmGroupByOutputType[P]>
            : GetScalarType<T[P], BmGroupByOutputType[P]>
        }
      >
    >


  export type BmSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    composicao?: boolean
    fechado?: boolean
    CreatedAt?: boolean
    BmMalhas?: boolean | Bm$BmMalhasArgs<ExtArgs>
    BmOp?: boolean | Bm$BmOpArgs<ExtArgs>
    BmTc?: boolean | Bm$BmTcArgs<ExtArgs>
    _count?: boolean | BmCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bm"]>



  export type BmSelectScalar = {
    idBm?: boolean
    composicao?: boolean
    fechado?: boolean
    CreatedAt?: boolean
  }

  export type BmOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "composicao" | "fechado" | "CreatedAt", ExtArgs["result"]["bm"]>
  export type BmInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhas?: boolean | Bm$BmMalhasArgs<ExtArgs>
    BmOp?: boolean | Bm$BmOpArgs<ExtArgs>
    BmTc?: boolean | Bm$BmTcArgs<ExtArgs>
    _count?: boolean | BmCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bm"
    objects: {
      BmMalhas: Prisma.$BmMalhasPayload<ExtArgs>[]
      BmOp: Prisma.$BmOpPayload<ExtArgs>[]
      BmTc: Prisma.$BmTcPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      composicao: string
      fechado: boolean
      CreatedAt: Date
    }, ExtArgs["result"]["bm"]>
    composites: {}
  }

  type BmGetPayload<S extends boolean | null | undefined | BmDefaultArgs> = $Result.GetResult<Prisma.$BmPayload, S>

  type BmCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmCountAggregateInputType | true
    }

  export interface BmDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bm'], meta: { name: 'Bm' } }
    /**
     * Find zero or one Bm that matches the filter.
     * @param {BmFindUniqueArgs} args - Arguments to find a Bm
     * @example
     * // Get one Bm
     * const bm = await prisma.bm.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmFindUniqueArgs>(args: SelectSubset<T, BmFindUniqueArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Bm that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmFindUniqueOrThrowArgs} args - Arguments to find a Bm
     * @example
     * // Get one Bm
     * const bm = await prisma.bm.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmFindUniqueOrThrowArgs>(args: SelectSubset<T, BmFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Bm that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFindFirstArgs} args - Arguments to find a Bm
     * @example
     * // Get one Bm
     * const bm = await prisma.bm.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmFindFirstArgs>(args?: SelectSubset<T, BmFindFirstArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Bm that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFindFirstOrThrowArgs} args - Arguments to find a Bm
     * @example
     * // Get one Bm
     * const bm = await prisma.bm.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmFindFirstOrThrowArgs>(args?: SelectSubset<T, BmFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Bms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bms
     * const bms = await prisma.bm.findMany()
     * 
     * // Get first 10 Bms
     * const bms = await prisma.bm.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmWithIdBmOnly = await prisma.bm.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmFindManyArgs>(args?: SelectSubset<T, BmFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Bm.
     * @param {BmCreateArgs} args - Arguments to create a Bm.
     * @example
     * // Create one Bm
     * const Bm = await prisma.bm.create({
     *   data: {
     *     // ... data to create a Bm
     *   }
     * })
     * 
     */
    create<T extends BmCreateArgs>(args: SelectSubset<T, BmCreateArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Bms.
     * @param {BmCreateManyArgs} args - Arguments to create many Bms.
     * @example
     * // Create many Bms
     * const bm = await prisma.bm.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmCreateManyArgs>(args?: SelectSubset<T, BmCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bm.
     * @param {BmDeleteArgs} args - Arguments to delete one Bm.
     * @example
     * // Delete one Bm
     * const Bm = await prisma.bm.delete({
     *   where: {
     *     // ... filter to delete one Bm
     *   }
     * })
     * 
     */
    delete<T extends BmDeleteArgs>(args: SelectSubset<T, BmDeleteArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Bm.
     * @param {BmUpdateArgs} args - Arguments to update one Bm.
     * @example
     * // Update one Bm
     * const bm = await prisma.bm.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmUpdateArgs>(args: SelectSubset<T, BmUpdateArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Bms.
     * @param {BmDeleteManyArgs} args - Arguments to filter Bms to delete.
     * @example
     * // Delete a few Bms
     * const { count } = await prisma.bm.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmDeleteManyArgs>(args?: SelectSubset<T, BmDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bms
     * const bm = await prisma.bm.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmUpdateManyArgs>(args: SelectSubset<T, BmUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bm.
     * @param {BmUpsertArgs} args - Arguments to update or create a Bm.
     * @example
     * // Update or create a Bm
     * const bm = await prisma.bm.upsert({
     *   create: {
     *     // ... data to create a Bm
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bm we want to update
     *   }
     * })
     */
    upsert<T extends BmUpsertArgs>(args: SelectSubset<T, BmUpsertArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Bms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmCountArgs} args - Arguments to filter Bms to count.
     * @example
     * // Count the number of Bms
     * const count = await prisma.bm.count({
     *   where: {
     *     // ... the filter for the Bms we want to count
     *   }
     * })
    **/
    count<T extends BmCountArgs>(
      args?: Subset<T, BmCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmAggregateArgs>(args: Subset<T, BmAggregateArgs>): Prisma.PrismaPromise<GetBmAggregateType<T>>

    /**
     * Group by Bm.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmGroupByArgs['orderBy'] }
        : { orderBy?: BmGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bm model
   */
  readonly fields: BmFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bm.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMalhas<T extends Bm$BmMalhasArgs<ExtArgs> = {}>(args?: Subset<T, Bm$BmMalhasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmOp<T extends Bm$BmOpArgs<ExtArgs> = {}>(args?: Subset<T, Bm$BmOpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmTc<T extends Bm$BmTcArgs<ExtArgs> = {}>(args?: Subset<T, Bm$BmTcArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bm model
   */ 
  interface BmFieldRefs {
    readonly idBm: FieldRef<"Bm", 'String'>
    readonly composicao: FieldRef<"Bm", 'String'>
    readonly fechado: FieldRef<"Bm", 'Boolean'>
    readonly CreatedAt: FieldRef<"Bm", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bm findUnique
   */
  export type BmFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * Filter, which Bm to fetch.
     */
    where: BmWhereUniqueInput
  }

  /**
   * Bm findUniqueOrThrow
   */
  export type BmFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * Filter, which Bm to fetch.
     */
    where: BmWhereUniqueInput
  }

  /**
   * Bm findFirst
   */
  export type BmFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * Filter, which Bm to fetch.
     */
    where?: BmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bms to fetch.
     */
    orderBy?: BmOrderByWithRelationInput | BmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bms.
     */
    cursor?: BmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bms.
     */
    distinct?: BmScalarFieldEnum | BmScalarFieldEnum[]
  }

  /**
   * Bm findFirstOrThrow
   */
  export type BmFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * Filter, which Bm to fetch.
     */
    where?: BmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bms to fetch.
     */
    orderBy?: BmOrderByWithRelationInput | BmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bms.
     */
    cursor?: BmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bms.
     */
    distinct?: BmScalarFieldEnum | BmScalarFieldEnum[]
  }

  /**
   * Bm findMany
   */
  export type BmFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * Filter, which Bms to fetch.
     */
    where?: BmWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bms to fetch.
     */
    orderBy?: BmOrderByWithRelationInput | BmOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bms.
     */
    cursor?: BmWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bms.
     */
    skip?: number
    distinct?: BmScalarFieldEnum | BmScalarFieldEnum[]
  }

  /**
   * Bm create
   */
  export type BmCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * The data needed to create a Bm.
     */
    data: XOR<BmCreateInput, BmUncheckedCreateInput>
  }

  /**
   * Bm createMany
   */
  export type BmCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bms.
     */
    data: BmCreateManyInput | BmCreateManyInput[]
  }

  /**
   * Bm update
   */
  export type BmUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * The data needed to update a Bm.
     */
    data: XOR<BmUpdateInput, BmUncheckedUpdateInput>
    /**
     * Choose, which Bm to update.
     */
    where: BmWhereUniqueInput
  }

  /**
   * Bm updateMany
   */
  export type BmUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bms.
     */
    data: XOR<BmUpdateManyMutationInput, BmUncheckedUpdateManyInput>
    /**
     * Filter which Bms to update
     */
    where?: BmWhereInput
    /**
     * Limit how many Bms to update.
     */
    limit?: number
  }

  /**
   * Bm upsert
   */
  export type BmUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * The filter to search for the Bm to update in case it exists.
     */
    where: BmWhereUniqueInput
    /**
     * In case the Bm found by the `where` argument doesn't exist, create a new Bm with this data.
     */
    create: XOR<BmCreateInput, BmUncheckedCreateInput>
    /**
     * In case the Bm was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmUpdateInput, BmUncheckedUpdateInput>
  }

  /**
   * Bm delete
   */
  export type BmDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
    /**
     * Filter which Bm to delete.
     */
    where: BmWhereUniqueInput
  }

  /**
   * Bm deleteMany
   */
  export type BmDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bms to delete
     */
    where?: BmWhereInput
    /**
     * Limit how many Bms to delete.
     */
    limit?: number
  }

  /**
   * Bm.BmMalhas
   */
  export type Bm$BmMalhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    where?: BmMalhasWhereInput
    orderBy?: BmMalhasOrderByWithRelationInput | BmMalhasOrderByWithRelationInput[]
    cursor?: BmMalhasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMalhasScalarFieldEnum | BmMalhasScalarFieldEnum[]
  }

  /**
   * Bm.BmOp
   */
  export type Bm$BmOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    where?: BmOpWhereInput
    orderBy?: BmOpOrderByWithRelationInput | BmOpOrderByWithRelationInput[]
    cursor?: BmOpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmOpScalarFieldEnum | BmOpScalarFieldEnum[]
  }

  /**
   * Bm.BmTc
   */
  export type Bm$BmTcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    where?: BmTcWhereInput
    orderBy?: BmTcOrderByWithRelationInput | BmTcOrderByWithRelationInput[]
    cursor?: BmTcWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmTcScalarFieldEnum | BmTcScalarFieldEnum[]
  }

  /**
   * Bm without action
   */
  export type BmDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bm
     */
    select?: BmSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bm
     */
    omit?: BmOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmInclude<ExtArgs> | null
  }


  /**
   * Model BmFioComposicao
   */

  export type AggregateBmFioComposicao = {
    _count: BmFioComposicaoCountAggregateOutputType | null
    _avg: BmFioComposicaoAvgAggregateOutputType | null
    _sum: BmFioComposicaoSumAggregateOutputType | null
    _min: BmFioComposicaoMinAggregateOutputType | null
    _max: BmFioComposicaoMaxAggregateOutputType | null
  }

  export type BmFioComposicaoAvgAggregateOutputType = {
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmFioComposicaoSumAggregateOutputType = {
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmFioComposicaoMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmFioComposicaoMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmFioComposicaoCountAggregateOutputType = {
    idBm: number
    ref: number
    refOrigem: number
    idComposicao: number
    qtt: number
    _all: number
  }


  export type BmFioComposicaoAvgAggregateInputType = {
    idComposicao?: true
    qtt?: true
  }

  export type BmFioComposicaoSumAggregateInputType = {
    idComposicao?: true
    qtt?: true
  }

  export type BmFioComposicaoMinAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    idComposicao?: true
    qtt?: true
  }

  export type BmFioComposicaoMaxAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    idComposicao?: true
    qtt?: true
  }

  export type BmFioComposicaoCountAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    idComposicao?: true
    qtt?: true
    _all?: true
  }

  export type BmFioComposicaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmFioComposicao to aggregate.
     */
    where?: BmFioComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmFioComposicaos to fetch.
     */
    orderBy?: BmFioComposicaoOrderByWithRelationInput | BmFioComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmFioComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmFioComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmFioComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmFioComposicaos
    **/
    _count?: true | BmFioComposicaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmFioComposicaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmFioComposicaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmFioComposicaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmFioComposicaoMaxAggregateInputType
  }

  export type GetBmFioComposicaoAggregateType<T extends BmFioComposicaoAggregateArgs> = {
        [P in keyof T & keyof AggregateBmFioComposicao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmFioComposicao[P]>
      : GetScalarType<T[P], AggregateBmFioComposicao[P]>
  }




  export type BmFioComposicaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmFioComposicaoWhereInput
    orderBy?: BmFioComposicaoOrderByWithAggregationInput | BmFioComposicaoOrderByWithAggregationInput[]
    by: BmFioComposicaoScalarFieldEnum[] | BmFioComposicaoScalarFieldEnum
    having?: BmFioComposicaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmFioComposicaoCountAggregateInputType | true
    _avg?: BmFioComposicaoAvgAggregateInputType
    _sum?: BmFioComposicaoSumAggregateInputType
    _min?: BmFioComposicaoMinAggregateInputType
    _max?: BmFioComposicaoMaxAggregateInputType
  }

  export type BmFioComposicaoGroupByOutputType = {
    idBm: string
    ref: string
    refOrigem: string
    idComposicao: number
    qtt: Decimal
    _count: BmFioComposicaoCountAggregateOutputType | null
    _avg: BmFioComposicaoAvgAggregateOutputType | null
    _sum: BmFioComposicaoSumAggregateOutputType | null
    _min: BmFioComposicaoMinAggregateOutputType | null
    _max: BmFioComposicaoMaxAggregateOutputType | null
  }

  type GetBmFioComposicaoGroupByPayload<T extends BmFioComposicaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmFioComposicaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmFioComposicaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmFioComposicaoGroupByOutputType[P]>
            : GetScalarType<T[P], BmFioComposicaoGroupByOutputType[P]>
        }
      >
    >


  export type BmFioComposicaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    idComposicao?: boolean
    qtt?: boolean
    BmMalhasFio?: boolean | BmMalhasFioDefaultArgs<ExtArgs>
    BmMateriaisComposicao?: boolean | BmMateriaisComposicaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmFioComposicao"]>



  export type BmFioComposicaoSelectScalar = {
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    idComposicao?: boolean
    qtt?: boolean
  }

  export type BmFioComposicaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "refOrigem" | "idComposicao" | "qtt", ExtArgs["result"]["bmFioComposicao"]>
  export type BmFioComposicaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhasFio?: boolean | BmMalhasFioDefaultArgs<ExtArgs>
    BmMateriaisComposicao?: boolean | BmMateriaisComposicaoDefaultArgs<ExtArgs>
  }

  export type $BmFioComposicaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmFioComposicao"
    objects: {
      BmMalhasFio: Prisma.$BmMalhasFioPayload<ExtArgs>
      BmMateriaisComposicao: Prisma.$BmMateriaisComposicaoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      refOrigem: string
      idComposicao: number
      qtt: Prisma.Decimal
    }, ExtArgs["result"]["bmFioComposicao"]>
    composites: {}
  }

  type BmFioComposicaoGetPayload<S extends boolean | null | undefined | BmFioComposicaoDefaultArgs> = $Result.GetResult<Prisma.$BmFioComposicaoPayload, S>

  type BmFioComposicaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmFioComposicaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmFioComposicaoCountAggregateInputType | true
    }

  export interface BmFioComposicaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmFioComposicao'], meta: { name: 'BmFioComposicao' } }
    /**
     * Find zero or one BmFioComposicao that matches the filter.
     * @param {BmFioComposicaoFindUniqueArgs} args - Arguments to find a BmFioComposicao
     * @example
     * // Get one BmFioComposicao
     * const bmFioComposicao = await prisma.bmFioComposicao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmFioComposicaoFindUniqueArgs>(args: SelectSubset<T, BmFioComposicaoFindUniqueArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmFioComposicao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmFioComposicaoFindUniqueOrThrowArgs} args - Arguments to find a BmFioComposicao
     * @example
     * // Get one BmFioComposicao
     * const bmFioComposicao = await prisma.bmFioComposicao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmFioComposicaoFindUniqueOrThrowArgs>(args: SelectSubset<T, BmFioComposicaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmFioComposicao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFioComposicaoFindFirstArgs} args - Arguments to find a BmFioComposicao
     * @example
     * // Get one BmFioComposicao
     * const bmFioComposicao = await prisma.bmFioComposicao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmFioComposicaoFindFirstArgs>(args?: SelectSubset<T, BmFioComposicaoFindFirstArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmFioComposicao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFioComposicaoFindFirstOrThrowArgs} args - Arguments to find a BmFioComposicao
     * @example
     * // Get one BmFioComposicao
     * const bmFioComposicao = await prisma.bmFioComposicao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmFioComposicaoFindFirstOrThrowArgs>(args?: SelectSubset<T, BmFioComposicaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmFioComposicaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFioComposicaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmFioComposicaos
     * const bmFioComposicaos = await prisma.bmFioComposicao.findMany()
     * 
     * // Get first 10 BmFioComposicaos
     * const bmFioComposicaos = await prisma.bmFioComposicao.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmFioComposicaoWithIdBmOnly = await prisma.bmFioComposicao.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmFioComposicaoFindManyArgs>(args?: SelectSubset<T, BmFioComposicaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmFioComposicao.
     * @param {BmFioComposicaoCreateArgs} args - Arguments to create a BmFioComposicao.
     * @example
     * // Create one BmFioComposicao
     * const BmFioComposicao = await prisma.bmFioComposicao.create({
     *   data: {
     *     // ... data to create a BmFioComposicao
     *   }
     * })
     * 
     */
    create<T extends BmFioComposicaoCreateArgs>(args: SelectSubset<T, BmFioComposicaoCreateArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmFioComposicaos.
     * @param {BmFioComposicaoCreateManyArgs} args - Arguments to create many BmFioComposicaos.
     * @example
     * // Create many BmFioComposicaos
     * const bmFioComposicao = await prisma.bmFioComposicao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmFioComposicaoCreateManyArgs>(args?: SelectSubset<T, BmFioComposicaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmFioComposicao.
     * @param {BmFioComposicaoDeleteArgs} args - Arguments to delete one BmFioComposicao.
     * @example
     * // Delete one BmFioComposicao
     * const BmFioComposicao = await prisma.bmFioComposicao.delete({
     *   where: {
     *     // ... filter to delete one BmFioComposicao
     *   }
     * })
     * 
     */
    delete<T extends BmFioComposicaoDeleteArgs>(args: SelectSubset<T, BmFioComposicaoDeleteArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmFioComposicao.
     * @param {BmFioComposicaoUpdateArgs} args - Arguments to update one BmFioComposicao.
     * @example
     * // Update one BmFioComposicao
     * const bmFioComposicao = await prisma.bmFioComposicao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmFioComposicaoUpdateArgs>(args: SelectSubset<T, BmFioComposicaoUpdateArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmFioComposicaos.
     * @param {BmFioComposicaoDeleteManyArgs} args - Arguments to filter BmFioComposicaos to delete.
     * @example
     * // Delete a few BmFioComposicaos
     * const { count } = await prisma.bmFioComposicao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmFioComposicaoDeleteManyArgs>(args?: SelectSubset<T, BmFioComposicaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmFioComposicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFioComposicaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmFioComposicaos
     * const bmFioComposicao = await prisma.bmFioComposicao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmFioComposicaoUpdateManyArgs>(args: SelectSubset<T, BmFioComposicaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmFioComposicao.
     * @param {BmFioComposicaoUpsertArgs} args - Arguments to update or create a BmFioComposicao.
     * @example
     * // Update or create a BmFioComposicao
     * const bmFioComposicao = await prisma.bmFioComposicao.upsert({
     *   create: {
     *     // ... data to create a BmFioComposicao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmFioComposicao we want to update
     *   }
     * })
     */
    upsert<T extends BmFioComposicaoUpsertArgs>(args: SelectSubset<T, BmFioComposicaoUpsertArgs<ExtArgs>>): Prisma__BmFioComposicaoClient<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmFioComposicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFioComposicaoCountArgs} args - Arguments to filter BmFioComposicaos to count.
     * @example
     * // Count the number of BmFioComposicaos
     * const count = await prisma.bmFioComposicao.count({
     *   where: {
     *     // ... the filter for the BmFioComposicaos we want to count
     *   }
     * })
    **/
    count<T extends BmFioComposicaoCountArgs>(
      args?: Subset<T, BmFioComposicaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmFioComposicaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmFioComposicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFioComposicaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmFioComposicaoAggregateArgs>(args: Subset<T, BmFioComposicaoAggregateArgs>): Prisma.PrismaPromise<GetBmFioComposicaoAggregateType<T>>

    /**
     * Group by BmFioComposicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmFioComposicaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmFioComposicaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmFioComposicaoGroupByArgs['orderBy'] }
        : { orderBy?: BmFioComposicaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmFioComposicaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmFioComposicaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmFioComposicao model
   */
  readonly fields: BmFioComposicaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmFioComposicao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmFioComposicaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMalhasFio<T extends BmMalhasFioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhasFioDefaultArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmMateriaisComposicao<T extends BmMateriaisComposicaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriaisComposicaoDefaultArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmFioComposicao model
   */ 
  interface BmFioComposicaoFieldRefs {
    readonly idBm: FieldRef<"BmFioComposicao", 'String'>
    readonly ref: FieldRef<"BmFioComposicao", 'String'>
    readonly refOrigem: FieldRef<"BmFioComposicao", 'String'>
    readonly idComposicao: FieldRef<"BmFioComposicao", 'Int'>
    readonly qtt: FieldRef<"BmFioComposicao", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BmFioComposicao findUnique
   */
  export type BmFioComposicaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmFioComposicao to fetch.
     */
    where: BmFioComposicaoWhereUniqueInput
  }

  /**
   * BmFioComposicao findUniqueOrThrow
   */
  export type BmFioComposicaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmFioComposicao to fetch.
     */
    where: BmFioComposicaoWhereUniqueInput
  }

  /**
   * BmFioComposicao findFirst
   */
  export type BmFioComposicaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmFioComposicao to fetch.
     */
    where?: BmFioComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmFioComposicaos to fetch.
     */
    orderBy?: BmFioComposicaoOrderByWithRelationInput | BmFioComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmFioComposicaos.
     */
    cursor?: BmFioComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmFioComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmFioComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmFioComposicaos.
     */
    distinct?: BmFioComposicaoScalarFieldEnum | BmFioComposicaoScalarFieldEnum[]
  }

  /**
   * BmFioComposicao findFirstOrThrow
   */
  export type BmFioComposicaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmFioComposicao to fetch.
     */
    where?: BmFioComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmFioComposicaos to fetch.
     */
    orderBy?: BmFioComposicaoOrderByWithRelationInput | BmFioComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmFioComposicaos.
     */
    cursor?: BmFioComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmFioComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmFioComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmFioComposicaos.
     */
    distinct?: BmFioComposicaoScalarFieldEnum | BmFioComposicaoScalarFieldEnum[]
  }

  /**
   * BmFioComposicao findMany
   */
  export type BmFioComposicaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmFioComposicaos to fetch.
     */
    where?: BmFioComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmFioComposicaos to fetch.
     */
    orderBy?: BmFioComposicaoOrderByWithRelationInput | BmFioComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmFioComposicaos.
     */
    cursor?: BmFioComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmFioComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmFioComposicaos.
     */
    skip?: number
    distinct?: BmFioComposicaoScalarFieldEnum | BmFioComposicaoScalarFieldEnum[]
  }

  /**
   * BmFioComposicao create
   */
  export type BmFioComposicaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * The data needed to create a BmFioComposicao.
     */
    data: XOR<BmFioComposicaoCreateInput, BmFioComposicaoUncheckedCreateInput>
  }

  /**
   * BmFioComposicao createMany
   */
  export type BmFioComposicaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmFioComposicaos.
     */
    data: BmFioComposicaoCreateManyInput | BmFioComposicaoCreateManyInput[]
  }

  /**
   * BmFioComposicao update
   */
  export type BmFioComposicaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * The data needed to update a BmFioComposicao.
     */
    data: XOR<BmFioComposicaoUpdateInput, BmFioComposicaoUncheckedUpdateInput>
    /**
     * Choose, which BmFioComposicao to update.
     */
    where: BmFioComposicaoWhereUniqueInput
  }

  /**
   * BmFioComposicao updateMany
   */
  export type BmFioComposicaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmFioComposicaos.
     */
    data: XOR<BmFioComposicaoUpdateManyMutationInput, BmFioComposicaoUncheckedUpdateManyInput>
    /**
     * Filter which BmFioComposicaos to update
     */
    where?: BmFioComposicaoWhereInput
    /**
     * Limit how many BmFioComposicaos to update.
     */
    limit?: number
  }

  /**
   * BmFioComposicao upsert
   */
  export type BmFioComposicaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * The filter to search for the BmFioComposicao to update in case it exists.
     */
    where: BmFioComposicaoWhereUniqueInput
    /**
     * In case the BmFioComposicao found by the `where` argument doesn't exist, create a new BmFioComposicao with this data.
     */
    create: XOR<BmFioComposicaoCreateInput, BmFioComposicaoUncheckedCreateInput>
    /**
     * In case the BmFioComposicao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmFioComposicaoUpdateInput, BmFioComposicaoUncheckedUpdateInput>
  }

  /**
   * BmFioComposicao delete
   */
  export type BmFioComposicaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    /**
     * Filter which BmFioComposicao to delete.
     */
    where: BmFioComposicaoWhereUniqueInput
  }

  /**
   * BmFioComposicao deleteMany
   */
  export type BmFioComposicaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmFioComposicaos to delete
     */
    where?: BmFioComposicaoWhereInput
    /**
     * Limit how many BmFioComposicaos to delete.
     */
    limit?: number
  }

  /**
   * BmFioComposicao without action
   */
  export type BmFioComposicaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
  }


  /**
   * Model BmIdBmComposicao
   */

  export type AggregateBmIdBmComposicao = {
    _count: BmIdBmComposicaoCountAggregateOutputType | null
    _avg: BmIdBmComposicaoAvgAggregateOutputType | null
    _sum: BmIdBmComposicaoSumAggregateOutputType | null
    _min: BmIdBmComposicaoMinAggregateOutputType | null
    _max: BmIdBmComposicaoMaxAggregateOutputType | null
  }

  export type BmIdBmComposicaoAvgAggregateOutputType = {
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmIdBmComposicaoSumAggregateOutputType = {
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmIdBmComposicaoMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmIdBmComposicaoMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    idComposicao: number | null
    qtt: Decimal | null
  }

  export type BmIdBmComposicaoCountAggregateOutputType = {
    idBm: number
    ref: number
    idComposicao: number
    qtt: number
    _all: number
  }


  export type BmIdBmComposicaoAvgAggregateInputType = {
    idComposicao?: true
    qtt?: true
  }

  export type BmIdBmComposicaoSumAggregateInputType = {
    idComposicao?: true
    qtt?: true
  }

  export type BmIdBmComposicaoMinAggregateInputType = {
    idBm?: true
    ref?: true
    idComposicao?: true
    qtt?: true
  }

  export type BmIdBmComposicaoMaxAggregateInputType = {
    idBm?: true
    ref?: true
    idComposicao?: true
    qtt?: true
  }

  export type BmIdBmComposicaoCountAggregateInputType = {
    idBm?: true
    ref?: true
    idComposicao?: true
    qtt?: true
    _all?: true
  }

  export type BmIdBmComposicaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmIdBmComposicao to aggregate.
     */
    where?: BmIdBmComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmIdBmComposicaos to fetch.
     */
    orderBy?: BmIdBmComposicaoOrderByWithRelationInput | BmIdBmComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmIdBmComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmIdBmComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmIdBmComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmIdBmComposicaos
    **/
    _count?: true | BmIdBmComposicaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmIdBmComposicaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmIdBmComposicaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmIdBmComposicaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmIdBmComposicaoMaxAggregateInputType
  }

  export type GetBmIdBmComposicaoAggregateType<T extends BmIdBmComposicaoAggregateArgs> = {
        [P in keyof T & keyof AggregateBmIdBmComposicao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmIdBmComposicao[P]>
      : GetScalarType<T[P], AggregateBmIdBmComposicao[P]>
  }




  export type BmIdBmComposicaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmIdBmComposicaoWhereInput
    orderBy?: BmIdBmComposicaoOrderByWithAggregationInput | BmIdBmComposicaoOrderByWithAggregationInput[]
    by: BmIdBmComposicaoScalarFieldEnum[] | BmIdBmComposicaoScalarFieldEnum
    having?: BmIdBmComposicaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmIdBmComposicaoCountAggregateInputType | true
    _avg?: BmIdBmComposicaoAvgAggregateInputType
    _sum?: BmIdBmComposicaoSumAggregateInputType
    _min?: BmIdBmComposicaoMinAggregateInputType
    _max?: BmIdBmComposicaoMaxAggregateInputType
  }

  export type BmIdBmComposicaoGroupByOutputType = {
    idBm: string
    ref: string
    idComposicao: number
    qtt: Decimal
    _count: BmIdBmComposicaoCountAggregateOutputType | null
    _avg: BmIdBmComposicaoAvgAggregateOutputType | null
    _sum: BmIdBmComposicaoSumAggregateOutputType | null
    _min: BmIdBmComposicaoMinAggregateOutputType | null
    _max: BmIdBmComposicaoMaxAggregateOutputType | null
  }

  type GetBmIdBmComposicaoGroupByPayload<T extends BmIdBmComposicaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmIdBmComposicaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmIdBmComposicaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmIdBmComposicaoGroupByOutputType[P]>
            : GetScalarType<T[P], BmIdBmComposicaoGroupByOutputType[P]>
        }
      >
    >


  export type BmIdBmComposicaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    idComposicao?: boolean
    qtt?: boolean
    BmMalhas?: boolean | BmMalhasDefaultArgs<ExtArgs>
    BmMateriaisComposicao?: boolean | BmMateriaisComposicaoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmIdBmComposicao"]>



  export type BmIdBmComposicaoSelectScalar = {
    idBm?: boolean
    ref?: boolean
    idComposicao?: boolean
    qtt?: boolean
  }

  export type BmIdBmComposicaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "idComposicao" | "qtt", ExtArgs["result"]["bmIdBmComposicao"]>
  export type BmIdBmComposicaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhas?: boolean | BmMalhasDefaultArgs<ExtArgs>
    BmMateriaisComposicao?: boolean | BmMateriaisComposicaoDefaultArgs<ExtArgs>
  }

  export type $BmIdBmComposicaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmIdBmComposicao"
    objects: {
      BmMalhas: Prisma.$BmMalhasPayload<ExtArgs>
      BmMateriaisComposicao: Prisma.$BmMateriaisComposicaoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      idComposicao: number
      qtt: Prisma.Decimal
    }, ExtArgs["result"]["bmIdBmComposicao"]>
    composites: {}
  }

  type BmIdBmComposicaoGetPayload<S extends boolean | null | undefined | BmIdBmComposicaoDefaultArgs> = $Result.GetResult<Prisma.$BmIdBmComposicaoPayload, S>

  type BmIdBmComposicaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmIdBmComposicaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmIdBmComposicaoCountAggregateInputType | true
    }

  export interface BmIdBmComposicaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmIdBmComposicao'], meta: { name: 'BmIdBmComposicao' } }
    /**
     * Find zero or one BmIdBmComposicao that matches the filter.
     * @param {BmIdBmComposicaoFindUniqueArgs} args - Arguments to find a BmIdBmComposicao
     * @example
     * // Get one BmIdBmComposicao
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmIdBmComposicaoFindUniqueArgs>(args: SelectSubset<T, BmIdBmComposicaoFindUniqueArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmIdBmComposicao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmIdBmComposicaoFindUniqueOrThrowArgs} args - Arguments to find a BmIdBmComposicao
     * @example
     * // Get one BmIdBmComposicao
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmIdBmComposicaoFindUniqueOrThrowArgs>(args: SelectSubset<T, BmIdBmComposicaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmIdBmComposicao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmIdBmComposicaoFindFirstArgs} args - Arguments to find a BmIdBmComposicao
     * @example
     * // Get one BmIdBmComposicao
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmIdBmComposicaoFindFirstArgs>(args?: SelectSubset<T, BmIdBmComposicaoFindFirstArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmIdBmComposicao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmIdBmComposicaoFindFirstOrThrowArgs} args - Arguments to find a BmIdBmComposicao
     * @example
     * // Get one BmIdBmComposicao
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmIdBmComposicaoFindFirstOrThrowArgs>(args?: SelectSubset<T, BmIdBmComposicaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmIdBmComposicaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmIdBmComposicaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmIdBmComposicaos
     * const bmIdBmComposicaos = await prisma.bmIdBmComposicao.findMany()
     * 
     * // Get first 10 BmIdBmComposicaos
     * const bmIdBmComposicaos = await prisma.bmIdBmComposicao.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmIdBmComposicaoWithIdBmOnly = await prisma.bmIdBmComposicao.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmIdBmComposicaoFindManyArgs>(args?: SelectSubset<T, BmIdBmComposicaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmIdBmComposicao.
     * @param {BmIdBmComposicaoCreateArgs} args - Arguments to create a BmIdBmComposicao.
     * @example
     * // Create one BmIdBmComposicao
     * const BmIdBmComposicao = await prisma.bmIdBmComposicao.create({
     *   data: {
     *     // ... data to create a BmIdBmComposicao
     *   }
     * })
     * 
     */
    create<T extends BmIdBmComposicaoCreateArgs>(args: SelectSubset<T, BmIdBmComposicaoCreateArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmIdBmComposicaos.
     * @param {BmIdBmComposicaoCreateManyArgs} args - Arguments to create many BmIdBmComposicaos.
     * @example
     * // Create many BmIdBmComposicaos
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmIdBmComposicaoCreateManyArgs>(args?: SelectSubset<T, BmIdBmComposicaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmIdBmComposicao.
     * @param {BmIdBmComposicaoDeleteArgs} args - Arguments to delete one BmIdBmComposicao.
     * @example
     * // Delete one BmIdBmComposicao
     * const BmIdBmComposicao = await prisma.bmIdBmComposicao.delete({
     *   where: {
     *     // ... filter to delete one BmIdBmComposicao
     *   }
     * })
     * 
     */
    delete<T extends BmIdBmComposicaoDeleteArgs>(args: SelectSubset<T, BmIdBmComposicaoDeleteArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmIdBmComposicao.
     * @param {BmIdBmComposicaoUpdateArgs} args - Arguments to update one BmIdBmComposicao.
     * @example
     * // Update one BmIdBmComposicao
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmIdBmComposicaoUpdateArgs>(args: SelectSubset<T, BmIdBmComposicaoUpdateArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmIdBmComposicaos.
     * @param {BmIdBmComposicaoDeleteManyArgs} args - Arguments to filter BmIdBmComposicaos to delete.
     * @example
     * // Delete a few BmIdBmComposicaos
     * const { count } = await prisma.bmIdBmComposicao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmIdBmComposicaoDeleteManyArgs>(args?: SelectSubset<T, BmIdBmComposicaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmIdBmComposicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmIdBmComposicaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmIdBmComposicaos
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmIdBmComposicaoUpdateManyArgs>(args: SelectSubset<T, BmIdBmComposicaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmIdBmComposicao.
     * @param {BmIdBmComposicaoUpsertArgs} args - Arguments to update or create a BmIdBmComposicao.
     * @example
     * // Update or create a BmIdBmComposicao
     * const bmIdBmComposicao = await prisma.bmIdBmComposicao.upsert({
     *   create: {
     *     // ... data to create a BmIdBmComposicao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmIdBmComposicao we want to update
     *   }
     * })
     */
    upsert<T extends BmIdBmComposicaoUpsertArgs>(args: SelectSubset<T, BmIdBmComposicaoUpsertArgs<ExtArgs>>): Prisma__BmIdBmComposicaoClient<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmIdBmComposicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmIdBmComposicaoCountArgs} args - Arguments to filter BmIdBmComposicaos to count.
     * @example
     * // Count the number of BmIdBmComposicaos
     * const count = await prisma.bmIdBmComposicao.count({
     *   where: {
     *     // ... the filter for the BmIdBmComposicaos we want to count
     *   }
     * })
    **/
    count<T extends BmIdBmComposicaoCountArgs>(
      args?: Subset<T, BmIdBmComposicaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmIdBmComposicaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmIdBmComposicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmIdBmComposicaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmIdBmComposicaoAggregateArgs>(args: Subset<T, BmIdBmComposicaoAggregateArgs>): Prisma.PrismaPromise<GetBmIdBmComposicaoAggregateType<T>>

    /**
     * Group by BmIdBmComposicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmIdBmComposicaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmIdBmComposicaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmIdBmComposicaoGroupByArgs['orderBy'] }
        : { orderBy?: BmIdBmComposicaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmIdBmComposicaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmIdBmComposicaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmIdBmComposicao model
   */
  readonly fields: BmIdBmComposicaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmIdBmComposicao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmIdBmComposicaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMalhas<T extends BmMalhasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhasDefaultArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmMateriaisComposicao<T extends BmMateriaisComposicaoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriaisComposicaoDefaultArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmIdBmComposicao model
   */ 
  interface BmIdBmComposicaoFieldRefs {
    readonly idBm: FieldRef<"BmIdBmComposicao", 'String'>
    readonly ref: FieldRef<"BmIdBmComposicao", 'String'>
    readonly idComposicao: FieldRef<"BmIdBmComposicao", 'Int'>
    readonly qtt: FieldRef<"BmIdBmComposicao", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * BmIdBmComposicao findUnique
   */
  export type BmIdBmComposicaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmIdBmComposicao to fetch.
     */
    where: BmIdBmComposicaoWhereUniqueInput
  }

  /**
   * BmIdBmComposicao findUniqueOrThrow
   */
  export type BmIdBmComposicaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmIdBmComposicao to fetch.
     */
    where: BmIdBmComposicaoWhereUniqueInput
  }

  /**
   * BmIdBmComposicao findFirst
   */
  export type BmIdBmComposicaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmIdBmComposicao to fetch.
     */
    where?: BmIdBmComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmIdBmComposicaos to fetch.
     */
    orderBy?: BmIdBmComposicaoOrderByWithRelationInput | BmIdBmComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmIdBmComposicaos.
     */
    cursor?: BmIdBmComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmIdBmComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmIdBmComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmIdBmComposicaos.
     */
    distinct?: BmIdBmComposicaoScalarFieldEnum | BmIdBmComposicaoScalarFieldEnum[]
  }

  /**
   * BmIdBmComposicao findFirstOrThrow
   */
  export type BmIdBmComposicaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmIdBmComposicao to fetch.
     */
    where?: BmIdBmComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmIdBmComposicaos to fetch.
     */
    orderBy?: BmIdBmComposicaoOrderByWithRelationInput | BmIdBmComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmIdBmComposicaos.
     */
    cursor?: BmIdBmComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmIdBmComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmIdBmComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmIdBmComposicaos.
     */
    distinct?: BmIdBmComposicaoScalarFieldEnum | BmIdBmComposicaoScalarFieldEnum[]
  }

  /**
   * BmIdBmComposicao findMany
   */
  export type BmIdBmComposicaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmIdBmComposicaos to fetch.
     */
    where?: BmIdBmComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmIdBmComposicaos to fetch.
     */
    orderBy?: BmIdBmComposicaoOrderByWithRelationInput | BmIdBmComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmIdBmComposicaos.
     */
    cursor?: BmIdBmComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmIdBmComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmIdBmComposicaos.
     */
    skip?: number
    distinct?: BmIdBmComposicaoScalarFieldEnum | BmIdBmComposicaoScalarFieldEnum[]
  }

  /**
   * BmIdBmComposicao create
   */
  export type BmIdBmComposicaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * The data needed to create a BmIdBmComposicao.
     */
    data: XOR<BmIdBmComposicaoCreateInput, BmIdBmComposicaoUncheckedCreateInput>
  }

  /**
   * BmIdBmComposicao createMany
   */
  export type BmIdBmComposicaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmIdBmComposicaos.
     */
    data: BmIdBmComposicaoCreateManyInput | BmIdBmComposicaoCreateManyInput[]
  }

  /**
   * BmIdBmComposicao update
   */
  export type BmIdBmComposicaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * The data needed to update a BmIdBmComposicao.
     */
    data: XOR<BmIdBmComposicaoUpdateInput, BmIdBmComposicaoUncheckedUpdateInput>
    /**
     * Choose, which BmIdBmComposicao to update.
     */
    where: BmIdBmComposicaoWhereUniqueInput
  }

  /**
   * BmIdBmComposicao updateMany
   */
  export type BmIdBmComposicaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmIdBmComposicaos.
     */
    data: XOR<BmIdBmComposicaoUpdateManyMutationInput, BmIdBmComposicaoUncheckedUpdateManyInput>
    /**
     * Filter which BmIdBmComposicaos to update
     */
    where?: BmIdBmComposicaoWhereInput
    /**
     * Limit how many BmIdBmComposicaos to update.
     */
    limit?: number
  }

  /**
   * BmIdBmComposicao upsert
   */
  export type BmIdBmComposicaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * The filter to search for the BmIdBmComposicao to update in case it exists.
     */
    where: BmIdBmComposicaoWhereUniqueInput
    /**
     * In case the BmIdBmComposicao found by the `where` argument doesn't exist, create a new BmIdBmComposicao with this data.
     */
    create: XOR<BmIdBmComposicaoCreateInput, BmIdBmComposicaoUncheckedCreateInput>
    /**
     * In case the BmIdBmComposicao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmIdBmComposicaoUpdateInput, BmIdBmComposicaoUncheckedUpdateInput>
  }

  /**
   * BmIdBmComposicao delete
   */
  export type BmIdBmComposicaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    /**
     * Filter which BmIdBmComposicao to delete.
     */
    where: BmIdBmComposicaoWhereUniqueInput
  }

  /**
   * BmIdBmComposicao deleteMany
   */
  export type BmIdBmComposicaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmIdBmComposicaos to delete
     */
    where?: BmIdBmComposicaoWhereInput
    /**
     * Limit how many BmIdBmComposicaos to delete.
     */
    limit?: number
  }

  /**
   * BmIdBmComposicao without action
   */
  export type BmIdBmComposicaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
  }


  /**
   * Model BmMalhas
   */

  export type AggregateBmMalhas = {
    _count: BmMalhasCountAggregateOutputType | null
    _avg: BmMalhasAvgAggregateOutputType | null
    _sum: BmMalhasSumAggregateOutputType | null
    _min: BmMalhasMinAggregateOutputType | null
    _max: BmMalhasMaxAggregateOutputType | null
  }

  export type BmMalhasAvgAggregateOutputType = {
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    qtdeEntradaSeUnidade: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
  }

  export type BmMalhasSumAggregateOutputType = {
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    qtdeEntradaSeUnidade: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
  }

  export type BmMalhasMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    malha: string | null
    grupo: string | null
    subGrupo: string | null
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    qtdeEntradaSeUnidade: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMalhasMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    malha: string | null
    grupo: string | null
    subGrupo: string | null
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    qtdeEntradaSeUnidade: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMalhasCountAggregateOutputType = {
    idBm: number
    ref: number
    malha: number
    grupo: number
    subGrupo: number
    qtdePedida: number
    qtdeEntrada: number
    qtdeEntradaSeUnidade: number
    defeitosStock: number
    sobras: number
    unidade: number
    lote: number
    _all: number
  }


  export type BmMalhasAvgAggregateInputType = {
    qtdePedida?: true
    qtdeEntrada?: true
    qtdeEntradaSeUnidade?: true
    defeitosStock?: true
    sobras?: true
  }

  export type BmMalhasSumAggregateInputType = {
    qtdePedida?: true
    qtdeEntrada?: true
    qtdeEntradaSeUnidade?: true
    defeitosStock?: true
    sobras?: true
  }

  export type BmMalhasMinAggregateInputType = {
    idBm?: true
    ref?: true
    malha?: true
    grupo?: true
    subGrupo?: true
    qtdePedida?: true
    qtdeEntrada?: true
    qtdeEntradaSeUnidade?: true
    defeitosStock?: true
    sobras?: true
    unidade?: true
    lote?: true
  }

  export type BmMalhasMaxAggregateInputType = {
    idBm?: true
    ref?: true
    malha?: true
    grupo?: true
    subGrupo?: true
    qtdePedida?: true
    qtdeEntrada?: true
    qtdeEntradaSeUnidade?: true
    defeitosStock?: true
    sobras?: true
    unidade?: true
    lote?: true
  }

  export type BmMalhasCountAggregateInputType = {
    idBm?: true
    ref?: true
    malha?: true
    grupo?: true
    subGrupo?: true
    qtdePedida?: true
    qtdeEntrada?: true
    qtdeEntradaSeUnidade?: true
    defeitosStock?: true
    sobras?: true
    unidade?: true
    lote?: true
    _all?: true
  }

  export type BmMalhasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMalhas to aggregate.
     */
    where?: BmMalhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhas to fetch.
     */
    orderBy?: BmMalhasOrderByWithRelationInput | BmMalhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMalhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMalhas
    **/
    _count?: true | BmMalhasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmMalhasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmMalhasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMalhasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMalhasMaxAggregateInputType
  }

  export type GetBmMalhasAggregateType<T extends BmMalhasAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMalhas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMalhas[P]>
      : GetScalarType<T[P], AggregateBmMalhas[P]>
  }




  export type BmMalhasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasWhereInput
    orderBy?: BmMalhasOrderByWithAggregationInput | BmMalhasOrderByWithAggregationInput[]
    by: BmMalhasScalarFieldEnum[] | BmMalhasScalarFieldEnum
    having?: BmMalhasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMalhasCountAggregateInputType | true
    _avg?: BmMalhasAvgAggregateInputType
    _sum?: BmMalhasSumAggregateInputType
    _min?: BmMalhasMinAggregateInputType
    _max?: BmMalhasMaxAggregateInputType
  }

  export type BmMalhasGroupByOutputType = {
    idBm: string
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal
    qtdeEntrada: Decimal
    qtdeEntradaSeUnidade: Decimal | null
    defeitosStock: Decimal
    sobras: Decimal
    unidade: string
    lote: string
    _count: BmMalhasCountAggregateOutputType | null
    _avg: BmMalhasAvgAggregateOutputType | null
    _sum: BmMalhasSumAggregateOutputType | null
    _min: BmMalhasMinAggregateOutputType | null
    _max: BmMalhasMaxAggregateOutputType | null
  }

  type GetBmMalhasGroupByPayload<T extends BmMalhasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMalhasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMalhasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMalhasGroupByOutputType[P]>
            : GetScalarType<T[P], BmMalhasGroupByOutputType[P]>
        }
      >
    >


  export type BmMalhasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    malha?: boolean
    grupo?: boolean
    subGrupo?: boolean
    qtdePedida?: boolean
    qtdeEntrada?: boolean
    qtdeEntradaSeUnidade?: boolean
    defeitosStock?: boolean
    sobras?: boolean
    unidade?: boolean
    lote?: boolean
    BmIdBmComposicao?: boolean | BmMalhas$BmIdBmComposicaoArgs<ExtArgs>
    Bm?: boolean | BmDefaultArgs<ExtArgs>
    BmMateriais?: boolean | BmMateriaisDefaultArgs<ExtArgs>
    BmMalhasFio?: boolean | BmMalhas$BmMalhasFioArgs<ExtArgs>
    BmOpsPorMalha?: boolean | BmMalhas$BmOpsPorMalhaArgs<ExtArgs>
    _count?: boolean | BmMalhasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMalhas"]>



  export type BmMalhasSelectScalar = {
    idBm?: boolean
    ref?: boolean
    malha?: boolean
    grupo?: boolean
    subGrupo?: boolean
    qtdePedida?: boolean
    qtdeEntrada?: boolean
    qtdeEntradaSeUnidade?: boolean
    defeitosStock?: boolean
    sobras?: boolean
    unidade?: boolean
    lote?: boolean
  }

  export type BmMalhasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "malha" | "grupo" | "subGrupo" | "qtdePedida" | "qtdeEntrada" | "qtdeEntradaSeUnidade" | "defeitosStock" | "sobras" | "unidade" | "lote", ExtArgs["result"]["bmMalhas"]>
  export type BmMalhasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmIdBmComposicao?: boolean | BmMalhas$BmIdBmComposicaoArgs<ExtArgs>
    Bm?: boolean | BmDefaultArgs<ExtArgs>
    BmMateriais?: boolean | BmMateriaisDefaultArgs<ExtArgs>
    BmMalhasFio?: boolean | BmMalhas$BmMalhasFioArgs<ExtArgs>
    BmOpsPorMalha?: boolean | BmMalhas$BmOpsPorMalhaArgs<ExtArgs>
    _count?: boolean | BmMalhasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMalhasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMalhas"
    objects: {
      BmIdBmComposicao: Prisma.$BmIdBmComposicaoPayload<ExtArgs>[]
      Bm: Prisma.$BmPayload<ExtArgs>
      BmMateriais: Prisma.$BmMateriaisPayload<ExtArgs>
      BmMalhasFio: Prisma.$BmMalhasFioPayload<ExtArgs>[]
      BmOpsPorMalha: Prisma.$BmOpsPorMalhaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      malha: string
      grupo: string
      subGrupo: string
      qtdePedida: Prisma.Decimal
      qtdeEntrada: Prisma.Decimal
      qtdeEntradaSeUnidade: Prisma.Decimal | null
      defeitosStock: Prisma.Decimal
      sobras: Prisma.Decimal
      unidade: string
      lote: string
    }, ExtArgs["result"]["bmMalhas"]>
    composites: {}
  }

  type BmMalhasGetPayload<S extends boolean | null | undefined | BmMalhasDefaultArgs> = $Result.GetResult<Prisma.$BmMalhasPayload, S>

  type BmMalhasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMalhasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMalhasCountAggregateInputType | true
    }

  export interface BmMalhasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMalhas'], meta: { name: 'BmMalhas' } }
    /**
     * Find zero or one BmMalhas that matches the filter.
     * @param {BmMalhasFindUniqueArgs} args - Arguments to find a BmMalhas
     * @example
     * // Get one BmMalhas
     * const bmMalhas = await prisma.bmMalhas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMalhasFindUniqueArgs>(args: SelectSubset<T, BmMalhasFindUniqueArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMalhas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMalhasFindUniqueOrThrowArgs} args - Arguments to find a BmMalhas
     * @example
     * // Get one BmMalhas
     * const bmMalhas = await prisma.bmMalhas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMalhasFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMalhasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMalhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFindFirstArgs} args - Arguments to find a BmMalhas
     * @example
     * // Get one BmMalhas
     * const bmMalhas = await prisma.bmMalhas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMalhasFindFirstArgs>(args?: SelectSubset<T, BmMalhasFindFirstArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMalhas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFindFirstOrThrowArgs} args - Arguments to find a BmMalhas
     * @example
     * // Get one BmMalhas
     * const bmMalhas = await prisma.bmMalhas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMalhasFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMalhasFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMalhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMalhas
     * const bmMalhas = await prisma.bmMalhas.findMany()
     * 
     * // Get first 10 BmMalhas
     * const bmMalhas = await prisma.bmMalhas.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmMalhasWithIdBmOnly = await prisma.bmMalhas.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmMalhasFindManyArgs>(args?: SelectSubset<T, BmMalhasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMalhas.
     * @param {BmMalhasCreateArgs} args - Arguments to create a BmMalhas.
     * @example
     * // Create one BmMalhas
     * const BmMalhas = await prisma.bmMalhas.create({
     *   data: {
     *     // ... data to create a BmMalhas
     *   }
     * })
     * 
     */
    create<T extends BmMalhasCreateArgs>(args: SelectSubset<T, BmMalhasCreateArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMalhas.
     * @param {BmMalhasCreateManyArgs} args - Arguments to create many BmMalhas.
     * @example
     * // Create many BmMalhas
     * const bmMalhas = await prisma.bmMalhas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMalhasCreateManyArgs>(args?: SelectSubset<T, BmMalhasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMalhas.
     * @param {BmMalhasDeleteArgs} args - Arguments to delete one BmMalhas.
     * @example
     * // Delete one BmMalhas
     * const BmMalhas = await prisma.bmMalhas.delete({
     *   where: {
     *     // ... filter to delete one BmMalhas
     *   }
     * })
     * 
     */
    delete<T extends BmMalhasDeleteArgs>(args: SelectSubset<T, BmMalhasDeleteArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMalhas.
     * @param {BmMalhasUpdateArgs} args - Arguments to update one BmMalhas.
     * @example
     * // Update one BmMalhas
     * const bmMalhas = await prisma.bmMalhas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMalhasUpdateArgs>(args: SelectSubset<T, BmMalhasUpdateArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMalhas.
     * @param {BmMalhasDeleteManyArgs} args - Arguments to filter BmMalhas to delete.
     * @example
     * // Delete a few BmMalhas
     * const { count } = await prisma.bmMalhas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMalhasDeleteManyArgs>(args?: SelectSubset<T, BmMalhasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMalhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMalhas
     * const bmMalhas = await prisma.bmMalhas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMalhasUpdateManyArgs>(args: SelectSubset<T, BmMalhasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMalhas.
     * @param {BmMalhasUpsertArgs} args - Arguments to update or create a BmMalhas.
     * @example
     * // Update or create a BmMalhas
     * const bmMalhas = await prisma.bmMalhas.upsert({
     *   create: {
     *     // ... data to create a BmMalhas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMalhas we want to update
     *   }
     * })
     */
    upsert<T extends BmMalhasUpsertArgs>(args: SelectSubset<T, BmMalhasUpsertArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMalhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasCountArgs} args - Arguments to filter BmMalhas to count.
     * @example
     * // Count the number of BmMalhas
     * const count = await prisma.bmMalhas.count({
     *   where: {
     *     // ... the filter for the BmMalhas we want to count
     *   }
     * })
    **/
    count<T extends BmMalhasCountArgs>(
      args?: Subset<T, BmMalhasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMalhasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMalhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMalhasAggregateArgs>(args: Subset<T, BmMalhasAggregateArgs>): Prisma.PrismaPromise<GetBmMalhasAggregateType<T>>

    /**
     * Group by BmMalhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMalhasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMalhasGroupByArgs['orderBy'] }
        : { orderBy?: BmMalhasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMalhasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMalhasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMalhas model
   */
  readonly fields: BmMalhasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMalhas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMalhasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmIdBmComposicao<T extends BmMalhas$BmIdBmComposicaoArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhas$BmIdBmComposicaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Bm<T extends BmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmDefaultArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmMateriais<T extends BmMateriaisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriaisDefaultArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmMalhasFio<T extends BmMalhas$BmMalhasFioArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhas$BmMalhasFioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmOpsPorMalha<T extends BmMalhas$BmOpsPorMalhaArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhas$BmOpsPorMalhaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMalhas model
   */ 
  interface BmMalhasFieldRefs {
    readonly idBm: FieldRef<"BmMalhas", 'String'>
    readonly ref: FieldRef<"BmMalhas", 'String'>
    readonly malha: FieldRef<"BmMalhas", 'String'>
    readonly grupo: FieldRef<"BmMalhas", 'String'>
    readonly subGrupo: FieldRef<"BmMalhas", 'String'>
    readonly qtdePedida: FieldRef<"BmMalhas", 'Decimal'>
    readonly qtdeEntrada: FieldRef<"BmMalhas", 'Decimal'>
    readonly qtdeEntradaSeUnidade: FieldRef<"BmMalhas", 'Decimal'>
    readonly defeitosStock: FieldRef<"BmMalhas", 'Decimal'>
    readonly sobras: FieldRef<"BmMalhas", 'Decimal'>
    readonly unidade: FieldRef<"BmMalhas", 'String'>
    readonly lote: FieldRef<"BmMalhas", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMalhas findUnique
   */
  export type BmMalhasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhas to fetch.
     */
    where: BmMalhasWhereUniqueInput
  }

  /**
   * BmMalhas findUniqueOrThrow
   */
  export type BmMalhasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhas to fetch.
     */
    where: BmMalhasWhereUniqueInput
  }

  /**
   * BmMalhas findFirst
   */
  export type BmMalhasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhas to fetch.
     */
    where?: BmMalhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhas to fetch.
     */
    orderBy?: BmMalhasOrderByWithRelationInput | BmMalhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMalhas.
     */
    cursor?: BmMalhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMalhas.
     */
    distinct?: BmMalhasScalarFieldEnum | BmMalhasScalarFieldEnum[]
  }

  /**
   * BmMalhas findFirstOrThrow
   */
  export type BmMalhasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhas to fetch.
     */
    where?: BmMalhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhas to fetch.
     */
    orderBy?: BmMalhasOrderByWithRelationInput | BmMalhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMalhas.
     */
    cursor?: BmMalhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMalhas.
     */
    distinct?: BmMalhasScalarFieldEnum | BmMalhasScalarFieldEnum[]
  }

  /**
   * BmMalhas findMany
   */
  export type BmMalhasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhas to fetch.
     */
    where?: BmMalhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhas to fetch.
     */
    orderBy?: BmMalhasOrderByWithRelationInput | BmMalhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMalhas.
     */
    cursor?: BmMalhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhas.
     */
    skip?: number
    distinct?: BmMalhasScalarFieldEnum | BmMalhasScalarFieldEnum[]
  }

  /**
   * BmMalhas create
   */
  export type BmMalhasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMalhas.
     */
    data: XOR<BmMalhasCreateInput, BmMalhasUncheckedCreateInput>
  }

  /**
   * BmMalhas createMany
   */
  export type BmMalhasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMalhas.
     */
    data: BmMalhasCreateManyInput | BmMalhasCreateManyInput[]
  }

  /**
   * BmMalhas update
   */
  export type BmMalhasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMalhas.
     */
    data: XOR<BmMalhasUpdateInput, BmMalhasUncheckedUpdateInput>
    /**
     * Choose, which BmMalhas to update.
     */
    where: BmMalhasWhereUniqueInput
  }

  /**
   * BmMalhas updateMany
   */
  export type BmMalhasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMalhas.
     */
    data: XOR<BmMalhasUpdateManyMutationInput, BmMalhasUncheckedUpdateManyInput>
    /**
     * Filter which BmMalhas to update
     */
    where?: BmMalhasWhereInput
    /**
     * Limit how many BmMalhas to update.
     */
    limit?: number
  }

  /**
   * BmMalhas upsert
   */
  export type BmMalhasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMalhas to update in case it exists.
     */
    where: BmMalhasWhereUniqueInput
    /**
     * In case the BmMalhas found by the `where` argument doesn't exist, create a new BmMalhas with this data.
     */
    create: XOR<BmMalhasCreateInput, BmMalhasUncheckedCreateInput>
    /**
     * In case the BmMalhas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMalhasUpdateInput, BmMalhasUncheckedUpdateInput>
  }

  /**
   * BmMalhas delete
   */
  export type BmMalhasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    /**
     * Filter which BmMalhas to delete.
     */
    where: BmMalhasWhereUniqueInput
  }

  /**
   * BmMalhas deleteMany
   */
  export type BmMalhasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMalhas to delete
     */
    where?: BmMalhasWhereInput
    /**
     * Limit how many BmMalhas to delete.
     */
    limit?: number
  }

  /**
   * BmMalhas.BmIdBmComposicao
   */
  export type BmMalhas$BmIdBmComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    where?: BmIdBmComposicaoWhereInput
    orderBy?: BmIdBmComposicaoOrderByWithRelationInput | BmIdBmComposicaoOrderByWithRelationInput[]
    cursor?: BmIdBmComposicaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmIdBmComposicaoScalarFieldEnum | BmIdBmComposicaoScalarFieldEnum[]
  }

  /**
   * BmMalhas.BmMalhasFio
   */
  export type BmMalhas$BmMalhasFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    where?: BmMalhasFioWhereInput
    orderBy?: BmMalhasFioOrderByWithRelationInput | BmMalhasFioOrderByWithRelationInput[]
    cursor?: BmMalhasFioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMalhasFioScalarFieldEnum | BmMalhasFioScalarFieldEnum[]
  }

  /**
   * BmMalhas.BmOpsPorMalha
   */
  export type BmMalhas$BmOpsPorMalhaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    where?: BmOpsPorMalhaWhereInput
    orderBy?: BmOpsPorMalhaOrderByWithRelationInput | BmOpsPorMalhaOrderByWithRelationInput[]
    cursor?: BmOpsPorMalhaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmOpsPorMalhaScalarFieldEnum | BmOpsPorMalhaScalarFieldEnum[]
  }

  /**
   * BmMalhas without action
   */
  export type BmMalhasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
  }


  /**
   * Model BmMalhasFio
   */

  export type AggregateBmMalhasFio = {
    _count: BmMalhasFioCountAggregateOutputType | null
    _avg: BmMalhasFioAvgAggregateOutputType | null
    _sum: BmMalhasFioSumAggregateOutputType | null
    _min: BmMalhasFioMinAggregateOutputType | null
    _max: BmMalhasFioMaxAggregateOutputType | null
  }

  export type BmMalhasFioAvgAggregateOutputType = {
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
  }

  export type BmMalhasFioSumAggregateOutputType = {
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
  }

  export type BmMalhasFioMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    fio: string | null
    grupo: string | null
    subGrupo: string | null
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMalhasFioMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    fio: string | null
    grupo: string | null
    subGrupo: string | null
    qtdePedida: Decimal | null
    qtdeEntrada: Decimal | null
    defeitosStock: Decimal | null
    sobras: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMalhasFioCountAggregateOutputType = {
    idBm: number
    ref: number
    refOrigem: number
    fio: number
    grupo: number
    subGrupo: number
    qtdePedida: number
    qtdeEntrada: number
    defeitosStock: number
    sobras: number
    unidade: number
    lote: number
    _all: number
  }


  export type BmMalhasFioAvgAggregateInputType = {
    qtdePedida?: true
    qtdeEntrada?: true
    defeitosStock?: true
    sobras?: true
  }

  export type BmMalhasFioSumAggregateInputType = {
    qtdePedida?: true
    qtdeEntrada?: true
    defeitosStock?: true
    sobras?: true
  }

  export type BmMalhasFioMinAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    fio?: true
    grupo?: true
    subGrupo?: true
    qtdePedida?: true
    qtdeEntrada?: true
    defeitosStock?: true
    sobras?: true
    unidade?: true
    lote?: true
  }

  export type BmMalhasFioMaxAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    fio?: true
    grupo?: true
    subGrupo?: true
    qtdePedida?: true
    qtdeEntrada?: true
    defeitosStock?: true
    sobras?: true
    unidade?: true
    lote?: true
  }

  export type BmMalhasFioCountAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    fio?: true
    grupo?: true
    subGrupo?: true
    qtdePedida?: true
    qtdeEntrada?: true
    defeitosStock?: true
    sobras?: true
    unidade?: true
    lote?: true
    _all?: true
  }

  export type BmMalhasFioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMalhasFio to aggregate.
     */
    where?: BmMalhasFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFios to fetch.
     */
    orderBy?: BmMalhasFioOrderByWithRelationInput | BmMalhasFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMalhasFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMalhasFios
    **/
    _count?: true | BmMalhasFioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmMalhasFioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmMalhasFioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMalhasFioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMalhasFioMaxAggregateInputType
  }

  export type GetBmMalhasFioAggregateType<T extends BmMalhasFioAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMalhasFio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMalhasFio[P]>
      : GetScalarType<T[P], AggregateBmMalhasFio[P]>
  }




  export type BmMalhasFioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasFioWhereInput
    orderBy?: BmMalhasFioOrderByWithAggregationInput | BmMalhasFioOrderByWithAggregationInput[]
    by: BmMalhasFioScalarFieldEnum[] | BmMalhasFioScalarFieldEnum
    having?: BmMalhasFioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMalhasFioCountAggregateInputType | true
    _avg?: BmMalhasFioAvgAggregateInputType
    _sum?: BmMalhasFioSumAggregateInputType
    _min?: BmMalhasFioMinAggregateInputType
    _max?: BmMalhasFioMaxAggregateInputType
  }

  export type BmMalhasFioGroupByOutputType = {
    idBm: string
    ref: string
    refOrigem: string
    fio: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal
    qtdeEntrada: Decimal
    defeitosStock: Decimal
    sobras: Decimal
    unidade: string
    lote: string
    _count: BmMalhasFioCountAggregateOutputType | null
    _avg: BmMalhasFioAvgAggregateOutputType | null
    _sum: BmMalhasFioSumAggregateOutputType | null
    _min: BmMalhasFioMinAggregateOutputType | null
    _max: BmMalhasFioMaxAggregateOutputType | null
  }

  type GetBmMalhasFioGroupByPayload<T extends BmMalhasFioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMalhasFioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMalhasFioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMalhasFioGroupByOutputType[P]>
            : GetScalarType<T[P], BmMalhasFioGroupByOutputType[P]>
        }
      >
    >


  export type BmMalhasFioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    fio?: boolean
    grupo?: boolean
    subGrupo?: boolean
    qtdePedida?: boolean
    qtdeEntrada?: boolean
    defeitosStock?: boolean
    sobras?: boolean
    unidade?: boolean
    lote?: boolean
    BmFioComposicao?: boolean | BmMalhasFio$BmFioComposicaoArgs<ExtArgs>
    BmMalhas?: boolean | BmMalhasDefaultArgs<ExtArgs>
    BmMateriaisFio?: boolean | BmMateriaisFioDefaultArgs<ExtArgs>
    BmOpsPorMalhaFio?: boolean | BmMalhasFio$BmOpsPorMalhaFioArgs<ExtArgs>
    _count?: boolean | BmMalhasFioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMalhasFio"]>



  export type BmMalhasFioSelectScalar = {
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    fio?: boolean
    grupo?: boolean
    subGrupo?: boolean
    qtdePedida?: boolean
    qtdeEntrada?: boolean
    defeitosStock?: boolean
    sobras?: boolean
    unidade?: boolean
    lote?: boolean
  }

  export type BmMalhasFioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "refOrigem" | "fio" | "grupo" | "subGrupo" | "qtdePedida" | "qtdeEntrada" | "defeitosStock" | "sobras" | "unidade" | "lote", ExtArgs["result"]["bmMalhasFio"]>
  export type BmMalhasFioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmFioComposicao?: boolean | BmMalhasFio$BmFioComposicaoArgs<ExtArgs>
    BmMalhas?: boolean | BmMalhasDefaultArgs<ExtArgs>
    BmMateriaisFio?: boolean | BmMateriaisFioDefaultArgs<ExtArgs>
    BmOpsPorMalhaFio?: boolean | BmMalhasFio$BmOpsPorMalhaFioArgs<ExtArgs>
    _count?: boolean | BmMalhasFioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMalhasFioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMalhasFio"
    objects: {
      BmFioComposicao: Prisma.$BmFioComposicaoPayload<ExtArgs>[]
      BmMalhas: Prisma.$BmMalhasPayload<ExtArgs>
      BmMateriaisFio: Prisma.$BmMateriaisFioPayload<ExtArgs>
      BmOpsPorMalhaFio: Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      refOrigem: string
      fio: string
      grupo: string
      subGrupo: string
      qtdePedida: Prisma.Decimal
      qtdeEntrada: Prisma.Decimal
      defeitosStock: Prisma.Decimal
      sobras: Prisma.Decimal
      unidade: string
      lote: string
    }, ExtArgs["result"]["bmMalhasFio"]>
    composites: {}
  }

  type BmMalhasFioGetPayload<S extends boolean | null | undefined | BmMalhasFioDefaultArgs> = $Result.GetResult<Prisma.$BmMalhasFioPayload, S>

  type BmMalhasFioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMalhasFioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMalhasFioCountAggregateInputType | true
    }

  export interface BmMalhasFioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMalhasFio'], meta: { name: 'BmMalhasFio' } }
    /**
     * Find zero or one BmMalhasFio that matches the filter.
     * @param {BmMalhasFioFindUniqueArgs} args - Arguments to find a BmMalhasFio
     * @example
     * // Get one BmMalhasFio
     * const bmMalhasFio = await prisma.bmMalhasFio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMalhasFioFindUniqueArgs>(args: SelectSubset<T, BmMalhasFioFindUniqueArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMalhasFio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMalhasFioFindUniqueOrThrowArgs} args - Arguments to find a BmMalhasFio
     * @example
     * // Get one BmMalhasFio
     * const bmMalhasFio = await prisma.bmMalhasFio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMalhasFioFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMalhasFioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMalhasFio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioFindFirstArgs} args - Arguments to find a BmMalhasFio
     * @example
     * // Get one BmMalhasFio
     * const bmMalhasFio = await prisma.bmMalhasFio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMalhasFioFindFirstArgs>(args?: SelectSubset<T, BmMalhasFioFindFirstArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMalhasFio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioFindFirstOrThrowArgs} args - Arguments to find a BmMalhasFio
     * @example
     * // Get one BmMalhasFio
     * const bmMalhasFio = await prisma.bmMalhasFio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMalhasFioFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMalhasFioFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMalhasFios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMalhasFios
     * const bmMalhasFios = await prisma.bmMalhasFio.findMany()
     * 
     * // Get first 10 BmMalhasFios
     * const bmMalhasFios = await prisma.bmMalhasFio.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmMalhasFioWithIdBmOnly = await prisma.bmMalhasFio.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmMalhasFioFindManyArgs>(args?: SelectSubset<T, BmMalhasFioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMalhasFio.
     * @param {BmMalhasFioCreateArgs} args - Arguments to create a BmMalhasFio.
     * @example
     * // Create one BmMalhasFio
     * const BmMalhasFio = await prisma.bmMalhasFio.create({
     *   data: {
     *     // ... data to create a BmMalhasFio
     *   }
     * })
     * 
     */
    create<T extends BmMalhasFioCreateArgs>(args: SelectSubset<T, BmMalhasFioCreateArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMalhasFios.
     * @param {BmMalhasFioCreateManyArgs} args - Arguments to create many BmMalhasFios.
     * @example
     * // Create many BmMalhasFios
     * const bmMalhasFio = await prisma.bmMalhasFio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMalhasFioCreateManyArgs>(args?: SelectSubset<T, BmMalhasFioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMalhasFio.
     * @param {BmMalhasFioDeleteArgs} args - Arguments to delete one BmMalhasFio.
     * @example
     * // Delete one BmMalhasFio
     * const BmMalhasFio = await prisma.bmMalhasFio.delete({
     *   where: {
     *     // ... filter to delete one BmMalhasFio
     *   }
     * })
     * 
     */
    delete<T extends BmMalhasFioDeleteArgs>(args: SelectSubset<T, BmMalhasFioDeleteArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMalhasFio.
     * @param {BmMalhasFioUpdateArgs} args - Arguments to update one BmMalhasFio.
     * @example
     * // Update one BmMalhasFio
     * const bmMalhasFio = await prisma.bmMalhasFio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMalhasFioUpdateArgs>(args: SelectSubset<T, BmMalhasFioUpdateArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMalhasFios.
     * @param {BmMalhasFioDeleteManyArgs} args - Arguments to filter BmMalhasFios to delete.
     * @example
     * // Delete a few BmMalhasFios
     * const { count } = await prisma.bmMalhasFio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMalhasFioDeleteManyArgs>(args?: SelectSubset<T, BmMalhasFioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMalhasFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMalhasFios
     * const bmMalhasFio = await prisma.bmMalhasFio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMalhasFioUpdateManyArgs>(args: SelectSubset<T, BmMalhasFioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMalhasFio.
     * @param {BmMalhasFioUpsertArgs} args - Arguments to update or create a BmMalhasFio.
     * @example
     * // Update or create a BmMalhasFio
     * const bmMalhasFio = await prisma.bmMalhasFio.upsert({
     *   create: {
     *     // ... data to create a BmMalhasFio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMalhasFio we want to update
     *   }
     * })
     */
    upsert<T extends BmMalhasFioUpsertArgs>(args: SelectSubset<T, BmMalhasFioUpsertArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMalhasFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioCountArgs} args - Arguments to filter BmMalhasFios to count.
     * @example
     * // Count the number of BmMalhasFios
     * const count = await prisma.bmMalhasFio.count({
     *   where: {
     *     // ... the filter for the BmMalhasFios we want to count
     *   }
     * })
    **/
    count<T extends BmMalhasFioCountArgs>(
      args?: Subset<T, BmMalhasFioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMalhasFioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMalhasFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMalhasFioAggregateArgs>(args: Subset<T, BmMalhasFioAggregateArgs>): Prisma.PrismaPromise<GetBmMalhasFioAggregateType<T>>

    /**
     * Group by BmMalhasFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMalhasFioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMalhasFioGroupByArgs['orderBy'] }
        : { orderBy?: BmMalhasFioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMalhasFioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMalhasFioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMalhasFio model
   */
  readonly fields: BmMalhasFioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMalhasFio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMalhasFioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmFioComposicao<T extends BmMalhasFio$BmFioComposicaoArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhasFio$BmFioComposicaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmMalhas<T extends BmMalhasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhasDefaultArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmMateriaisFio<T extends BmMateriaisFioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriaisFioDefaultArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmOpsPorMalhaFio<T extends BmMalhasFio$BmOpsPorMalhaFioArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhasFio$BmOpsPorMalhaFioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMalhasFio model
   */ 
  interface BmMalhasFioFieldRefs {
    readonly idBm: FieldRef<"BmMalhasFio", 'String'>
    readonly ref: FieldRef<"BmMalhasFio", 'String'>
    readonly refOrigem: FieldRef<"BmMalhasFio", 'String'>
    readonly fio: FieldRef<"BmMalhasFio", 'String'>
    readonly grupo: FieldRef<"BmMalhasFio", 'String'>
    readonly subGrupo: FieldRef<"BmMalhasFio", 'String'>
    readonly qtdePedida: FieldRef<"BmMalhasFio", 'Decimal'>
    readonly qtdeEntrada: FieldRef<"BmMalhasFio", 'Decimal'>
    readonly defeitosStock: FieldRef<"BmMalhasFio", 'Decimal'>
    readonly sobras: FieldRef<"BmMalhasFio", 'Decimal'>
    readonly unidade: FieldRef<"BmMalhasFio", 'String'>
    readonly lote: FieldRef<"BmMalhasFio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMalhasFio findUnique
   */
  export type BmMalhasFioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFio to fetch.
     */
    where: BmMalhasFioWhereUniqueInput
  }

  /**
   * BmMalhasFio findUniqueOrThrow
   */
  export type BmMalhasFioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFio to fetch.
     */
    where: BmMalhasFioWhereUniqueInput
  }

  /**
   * BmMalhasFio findFirst
   */
  export type BmMalhasFioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFio to fetch.
     */
    where?: BmMalhasFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFios to fetch.
     */
    orderBy?: BmMalhasFioOrderByWithRelationInput | BmMalhasFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMalhasFios.
     */
    cursor?: BmMalhasFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMalhasFios.
     */
    distinct?: BmMalhasFioScalarFieldEnum | BmMalhasFioScalarFieldEnum[]
  }

  /**
   * BmMalhasFio findFirstOrThrow
   */
  export type BmMalhasFioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFio to fetch.
     */
    where?: BmMalhasFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFios to fetch.
     */
    orderBy?: BmMalhasFioOrderByWithRelationInput | BmMalhasFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMalhasFios.
     */
    cursor?: BmMalhasFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMalhasFios.
     */
    distinct?: BmMalhasFioScalarFieldEnum | BmMalhasFioScalarFieldEnum[]
  }

  /**
   * BmMalhasFio findMany
   */
  export type BmMalhasFioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFios to fetch.
     */
    where?: BmMalhasFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFios to fetch.
     */
    orderBy?: BmMalhasFioOrderByWithRelationInput | BmMalhasFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMalhasFios.
     */
    cursor?: BmMalhasFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFios.
     */
    skip?: number
    distinct?: BmMalhasFioScalarFieldEnum | BmMalhasFioScalarFieldEnum[]
  }

  /**
   * BmMalhasFio create
   */
  export type BmMalhasFioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMalhasFio.
     */
    data: XOR<BmMalhasFioCreateInput, BmMalhasFioUncheckedCreateInput>
  }

  /**
   * BmMalhasFio createMany
   */
  export type BmMalhasFioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMalhasFios.
     */
    data: BmMalhasFioCreateManyInput | BmMalhasFioCreateManyInput[]
  }

  /**
   * BmMalhasFio update
   */
  export type BmMalhasFioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMalhasFio.
     */
    data: XOR<BmMalhasFioUpdateInput, BmMalhasFioUncheckedUpdateInput>
    /**
     * Choose, which BmMalhasFio to update.
     */
    where: BmMalhasFioWhereUniqueInput
  }

  /**
   * BmMalhasFio updateMany
   */
  export type BmMalhasFioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMalhasFios.
     */
    data: XOR<BmMalhasFioUpdateManyMutationInput, BmMalhasFioUncheckedUpdateManyInput>
    /**
     * Filter which BmMalhasFios to update
     */
    where?: BmMalhasFioWhereInput
    /**
     * Limit how many BmMalhasFios to update.
     */
    limit?: number
  }

  /**
   * BmMalhasFio upsert
   */
  export type BmMalhasFioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMalhasFio to update in case it exists.
     */
    where: BmMalhasFioWhereUniqueInput
    /**
     * In case the BmMalhasFio found by the `where` argument doesn't exist, create a new BmMalhasFio with this data.
     */
    create: XOR<BmMalhasFioCreateInput, BmMalhasFioUncheckedCreateInput>
    /**
     * In case the BmMalhasFio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMalhasFioUpdateInput, BmMalhasFioUncheckedUpdateInput>
  }

  /**
   * BmMalhasFio delete
   */
  export type BmMalhasFioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    /**
     * Filter which BmMalhasFio to delete.
     */
    where: BmMalhasFioWhereUniqueInput
  }

  /**
   * BmMalhasFio deleteMany
   */
  export type BmMalhasFioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMalhasFios to delete
     */
    where?: BmMalhasFioWhereInput
    /**
     * Limit how many BmMalhasFios to delete.
     */
    limit?: number
  }

  /**
   * BmMalhasFio.BmFioComposicao
   */
  export type BmMalhasFio$BmFioComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    where?: BmFioComposicaoWhereInput
    orderBy?: BmFioComposicaoOrderByWithRelationInput | BmFioComposicaoOrderByWithRelationInput[]
    cursor?: BmFioComposicaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmFioComposicaoScalarFieldEnum | BmFioComposicaoScalarFieldEnum[]
  }

  /**
   * BmMalhasFio.BmOpsPorMalhaFio
   */
  export type BmMalhasFio$BmOpsPorMalhaFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    where?: BmOpsPorMalhaFioWhereInput
    orderBy?: BmOpsPorMalhaFioOrderByWithRelationInput | BmOpsPorMalhaFioOrderByWithRelationInput[]
    cursor?: BmOpsPorMalhaFioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmOpsPorMalhaFioScalarFieldEnum | BmOpsPorMalhaFioScalarFieldEnum[]
  }

  /**
   * BmMalhasFio without action
   */
  export type BmMalhasFioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
  }


  /**
   * Model BmMalhasFioMovimentos
   */

  export type AggregateBmMalhasFioMovimentos = {
    _count: BmMalhasFioMovimentosCountAggregateOutputType | null
    _avg: BmMalhasFioMovimentosAvgAggregateOutputType | null
    _sum: BmMalhasFioMovimentosSumAggregateOutputType | null
    _min: BmMalhasFioMovimentosMinAggregateOutputType | null
    _max: BmMalhasFioMovimentosMaxAggregateOutputType | null
  }

  export type BmMalhasFioMovimentosAvgAggregateOutputType = {
    op: number | null
    nMovimento: number | null
    idTipo: Decimal | null
    qtt: Decimal | null
  }

  export type BmMalhasFioMovimentosSumAggregateOutputType = {
    op: number | null
    nMovimento: number | null
    idTipo: Decimal | null
    qtt: Decimal | null
  }

  export type BmMalhasFioMovimentosMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    op: number | null
    idBmMovimentosLote: string | null
    idMovimento: string | null
    nMovimento: number | null
    nome: string | null
    idTipo: Decimal | null
    tipo: string | null
    qtt: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMalhasFioMovimentosMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    op: number | null
    idBmMovimentosLote: string | null
    idMovimento: string | null
    nMovimento: number | null
    nome: string | null
    idTipo: Decimal | null
    tipo: string | null
    qtt: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMalhasFioMovimentosCountAggregateOutputType = {
    idBm: number
    ref: number
    refOrigem: number
    op: number
    idBmMovimentosLote: number
    idMovimento: number
    nMovimento: number
    nome: number
    idTipo: number
    tipo: number
    qtt: number
    unidade: number
    lote: number
    _all: number
  }


  export type BmMalhasFioMovimentosAvgAggregateInputType = {
    op?: true
    nMovimento?: true
    idTipo?: true
    qtt?: true
  }

  export type BmMalhasFioMovimentosSumAggregateInputType = {
    op?: true
    nMovimento?: true
    idTipo?: true
    qtt?: true
  }

  export type BmMalhasFioMovimentosMinAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    op?: true
    idBmMovimentosLote?: true
    idMovimento?: true
    nMovimento?: true
    nome?: true
    idTipo?: true
    tipo?: true
    qtt?: true
    unidade?: true
    lote?: true
  }

  export type BmMalhasFioMovimentosMaxAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    op?: true
    idBmMovimentosLote?: true
    idMovimento?: true
    nMovimento?: true
    nome?: true
    idTipo?: true
    tipo?: true
    qtt?: true
    unidade?: true
    lote?: true
  }

  export type BmMalhasFioMovimentosCountAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    op?: true
    idBmMovimentosLote?: true
    idMovimento?: true
    nMovimento?: true
    nome?: true
    idTipo?: true
    tipo?: true
    qtt?: true
    unidade?: true
    lote?: true
    _all?: true
  }

  export type BmMalhasFioMovimentosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMalhasFioMovimentos to aggregate.
     */
    where?: BmMalhasFioMovimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFioMovimentos to fetch.
     */
    orderBy?: BmMalhasFioMovimentosOrderByWithRelationInput | BmMalhasFioMovimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMalhasFioMovimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFioMovimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFioMovimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMalhasFioMovimentos
    **/
    _count?: true | BmMalhasFioMovimentosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmMalhasFioMovimentosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmMalhasFioMovimentosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMalhasFioMovimentosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMalhasFioMovimentosMaxAggregateInputType
  }

  export type GetBmMalhasFioMovimentosAggregateType<T extends BmMalhasFioMovimentosAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMalhasFioMovimentos]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMalhasFioMovimentos[P]>
      : GetScalarType<T[P], AggregateBmMalhasFioMovimentos[P]>
  }




  export type BmMalhasFioMovimentosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMalhasFioMovimentosWhereInput
    orderBy?: BmMalhasFioMovimentosOrderByWithAggregationInput | BmMalhasFioMovimentosOrderByWithAggregationInput[]
    by: BmMalhasFioMovimentosScalarFieldEnum[] | BmMalhasFioMovimentosScalarFieldEnum
    having?: BmMalhasFioMovimentosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMalhasFioMovimentosCountAggregateInputType | true
    _avg?: BmMalhasFioMovimentosAvgAggregateInputType
    _sum?: BmMalhasFioMovimentosSumAggregateInputType
    _min?: BmMalhasFioMovimentosMinAggregateInputType
    _max?: BmMalhasFioMovimentosMaxAggregateInputType
  }

  export type BmMalhasFioMovimentosGroupByOutputType = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
    idBmMovimentosLote: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal
    tipo: string
    qtt: Decimal
    unidade: string
    lote: string
    _count: BmMalhasFioMovimentosCountAggregateOutputType | null
    _avg: BmMalhasFioMovimentosAvgAggregateOutputType | null
    _sum: BmMalhasFioMovimentosSumAggregateOutputType | null
    _min: BmMalhasFioMovimentosMinAggregateOutputType | null
    _max: BmMalhasFioMovimentosMaxAggregateOutputType | null
  }

  type GetBmMalhasFioMovimentosGroupByPayload<T extends BmMalhasFioMovimentosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMalhasFioMovimentosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMalhasFioMovimentosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMalhasFioMovimentosGroupByOutputType[P]>
            : GetScalarType<T[P], BmMalhasFioMovimentosGroupByOutputType[P]>
        }
      >
    >


  export type BmMalhasFioMovimentosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    op?: boolean
    idBmMovimentosLote?: boolean
    idMovimento?: boolean
    nMovimento?: boolean
    nome?: boolean
    idTipo?: boolean
    tipo?: boolean
    qtt?: boolean
    unidade?: boolean
    lote?: boolean
    BmOpsPorMalhaFio?: boolean | BmOpsPorMalhaFioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMalhasFioMovimentos"]>



  export type BmMalhasFioMovimentosSelectScalar = {
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    op?: boolean
    idBmMovimentosLote?: boolean
    idMovimento?: boolean
    nMovimento?: boolean
    nome?: boolean
    idTipo?: boolean
    tipo?: boolean
    qtt?: boolean
    unidade?: boolean
    lote?: boolean
  }

  export type BmMalhasFioMovimentosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "refOrigem" | "op" | "idBmMovimentosLote" | "idMovimento" | "nMovimento" | "nome" | "idTipo" | "tipo" | "qtt" | "unidade" | "lote", ExtArgs["result"]["bmMalhasFioMovimentos"]>
  export type BmMalhasFioMovimentosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmOpsPorMalhaFio?: boolean | BmOpsPorMalhaFioDefaultArgs<ExtArgs>
  }

  export type $BmMalhasFioMovimentosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMalhasFioMovimentos"
    objects: {
      BmOpsPorMalhaFio: Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      refOrigem: string
      op: number
      idBmMovimentosLote: string
      idMovimento: string
      nMovimento: number
      nome: string
      idTipo: Prisma.Decimal
      tipo: string
      qtt: Prisma.Decimal
      unidade: string
      lote: string
    }, ExtArgs["result"]["bmMalhasFioMovimentos"]>
    composites: {}
  }

  type BmMalhasFioMovimentosGetPayload<S extends boolean | null | undefined | BmMalhasFioMovimentosDefaultArgs> = $Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload, S>

  type BmMalhasFioMovimentosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMalhasFioMovimentosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMalhasFioMovimentosCountAggregateInputType | true
    }

  export interface BmMalhasFioMovimentosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMalhasFioMovimentos'], meta: { name: 'BmMalhasFioMovimentos' } }
    /**
     * Find zero or one BmMalhasFioMovimentos that matches the filter.
     * @param {BmMalhasFioMovimentosFindUniqueArgs} args - Arguments to find a BmMalhasFioMovimentos
     * @example
     * // Get one BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMalhasFioMovimentosFindUniqueArgs>(args: SelectSubset<T, BmMalhasFioMovimentosFindUniqueArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMalhasFioMovimentos that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMalhasFioMovimentosFindUniqueOrThrowArgs} args - Arguments to find a BmMalhasFioMovimentos
     * @example
     * // Get one BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMalhasFioMovimentosFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMalhasFioMovimentosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMalhasFioMovimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioMovimentosFindFirstArgs} args - Arguments to find a BmMalhasFioMovimentos
     * @example
     * // Get one BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMalhasFioMovimentosFindFirstArgs>(args?: SelectSubset<T, BmMalhasFioMovimentosFindFirstArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMalhasFioMovimentos that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioMovimentosFindFirstOrThrowArgs} args - Arguments to find a BmMalhasFioMovimentos
     * @example
     * // Get one BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMalhasFioMovimentosFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMalhasFioMovimentosFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMalhasFioMovimentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioMovimentosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.findMany()
     * 
     * // Get first 10 BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmMalhasFioMovimentosWithIdBmOnly = await prisma.bmMalhasFioMovimentos.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmMalhasFioMovimentosFindManyArgs>(args?: SelectSubset<T, BmMalhasFioMovimentosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMalhasFioMovimentos.
     * @param {BmMalhasFioMovimentosCreateArgs} args - Arguments to create a BmMalhasFioMovimentos.
     * @example
     * // Create one BmMalhasFioMovimentos
     * const BmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.create({
     *   data: {
     *     // ... data to create a BmMalhasFioMovimentos
     *   }
     * })
     * 
     */
    create<T extends BmMalhasFioMovimentosCreateArgs>(args: SelectSubset<T, BmMalhasFioMovimentosCreateArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMalhasFioMovimentos.
     * @param {BmMalhasFioMovimentosCreateManyArgs} args - Arguments to create many BmMalhasFioMovimentos.
     * @example
     * // Create many BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMalhasFioMovimentosCreateManyArgs>(args?: SelectSubset<T, BmMalhasFioMovimentosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMalhasFioMovimentos.
     * @param {BmMalhasFioMovimentosDeleteArgs} args - Arguments to delete one BmMalhasFioMovimentos.
     * @example
     * // Delete one BmMalhasFioMovimentos
     * const BmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.delete({
     *   where: {
     *     // ... filter to delete one BmMalhasFioMovimentos
     *   }
     * })
     * 
     */
    delete<T extends BmMalhasFioMovimentosDeleteArgs>(args: SelectSubset<T, BmMalhasFioMovimentosDeleteArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMalhasFioMovimentos.
     * @param {BmMalhasFioMovimentosUpdateArgs} args - Arguments to update one BmMalhasFioMovimentos.
     * @example
     * // Update one BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMalhasFioMovimentosUpdateArgs>(args: SelectSubset<T, BmMalhasFioMovimentosUpdateArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMalhasFioMovimentos.
     * @param {BmMalhasFioMovimentosDeleteManyArgs} args - Arguments to filter BmMalhasFioMovimentos to delete.
     * @example
     * // Delete a few BmMalhasFioMovimentos
     * const { count } = await prisma.bmMalhasFioMovimentos.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMalhasFioMovimentosDeleteManyArgs>(args?: SelectSubset<T, BmMalhasFioMovimentosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMalhasFioMovimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioMovimentosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMalhasFioMovimentosUpdateManyArgs>(args: SelectSubset<T, BmMalhasFioMovimentosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMalhasFioMovimentos.
     * @param {BmMalhasFioMovimentosUpsertArgs} args - Arguments to update or create a BmMalhasFioMovimentos.
     * @example
     * // Update or create a BmMalhasFioMovimentos
     * const bmMalhasFioMovimentos = await prisma.bmMalhasFioMovimentos.upsert({
     *   create: {
     *     // ... data to create a BmMalhasFioMovimentos
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMalhasFioMovimentos we want to update
     *   }
     * })
     */
    upsert<T extends BmMalhasFioMovimentosUpsertArgs>(args: SelectSubset<T, BmMalhasFioMovimentosUpsertArgs<ExtArgs>>): Prisma__BmMalhasFioMovimentosClient<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMalhasFioMovimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioMovimentosCountArgs} args - Arguments to filter BmMalhasFioMovimentos to count.
     * @example
     * // Count the number of BmMalhasFioMovimentos
     * const count = await prisma.bmMalhasFioMovimentos.count({
     *   where: {
     *     // ... the filter for the BmMalhasFioMovimentos we want to count
     *   }
     * })
    **/
    count<T extends BmMalhasFioMovimentosCountArgs>(
      args?: Subset<T, BmMalhasFioMovimentosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMalhasFioMovimentosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMalhasFioMovimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioMovimentosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMalhasFioMovimentosAggregateArgs>(args: Subset<T, BmMalhasFioMovimentosAggregateArgs>): Prisma.PrismaPromise<GetBmMalhasFioMovimentosAggregateType<T>>

    /**
     * Group by BmMalhasFioMovimentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMalhasFioMovimentosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMalhasFioMovimentosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMalhasFioMovimentosGroupByArgs['orderBy'] }
        : { orderBy?: BmMalhasFioMovimentosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMalhasFioMovimentosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMalhasFioMovimentosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMalhasFioMovimentos model
   */
  readonly fields: BmMalhasFioMovimentosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMalhasFioMovimentos.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMalhasFioMovimentosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmOpsPorMalhaFio<T extends BmOpsPorMalhaFioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmOpsPorMalhaFioDefaultArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMalhasFioMovimentos model
   */ 
  interface BmMalhasFioMovimentosFieldRefs {
    readonly idBm: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly ref: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly refOrigem: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly op: FieldRef<"BmMalhasFioMovimentos", 'Int'>
    readonly idBmMovimentosLote: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly idMovimento: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly nMovimento: FieldRef<"BmMalhasFioMovimentos", 'Int'>
    readonly nome: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly idTipo: FieldRef<"BmMalhasFioMovimentos", 'Decimal'>
    readonly tipo: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly qtt: FieldRef<"BmMalhasFioMovimentos", 'Decimal'>
    readonly unidade: FieldRef<"BmMalhasFioMovimentos", 'String'>
    readonly lote: FieldRef<"BmMalhasFioMovimentos", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMalhasFioMovimentos findUnique
   */
  export type BmMalhasFioMovimentosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFioMovimentos to fetch.
     */
    where: BmMalhasFioMovimentosWhereUniqueInput
  }

  /**
   * BmMalhasFioMovimentos findUniqueOrThrow
   */
  export type BmMalhasFioMovimentosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFioMovimentos to fetch.
     */
    where: BmMalhasFioMovimentosWhereUniqueInput
  }

  /**
   * BmMalhasFioMovimentos findFirst
   */
  export type BmMalhasFioMovimentosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFioMovimentos to fetch.
     */
    where?: BmMalhasFioMovimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFioMovimentos to fetch.
     */
    orderBy?: BmMalhasFioMovimentosOrderByWithRelationInput | BmMalhasFioMovimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMalhasFioMovimentos.
     */
    cursor?: BmMalhasFioMovimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFioMovimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFioMovimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMalhasFioMovimentos.
     */
    distinct?: BmMalhasFioMovimentosScalarFieldEnum | BmMalhasFioMovimentosScalarFieldEnum[]
  }

  /**
   * BmMalhasFioMovimentos findFirstOrThrow
   */
  export type BmMalhasFioMovimentosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFioMovimentos to fetch.
     */
    where?: BmMalhasFioMovimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFioMovimentos to fetch.
     */
    orderBy?: BmMalhasFioMovimentosOrderByWithRelationInput | BmMalhasFioMovimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMalhasFioMovimentos.
     */
    cursor?: BmMalhasFioMovimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFioMovimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFioMovimentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMalhasFioMovimentos.
     */
    distinct?: BmMalhasFioMovimentosScalarFieldEnum | BmMalhasFioMovimentosScalarFieldEnum[]
  }

  /**
   * BmMalhasFioMovimentos findMany
   */
  export type BmMalhasFioMovimentosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * Filter, which BmMalhasFioMovimentos to fetch.
     */
    where?: BmMalhasFioMovimentosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMalhasFioMovimentos to fetch.
     */
    orderBy?: BmMalhasFioMovimentosOrderByWithRelationInput | BmMalhasFioMovimentosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMalhasFioMovimentos.
     */
    cursor?: BmMalhasFioMovimentosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMalhasFioMovimentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMalhasFioMovimentos.
     */
    skip?: number
    distinct?: BmMalhasFioMovimentosScalarFieldEnum | BmMalhasFioMovimentosScalarFieldEnum[]
  }

  /**
   * BmMalhasFioMovimentos create
   */
  export type BmMalhasFioMovimentosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMalhasFioMovimentos.
     */
    data: XOR<BmMalhasFioMovimentosCreateInput, BmMalhasFioMovimentosUncheckedCreateInput>
  }

  /**
   * BmMalhasFioMovimentos createMany
   */
  export type BmMalhasFioMovimentosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMalhasFioMovimentos.
     */
    data: BmMalhasFioMovimentosCreateManyInput | BmMalhasFioMovimentosCreateManyInput[]
  }

  /**
   * BmMalhasFioMovimentos update
   */
  export type BmMalhasFioMovimentosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMalhasFioMovimentos.
     */
    data: XOR<BmMalhasFioMovimentosUpdateInput, BmMalhasFioMovimentosUncheckedUpdateInput>
    /**
     * Choose, which BmMalhasFioMovimentos to update.
     */
    where: BmMalhasFioMovimentosWhereUniqueInput
  }

  /**
   * BmMalhasFioMovimentos updateMany
   */
  export type BmMalhasFioMovimentosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMalhasFioMovimentos.
     */
    data: XOR<BmMalhasFioMovimentosUpdateManyMutationInput, BmMalhasFioMovimentosUncheckedUpdateManyInput>
    /**
     * Filter which BmMalhasFioMovimentos to update
     */
    where?: BmMalhasFioMovimentosWhereInput
    /**
     * Limit how many BmMalhasFioMovimentos to update.
     */
    limit?: number
  }

  /**
   * BmMalhasFioMovimentos upsert
   */
  export type BmMalhasFioMovimentosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMalhasFioMovimentos to update in case it exists.
     */
    where: BmMalhasFioMovimentosWhereUniqueInput
    /**
     * In case the BmMalhasFioMovimentos found by the `where` argument doesn't exist, create a new BmMalhasFioMovimentos with this data.
     */
    create: XOR<BmMalhasFioMovimentosCreateInput, BmMalhasFioMovimentosUncheckedCreateInput>
    /**
     * In case the BmMalhasFioMovimentos was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMalhasFioMovimentosUpdateInput, BmMalhasFioMovimentosUncheckedUpdateInput>
  }

  /**
   * BmMalhasFioMovimentos delete
   */
  export type BmMalhasFioMovimentosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    /**
     * Filter which BmMalhasFioMovimentos to delete.
     */
    where: BmMalhasFioMovimentosWhereUniqueInput
  }

  /**
   * BmMalhasFioMovimentos deleteMany
   */
  export type BmMalhasFioMovimentosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMalhasFioMovimentos to delete
     */
    where?: BmMalhasFioMovimentosWhereInput
    /**
     * Limit how many BmMalhasFioMovimentos to delete.
     */
    limit?: number
  }

  /**
   * BmMalhasFioMovimentos without action
   */
  export type BmMalhasFioMovimentosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
  }


  /**
   * Model BmMateriais
   */

  export type AggregateBmMateriais = {
    _count: BmMateriaisCountAggregateOutputType | null
    _min: BmMateriaisMinAggregateOutputType | null
    _max: BmMateriaisMaxAggregateOutputType | null
  }

  export type BmMateriaisMinAggregateOutputType = {
    grupo: string | null
    subGrupo: string | null
  }

  export type BmMateriaisMaxAggregateOutputType = {
    grupo: string | null
    subGrupo: string | null
  }

  export type BmMateriaisCountAggregateOutputType = {
    grupo: number
    subGrupo: number
    _all: number
  }


  export type BmMateriaisMinAggregateInputType = {
    grupo?: true
    subGrupo?: true
  }

  export type BmMateriaisMaxAggregateInputType = {
    grupo?: true
    subGrupo?: true
  }

  export type BmMateriaisCountAggregateInputType = {
    grupo?: true
    subGrupo?: true
    _all?: true
  }

  export type BmMateriaisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMateriais to aggregate.
     */
    where?: BmMateriaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriais to fetch.
     */
    orderBy?: BmMateriaisOrderByWithRelationInput | BmMateriaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMateriaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMateriais
    **/
    _count?: true | BmMateriaisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMateriaisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMateriaisMaxAggregateInputType
  }

  export type GetBmMateriaisAggregateType<T extends BmMateriaisAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMateriais]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMateriais[P]>
      : GetScalarType<T[P], AggregateBmMateriais[P]>
  }




  export type BmMateriaisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMateriaisWhereInput
    orderBy?: BmMateriaisOrderByWithAggregationInput | BmMateriaisOrderByWithAggregationInput[]
    by: BmMateriaisScalarFieldEnum[] | BmMateriaisScalarFieldEnum
    having?: BmMateriaisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMateriaisCountAggregateInputType | true
    _min?: BmMateriaisMinAggregateInputType
    _max?: BmMateriaisMaxAggregateInputType
  }

  export type BmMateriaisGroupByOutputType = {
    grupo: string
    subGrupo: string
    _count: BmMateriaisCountAggregateOutputType | null
    _min: BmMateriaisMinAggregateOutputType | null
    _max: BmMateriaisMaxAggregateOutputType | null
  }

  type GetBmMateriaisGroupByPayload<T extends BmMateriaisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMateriaisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMateriaisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMateriaisGroupByOutputType[P]>
            : GetScalarType<T[P], BmMateriaisGroupByOutputType[P]>
        }
      >
    >


  export type BmMateriaisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    grupo?: boolean
    subGrupo?: boolean
    BmMalhas?: boolean | BmMateriais$BmMalhasArgs<ExtArgs>
    BmMaterialGrupo?: boolean | BmMaterialGrupoDefaultArgs<ExtArgs>
    BmMaterialSubGrupo?: boolean | BmMaterialSubGrupoDefaultArgs<ExtArgs>
    _count?: boolean | BmMateriaisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMateriais"]>



  export type BmMateriaisSelectScalar = {
    grupo?: boolean
    subGrupo?: boolean
  }

  export type BmMateriaisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"grupo" | "subGrupo", ExtArgs["result"]["bmMateriais"]>
  export type BmMateriaisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhas?: boolean | BmMateriais$BmMalhasArgs<ExtArgs>
    BmMaterialGrupo?: boolean | BmMaterialGrupoDefaultArgs<ExtArgs>
    BmMaterialSubGrupo?: boolean | BmMaterialSubGrupoDefaultArgs<ExtArgs>
    _count?: boolean | BmMateriaisCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMateriaisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMateriais"
    objects: {
      BmMalhas: Prisma.$BmMalhasPayload<ExtArgs>[]
      BmMaterialGrupo: Prisma.$BmMaterialGrupoPayload<ExtArgs>
      BmMaterialSubGrupo: Prisma.$BmMaterialSubGrupoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      grupo: string
      subGrupo: string
    }, ExtArgs["result"]["bmMateriais"]>
    composites: {}
  }

  type BmMateriaisGetPayload<S extends boolean | null | undefined | BmMateriaisDefaultArgs> = $Result.GetResult<Prisma.$BmMateriaisPayload, S>

  type BmMateriaisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMateriaisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMateriaisCountAggregateInputType | true
    }

  export interface BmMateriaisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMateriais'], meta: { name: 'BmMateriais' } }
    /**
     * Find zero or one BmMateriais that matches the filter.
     * @param {BmMateriaisFindUniqueArgs} args - Arguments to find a BmMateriais
     * @example
     * // Get one BmMateriais
     * const bmMateriais = await prisma.bmMateriais.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMateriaisFindUniqueArgs>(args: SelectSubset<T, BmMateriaisFindUniqueArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMateriais that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMateriaisFindUniqueOrThrowArgs} args - Arguments to find a BmMateriais
     * @example
     * // Get one BmMateriais
     * const bmMateriais = await prisma.bmMateriais.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMateriaisFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMateriaisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMateriais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFindFirstArgs} args - Arguments to find a BmMateriais
     * @example
     * // Get one BmMateriais
     * const bmMateriais = await prisma.bmMateriais.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMateriaisFindFirstArgs>(args?: SelectSubset<T, BmMateriaisFindFirstArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMateriais that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFindFirstOrThrowArgs} args - Arguments to find a BmMateriais
     * @example
     * // Get one BmMateriais
     * const bmMateriais = await prisma.bmMateriais.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMateriaisFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMateriaisFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMateriais that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMateriais
     * const bmMateriais = await prisma.bmMateriais.findMany()
     * 
     * // Get first 10 BmMateriais
     * const bmMateriais = await prisma.bmMateriais.findMany({ take: 10 })
     * 
     * // Only select the `grupo`
     * const bmMateriaisWithGrupoOnly = await prisma.bmMateriais.findMany({ select: { grupo: true } })
     * 
     */
    findMany<T extends BmMateriaisFindManyArgs>(args?: SelectSubset<T, BmMateriaisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMateriais.
     * @param {BmMateriaisCreateArgs} args - Arguments to create a BmMateriais.
     * @example
     * // Create one BmMateriais
     * const BmMateriais = await prisma.bmMateriais.create({
     *   data: {
     *     // ... data to create a BmMateriais
     *   }
     * })
     * 
     */
    create<T extends BmMateriaisCreateArgs>(args: SelectSubset<T, BmMateriaisCreateArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMateriais.
     * @param {BmMateriaisCreateManyArgs} args - Arguments to create many BmMateriais.
     * @example
     * // Create many BmMateriais
     * const bmMateriais = await prisma.bmMateriais.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMateriaisCreateManyArgs>(args?: SelectSubset<T, BmMateriaisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMateriais.
     * @param {BmMateriaisDeleteArgs} args - Arguments to delete one BmMateriais.
     * @example
     * // Delete one BmMateriais
     * const BmMateriais = await prisma.bmMateriais.delete({
     *   where: {
     *     // ... filter to delete one BmMateriais
     *   }
     * })
     * 
     */
    delete<T extends BmMateriaisDeleteArgs>(args: SelectSubset<T, BmMateriaisDeleteArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMateriais.
     * @param {BmMateriaisUpdateArgs} args - Arguments to update one BmMateriais.
     * @example
     * // Update one BmMateriais
     * const bmMateriais = await prisma.bmMateriais.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMateriaisUpdateArgs>(args: SelectSubset<T, BmMateriaisUpdateArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMateriais.
     * @param {BmMateriaisDeleteManyArgs} args - Arguments to filter BmMateriais to delete.
     * @example
     * // Delete a few BmMateriais
     * const { count } = await prisma.bmMateriais.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMateriaisDeleteManyArgs>(args?: SelectSubset<T, BmMateriaisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMateriais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMateriais
     * const bmMateriais = await prisma.bmMateriais.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMateriaisUpdateManyArgs>(args: SelectSubset<T, BmMateriaisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMateriais.
     * @param {BmMateriaisUpsertArgs} args - Arguments to update or create a BmMateriais.
     * @example
     * // Update or create a BmMateriais
     * const bmMateriais = await prisma.bmMateriais.upsert({
     *   create: {
     *     // ... data to create a BmMateriais
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMateriais we want to update
     *   }
     * })
     */
    upsert<T extends BmMateriaisUpsertArgs>(args: SelectSubset<T, BmMateriaisUpsertArgs<ExtArgs>>): Prisma__BmMateriaisClient<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMateriais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisCountArgs} args - Arguments to filter BmMateriais to count.
     * @example
     * // Count the number of BmMateriais
     * const count = await prisma.bmMateriais.count({
     *   where: {
     *     // ... the filter for the BmMateriais we want to count
     *   }
     * })
    **/
    count<T extends BmMateriaisCountArgs>(
      args?: Subset<T, BmMateriaisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMateriaisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMateriais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMateriaisAggregateArgs>(args: Subset<T, BmMateriaisAggregateArgs>): Prisma.PrismaPromise<GetBmMateriaisAggregateType<T>>

    /**
     * Group by BmMateriais.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMateriaisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMateriaisGroupByArgs['orderBy'] }
        : { orderBy?: BmMateriaisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMateriaisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMateriaisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMateriais model
   */
  readonly fields: BmMateriaisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMateriais.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMateriaisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMalhas<T extends BmMateriais$BmMalhasArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriais$BmMalhasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmMaterialGrupo<T extends BmMaterialGrupoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialGrupoDefaultArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmMaterialSubGrupo<T extends BmMaterialSubGrupoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialSubGrupoDefaultArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMateriais model
   */ 
  interface BmMateriaisFieldRefs {
    readonly grupo: FieldRef<"BmMateriais", 'String'>
    readonly subGrupo: FieldRef<"BmMateriais", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMateriais findUnique
   */
  export type BmMateriaisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriais to fetch.
     */
    where: BmMateriaisWhereUniqueInput
  }

  /**
   * BmMateriais findUniqueOrThrow
   */
  export type BmMateriaisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriais to fetch.
     */
    where: BmMateriaisWhereUniqueInput
  }

  /**
   * BmMateriais findFirst
   */
  export type BmMateriaisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriais to fetch.
     */
    where?: BmMateriaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriais to fetch.
     */
    orderBy?: BmMateriaisOrderByWithRelationInput | BmMateriaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMateriais.
     */
    cursor?: BmMateriaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMateriais.
     */
    distinct?: BmMateriaisScalarFieldEnum | BmMateriaisScalarFieldEnum[]
  }

  /**
   * BmMateriais findFirstOrThrow
   */
  export type BmMateriaisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriais to fetch.
     */
    where?: BmMateriaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriais to fetch.
     */
    orderBy?: BmMateriaisOrderByWithRelationInput | BmMateriaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMateriais.
     */
    cursor?: BmMateriaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriais.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMateriais.
     */
    distinct?: BmMateriaisScalarFieldEnum | BmMateriaisScalarFieldEnum[]
  }

  /**
   * BmMateriais findMany
   */
  export type BmMateriaisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriais to fetch.
     */
    where?: BmMateriaisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriais to fetch.
     */
    orderBy?: BmMateriaisOrderByWithRelationInput | BmMateriaisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMateriais.
     */
    cursor?: BmMateriaisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriais from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriais.
     */
    skip?: number
    distinct?: BmMateriaisScalarFieldEnum | BmMateriaisScalarFieldEnum[]
  }

  /**
   * BmMateriais create
   */
  export type BmMateriaisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMateriais.
     */
    data: XOR<BmMateriaisCreateInput, BmMateriaisUncheckedCreateInput>
  }

  /**
   * BmMateriais createMany
   */
  export type BmMateriaisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMateriais.
     */
    data: BmMateriaisCreateManyInput | BmMateriaisCreateManyInput[]
  }

  /**
   * BmMateriais update
   */
  export type BmMateriaisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMateriais.
     */
    data: XOR<BmMateriaisUpdateInput, BmMateriaisUncheckedUpdateInput>
    /**
     * Choose, which BmMateriais to update.
     */
    where: BmMateriaisWhereUniqueInput
  }

  /**
   * BmMateriais updateMany
   */
  export type BmMateriaisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMateriais.
     */
    data: XOR<BmMateriaisUpdateManyMutationInput, BmMateriaisUncheckedUpdateManyInput>
    /**
     * Filter which BmMateriais to update
     */
    where?: BmMateriaisWhereInput
    /**
     * Limit how many BmMateriais to update.
     */
    limit?: number
  }

  /**
   * BmMateriais upsert
   */
  export type BmMateriaisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMateriais to update in case it exists.
     */
    where: BmMateriaisWhereUniqueInput
    /**
     * In case the BmMateriais found by the `where` argument doesn't exist, create a new BmMateriais with this data.
     */
    create: XOR<BmMateriaisCreateInput, BmMateriaisUncheckedCreateInput>
    /**
     * In case the BmMateriais was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMateriaisUpdateInput, BmMateriaisUncheckedUpdateInput>
  }

  /**
   * BmMateriais delete
   */
  export type BmMateriaisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    /**
     * Filter which BmMateriais to delete.
     */
    where: BmMateriaisWhereUniqueInput
  }

  /**
   * BmMateriais deleteMany
   */
  export type BmMateriaisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMateriais to delete
     */
    where?: BmMateriaisWhereInput
    /**
     * Limit how many BmMateriais to delete.
     */
    limit?: number
  }

  /**
   * BmMateriais.BmMalhas
   */
  export type BmMateriais$BmMalhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhas
     */
    select?: BmMalhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhas
     */
    omit?: BmMalhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasInclude<ExtArgs> | null
    where?: BmMalhasWhereInput
    orderBy?: BmMalhasOrderByWithRelationInput | BmMalhasOrderByWithRelationInput[]
    cursor?: BmMalhasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMalhasScalarFieldEnum | BmMalhasScalarFieldEnum[]
  }

  /**
   * BmMateriais without action
   */
  export type BmMateriaisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
  }


  /**
   * Model BmMateriaisComposicao
   */

  export type AggregateBmMateriaisComposicao = {
    _count: BmMateriaisComposicaoCountAggregateOutputType | null
    _avg: BmMateriaisComposicaoAvgAggregateOutputType | null
    _sum: BmMateriaisComposicaoSumAggregateOutputType | null
    _min: BmMateriaisComposicaoMinAggregateOutputType | null
    _max: BmMateriaisComposicaoMaxAggregateOutputType | null
  }

  export type BmMateriaisComposicaoAvgAggregateOutputType = {
    idComposicao: number | null
    ordem: number | null
  }

  export type BmMateriaisComposicaoSumAggregateOutputType = {
    idComposicao: number | null
    ordem: number | null
  }

  export type BmMateriaisComposicaoMinAggregateOutputType = {
    idComposicao: number | null
    composicao: string | null
    composicaoAbreviatura: string | null
    ordem: number | null
    inactivo: boolean | null
  }

  export type BmMateriaisComposicaoMaxAggregateOutputType = {
    idComposicao: number | null
    composicao: string | null
    composicaoAbreviatura: string | null
    ordem: number | null
    inactivo: boolean | null
  }

  export type BmMateriaisComposicaoCountAggregateOutputType = {
    idComposicao: number
    composicao: number
    composicaoAbreviatura: number
    ordem: number
    inactivo: number
    _all: number
  }


  export type BmMateriaisComposicaoAvgAggregateInputType = {
    idComposicao?: true
    ordem?: true
  }

  export type BmMateriaisComposicaoSumAggregateInputType = {
    idComposicao?: true
    ordem?: true
  }

  export type BmMateriaisComposicaoMinAggregateInputType = {
    idComposicao?: true
    composicao?: true
    composicaoAbreviatura?: true
    ordem?: true
    inactivo?: true
  }

  export type BmMateriaisComposicaoMaxAggregateInputType = {
    idComposicao?: true
    composicao?: true
    composicaoAbreviatura?: true
    ordem?: true
    inactivo?: true
  }

  export type BmMateriaisComposicaoCountAggregateInputType = {
    idComposicao?: true
    composicao?: true
    composicaoAbreviatura?: true
    ordem?: true
    inactivo?: true
    _all?: true
  }

  export type BmMateriaisComposicaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMateriaisComposicao to aggregate.
     */
    where?: BmMateriaisComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisComposicaos to fetch.
     */
    orderBy?: BmMateriaisComposicaoOrderByWithRelationInput | BmMateriaisComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMateriaisComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMateriaisComposicaos
    **/
    _count?: true | BmMateriaisComposicaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmMateriaisComposicaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmMateriaisComposicaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMateriaisComposicaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMateriaisComposicaoMaxAggregateInputType
  }

  export type GetBmMateriaisComposicaoAggregateType<T extends BmMateriaisComposicaoAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMateriaisComposicao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMateriaisComposicao[P]>
      : GetScalarType<T[P], AggregateBmMateriaisComposicao[P]>
  }




  export type BmMateriaisComposicaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMateriaisComposicaoWhereInput
    orderBy?: BmMateriaisComposicaoOrderByWithAggregationInput | BmMateriaisComposicaoOrderByWithAggregationInput[]
    by: BmMateriaisComposicaoScalarFieldEnum[] | BmMateriaisComposicaoScalarFieldEnum
    having?: BmMateriaisComposicaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMateriaisComposicaoCountAggregateInputType | true
    _avg?: BmMateriaisComposicaoAvgAggregateInputType
    _sum?: BmMateriaisComposicaoSumAggregateInputType
    _min?: BmMateriaisComposicaoMinAggregateInputType
    _max?: BmMateriaisComposicaoMaxAggregateInputType
  }

  export type BmMateriaisComposicaoGroupByOutputType = {
    idComposicao: number
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
    _count: BmMateriaisComposicaoCountAggregateOutputType | null
    _avg: BmMateriaisComposicaoAvgAggregateOutputType | null
    _sum: BmMateriaisComposicaoSumAggregateOutputType | null
    _min: BmMateriaisComposicaoMinAggregateOutputType | null
    _max: BmMateriaisComposicaoMaxAggregateOutputType | null
  }

  type GetBmMateriaisComposicaoGroupByPayload<T extends BmMateriaisComposicaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMateriaisComposicaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMateriaisComposicaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMateriaisComposicaoGroupByOutputType[P]>
            : GetScalarType<T[P], BmMateriaisComposicaoGroupByOutputType[P]>
        }
      >
    >


  export type BmMateriaisComposicaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idComposicao?: boolean
    composicao?: boolean
    composicaoAbreviatura?: boolean
    ordem?: boolean
    inactivo?: boolean
    BmFioComposicao?: boolean | BmMateriaisComposicao$BmFioComposicaoArgs<ExtArgs>
    BmIdBmComposicao?: boolean | BmMateriaisComposicao$BmIdBmComposicaoArgs<ExtArgs>
    _count?: boolean | BmMateriaisComposicaoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMateriaisComposicao"]>



  export type BmMateriaisComposicaoSelectScalar = {
    idComposicao?: boolean
    composicao?: boolean
    composicaoAbreviatura?: boolean
    ordem?: boolean
    inactivo?: boolean
  }

  export type BmMateriaisComposicaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idComposicao" | "composicao" | "composicaoAbreviatura" | "ordem" | "inactivo", ExtArgs["result"]["bmMateriaisComposicao"]>
  export type BmMateriaisComposicaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmFioComposicao?: boolean | BmMateriaisComposicao$BmFioComposicaoArgs<ExtArgs>
    BmIdBmComposicao?: boolean | BmMateriaisComposicao$BmIdBmComposicaoArgs<ExtArgs>
    _count?: boolean | BmMateriaisComposicaoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMateriaisComposicaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMateriaisComposicao"
    objects: {
      BmFioComposicao: Prisma.$BmFioComposicaoPayload<ExtArgs>[]
      BmIdBmComposicao: Prisma.$BmIdBmComposicaoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idComposicao: number
      composicao: string
      composicaoAbreviatura: string
      ordem: number
      inactivo: boolean
    }, ExtArgs["result"]["bmMateriaisComposicao"]>
    composites: {}
  }

  type BmMateriaisComposicaoGetPayload<S extends boolean | null | undefined | BmMateriaisComposicaoDefaultArgs> = $Result.GetResult<Prisma.$BmMateriaisComposicaoPayload, S>

  type BmMateriaisComposicaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMateriaisComposicaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMateriaisComposicaoCountAggregateInputType | true
    }

  export interface BmMateriaisComposicaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMateriaisComposicao'], meta: { name: 'BmMateriaisComposicao' } }
    /**
     * Find zero or one BmMateriaisComposicao that matches the filter.
     * @param {BmMateriaisComposicaoFindUniqueArgs} args - Arguments to find a BmMateriaisComposicao
     * @example
     * // Get one BmMateriaisComposicao
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMateriaisComposicaoFindUniqueArgs>(args: SelectSubset<T, BmMateriaisComposicaoFindUniqueArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMateriaisComposicao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMateriaisComposicaoFindUniqueOrThrowArgs} args - Arguments to find a BmMateriaisComposicao
     * @example
     * // Get one BmMateriaisComposicao
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMateriaisComposicaoFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMateriaisComposicaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMateriaisComposicao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisComposicaoFindFirstArgs} args - Arguments to find a BmMateriaisComposicao
     * @example
     * // Get one BmMateriaisComposicao
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMateriaisComposicaoFindFirstArgs>(args?: SelectSubset<T, BmMateriaisComposicaoFindFirstArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMateriaisComposicao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisComposicaoFindFirstOrThrowArgs} args - Arguments to find a BmMateriaisComposicao
     * @example
     * // Get one BmMateriaisComposicao
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMateriaisComposicaoFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMateriaisComposicaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMateriaisComposicaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisComposicaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMateriaisComposicaos
     * const bmMateriaisComposicaos = await prisma.bmMateriaisComposicao.findMany()
     * 
     * // Get first 10 BmMateriaisComposicaos
     * const bmMateriaisComposicaos = await prisma.bmMateriaisComposicao.findMany({ take: 10 })
     * 
     * // Only select the `idComposicao`
     * const bmMateriaisComposicaoWithIdComposicaoOnly = await prisma.bmMateriaisComposicao.findMany({ select: { idComposicao: true } })
     * 
     */
    findMany<T extends BmMateriaisComposicaoFindManyArgs>(args?: SelectSubset<T, BmMateriaisComposicaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMateriaisComposicao.
     * @param {BmMateriaisComposicaoCreateArgs} args - Arguments to create a BmMateriaisComposicao.
     * @example
     * // Create one BmMateriaisComposicao
     * const BmMateriaisComposicao = await prisma.bmMateriaisComposicao.create({
     *   data: {
     *     // ... data to create a BmMateriaisComposicao
     *   }
     * })
     * 
     */
    create<T extends BmMateriaisComposicaoCreateArgs>(args: SelectSubset<T, BmMateriaisComposicaoCreateArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMateriaisComposicaos.
     * @param {BmMateriaisComposicaoCreateManyArgs} args - Arguments to create many BmMateriaisComposicaos.
     * @example
     * // Create many BmMateriaisComposicaos
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMateriaisComposicaoCreateManyArgs>(args?: SelectSubset<T, BmMateriaisComposicaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMateriaisComposicao.
     * @param {BmMateriaisComposicaoDeleteArgs} args - Arguments to delete one BmMateriaisComposicao.
     * @example
     * // Delete one BmMateriaisComposicao
     * const BmMateriaisComposicao = await prisma.bmMateriaisComposicao.delete({
     *   where: {
     *     // ... filter to delete one BmMateriaisComposicao
     *   }
     * })
     * 
     */
    delete<T extends BmMateriaisComposicaoDeleteArgs>(args: SelectSubset<T, BmMateriaisComposicaoDeleteArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMateriaisComposicao.
     * @param {BmMateriaisComposicaoUpdateArgs} args - Arguments to update one BmMateriaisComposicao.
     * @example
     * // Update one BmMateriaisComposicao
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMateriaisComposicaoUpdateArgs>(args: SelectSubset<T, BmMateriaisComposicaoUpdateArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMateriaisComposicaos.
     * @param {BmMateriaisComposicaoDeleteManyArgs} args - Arguments to filter BmMateriaisComposicaos to delete.
     * @example
     * // Delete a few BmMateriaisComposicaos
     * const { count } = await prisma.bmMateriaisComposicao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMateriaisComposicaoDeleteManyArgs>(args?: SelectSubset<T, BmMateriaisComposicaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMateriaisComposicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisComposicaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMateriaisComposicaos
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMateriaisComposicaoUpdateManyArgs>(args: SelectSubset<T, BmMateriaisComposicaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMateriaisComposicao.
     * @param {BmMateriaisComposicaoUpsertArgs} args - Arguments to update or create a BmMateriaisComposicao.
     * @example
     * // Update or create a BmMateriaisComposicao
     * const bmMateriaisComposicao = await prisma.bmMateriaisComposicao.upsert({
     *   create: {
     *     // ... data to create a BmMateriaisComposicao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMateriaisComposicao we want to update
     *   }
     * })
     */
    upsert<T extends BmMateriaisComposicaoUpsertArgs>(args: SelectSubset<T, BmMateriaisComposicaoUpsertArgs<ExtArgs>>): Prisma__BmMateriaisComposicaoClient<$Result.GetResult<Prisma.$BmMateriaisComposicaoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMateriaisComposicaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisComposicaoCountArgs} args - Arguments to filter BmMateriaisComposicaos to count.
     * @example
     * // Count the number of BmMateriaisComposicaos
     * const count = await prisma.bmMateriaisComposicao.count({
     *   where: {
     *     // ... the filter for the BmMateriaisComposicaos we want to count
     *   }
     * })
    **/
    count<T extends BmMateriaisComposicaoCountArgs>(
      args?: Subset<T, BmMateriaisComposicaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMateriaisComposicaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMateriaisComposicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisComposicaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMateriaisComposicaoAggregateArgs>(args: Subset<T, BmMateriaisComposicaoAggregateArgs>): Prisma.PrismaPromise<GetBmMateriaisComposicaoAggregateType<T>>

    /**
     * Group by BmMateriaisComposicao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisComposicaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMateriaisComposicaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMateriaisComposicaoGroupByArgs['orderBy'] }
        : { orderBy?: BmMateriaisComposicaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMateriaisComposicaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMateriaisComposicaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMateriaisComposicao model
   */
  readonly fields: BmMateriaisComposicaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMateriaisComposicao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMateriaisComposicaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmFioComposicao<T extends BmMateriaisComposicao$BmFioComposicaoArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriaisComposicao$BmFioComposicaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmFioComposicaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmIdBmComposicao<T extends BmMateriaisComposicao$BmIdBmComposicaoArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriaisComposicao$BmIdBmComposicaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmIdBmComposicaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMateriaisComposicao model
   */ 
  interface BmMateriaisComposicaoFieldRefs {
    readonly idComposicao: FieldRef<"BmMateriaisComposicao", 'Int'>
    readonly composicao: FieldRef<"BmMateriaisComposicao", 'String'>
    readonly composicaoAbreviatura: FieldRef<"BmMateriaisComposicao", 'String'>
    readonly ordem: FieldRef<"BmMateriaisComposicao", 'Int'>
    readonly inactivo: FieldRef<"BmMateriaisComposicao", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * BmMateriaisComposicao findUnique
   */
  export type BmMateriaisComposicaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisComposicao to fetch.
     */
    where: BmMateriaisComposicaoWhereUniqueInput
  }

  /**
   * BmMateriaisComposicao findUniqueOrThrow
   */
  export type BmMateriaisComposicaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisComposicao to fetch.
     */
    where: BmMateriaisComposicaoWhereUniqueInput
  }

  /**
   * BmMateriaisComposicao findFirst
   */
  export type BmMateriaisComposicaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisComposicao to fetch.
     */
    where?: BmMateriaisComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisComposicaos to fetch.
     */
    orderBy?: BmMateriaisComposicaoOrderByWithRelationInput | BmMateriaisComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMateriaisComposicaos.
     */
    cursor?: BmMateriaisComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMateriaisComposicaos.
     */
    distinct?: BmMateriaisComposicaoScalarFieldEnum | BmMateriaisComposicaoScalarFieldEnum[]
  }

  /**
   * BmMateriaisComposicao findFirstOrThrow
   */
  export type BmMateriaisComposicaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisComposicao to fetch.
     */
    where?: BmMateriaisComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisComposicaos to fetch.
     */
    orderBy?: BmMateriaisComposicaoOrderByWithRelationInput | BmMateriaisComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMateriaisComposicaos.
     */
    cursor?: BmMateriaisComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisComposicaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMateriaisComposicaos.
     */
    distinct?: BmMateriaisComposicaoScalarFieldEnum | BmMateriaisComposicaoScalarFieldEnum[]
  }

  /**
   * BmMateriaisComposicao findMany
   */
  export type BmMateriaisComposicaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisComposicaos to fetch.
     */
    where?: BmMateriaisComposicaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisComposicaos to fetch.
     */
    orderBy?: BmMateriaisComposicaoOrderByWithRelationInput | BmMateriaisComposicaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMateriaisComposicaos.
     */
    cursor?: BmMateriaisComposicaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisComposicaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisComposicaos.
     */
    skip?: number
    distinct?: BmMateriaisComposicaoScalarFieldEnum | BmMateriaisComposicaoScalarFieldEnum[]
  }

  /**
   * BmMateriaisComposicao create
   */
  export type BmMateriaisComposicaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMateriaisComposicao.
     */
    data: XOR<BmMateriaisComposicaoCreateInput, BmMateriaisComposicaoUncheckedCreateInput>
  }

  /**
   * BmMateriaisComposicao createMany
   */
  export type BmMateriaisComposicaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMateriaisComposicaos.
     */
    data: BmMateriaisComposicaoCreateManyInput | BmMateriaisComposicaoCreateManyInput[]
  }

  /**
   * BmMateriaisComposicao update
   */
  export type BmMateriaisComposicaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMateriaisComposicao.
     */
    data: XOR<BmMateriaisComposicaoUpdateInput, BmMateriaisComposicaoUncheckedUpdateInput>
    /**
     * Choose, which BmMateriaisComposicao to update.
     */
    where: BmMateriaisComposicaoWhereUniqueInput
  }

  /**
   * BmMateriaisComposicao updateMany
   */
  export type BmMateriaisComposicaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMateriaisComposicaos.
     */
    data: XOR<BmMateriaisComposicaoUpdateManyMutationInput, BmMateriaisComposicaoUncheckedUpdateManyInput>
    /**
     * Filter which BmMateriaisComposicaos to update
     */
    where?: BmMateriaisComposicaoWhereInput
    /**
     * Limit how many BmMateriaisComposicaos to update.
     */
    limit?: number
  }

  /**
   * BmMateriaisComposicao upsert
   */
  export type BmMateriaisComposicaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMateriaisComposicao to update in case it exists.
     */
    where: BmMateriaisComposicaoWhereUniqueInput
    /**
     * In case the BmMateriaisComposicao found by the `where` argument doesn't exist, create a new BmMateriaisComposicao with this data.
     */
    create: XOR<BmMateriaisComposicaoCreateInput, BmMateriaisComposicaoUncheckedCreateInput>
    /**
     * In case the BmMateriaisComposicao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMateriaisComposicaoUpdateInput, BmMateriaisComposicaoUncheckedUpdateInput>
  }

  /**
   * BmMateriaisComposicao delete
   */
  export type BmMateriaisComposicaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
    /**
     * Filter which BmMateriaisComposicao to delete.
     */
    where: BmMateriaisComposicaoWhereUniqueInput
  }

  /**
   * BmMateriaisComposicao deleteMany
   */
  export type BmMateriaisComposicaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMateriaisComposicaos to delete
     */
    where?: BmMateriaisComposicaoWhereInput
    /**
     * Limit how many BmMateriaisComposicaos to delete.
     */
    limit?: number
  }

  /**
   * BmMateriaisComposicao.BmFioComposicao
   */
  export type BmMateriaisComposicao$BmFioComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmFioComposicao
     */
    select?: BmFioComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmFioComposicao
     */
    omit?: BmFioComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmFioComposicaoInclude<ExtArgs> | null
    where?: BmFioComposicaoWhereInput
    orderBy?: BmFioComposicaoOrderByWithRelationInput | BmFioComposicaoOrderByWithRelationInput[]
    cursor?: BmFioComposicaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmFioComposicaoScalarFieldEnum | BmFioComposicaoScalarFieldEnum[]
  }

  /**
   * BmMateriaisComposicao.BmIdBmComposicao
   */
  export type BmMateriaisComposicao$BmIdBmComposicaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmIdBmComposicao
     */
    select?: BmIdBmComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmIdBmComposicao
     */
    omit?: BmIdBmComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmIdBmComposicaoInclude<ExtArgs> | null
    where?: BmIdBmComposicaoWhereInput
    orderBy?: BmIdBmComposicaoOrderByWithRelationInput | BmIdBmComposicaoOrderByWithRelationInput[]
    cursor?: BmIdBmComposicaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmIdBmComposicaoScalarFieldEnum | BmIdBmComposicaoScalarFieldEnum[]
  }

  /**
   * BmMateriaisComposicao without action
   */
  export type BmMateriaisComposicaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisComposicao
     */
    select?: BmMateriaisComposicaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisComposicao
     */
    omit?: BmMateriaisComposicaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisComposicaoInclude<ExtArgs> | null
  }


  /**
   * Model BmMateriaisFio
   */

  export type AggregateBmMateriaisFio = {
    _count: BmMateriaisFioCountAggregateOutputType | null
    _min: BmMateriaisFioMinAggregateOutputType | null
    _max: BmMateriaisFioMaxAggregateOutputType | null
  }

  export type BmMateriaisFioMinAggregateOutputType = {
    grupo: string | null
    subGrupo: string | null
  }

  export type BmMateriaisFioMaxAggregateOutputType = {
    grupo: string | null
    subGrupo: string | null
  }

  export type BmMateriaisFioCountAggregateOutputType = {
    grupo: number
    subGrupo: number
    _all: number
  }


  export type BmMateriaisFioMinAggregateInputType = {
    grupo?: true
    subGrupo?: true
  }

  export type BmMateriaisFioMaxAggregateInputType = {
    grupo?: true
    subGrupo?: true
  }

  export type BmMateriaisFioCountAggregateInputType = {
    grupo?: true
    subGrupo?: true
    _all?: true
  }

  export type BmMateriaisFioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMateriaisFio to aggregate.
     */
    where?: BmMateriaisFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisFios to fetch.
     */
    orderBy?: BmMateriaisFioOrderByWithRelationInput | BmMateriaisFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMateriaisFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMateriaisFios
    **/
    _count?: true | BmMateriaisFioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMateriaisFioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMateriaisFioMaxAggregateInputType
  }

  export type GetBmMateriaisFioAggregateType<T extends BmMateriaisFioAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMateriaisFio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMateriaisFio[P]>
      : GetScalarType<T[P], AggregateBmMateriaisFio[P]>
  }




  export type BmMateriaisFioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMateriaisFioWhereInput
    orderBy?: BmMateriaisFioOrderByWithAggregationInput | BmMateriaisFioOrderByWithAggregationInput[]
    by: BmMateriaisFioScalarFieldEnum[] | BmMateriaisFioScalarFieldEnum
    having?: BmMateriaisFioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMateriaisFioCountAggregateInputType | true
    _min?: BmMateriaisFioMinAggregateInputType
    _max?: BmMateriaisFioMaxAggregateInputType
  }

  export type BmMateriaisFioGroupByOutputType = {
    grupo: string
    subGrupo: string
    _count: BmMateriaisFioCountAggregateOutputType | null
    _min: BmMateriaisFioMinAggregateOutputType | null
    _max: BmMateriaisFioMaxAggregateOutputType | null
  }

  type GetBmMateriaisFioGroupByPayload<T extends BmMateriaisFioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMateriaisFioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMateriaisFioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMateriaisFioGroupByOutputType[P]>
            : GetScalarType<T[P], BmMateriaisFioGroupByOutputType[P]>
        }
      >
    >


  export type BmMateriaisFioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    grupo?: boolean
    subGrupo?: boolean
    BmMalhasFio?: boolean | BmMateriaisFio$BmMalhasFioArgs<ExtArgs>
    BmMaterialGrupoFio?: boolean | BmMaterialGrupoFioDefaultArgs<ExtArgs>
    BmMaterialSubGrupoFio?: boolean | BmMaterialSubGrupoFioDefaultArgs<ExtArgs>
    _count?: boolean | BmMateriaisFioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMateriaisFio"]>



  export type BmMateriaisFioSelectScalar = {
    grupo?: boolean
    subGrupo?: boolean
  }

  export type BmMateriaisFioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"grupo" | "subGrupo", ExtArgs["result"]["bmMateriaisFio"]>
  export type BmMateriaisFioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhasFio?: boolean | BmMateriaisFio$BmMalhasFioArgs<ExtArgs>
    BmMaterialGrupoFio?: boolean | BmMaterialGrupoFioDefaultArgs<ExtArgs>
    BmMaterialSubGrupoFio?: boolean | BmMaterialSubGrupoFioDefaultArgs<ExtArgs>
    _count?: boolean | BmMateriaisFioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMateriaisFioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMateriaisFio"
    objects: {
      BmMalhasFio: Prisma.$BmMalhasFioPayload<ExtArgs>[]
      BmMaterialGrupoFio: Prisma.$BmMaterialGrupoFioPayload<ExtArgs>
      BmMaterialSubGrupoFio: Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      grupo: string
      subGrupo: string
    }, ExtArgs["result"]["bmMateriaisFio"]>
    composites: {}
  }

  type BmMateriaisFioGetPayload<S extends boolean | null | undefined | BmMateriaisFioDefaultArgs> = $Result.GetResult<Prisma.$BmMateriaisFioPayload, S>

  type BmMateriaisFioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMateriaisFioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMateriaisFioCountAggregateInputType | true
    }

  export interface BmMateriaisFioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMateriaisFio'], meta: { name: 'BmMateriaisFio' } }
    /**
     * Find zero or one BmMateriaisFio that matches the filter.
     * @param {BmMateriaisFioFindUniqueArgs} args - Arguments to find a BmMateriaisFio
     * @example
     * // Get one BmMateriaisFio
     * const bmMateriaisFio = await prisma.bmMateriaisFio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMateriaisFioFindUniqueArgs>(args: SelectSubset<T, BmMateriaisFioFindUniqueArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMateriaisFio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMateriaisFioFindUniqueOrThrowArgs} args - Arguments to find a BmMateriaisFio
     * @example
     * // Get one BmMateriaisFio
     * const bmMateriaisFio = await prisma.bmMateriaisFio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMateriaisFioFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMateriaisFioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMateriaisFio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFioFindFirstArgs} args - Arguments to find a BmMateriaisFio
     * @example
     * // Get one BmMateriaisFio
     * const bmMateriaisFio = await prisma.bmMateriaisFio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMateriaisFioFindFirstArgs>(args?: SelectSubset<T, BmMateriaisFioFindFirstArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMateriaisFio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFioFindFirstOrThrowArgs} args - Arguments to find a BmMateriaisFio
     * @example
     * // Get one BmMateriaisFio
     * const bmMateriaisFio = await prisma.bmMateriaisFio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMateriaisFioFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMateriaisFioFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMateriaisFios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMateriaisFios
     * const bmMateriaisFios = await prisma.bmMateriaisFio.findMany()
     * 
     * // Get first 10 BmMateriaisFios
     * const bmMateriaisFios = await prisma.bmMateriaisFio.findMany({ take: 10 })
     * 
     * // Only select the `grupo`
     * const bmMateriaisFioWithGrupoOnly = await prisma.bmMateriaisFio.findMany({ select: { grupo: true } })
     * 
     */
    findMany<T extends BmMateriaisFioFindManyArgs>(args?: SelectSubset<T, BmMateriaisFioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMateriaisFio.
     * @param {BmMateriaisFioCreateArgs} args - Arguments to create a BmMateriaisFio.
     * @example
     * // Create one BmMateriaisFio
     * const BmMateriaisFio = await prisma.bmMateriaisFio.create({
     *   data: {
     *     // ... data to create a BmMateriaisFio
     *   }
     * })
     * 
     */
    create<T extends BmMateriaisFioCreateArgs>(args: SelectSubset<T, BmMateriaisFioCreateArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMateriaisFios.
     * @param {BmMateriaisFioCreateManyArgs} args - Arguments to create many BmMateriaisFios.
     * @example
     * // Create many BmMateriaisFios
     * const bmMateriaisFio = await prisma.bmMateriaisFio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMateriaisFioCreateManyArgs>(args?: SelectSubset<T, BmMateriaisFioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMateriaisFio.
     * @param {BmMateriaisFioDeleteArgs} args - Arguments to delete one BmMateriaisFio.
     * @example
     * // Delete one BmMateriaisFio
     * const BmMateriaisFio = await prisma.bmMateriaisFio.delete({
     *   where: {
     *     // ... filter to delete one BmMateriaisFio
     *   }
     * })
     * 
     */
    delete<T extends BmMateriaisFioDeleteArgs>(args: SelectSubset<T, BmMateriaisFioDeleteArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMateriaisFio.
     * @param {BmMateriaisFioUpdateArgs} args - Arguments to update one BmMateriaisFio.
     * @example
     * // Update one BmMateriaisFio
     * const bmMateriaisFio = await prisma.bmMateriaisFio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMateriaisFioUpdateArgs>(args: SelectSubset<T, BmMateriaisFioUpdateArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMateriaisFios.
     * @param {BmMateriaisFioDeleteManyArgs} args - Arguments to filter BmMateriaisFios to delete.
     * @example
     * // Delete a few BmMateriaisFios
     * const { count } = await prisma.bmMateriaisFio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMateriaisFioDeleteManyArgs>(args?: SelectSubset<T, BmMateriaisFioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMateriaisFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMateriaisFios
     * const bmMateriaisFio = await prisma.bmMateriaisFio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMateriaisFioUpdateManyArgs>(args: SelectSubset<T, BmMateriaisFioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMateriaisFio.
     * @param {BmMateriaisFioUpsertArgs} args - Arguments to update or create a BmMateriaisFio.
     * @example
     * // Update or create a BmMateriaisFio
     * const bmMateriaisFio = await prisma.bmMateriaisFio.upsert({
     *   create: {
     *     // ... data to create a BmMateriaisFio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMateriaisFio we want to update
     *   }
     * })
     */
    upsert<T extends BmMateriaisFioUpsertArgs>(args: SelectSubset<T, BmMateriaisFioUpsertArgs<ExtArgs>>): Prisma__BmMateriaisFioClient<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMateriaisFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFioCountArgs} args - Arguments to filter BmMateriaisFios to count.
     * @example
     * // Count the number of BmMateriaisFios
     * const count = await prisma.bmMateriaisFio.count({
     *   where: {
     *     // ... the filter for the BmMateriaisFios we want to count
     *   }
     * })
    **/
    count<T extends BmMateriaisFioCountArgs>(
      args?: Subset<T, BmMateriaisFioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMateriaisFioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMateriaisFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMateriaisFioAggregateArgs>(args: Subset<T, BmMateriaisFioAggregateArgs>): Prisma.PrismaPromise<GetBmMateriaisFioAggregateType<T>>

    /**
     * Group by BmMateriaisFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMateriaisFioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMateriaisFioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMateriaisFioGroupByArgs['orderBy'] }
        : { orderBy?: BmMateriaisFioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMateriaisFioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMateriaisFioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMateriaisFio model
   */
  readonly fields: BmMateriaisFioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMateriaisFio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMateriaisFioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMalhasFio<T extends BmMateriaisFio$BmMalhasFioArgs<ExtArgs> = {}>(args?: Subset<T, BmMateriaisFio$BmMalhasFioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmMaterialGrupoFio<T extends BmMaterialGrupoFioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialGrupoFioDefaultArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmMaterialSubGrupoFio<T extends BmMaterialSubGrupoFioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialSubGrupoFioDefaultArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMateriaisFio model
   */ 
  interface BmMateriaisFioFieldRefs {
    readonly grupo: FieldRef<"BmMateriaisFio", 'String'>
    readonly subGrupo: FieldRef<"BmMateriaisFio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMateriaisFio findUnique
   */
  export type BmMateriaisFioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisFio to fetch.
     */
    where: BmMateriaisFioWhereUniqueInput
  }

  /**
   * BmMateriaisFio findUniqueOrThrow
   */
  export type BmMateriaisFioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisFio to fetch.
     */
    where: BmMateriaisFioWhereUniqueInput
  }

  /**
   * BmMateriaisFio findFirst
   */
  export type BmMateriaisFioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisFio to fetch.
     */
    where?: BmMateriaisFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisFios to fetch.
     */
    orderBy?: BmMateriaisFioOrderByWithRelationInput | BmMateriaisFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMateriaisFios.
     */
    cursor?: BmMateriaisFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMateriaisFios.
     */
    distinct?: BmMateriaisFioScalarFieldEnum | BmMateriaisFioScalarFieldEnum[]
  }

  /**
   * BmMateriaisFio findFirstOrThrow
   */
  export type BmMateriaisFioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisFio to fetch.
     */
    where?: BmMateriaisFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisFios to fetch.
     */
    orderBy?: BmMateriaisFioOrderByWithRelationInput | BmMateriaisFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMateriaisFios.
     */
    cursor?: BmMateriaisFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMateriaisFios.
     */
    distinct?: BmMateriaisFioScalarFieldEnum | BmMateriaisFioScalarFieldEnum[]
  }

  /**
   * BmMateriaisFio findMany
   */
  export type BmMateriaisFioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMateriaisFios to fetch.
     */
    where?: BmMateriaisFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMateriaisFios to fetch.
     */
    orderBy?: BmMateriaisFioOrderByWithRelationInput | BmMateriaisFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMateriaisFios.
     */
    cursor?: BmMateriaisFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMateriaisFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMateriaisFios.
     */
    skip?: number
    distinct?: BmMateriaisFioScalarFieldEnum | BmMateriaisFioScalarFieldEnum[]
  }

  /**
   * BmMateriaisFio create
   */
  export type BmMateriaisFioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMateriaisFio.
     */
    data: XOR<BmMateriaisFioCreateInput, BmMateriaisFioUncheckedCreateInput>
  }

  /**
   * BmMateriaisFio createMany
   */
  export type BmMateriaisFioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMateriaisFios.
     */
    data: BmMateriaisFioCreateManyInput | BmMateriaisFioCreateManyInput[]
  }

  /**
   * BmMateriaisFio update
   */
  export type BmMateriaisFioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMateriaisFio.
     */
    data: XOR<BmMateriaisFioUpdateInput, BmMateriaisFioUncheckedUpdateInput>
    /**
     * Choose, which BmMateriaisFio to update.
     */
    where: BmMateriaisFioWhereUniqueInput
  }

  /**
   * BmMateriaisFio updateMany
   */
  export type BmMateriaisFioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMateriaisFios.
     */
    data: XOR<BmMateriaisFioUpdateManyMutationInput, BmMateriaisFioUncheckedUpdateManyInput>
    /**
     * Filter which BmMateriaisFios to update
     */
    where?: BmMateriaisFioWhereInput
    /**
     * Limit how many BmMateriaisFios to update.
     */
    limit?: number
  }

  /**
   * BmMateriaisFio upsert
   */
  export type BmMateriaisFioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMateriaisFio to update in case it exists.
     */
    where: BmMateriaisFioWhereUniqueInput
    /**
     * In case the BmMateriaisFio found by the `where` argument doesn't exist, create a new BmMateriaisFio with this data.
     */
    create: XOR<BmMateriaisFioCreateInput, BmMateriaisFioUncheckedCreateInput>
    /**
     * In case the BmMateriaisFio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMateriaisFioUpdateInput, BmMateriaisFioUncheckedUpdateInput>
  }

  /**
   * BmMateriaisFio delete
   */
  export type BmMateriaisFioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    /**
     * Filter which BmMateriaisFio to delete.
     */
    where: BmMateriaisFioWhereUniqueInput
  }

  /**
   * BmMateriaisFio deleteMany
   */
  export type BmMateriaisFioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMateriaisFios to delete
     */
    where?: BmMateriaisFioWhereInput
    /**
     * Limit how many BmMateriaisFios to delete.
     */
    limit?: number
  }

  /**
   * BmMateriaisFio.BmMalhasFio
   */
  export type BmMateriaisFio$BmMalhasFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFio
     */
    select?: BmMalhasFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFio
     */
    omit?: BmMalhasFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioInclude<ExtArgs> | null
    where?: BmMalhasFioWhereInput
    orderBy?: BmMalhasFioOrderByWithRelationInput | BmMalhasFioOrderByWithRelationInput[]
    cursor?: BmMalhasFioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMalhasFioScalarFieldEnum | BmMalhasFioScalarFieldEnum[]
  }

  /**
   * BmMateriaisFio without action
   */
  export type BmMateriaisFioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
  }


  /**
   * Model BmMaterialGrupo
   */

  export type AggregateBmMaterialGrupo = {
    _count: BmMaterialGrupoCountAggregateOutputType | null
    _min: BmMaterialGrupoMinAggregateOutputType | null
    _max: BmMaterialGrupoMaxAggregateOutputType | null
  }

  export type BmMaterialGrupoMinAggregateOutputType = {
    grupo: string | null
    grupoDescricao: string | null
  }

  export type BmMaterialGrupoMaxAggregateOutputType = {
    grupo: string | null
    grupoDescricao: string | null
  }

  export type BmMaterialGrupoCountAggregateOutputType = {
    grupo: number
    grupoDescricao: number
    _all: number
  }


  export type BmMaterialGrupoMinAggregateInputType = {
    grupo?: true
    grupoDescricao?: true
  }

  export type BmMaterialGrupoMaxAggregateInputType = {
    grupo?: true
    grupoDescricao?: true
  }

  export type BmMaterialGrupoCountAggregateInputType = {
    grupo?: true
    grupoDescricao?: true
    _all?: true
  }

  export type BmMaterialGrupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialGrupo to aggregate.
     */
    where?: BmMaterialGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupos to fetch.
     */
    orderBy?: BmMaterialGrupoOrderByWithRelationInput | BmMaterialGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMaterialGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMaterialGrupos
    **/
    _count?: true | BmMaterialGrupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMaterialGrupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMaterialGrupoMaxAggregateInputType
  }

  export type GetBmMaterialGrupoAggregateType<T extends BmMaterialGrupoAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMaterialGrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMaterialGrupo[P]>
      : GetScalarType<T[P], AggregateBmMaterialGrupo[P]>
  }




  export type BmMaterialGrupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMaterialGrupoWhereInput
    orderBy?: BmMaterialGrupoOrderByWithAggregationInput | BmMaterialGrupoOrderByWithAggregationInput[]
    by: BmMaterialGrupoScalarFieldEnum[] | BmMaterialGrupoScalarFieldEnum
    having?: BmMaterialGrupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMaterialGrupoCountAggregateInputType | true
    _min?: BmMaterialGrupoMinAggregateInputType
    _max?: BmMaterialGrupoMaxAggregateInputType
  }

  export type BmMaterialGrupoGroupByOutputType = {
    grupo: string
    grupoDescricao: string
    _count: BmMaterialGrupoCountAggregateOutputType | null
    _min: BmMaterialGrupoMinAggregateOutputType | null
    _max: BmMaterialGrupoMaxAggregateOutputType | null
  }

  type GetBmMaterialGrupoGroupByPayload<T extends BmMaterialGrupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMaterialGrupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMaterialGrupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMaterialGrupoGroupByOutputType[P]>
            : GetScalarType<T[P], BmMaterialGrupoGroupByOutputType[P]>
        }
      >
    >


  export type BmMaterialGrupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    grupo?: boolean
    grupoDescricao?: boolean
    BmMateriais?: boolean | BmMaterialGrupo$BmMateriaisArgs<ExtArgs>
    _count?: boolean | BmMaterialGrupoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMaterialGrupo"]>



  export type BmMaterialGrupoSelectScalar = {
    grupo?: boolean
    grupoDescricao?: boolean
  }

  export type BmMaterialGrupoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"grupo" | "grupoDescricao", ExtArgs["result"]["bmMaterialGrupo"]>
  export type BmMaterialGrupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriais?: boolean | BmMaterialGrupo$BmMateriaisArgs<ExtArgs>
    _count?: boolean | BmMaterialGrupoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMaterialGrupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMaterialGrupo"
    objects: {
      BmMateriais: Prisma.$BmMateriaisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      grupo: string
      grupoDescricao: string
    }, ExtArgs["result"]["bmMaterialGrupo"]>
    composites: {}
  }

  type BmMaterialGrupoGetPayload<S extends boolean | null | undefined | BmMaterialGrupoDefaultArgs> = $Result.GetResult<Prisma.$BmMaterialGrupoPayload, S>

  type BmMaterialGrupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMaterialGrupoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMaterialGrupoCountAggregateInputType | true
    }

  export interface BmMaterialGrupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMaterialGrupo'], meta: { name: 'BmMaterialGrupo' } }
    /**
     * Find zero or one BmMaterialGrupo that matches the filter.
     * @param {BmMaterialGrupoFindUniqueArgs} args - Arguments to find a BmMaterialGrupo
     * @example
     * // Get one BmMaterialGrupo
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMaterialGrupoFindUniqueArgs>(args: SelectSubset<T, BmMaterialGrupoFindUniqueArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMaterialGrupo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMaterialGrupoFindUniqueOrThrowArgs} args - Arguments to find a BmMaterialGrupo
     * @example
     * // Get one BmMaterialGrupo
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMaterialGrupoFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMaterialGrupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialGrupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFindFirstArgs} args - Arguments to find a BmMaterialGrupo
     * @example
     * // Get one BmMaterialGrupo
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMaterialGrupoFindFirstArgs>(args?: SelectSubset<T, BmMaterialGrupoFindFirstArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialGrupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFindFirstOrThrowArgs} args - Arguments to find a BmMaterialGrupo
     * @example
     * // Get one BmMaterialGrupo
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMaterialGrupoFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMaterialGrupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMaterialGrupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMaterialGrupos
     * const bmMaterialGrupos = await prisma.bmMaterialGrupo.findMany()
     * 
     * // Get first 10 BmMaterialGrupos
     * const bmMaterialGrupos = await prisma.bmMaterialGrupo.findMany({ take: 10 })
     * 
     * // Only select the `grupo`
     * const bmMaterialGrupoWithGrupoOnly = await prisma.bmMaterialGrupo.findMany({ select: { grupo: true } })
     * 
     */
    findMany<T extends BmMaterialGrupoFindManyArgs>(args?: SelectSubset<T, BmMaterialGrupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMaterialGrupo.
     * @param {BmMaterialGrupoCreateArgs} args - Arguments to create a BmMaterialGrupo.
     * @example
     * // Create one BmMaterialGrupo
     * const BmMaterialGrupo = await prisma.bmMaterialGrupo.create({
     *   data: {
     *     // ... data to create a BmMaterialGrupo
     *   }
     * })
     * 
     */
    create<T extends BmMaterialGrupoCreateArgs>(args: SelectSubset<T, BmMaterialGrupoCreateArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMaterialGrupos.
     * @param {BmMaterialGrupoCreateManyArgs} args - Arguments to create many BmMaterialGrupos.
     * @example
     * // Create many BmMaterialGrupos
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMaterialGrupoCreateManyArgs>(args?: SelectSubset<T, BmMaterialGrupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMaterialGrupo.
     * @param {BmMaterialGrupoDeleteArgs} args - Arguments to delete one BmMaterialGrupo.
     * @example
     * // Delete one BmMaterialGrupo
     * const BmMaterialGrupo = await prisma.bmMaterialGrupo.delete({
     *   where: {
     *     // ... filter to delete one BmMaterialGrupo
     *   }
     * })
     * 
     */
    delete<T extends BmMaterialGrupoDeleteArgs>(args: SelectSubset<T, BmMaterialGrupoDeleteArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMaterialGrupo.
     * @param {BmMaterialGrupoUpdateArgs} args - Arguments to update one BmMaterialGrupo.
     * @example
     * // Update one BmMaterialGrupo
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMaterialGrupoUpdateArgs>(args: SelectSubset<T, BmMaterialGrupoUpdateArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMaterialGrupos.
     * @param {BmMaterialGrupoDeleteManyArgs} args - Arguments to filter BmMaterialGrupos to delete.
     * @example
     * // Delete a few BmMaterialGrupos
     * const { count } = await prisma.bmMaterialGrupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMaterialGrupoDeleteManyArgs>(args?: SelectSubset<T, BmMaterialGrupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMaterialGrupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMaterialGrupos
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMaterialGrupoUpdateManyArgs>(args: SelectSubset<T, BmMaterialGrupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMaterialGrupo.
     * @param {BmMaterialGrupoUpsertArgs} args - Arguments to update or create a BmMaterialGrupo.
     * @example
     * // Update or create a BmMaterialGrupo
     * const bmMaterialGrupo = await prisma.bmMaterialGrupo.upsert({
     *   create: {
     *     // ... data to create a BmMaterialGrupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMaterialGrupo we want to update
     *   }
     * })
     */
    upsert<T extends BmMaterialGrupoUpsertArgs>(args: SelectSubset<T, BmMaterialGrupoUpsertArgs<ExtArgs>>): Prisma__BmMaterialGrupoClient<$Result.GetResult<Prisma.$BmMaterialGrupoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMaterialGrupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoCountArgs} args - Arguments to filter BmMaterialGrupos to count.
     * @example
     * // Count the number of BmMaterialGrupos
     * const count = await prisma.bmMaterialGrupo.count({
     *   where: {
     *     // ... the filter for the BmMaterialGrupos we want to count
     *   }
     * })
    **/
    count<T extends BmMaterialGrupoCountArgs>(
      args?: Subset<T, BmMaterialGrupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMaterialGrupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMaterialGrupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMaterialGrupoAggregateArgs>(args: Subset<T, BmMaterialGrupoAggregateArgs>): Prisma.PrismaPromise<GetBmMaterialGrupoAggregateType<T>>

    /**
     * Group by BmMaterialGrupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMaterialGrupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMaterialGrupoGroupByArgs['orderBy'] }
        : { orderBy?: BmMaterialGrupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMaterialGrupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMaterialGrupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMaterialGrupo model
   */
  readonly fields: BmMaterialGrupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMaterialGrupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMaterialGrupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMateriais<T extends BmMaterialGrupo$BmMateriaisArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialGrupo$BmMateriaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMaterialGrupo model
   */ 
  interface BmMaterialGrupoFieldRefs {
    readonly grupo: FieldRef<"BmMaterialGrupo", 'String'>
    readonly grupoDescricao: FieldRef<"BmMaterialGrupo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMaterialGrupo findUnique
   */
  export type BmMaterialGrupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupo to fetch.
     */
    where: BmMaterialGrupoWhereUniqueInput
  }

  /**
   * BmMaterialGrupo findUniqueOrThrow
   */
  export type BmMaterialGrupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupo to fetch.
     */
    where: BmMaterialGrupoWhereUniqueInput
  }

  /**
   * BmMaterialGrupo findFirst
   */
  export type BmMaterialGrupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupo to fetch.
     */
    where?: BmMaterialGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupos to fetch.
     */
    orderBy?: BmMaterialGrupoOrderByWithRelationInput | BmMaterialGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialGrupos.
     */
    cursor?: BmMaterialGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialGrupos.
     */
    distinct?: BmMaterialGrupoScalarFieldEnum | BmMaterialGrupoScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupo findFirstOrThrow
   */
  export type BmMaterialGrupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupo to fetch.
     */
    where?: BmMaterialGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupos to fetch.
     */
    orderBy?: BmMaterialGrupoOrderByWithRelationInput | BmMaterialGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialGrupos.
     */
    cursor?: BmMaterialGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialGrupos.
     */
    distinct?: BmMaterialGrupoScalarFieldEnum | BmMaterialGrupoScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupo findMany
   */
  export type BmMaterialGrupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupos to fetch.
     */
    where?: BmMaterialGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupos to fetch.
     */
    orderBy?: BmMaterialGrupoOrderByWithRelationInput | BmMaterialGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMaterialGrupos.
     */
    cursor?: BmMaterialGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupos.
     */
    skip?: number
    distinct?: BmMaterialGrupoScalarFieldEnum | BmMaterialGrupoScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupo create
   */
  export type BmMaterialGrupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMaterialGrupo.
     */
    data: XOR<BmMaterialGrupoCreateInput, BmMaterialGrupoUncheckedCreateInput>
  }

  /**
   * BmMaterialGrupo createMany
   */
  export type BmMaterialGrupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMaterialGrupos.
     */
    data: BmMaterialGrupoCreateManyInput | BmMaterialGrupoCreateManyInput[]
  }

  /**
   * BmMaterialGrupo update
   */
  export type BmMaterialGrupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMaterialGrupo.
     */
    data: XOR<BmMaterialGrupoUpdateInput, BmMaterialGrupoUncheckedUpdateInput>
    /**
     * Choose, which BmMaterialGrupo to update.
     */
    where: BmMaterialGrupoWhereUniqueInput
  }

  /**
   * BmMaterialGrupo updateMany
   */
  export type BmMaterialGrupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMaterialGrupos.
     */
    data: XOR<BmMaterialGrupoUpdateManyMutationInput, BmMaterialGrupoUncheckedUpdateManyInput>
    /**
     * Filter which BmMaterialGrupos to update
     */
    where?: BmMaterialGrupoWhereInput
    /**
     * Limit how many BmMaterialGrupos to update.
     */
    limit?: number
  }

  /**
   * BmMaterialGrupo upsert
   */
  export type BmMaterialGrupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMaterialGrupo to update in case it exists.
     */
    where: BmMaterialGrupoWhereUniqueInput
    /**
     * In case the BmMaterialGrupo found by the `where` argument doesn't exist, create a new BmMaterialGrupo with this data.
     */
    create: XOR<BmMaterialGrupoCreateInput, BmMaterialGrupoUncheckedCreateInput>
    /**
     * In case the BmMaterialGrupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMaterialGrupoUpdateInput, BmMaterialGrupoUncheckedUpdateInput>
  }

  /**
   * BmMaterialGrupo delete
   */
  export type BmMaterialGrupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
    /**
     * Filter which BmMaterialGrupo to delete.
     */
    where: BmMaterialGrupoWhereUniqueInput
  }

  /**
   * BmMaterialGrupo deleteMany
   */
  export type BmMaterialGrupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialGrupos to delete
     */
    where?: BmMaterialGrupoWhereInput
    /**
     * Limit how many BmMaterialGrupos to delete.
     */
    limit?: number
  }

  /**
   * BmMaterialGrupo.BmMateriais
   */
  export type BmMaterialGrupo$BmMateriaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    where?: BmMateriaisWhereInput
    orderBy?: BmMateriaisOrderByWithRelationInput | BmMateriaisOrderByWithRelationInput[]
    cursor?: BmMateriaisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMateriaisScalarFieldEnum | BmMateriaisScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupo without action
   */
  export type BmMaterialGrupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupo
     */
    select?: BmMaterialGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupo
     */
    omit?: BmMaterialGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoInclude<ExtArgs> | null
  }


  /**
   * Model BmMaterialGrupoFio
   */

  export type AggregateBmMaterialGrupoFio = {
    _count: BmMaterialGrupoFioCountAggregateOutputType | null
    _min: BmMaterialGrupoFioMinAggregateOutputType | null
    _max: BmMaterialGrupoFioMaxAggregateOutputType | null
  }

  export type BmMaterialGrupoFioMinAggregateOutputType = {
    grupo: string | null
    grupoDescricao: string | null
  }

  export type BmMaterialGrupoFioMaxAggregateOutputType = {
    grupo: string | null
    grupoDescricao: string | null
  }

  export type BmMaterialGrupoFioCountAggregateOutputType = {
    grupo: number
    grupoDescricao: number
    _all: number
  }


  export type BmMaterialGrupoFioMinAggregateInputType = {
    grupo?: true
    grupoDescricao?: true
  }

  export type BmMaterialGrupoFioMaxAggregateInputType = {
    grupo?: true
    grupoDescricao?: true
  }

  export type BmMaterialGrupoFioCountAggregateInputType = {
    grupo?: true
    grupoDescricao?: true
    _all?: true
  }

  export type BmMaterialGrupoFioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialGrupoFio to aggregate.
     */
    where?: BmMaterialGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupoFios to fetch.
     */
    orderBy?: BmMaterialGrupoFioOrderByWithRelationInput | BmMaterialGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMaterialGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupoFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMaterialGrupoFios
    **/
    _count?: true | BmMaterialGrupoFioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMaterialGrupoFioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMaterialGrupoFioMaxAggregateInputType
  }

  export type GetBmMaterialGrupoFioAggregateType<T extends BmMaterialGrupoFioAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMaterialGrupoFio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMaterialGrupoFio[P]>
      : GetScalarType<T[P], AggregateBmMaterialGrupoFio[P]>
  }




  export type BmMaterialGrupoFioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMaterialGrupoFioWhereInput
    orderBy?: BmMaterialGrupoFioOrderByWithAggregationInput | BmMaterialGrupoFioOrderByWithAggregationInput[]
    by: BmMaterialGrupoFioScalarFieldEnum[] | BmMaterialGrupoFioScalarFieldEnum
    having?: BmMaterialGrupoFioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMaterialGrupoFioCountAggregateInputType | true
    _min?: BmMaterialGrupoFioMinAggregateInputType
    _max?: BmMaterialGrupoFioMaxAggregateInputType
  }

  export type BmMaterialGrupoFioGroupByOutputType = {
    grupo: string
    grupoDescricao: string
    _count: BmMaterialGrupoFioCountAggregateOutputType | null
    _min: BmMaterialGrupoFioMinAggregateOutputType | null
    _max: BmMaterialGrupoFioMaxAggregateOutputType | null
  }

  type GetBmMaterialGrupoFioGroupByPayload<T extends BmMaterialGrupoFioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMaterialGrupoFioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMaterialGrupoFioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMaterialGrupoFioGroupByOutputType[P]>
            : GetScalarType<T[P], BmMaterialGrupoFioGroupByOutputType[P]>
        }
      >
    >


  export type BmMaterialGrupoFioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    grupo?: boolean
    grupoDescricao?: boolean
    BmMateriaisFio?: boolean | BmMaterialGrupoFio$BmMateriaisFioArgs<ExtArgs>
    _count?: boolean | BmMaterialGrupoFioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMaterialGrupoFio"]>



  export type BmMaterialGrupoFioSelectScalar = {
    grupo?: boolean
    grupoDescricao?: boolean
  }

  export type BmMaterialGrupoFioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"grupo" | "grupoDescricao", ExtArgs["result"]["bmMaterialGrupoFio"]>
  export type BmMaterialGrupoFioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriaisFio?: boolean | BmMaterialGrupoFio$BmMateriaisFioArgs<ExtArgs>
    _count?: boolean | BmMaterialGrupoFioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMaterialGrupoFioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMaterialGrupoFio"
    objects: {
      BmMateriaisFio: Prisma.$BmMateriaisFioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      grupo: string
      grupoDescricao: string
    }, ExtArgs["result"]["bmMaterialGrupoFio"]>
    composites: {}
  }

  type BmMaterialGrupoFioGetPayload<S extends boolean | null | undefined | BmMaterialGrupoFioDefaultArgs> = $Result.GetResult<Prisma.$BmMaterialGrupoFioPayload, S>

  type BmMaterialGrupoFioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMaterialGrupoFioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMaterialGrupoFioCountAggregateInputType | true
    }

  export interface BmMaterialGrupoFioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMaterialGrupoFio'], meta: { name: 'BmMaterialGrupoFio' } }
    /**
     * Find zero or one BmMaterialGrupoFio that matches the filter.
     * @param {BmMaterialGrupoFioFindUniqueArgs} args - Arguments to find a BmMaterialGrupoFio
     * @example
     * // Get one BmMaterialGrupoFio
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMaterialGrupoFioFindUniqueArgs>(args: SelectSubset<T, BmMaterialGrupoFioFindUniqueArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMaterialGrupoFio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMaterialGrupoFioFindUniqueOrThrowArgs} args - Arguments to find a BmMaterialGrupoFio
     * @example
     * // Get one BmMaterialGrupoFio
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMaterialGrupoFioFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMaterialGrupoFioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialGrupoFio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFioFindFirstArgs} args - Arguments to find a BmMaterialGrupoFio
     * @example
     * // Get one BmMaterialGrupoFio
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMaterialGrupoFioFindFirstArgs>(args?: SelectSubset<T, BmMaterialGrupoFioFindFirstArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialGrupoFio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFioFindFirstOrThrowArgs} args - Arguments to find a BmMaterialGrupoFio
     * @example
     * // Get one BmMaterialGrupoFio
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMaterialGrupoFioFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMaterialGrupoFioFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMaterialGrupoFios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMaterialGrupoFios
     * const bmMaterialGrupoFios = await prisma.bmMaterialGrupoFio.findMany()
     * 
     * // Get first 10 BmMaterialGrupoFios
     * const bmMaterialGrupoFios = await prisma.bmMaterialGrupoFio.findMany({ take: 10 })
     * 
     * // Only select the `grupo`
     * const bmMaterialGrupoFioWithGrupoOnly = await prisma.bmMaterialGrupoFio.findMany({ select: { grupo: true } })
     * 
     */
    findMany<T extends BmMaterialGrupoFioFindManyArgs>(args?: SelectSubset<T, BmMaterialGrupoFioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMaterialGrupoFio.
     * @param {BmMaterialGrupoFioCreateArgs} args - Arguments to create a BmMaterialGrupoFio.
     * @example
     * // Create one BmMaterialGrupoFio
     * const BmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.create({
     *   data: {
     *     // ... data to create a BmMaterialGrupoFio
     *   }
     * })
     * 
     */
    create<T extends BmMaterialGrupoFioCreateArgs>(args: SelectSubset<T, BmMaterialGrupoFioCreateArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMaterialGrupoFios.
     * @param {BmMaterialGrupoFioCreateManyArgs} args - Arguments to create many BmMaterialGrupoFios.
     * @example
     * // Create many BmMaterialGrupoFios
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMaterialGrupoFioCreateManyArgs>(args?: SelectSubset<T, BmMaterialGrupoFioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMaterialGrupoFio.
     * @param {BmMaterialGrupoFioDeleteArgs} args - Arguments to delete one BmMaterialGrupoFio.
     * @example
     * // Delete one BmMaterialGrupoFio
     * const BmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.delete({
     *   where: {
     *     // ... filter to delete one BmMaterialGrupoFio
     *   }
     * })
     * 
     */
    delete<T extends BmMaterialGrupoFioDeleteArgs>(args: SelectSubset<T, BmMaterialGrupoFioDeleteArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMaterialGrupoFio.
     * @param {BmMaterialGrupoFioUpdateArgs} args - Arguments to update one BmMaterialGrupoFio.
     * @example
     * // Update one BmMaterialGrupoFio
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMaterialGrupoFioUpdateArgs>(args: SelectSubset<T, BmMaterialGrupoFioUpdateArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMaterialGrupoFios.
     * @param {BmMaterialGrupoFioDeleteManyArgs} args - Arguments to filter BmMaterialGrupoFios to delete.
     * @example
     * // Delete a few BmMaterialGrupoFios
     * const { count } = await prisma.bmMaterialGrupoFio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMaterialGrupoFioDeleteManyArgs>(args?: SelectSubset<T, BmMaterialGrupoFioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMaterialGrupoFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMaterialGrupoFios
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMaterialGrupoFioUpdateManyArgs>(args: SelectSubset<T, BmMaterialGrupoFioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMaterialGrupoFio.
     * @param {BmMaterialGrupoFioUpsertArgs} args - Arguments to update or create a BmMaterialGrupoFio.
     * @example
     * // Update or create a BmMaterialGrupoFio
     * const bmMaterialGrupoFio = await prisma.bmMaterialGrupoFio.upsert({
     *   create: {
     *     // ... data to create a BmMaterialGrupoFio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMaterialGrupoFio we want to update
     *   }
     * })
     */
    upsert<T extends BmMaterialGrupoFioUpsertArgs>(args: SelectSubset<T, BmMaterialGrupoFioUpsertArgs<ExtArgs>>): Prisma__BmMaterialGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialGrupoFioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMaterialGrupoFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFioCountArgs} args - Arguments to filter BmMaterialGrupoFios to count.
     * @example
     * // Count the number of BmMaterialGrupoFios
     * const count = await prisma.bmMaterialGrupoFio.count({
     *   where: {
     *     // ... the filter for the BmMaterialGrupoFios we want to count
     *   }
     * })
    **/
    count<T extends BmMaterialGrupoFioCountArgs>(
      args?: Subset<T, BmMaterialGrupoFioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMaterialGrupoFioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMaterialGrupoFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMaterialGrupoFioAggregateArgs>(args: Subset<T, BmMaterialGrupoFioAggregateArgs>): Prisma.PrismaPromise<GetBmMaterialGrupoFioAggregateType<T>>

    /**
     * Group by BmMaterialGrupoFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialGrupoFioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMaterialGrupoFioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMaterialGrupoFioGroupByArgs['orderBy'] }
        : { orderBy?: BmMaterialGrupoFioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMaterialGrupoFioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMaterialGrupoFioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMaterialGrupoFio model
   */
  readonly fields: BmMaterialGrupoFioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMaterialGrupoFio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMaterialGrupoFioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMateriaisFio<T extends BmMaterialGrupoFio$BmMateriaisFioArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialGrupoFio$BmMateriaisFioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMaterialGrupoFio model
   */ 
  interface BmMaterialGrupoFioFieldRefs {
    readonly grupo: FieldRef<"BmMaterialGrupoFio", 'String'>
    readonly grupoDescricao: FieldRef<"BmMaterialGrupoFio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMaterialGrupoFio findUnique
   */
  export type BmMaterialGrupoFioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupoFio to fetch.
     */
    where: BmMaterialGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialGrupoFio findUniqueOrThrow
   */
  export type BmMaterialGrupoFioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupoFio to fetch.
     */
    where: BmMaterialGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialGrupoFio findFirst
   */
  export type BmMaterialGrupoFioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupoFio to fetch.
     */
    where?: BmMaterialGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupoFios to fetch.
     */
    orderBy?: BmMaterialGrupoFioOrderByWithRelationInput | BmMaterialGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialGrupoFios.
     */
    cursor?: BmMaterialGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupoFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialGrupoFios.
     */
    distinct?: BmMaterialGrupoFioScalarFieldEnum | BmMaterialGrupoFioScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupoFio findFirstOrThrow
   */
  export type BmMaterialGrupoFioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupoFio to fetch.
     */
    where?: BmMaterialGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupoFios to fetch.
     */
    orderBy?: BmMaterialGrupoFioOrderByWithRelationInput | BmMaterialGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialGrupoFios.
     */
    cursor?: BmMaterialGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupoFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialGrupoFios.
     */
    distinct?: BmMaterialGrupoFioScalarFieldEnum | BmMaterialGrupoFioScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupoFio findMany
   */
  export type BmMaterialGrupoFioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialGrupoFios to fetch.
     */
    where?: BmMaterialGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialGrupoFios to fetch.
     */
    orderBy?: BmMaterialGrupoFioOrderByWithRelationInput | BmMaterialGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMaterialGrupoFios.
     */
    cursor?: BmMaterialGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialGrupoFios.
     */
    skip?: number
    distinct?: BmMaterialGrupoFioScalarFieldEnum | BmMaterialGrupoFioScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupoFio create
   */
  export type BmMaterialGrupoFioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMaterialGrupoFio.
     */
    data: XOR<BmMaterialGrupoFioCreateInput, BmMaterialGrupoFioUncheckedCreateInput>
  }

  /**
   * BmMaterialGrupoFio createMany
   */
  export type BmMaterialGrupoFioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMaterialGrupoFios.
     */
    data: BmMaterialGrupoFioCreateManyInput | BmMaterialGrupoFioCreateManyInput[]
  }

  /**
   * BmMaterialGrupoFio update
   */
  export type BmMaterialGrupoFioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMaterialGrupoFio.
     */
    data: XOR<BmMaterialGrupoFioUpdateInput, BmMaterialGrupoFioUncheckedUpdateInput>
    /**
     * Choose, which BmMaterialGrupoFio to update.
     */
    where: BmMaterialGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialGrupoFio updateMany
   */
  export type BmMaterialGrupoFioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMaterialGrupoFios.
     */
    data: XOR<BmMaterialGrupoFioUpdateManyMutationInput, BmMaterialGrupoFioUncheckedUpdateManyInput>
    /**
     * Filter which BmMaterialGrupoFios to update
     */
    where?: BmMaterialGrupoFioWhereInput
    /**
     * Limit how many BmMaterialGrupoFios to update.
     */
    limit?: number
  }

  /**
   * BmMaterialGrupoFio upsert
   */
  export type BmMaterialGrupoFioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMaterialGrupoFio to update in case it exists.
     */
    where: BmMaterialGrupoFioWhereUniqueInput
    /**
     * In case the BmMaterialGrupoFio found by the `where` argument doesn't exist, create a new BmMaterialGrupoFio with this data.
     */
    create: XOR<BmMaterialGrupoFioCreateInput, BmMaterialGrupoFioUncheckedCreateInput>
    /**
     * In case the BmMaterialGrupoFio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMaterialGrupoFioUpdateInput, BmMaterialGrupoFioUncheckedUpdateInput>
  }

  /**
   * BmMaterialGrupoFio delete
   */
  export type BmMaterialGrupoFioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
    /**
     * Filter which BmMaterialGrupoFio to delete.
     */
    where: BmMaterialGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialGrupoFio deleteMany
   */
  export type BmMaterialGrupoFioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialGrupoFios to delete
     */
    where?: BmMaterialGrupoFioWhereInput
    /**
     * Limit how many BmMaterialGrupoFios to delete.
     */
    limit?: number
  }

  /**
   * BmMaterialGrupoFio.BmMateriaisFio
   */
  export type BmMaterialGrupoFio$BmMateriaisFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    where?: BmMateriaisFioWhereInput
    orderBy?: BmMateriaisFioOrderByWithRelationInput | BmMateriaisFioOrderByWithRelationInput[]
    cursor?: BmMateriaisFioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMateriaisFioScalarFieldEnum | BmMateriaisFioScalarFieldEnum[]
  }

  /**
   * BmMaterialGrupoFio without action
   */
  export type BmMaterialGrupoFioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialGrupoFio
     */
    select?: BmMaterialGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialGrupoFio
     */
    omit?: BmMaterialGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialGrupoFioInclude<ExtArgs> | null
  }


  /**
   * Model BmMaterialSubGrupo
   */

  export type AggregateBmMaterialSubGrupo = {
    _count: BmMaterialSubGrupoCountAggregateOutputType | null
    _min: BmMaterialSubGrupoMinAggregateOutputType | null
    _max: BmMaterialSubGrupoMaxAggregateOutputType | null
  }

  export type BmMaterialSubGrupoMinAggregateOutputType = {
    subGrupo: string | null
    subGrupoDescricao: string | null
  }

  export type BmMaterialSubGrupoMaxAggregateOutputType = {
    subGrupo: string | null
    subGrupoDescricao: string | null
  }

  export type BmMaterialSubGrupoCountAggregateOutputType = {
    subGrupo: number
    subGrupoDescricao: number
    _all: number
  }


  export type BmMaterialSubGrupoMinAggregateInputType = {
    subGrupo?: true
    subGrupoDescricao?: true
  }

  export type BmMaterialSubGrupoMaxAggregateInputType = {
    subGrupo?: true
    subGrupoDescricao?: true
  }

  export type BmMaterialSubGrupoCountAggregateInputType = {
    subGrupo?: true
    subGrupoDescricao?: true
    _all?: true
  }

  export type BmMaterialSubGrupoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialSubGrupo to aggregate.
     */
    where?: BmMaterialSubGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupos to fetch.
     */
    orderBy?: BmMaterialSubGrupoOrderByWithRelationInput | BmMaterialSubGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMaterialSubGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMaterialSubGrupos
    **/
    _count?: true | BmMaterialSubGrupoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMaterialSubGrupoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMaterialSubGrupoMaxAggregateInputType
  }

  export type GetBmMaterialSubGrupoAggregateType<T extends BmMaterialSubGrupoAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMaterialSubGrupo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMaterialSubGrupo[P]>
      : GetScalarType<T[P], AggregateBmMaterialSubGrupo[P]>
  }




  export type BmMaterialSubGrupoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMaterialSubGrupoWhereInput
    orderBy?: BmMaterialSubGrupoOrderByWithAggregationInput | BmMaterialSubGrupoOrderByWithAggregationInput[]
    by: BmMaterialSubGrupoScalarFieldEnum[] | BmMaterialSubGrupoScalarFieldEnum
    having?: BmMaterialSubGrupoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMaterialSubGrupoCountAggregateInputType | true
    _min?: BmMaterialSubGrupoMinAggregateInputType
    _max?: BmMaterialSubGrupoMaxAggregateInputType
  }

  export type BmMaterialSubGrupoGroupByOutputType = {
    subGrupo: string
    subGrupoDescricao: string
    _count: BmMaterialSubGrupoCountAggregateOutputType | null
    _min: BmMaterialSubGrupoMinAggregateOutputType | null
    _max: BmMaterialSubGrupoMaxAggregateOutputType | null
  }

  type GetBmMaterialSubGrupoGroupByPayload<T extends BmMaterialSubGrupoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMaterialSubGrupoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMaterialSubGrupoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMaterialSubGrupoGroupByOutputType[P]>
            : GetScalarType<T[P], BmMaterialSubGrupoGroupByOutputType[P]>
        }
      >
    >


  export type BmMaterialSubGrupoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subGrupo?: boolean
    subGrupoDescricao?: boolean
    BmMateriais?: boolean | BmMaterialSubGrupo$BmMateriaisArgs<ExtArgs>
    _count?: boolean | BmMaterialSubGrupoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMaterialSubGrupo"]>



  export type BmMaterialSubGrupoSelectScalar = {
    subGrupo?: boolean
    subGrupoDescricao?: boolean
  }

  export type BmMaterialSubGrupoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subGrupo" | "subGrupoDescricao", ExtArgs["result"]["bmMaterialSubGrupo"]>
  export type BmMaterialSubGrupoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriais?: boolean | BmMaterialSubGrupo$BmMateriaisArgs<ExtArgs>
    _count?: boolean | BmMaterialSubGrupoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMaterialSubGrupoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMaterialSubGrupo"
    objects: {
      BmMateriais: Prisma.$BmMateriaisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subGrupo: string
      subGrupoDescricao: string
    }, ExtArgs["result"]["bmMaterialSubGrupo"]>
    composites: {}
  }

  type BmMaterialSubGrupoGetPayload<S extends boolean | null | undefined | BmMaterialSubGrupoDefaultArgs> = $Result.GetResult<Prisma.$BmMaterialSubGrupoPayload, S>

  type BmMaterialSubGrupoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMaterialSubGrupoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMaterialSubGrupoCountAggregateInputType | true
    }

  export interface BmMaterialSubGrupoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMaterialSubGrupo'], meta: { name: 'BmMaterialSubGrupo' } }
    /**
     * Find zero or one BmMaterialSubGrupo that matches the filter.
     * @param {BmMaterialSubGrupoFindUniqueArgs} args - Arguments to find a BmMaterialSubGrupo
     * @example
     * // Get one BmMaterialSubGrupo
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMaterialSubGrupoFindUniqueArgs>(args: SelectSubset<T, BmMaterialSubGrupoFindUniqueArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMaterialSubGrupo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMaterialSubGrupoFindUniqueOrThrowArgs} args - Arguments to find a BmMaterialSubGrupo
     * @example
     * // Get one BmMaterialSubGrupo
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMaterialSubGrupoFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMaterialSubGrupoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialSubGrupo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFindFirstArgs} args - Arguments to find a BmMaterialSubGrupo
     * @example
     * // Get one BmMaterialSubGrupo
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMaterialSubGrupoFindFirstArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFindFirstArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialSubGrupo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFindFirstOrThrowArgs} args - Arguments to find a BmMaterialSubGrupo
     * @example
     * // Get one BmMaterialSubGrupo
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMaterialSubGrupoFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMaterialSubGrupos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMaterialSubGrupos
     * const bmMaterialSubGrupos = await prisma.bmMaterialSubGrupo.findMany()
     * 
     * // Get first 10 BmMaterialSubGrupos
     * const bmMaterialSubGrupos = await prisma.bmMaterialSubGrupo.findMany({ take: 10 })
     * 
     * // Only select the `subGrupo`
     * const bmMaterialSubGrupoWithSubGrupoOnly = await prisma.bmMaterialSubGrupo.findMany({ select: { subGrupo: true } })
     * 
     */
    findMany<T extends BmMaterialSubGrupoFindManyArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMaterialSubGrupo.
     * @param {BmMaterialSubGrupoCreateArgs} args - Arguments to create a BmMaterialSubGrupo.
     * @example
     * // Create one BmMaterialSubGrupo
     * const BmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.create({
     *   data: {
     *     // ... data to create a BmMaterialSubGrupo
     *   }
     * })
     * 
     */
    create<T extends BmMaterialSubGrupoCreateArgs>(args: SelectSubset<T, BmMaterialSubGrupoCreateArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMaterialSubGrupos.
     * @param {BmMaterialSubGrupoCreateManyArgs} args - Arguments to create many BmMaterialSubGrupos.
     * @example
     * // Create many BmMaterialSubGrupos
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMaterialSubGrupoCreateManyArgs>(args?: SelectSubset<T, BmMaterialSubGrupoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMaterialSubGrupo.
     * @param {BmMaterialSubGrupoDeleteArgs} args - Arguments to delete one BmMaterialSubGrupo.
     * @example
     * // Delete one BmMaterialSubGrupo
     * const BmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.delete({
     *   where: {
     *     // ... filter to delete one BmMaterialSubGrupo
     *   }
     * })
     * 
     */
    delete<T extends BmMaterialSubGrupoDeleteArgs>(args: SelectSubset<T, BmMaterialSubGrupoDeleteArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMaterialSubGrupo.
     * @param {BmMaterialSubGrupoUpdateArgs} args - Arguments to update one BmMaterialSubGrupo.
     * @example
     * // Update one BmMaterialSubGrupo
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMaterialSubGrupoUpdateArgs>(args: SelectSubset<T, BmMaterialSubGrupoUpdateArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMaterialSubGrupos.
     * @param {BmMaterialSubGrupoDeleteManyArgs} args - Arguments to filter BmMaterialSubGrupos to delete.
     * @example
     * // Delete a few BmMaterialSubGrupos
     * const { count } = await prisma.bmMaterialSubGrupo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMaterialSubGrupoDeleteManyArgs>(args?: SelectSubset<T, BmMaterialSubGrupoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMaterialSubGrupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMaterialSubGrupos
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMaterialSubGrupoUpdateManyArgs>(args: SelectSubset<T, BmMaterialSubGrupoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMaterialSubGrupo.
     * @param {BmMaterialSubGrupoUpsertArgs} args - Arguments to update or create a BmMaterialSubGrupo.
     * @example
     * // Update or create a BmMaterialSubGrupo
     * const bmMaterialSubGrupo = await prisma.bmMaterialSubGrupo.upsert({
     *   create: {
     *     // ... data to create a BmMaterialSubGrupo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMaterialSubGrupo we want to update
     *   }
     * })
     */
    upsert<T extends BmMaterialSubGrupoUpsertArgs>(args: SelectSubset<T, BmMaterialSubGrupoUpsertArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMaterialSubGrupos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoCountArgs} args - Arguments to filter BmMaterialSubGrupos to count.
     * @example
     * // Count the number of BmMaterialSubGrupos
     * const count = await prisma.bmMaterialSubGrupo.count({
     *   where: {
     *     // ... the filter for the BmMaterialSubGrupos we want to count
     *   }
     * })
    **/
    count<T extends BmMaterialSubGrupoCountArgs>(
      args?: Subset<T, BmMaterialSubGrupoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMaterialSubGrupoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMaterialSubGrupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMaterialSubGrupoAggregateArgs>(args: Subset<T, BmMaterialSubGrupoAggregateArgs>): Prisma.PrismaPromise<GetBmMaterialSubGrupoAggregateType<T>>

    /**
     * Group by BmMaterialSubGrupo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMaterialSubGrupoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMaterialSubGrupoGroupByArgs['orderBy'] }
        : { orderBy?: BmMaterialSubGrupoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMaterialSubGrupoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMaterialSubGrupoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMaterialSubGrupo model
   */
  readonly fields: BmMaterialSubGrupoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMaterialSubGrupo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMaterialSubGrupoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMateriais<T extends BmMaterialSubGrupo$BmMateriaisArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialSubGrupo$BmMateriaisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMateriaisPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMaterialSubGrupo model
   */ 
  interface BmMaterialSubGrupoFieldRefs {
    readonly subGrupo: FieldRef<"BmMaterialSubGrupo", 'String'>
    readonly subGrupoDescricao: FieldRef<"BmMaterialSubGrupo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMaterialSubGrupo findUnique
   */
  export type BmMaterialSubGrupoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupo to fetch.
     */
    where: BmMaterialSubGrupoWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupo findUniqueOrThrow
   */
  export type BmMaterialSubGrupoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupo to fetch.
     */
    where: BmMaterialSubGrupoWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupo findFirst
   */
  export type BmMaterialSubGrupoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupo to fetch.
     */
    where?: BmMaterialSubGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupos to fetch.
     */
    orderBy?: BmMaterialSubGrupoOrderByWithRelationInput | BmMaterialSubGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialSubGrupos.
     */
    cursor?: BmMaterialSubGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialSubGrupos.
     */
    distinct?: BmMaterialSubGrupoScalarFieldEnum | BmMaterialSubGrupoScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupo findFirstOrThrow
   */
  export type BmMaterialSubGrupoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupo to fetch.
     */
    where?: BmMaterialSubGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupos to fetch.
     */
    orderBy?: BmMaterialSubGrupoOrderByWithRelationInput | BmMaterialSubGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialSubGrupos.
     */
    cursor?: BmMaterialSubGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialSubGrupos.
     */
    distinct?: BmMaterialSubGrupoScalarFieldEnum | BmMaterialSubGrupoScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupo findMany
   */
  export type BmMaterialSubGrupoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupos to fetch.
     */
    where?: BmMaterialSubGrupoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupos to fetch.
     */
    orderBy?: BmMaterialSubGrupoOrderByWithRelationInput | BmMaterialSubGrupoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMaterialSubGrupos.
     */
    cursor?: BmMaterialSubGrupoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupos.
     */
    skip?: number
    distinct?: BmMaterialSubGrupoScalarFieldEnum | BmMaterialSubGrupoScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupo create
   */
  export type BmMaterialSubGrupoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMaterialSubGrupo.
     */
    data: XOR<BmMaterialSubGrupoCreateInput, BmMaterialSubGrupoUncheckedCreateInput>
  }

  /**
   * BmMaterialSubGrupo createMany
   */
  export type BmMaterialSubGrupoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMaterialSubGrupos.
     */
    data: BmMaterialSubGrupoCreateManyInput | BmMaterialSubGrupoCreateManyInput[]
  }

  /**
   * BmMaterialSubGrupo update
   */
  export type BmMaterialSubGrupoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMaterialSubGrupo.
     */
    data: XOR<BmMaterialSubGrupoUpdateInput, BmMaterialSubGrupoUncheckedUpdateInput>
    /**
     * Choose, which BmMaterialSubGrupo to update.
     */
    where: BmMaterialSubGrupoWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupo updateMany
   */
  export type BmMaterialSubGrupoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMaterialSubGrupos.
     */
    data: XOR<BmMaterialSubGrupoUpdateManyMutationInput, BmMaterialSubGrupoUncheckedUpdateManyInput>
    /**
     * Filter which BmMaterialSubGrupos to update
     */
    where?: BmMaterialSubGrupoWhereInput
    /**
     * Limit how many BmMaterialSubGrupos to update.
     */
    limit?: number
  }

  /**
   * BmMaterialSubGrupo upsert
   */
  export type BmMaterialSubGrupoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMaterialSubGrupo to update in case it exists.
     */
    where: BmMaterialSubGrupoWhereUniqueInput
    /**
     * In case the BmMaterialSubGrupo found by the `where` argument doesn't exist, create a new BmMaterialSubGrupo with this data.
     */
    create: XOR<BmMaterialSubGrupoCreateInput, BmMaterialSubGrupoUncheckedCreateInput>
    /**
     * In case the BmMaterialSubGrupo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMaterialSubGrupoUpdateInput, BmMaterialSubGrupoUncheckedUpdateInput>
  }

  /**
   * BmMaterialSubGrupo delete
   */
  export type BmMaterialSubGrupoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
    /**
     * Filter which BmMaterialSubGrupo to delete.
     */
    where: BmMaterialSubGrupoWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupo deleteMany
   */
  export type BmMaterialSubGrupoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialSubGrupos to delete
     */
    where?: BmMaterialSubGrupoWhereInput
    /**
     * Limit how many BmMaterialSubGrupos to delete.
     */
    limit?: number
  }

  /**
   * BmMaterialSubGrupo.BmMateriais
   */
  export type BmMaterialSubGrupo$BmMateriaisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriais
     */
    select?: BmMateriaisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriais
     */
    omit?: BmMateriaisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisInclude<ExtArgs> | null
    where?: BmMateriaisWhereInput
    orderBy?: BmMateriaisOrderByWithRelationInput | BmMateriaisOrderByWithRelationInput[]
    cursor?: BmMateriaisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMateriaisScalarFieldEnum | BmMateriaisScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupo without action
   */
  export type BmMaterialSubGrupoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupo
     */
    select?: BmMaterialSubGrupoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupo
     */
    omit?: BmMaterialSubGrupoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoInclude<ExtArgs> | null
  }


  /**
   * Model BmMaterialSubGrupoFio
   */

  export type AggregateBmMaterialSubGrupoFio = {
    _count: BmMaterialSubGrupoFioCountAggregateOutputType | null
    _min: BmMaterialSubGrupoFioMinAggregateOutputType | null
    _max: BmMaterialSubGrupoFioMaxAggregateOutputType | null
  }

  export type BmMaterialSubGrupoFioMinAggregateOutputType = {
    subGrupo: string | null
    subGrupoDescricao: string | null
  }

  export type BmMaterialSubGrupoFioMaxAggregateOutputType = {
    subGrupo: string | null
    subGrupoDescricao: string | null
  }

  export type BmMaterialSubGrupoFioCountAggregateOutputType = {
    subGrupo: number
    subGrupoDescricao: number
    _all: number
  }


  export type BmMaterialSubGrupoFioMinAggregateInputType = {
    subGrupo?: true
    subGrupoDescricao?: true
  }

  export type BmMaterialSubGrupoFioMaxAggregateInputType = {
    subGrupo?: true
    subGrupoDescricao?: true
  }

  export type BmMaterialSubGrupoFioCountAggregateInputType = {
    subGrupo?: true
    subGrupoDescricao?: true
    _all?: true
  }

  export type BmMaterialSubGrupoFioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialSubGrupoFio to aggregate.
     */
    where?: BmMaterialSubGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupoFios to fetch.
     */
    orderBy?: BmMaterialSubGrupoFioOrderByWithRelationInput | BmMaterialSubGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMaterialSubGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupoFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMaterialSubGrupoFios
    **/
    _count?: true | BmMaterialSubGrupoFioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMaterialSubGrupoFioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMaterialSubGrupoFioMaxAggregateInputType
  }

  export type GetBmMaterialSubGrupoFioAggregateType<T extends BmMaterialSubGrupoFioAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMaterialSubGrupoFio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMaterialSubGrupoFio[P]>
      : GetScalarType<T[P], AggregateBmMaterialSubGrupoFio[P]>
  }




  export type BmMaterialSubGrupoFioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMaterialSubGrupoFioWhereInput
    orderBy?: BmMaterialSubGrupoFioOrderByWithAggregationInput | BmMaterialSubGrupoFioOrderByWithAggregationInput[]
    by: BmMaterialSubGrupoFioScalarFieldEnum[] | BmMaterialSubGrupoFioScalarFieldEnum
    having?: BmMaterialSubGrupoFioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMaterialSubGrupoFioCountAggregateInputType | true
    _min?: BmMaterialSubGrupoFioMinAggregateInputType
    _max?: BmMaterialSubGrupoFioMaxAggregateInputType
  }

  export type BmMaterialSubGrupoFioGroupByOutputType = {
    subGrupo: string
    subGrupoDescricao: string
    _count: BmMaterialSubGrupoFioCountAggregateOutputType | null
    _min: BmMaterialSubGrupoFioMinAggregateOutputType | null
    _max: BmMaterialSubGrupoFioMaxAggregateOutputType | null
  }

  type GetBmMaterialSubGrupoFioGroupByPayload<T extends BmMaterialSubGrupoFioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMaterialSubGrupoFioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMaterialSubGrupoFioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMaterialSubGrupoFioGroupByOutputType[P]>
            : GetScalarType<T[P], BmMaterialSubGrupoFioGroupByOutputType[P]>
        }
      >
    >


  export type BmMaterialSubGrupoFioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subGrupo?: boolean
    subGrupoDescricao?: boolean
    BmMateriaisFio?: boolean | BmMaterialSubGrupoFio$BmMateriaisFioArgs<ExtArgs>
    _count?: boolean | BmMaterialSubGrupoFioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMaterialSubGrupoFio"]>



  export type BmMaterialSubGrupoFioSelectScalar = {
    subGrupo?: boolean
    subGrupoDescricao?: boolean
  }

  export type BmMaterialSubGrupoFioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subGrupo" | "subGrupoDescricao", ExtArgs["result"]["bmMaterialSubGrupoFio"]>
  export type BmMaterialSubGrupoFioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMateriaisFio?: boolean | BmMaterialSubGrupoFio$BmMateriaisFioArgs<ExtArgs>
    _count?: boolean | BmMaterialSubGrupoFioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmMaterialSubGrupoFioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMaterialSubGrupoFio"
    objects: {
      BmMateriaisFio: Prisma.$BmMateriaisFioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      subGrupo: string
      subGrupoDescricao: string
    }, ExtArgs["result"]["bmMaterialSubGrupoFio"]>
    composites: {}
  }

  type BmMaterialSubGrupoFioGetPayload<S extends boolean | null | undefined | BmMaterialSubGrupoFioDefaultArgs> = $Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload, S>

  type BmMaterialSubGrupoFioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMaterialSubGrupoFioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMaterialSubGrupoFioCountAggregateInputType | true
    }

  export interface BmMaterialSubGrupoFioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMaterialSubGrupoFio'], meta: { name: 'BmMaterialSubGrupoFio' } }
    /**
     * Find zero or one BmMaterialSubGrupoFio that matches the filter.
     * @param {BmMaterialSubGrupoFioFindUniqueArgs} args - Arguments to find a BmMaterialSubGrupoFio
     * @example
     * // Get one BmMaterialSubGrupoFio
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMaterialSubGrupoFioFindUniqueArgs>(args: SelectSubset<T, BmMaterialSubGrupoFioFindUniqueArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMaterialSubGrupoFio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMaterialSubGrupoFioFindUniqueOrThrowArgs} args - Arguments to find a BmMaterialSubGrupoFio
     * @example
     * // Get one BmMaterialSubGrupoFio
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMaterialSubGrupoFioFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMaterialSubGrupoFioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialSubGrupoFio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFioFindFirstArgs} args - Arguments to find a BmMaterialSubGrupoFio
     * @example
     * // Get one BmMaterialSubGrupoFio
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMaterialSubGrupoFioFindFirstArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFioFindFirstArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMaterialSubGrupoFio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFioFindFirstOrThrowArgs} args - Arguments to find a BmMaterialSubGrupoFio
     * @example
     * // Get one BmMaterialSubGrupoFio
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMaterialSubGrupoFioFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFioFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMaterialSubGrupoFios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMaterialSubGrupoFios
     * const bmMaterialSubGrupoFios = await prisma.bmMaterialSubGrupoFio.findMany()
     * 
     * // Get first 10 BmMaterialSubGrupoFios
     * const bmMaterialSubGrupoFios = await prisma.bmMaterialSubGrupoFio.findMany({ take: 10 })
     * 
     * // Only select the `subGrupo`
     * const bmMaterialSubGrupoFioWithSubGrupoOnly = await prisma.bmMaterialSubGrupoFio.findMany({ select: { subGrupo: true } })
     * 
     */
    findMany<T extends BmMaterialSubGrupoFioFindManyArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMaterialSubGrupoFio.
     * @param {BmMaterialSubGrupoFioCreateArgs} args - Arguments to create a BmMaterialSubGrupoFio.
     * @example
     * // Create one BmMaterialSubGrupoFio
     * const BmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.create({
     *   data: {
     *     // ... data to create a BmMaterialSubGrupoFio
     *   }
     * })
     * 
     */
    create<T extends BmMaterialSubGrupoFioCreateArgs>(args: SelectSubset<T, BmMaterialSubGrupoFioCreateArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMaterialSubGrupoFios.
     * @param {BmMaterialSubGrupoFioCreateManyArgs} args - Arguments to create many BmMaterialSubGrupoFios.
     * @example
     * // Create many BmMaterialSubGrupoFios
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMaterialSubGrupoFioCreateManyArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMaterialSubGrupoFio.
     * @param {BmMaterialSubGrupoFioDeleteArgs} args - Arguments to delete one BmMaterialSubGrupoFio.
     * @example
     * // Delete one BmMaterialSubGrupoFio
     * const BmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.delete({
     *   where: {
     *     // ... filter to delete one BmMaterialSubGrupoFio
     *   }
     * })
     * 
     */
    delete<T extends BmMaterialSubGrupoFioDeleteArgs>(args: SelectSubset<T, BmMaterialSubGrupoFioDeleteArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMaterialSubGrupoFio.
     * @param {BmMaterialSubGrupoFioUpdateArgs} args - Arguments to update one BmMaterialSubGrupoFio.
     * @example
     * // Update one BmMaterialSubGrupoFio
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMaterialSubGrupoFioUpdateArgs>(args: SelectSubset<T, BmMaterialSubGrupoFioUpdateArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMaterialSubGrupoFios.
     * @param {BmMaterialSubGrupoFioDeleteManyArgs} args - Arguments to filter BmMaterialSubGrupoFios to delete.
     * @example
     * // Delete a few BmMaterialSubGrupoFios
     * const { count } = await prisma.bmMaterialSubGrupoFio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMaterialSubGrupoFioDeleteManyArgs>(args?: SelectSubset<T, BmMaterialSubGrupoFioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMaterialSubGrupoFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMaterialSubGrupoFios
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMaterialSubGrupoFioUpdateManyArgs>(args: SelectSubset<T, BmMaterialSubGrupoFioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMaterialSubGrupoFio.
     * @param {BmMaterialSubGrupoFioUpsertArgs} args - Arguments to update or create a BmMaterialSubGrupoFio.
     * @example
     * // Update or create a BmMaterialSubGrupoFio
     * const bmMaterialSubGrupoFio = await prisma.bmMaterialSubGrupoFio.upsert({
     *   create: {
     *     // ... data to create a BmMaterialSubGrupoFio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMaterialSubGrupoFio we want to update
     *   }
     * })
     */
    upsert<T extends BmMaterialSubGrupoFioUpsertArgs>(args: SelectSubset<T, BmMaterialSubGrupoFioUpsertArgs<ExtArgs>>): Prisma__BmMaterialSubGrupoFioClient<$Result.GetResult<Prisma.$BmMaterialSubGrupoFioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMaterialSubGrupoFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFioCountArgs} args - Arguments to filter BmMaterialSubGrupoFios to count.
     * @example
     * // Count the number of BmMaterialSubGrupoFios
     * const count = await prisma.bmMaterialSubGrupoFio.count({
     *   where: {
     *     // ... the filter for the BmMaterialSubGrupoFios we want to count
     *   }
     * })
    **/
    count<T extends BmMaterialSubGrupoFioCountArgs>(
      args?: Subset<T, BmMaterialSubGrupoFioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMaterialSubGrupoFioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMaterialSubGrupoFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMaterialSubGrupoFioAggregateArgs>(args: Subset<T, BmMaterialSubGrupoFioAggregateArgs>): Prisma.PrismaPromise<GetBmMaterialSubGrupoFioAggregateType<T>>

    /**
     * Group by BmMaterialSubGrupoFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMaterialSubGrupoFioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMaterialSubGrupoFioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMaterialSubGrupoFioGroupByArgs['orderBy'] }
        : { orderBy?: BmMaterialSubGrupoFioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMaterialSubGrupoFioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMaterialSubGrupoFioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMaterialSubGrupoFio model
   */
  readonly fields: BmMaterialSubGrupoFioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMaterialSubGrupoFio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMaterialSubGrupoFioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMateriaisFio<T extends BmMaterialSubGrupoFio$BmMateriaisFioArgs<ExtArgs> = {}>(args?: Subset<T, BmMaterialSubGrupoFio$BmMateriaisFioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMateriaisFioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMaterialSubGrupoFio model
   */ 
  interface BmMaterialSubGrupoFioFieldRefs {
    readonly subGrupo: FieldRef<"BmMaterialSubGrupoFio", 'String'>
    readonly subGrupoDescricao: FieldRef<"BmMaterialSubGrupoFio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMaterialSubGrupoFio findUnique
   */
  export type BmMaterialSubGrupoFioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupoFio to fetch.
     */
    where: BmMaterialSubGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupoFio findUniqueOrThrow
   */
  export type BmMaterialSubGrupoFioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupoFio to fetch.
     */
    where: BmMaterialSubGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupoFio findFirst
   */
  export type BmMaterialSubGrupoFioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupoFio to fetch.
     */
    where?: BmMaterialSubGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupoFios to fetch.
     */
    orderBy?: BmMaterialSubGrupoFioOrderByWithRelationInput | BmMaterialSubGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialSubGrupoFios.
     */
    cursor?: BmMaterialSubGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupoFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialSubGrupoFios.
     */
    distinct?: BmMaterialSubGrupoFioScalarFieldEnum | BmMaterialSubGrupoFioScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupoFio findFirstOrThrow
   */
  export type BmMaterialSubGrupoFioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupoFio to fetch.
     */
    where?: BmMaterialSubGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupoFios to fetch.
     */
    orderBy?: BmMaterialSubGrupoFioOrderByWithRelationInput | BmMaterialSubGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMaterialSubGrupoFios.
     */
    cursor?: BmMaterialSubGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupoFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMaterialSubGrupoFios.
     */
    distinct?: BmMaterialSubGrupoFioScalarFieldEnum | BmMaterialSubGrupoFioScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupoFio findMany
   */
  export type BmMaterialSubGrupoFioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * Filter, which BmMaterialSubGrupoFios to fetch.
     */
    where?: BmMaterialSubGrupoFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMaterialSubGrupoFios to fetch.
     */
    orderBy?: BmMaterialSubGrupoFioOrderByWithRelationInput | BmMaterialSubGrupoFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMaterialSubGrupoFios.
     */
    cursor?: BmMaterialSubGrupoFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMaterialSubGrupoFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMaterialSubGrupoFios.
     */
    skip?: number
    distinct?: BmMaterialSubGrupoFioScalarFieldEnum | BmMaterialSubGrupoFioScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupoFio create
   */
  export type BmMaterialSubGrupoFioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMaterialSubGrupoFio.
     */
    data: XOR<BmMaterialSubGrupoFioCreateInput, BmMaterialSubGrupoFioUncheckedCreateInput>
  }

  /**
   * BmMaterialSubGrupoFio createMany
   */
  export type BmMaterialSubGrupoFioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMaterialSubGrupoFios.
     */
    data: BmMaterialSubGrupoFioCreateManyInput | BmMaterialSubGrupoFioCreateManyInput[]
  }

  /**
   * BmMaterialSubGrupoFio update
   */
  export type BmMaterialSubGrupoFioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMaterialSubGrupoFio.
     */
    data: XOR<BmMaterialSubGrupoFioUpdateInput, BmMaterialSubGrupoFioUncheckedUpdateInput>
    /**
     * Choose, which BmMaterialSubGrupoFio to update.
     */
    where: BmMaterialSubGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupoFio updateMany
   */
  export type BmMaterialSubGrupoFioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMaterialSubGrupoFios.
     */
    data: XOR<BmMaterialSubGrupoFioUpdateManyMutationInput, BmMaterialSubGrupoFioUncheckedUpdateManyInput>
    /**
     * Filter which BmMaterialSubGrupoFios to update
     */
    where?: BmMaterialSubGrupoFioWhereInput
    /**
     * Limit how many BmMaterialSubGrupoFios to update.
     */
    limit?: number
  }

  /**
   * BmMaterialSubGrupoFio upsert
   */
  export type BmMaterialSubGrupoFioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMaterialSubGrupoFio to update in case it exists.
     */
    where: BmMaterialSubGrupoFioWhereUniqueInput
    /**
     * In case the BmMaterialSubGrupoFio found by the `where` argument doesn't exist, create a new BmMaterialSubGrupoFio with this data.
     */
    create: XOR<BmMaterialSubGrupoFioCreateInput, BmMaterialSubGrupoFioUncheckedCreateInput>
    /**
     * In case the BmMaterialSubGrupoFio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMaterialSubGrupoFioUpdateInput, BmMaterialSubGrupoFioUncheckedUpdateInput>
  }

  /**
   * BmMaterialSubGrupoFio delete
   */
  export type BmMaterialSubGrupoFioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
    /**
     * Filter which BmMaterialSubGrupoFio to delete.
     */
    where: BmMaterialSubGrupoFioWhereUniqueInput
  }

  /**
   * BmMaterialSubGrupoFio deleteMany
   */
  export type BmMaterialSubGrupoFioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMaterialSubGrupoFios to delete
     */
    where?: BmMaterialSubGrupoFioWhereInput
    /**
     * Limit how many BmMaterialSubGrupoFios to delete.
     */
    limit?: number
  }

  /**
   * BmMaterialSubGrupoFio.BmMateriaisFio
   */
  export type BmMaterialSubGrupoFio$BmMateriaisFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMateriaisFio
     */
    select?: BmMateriaisFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMateriaisFio
     */
    omit?: BmMateriaisFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMateriaisFioInclude<ExtArgs> | null
    where?: BmMateriaisFioWhereInput
    orderBy?: BmMateriaisFioOrderByWithRelationInput | BmMateriaisFioOrderByWithRelationInput[]
    cursor?: BmMateriaisFioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMateriaisFioScalarFieldEnum | BmMateriaisFioScalarFieldEnum[]
  }

  /**
   * BmMaterialSubGrupoFio without action
   */
  export type BmMaterialSubGrupoFioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMaterialSubGrupoFio
     */
    select?: BmMaterialSubGrupoFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMaterialSubGrupoFio
     */
    omit?: BmMaterialSubGrupoFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMaterialSubGrupoFioInclude<ExtArgs> | null
  }


  /**
   * Model BmMovimentosLotes
   */

  export type AggregateBmMovimentosLotes = {
    _count: BmMovimentosLotesCountAggregateOutputType | null
    _avg: BmMovimentosLotesAvgAggregateOutputType | null
    _sum: BmMovimentosLotesSumAggregateOutputType | null
    _min: BmMovimentosLotesMinAggregateOutputType | null
    _max: BmMovimentosLotesMaxAggregateOutputType | null
  }

  export type BmMovimentosLotesAvgAggregateOutputType = {
    op: number | null
    nMovimento: number | null
    idTipo: Decimal | null
    qtt: Decimal | null
  }

  export type BmMovimentosLotesSumAggregateOutputType = {
    op: number | null
    nMovimento: number | null
    idTipo: Decimal | null
    qtt: Decimal | null
  }

  export type BmMovimentosLotesMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    op: number | null
    idBmMovimentosLote: string | null
    idMovimento: string | null
    nMovimento: number | null
    nome: string | null
    idTipo: Decimal | null
    tipo: string | null
    qtt: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMovimentosLotesMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    op: number | null
    idBmMovimentosLote: string | null
    idMovimento: string | null
    nMovimento: number | null
    nome: string | null
    idTipo: Decimal | null
    tipo: string | null
    qtt: Decimal | null
    unidade: string | null
    lote: string | null
  }

  export type BmMovimentosLotesCountAggregateOutputType = {
    idBm: number
    ref: number
    op: number
    idBmMovimentosLote: number
    idMovimento: number
    nMovimento: number
    nome: number
    idTipo: number
    tipo: number
    qtt: number
    unidade: number
    lote: number
    _all: number
  }


  export type BmMovimentosLotesAvgAggregateInputType = {
    op?: true
    nMovimento?: true
    idTipo?: true
    qtt?: true
  }

  export type BmMovimentosLotesSumAggregateInputType = {
    op?: true
    nMovimento?: true
    idTipo?: true
    qtt?: true
  }

  export type BmMovimentosLotesMinAggregateInputType = {
    idBm?: true
    ref?: true
    op?: true
    idBmMovimentosLote?: true
    idMovimento?: true
    nMovimento?: true
    nome?: true
    idTipo?: true
    tipo?: true
    qtt?: true
    unidade?: true
    lote?: true
  }

  export type BmMovimentosLotesMaxAggregateInputType = {
    idBm?: true
    ref?: true
    op?: true
    idBmMovimentosLote?: true
    idMovimento?: true
    nMovimento?: true
    nome?: true
    idTipo?: true
    tipo?: true
    qtt?: true
    unidade?: true
    lote?: true
  }

  export type BmMovimentosLotesCountAggregateInputType = {
    idBm?: true
    ref?: true
    op?: true
    idBmMovimentosLote?: true
    idMovimento?: true
    nMovimento?: true
    nome?: true
    idTipo?: true
    tipo?: true
    qtt?: true
    unidade?: true
    lote?: true
    _all?: true
  }

  export type BmMovimentosLotesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMovimentosLotes to aggregate.
     */
    where?: BmMovimentosLotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMovimentosLotes to fetch.
     */
    orderBy?: BmMovimentosLotesOrderByWithRelationInput | BmMovimentosLotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmMovimentosLotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMovimentosLotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMovimentosLotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmMovimentosLotes
    **/
    _count?: true | BmMovimentosLotesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmMovimentosLotesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmMovimentosLotesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmMovimentosLotesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmMovimentosLotesMaxAggregateInputType
  }

  export type GetBmMovimentosLotesAggregateType<T extends BmMovimentosLotesAggregateArgs> = {
        [P in keyof T & keyof AggregateBmMovimentosLotes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmMovimentosLotes[P]>
      : GetScalarType<T[P], AggregateBmMovimentosLotes[P]>
  }




  export type BmMovimentosLotesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmMovimentosLotesWhereInput
    orderBy?: BmMovimentosLotesOrderByWithAggregationInput | BmMovimentosLotesOrderByWithAggregationInput[]
    by: BmMovimentosLotesScalarFieldEnum[] | BmMovimentosLotesScalarFieldEnum
    having?: BmMovimentosLotesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmMovimentosLotesCountAggregateInputType | true
    _avg?: BmMovimentosLotesAvgAggregateInputType
    _sum?: BmMovimentosLotesSumAggregateInputType
    _min?: BmMovimentosLotesMinAggregateInputType
    _max?: BmMovimentosLotesMaxAggregateInputType
  }

  export type BmMovimentosLotesGroupByOutputType = {
    idBm: string
    ref: string
    op: number
    idBmMovimentosLote: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal
    tipo: string
    qtt: Decimal
    unidade: string
    lote: string
    _count: BmMovimentosLotesCountAggregateOutputType | null
    _avg: BmMovimentosLotesAvgAggregateOutputType | null
    _sum: BmMovimentosLotesSumAggregateOutputType | null
    _min: BmMovimentosLotesMinAggregateOutputType | null
    _max: BmMovimentosLotesMaxAggregateOutputType | null
  }

  type GetBmMovimentosLotesGroupByPayload<T extends BmMovimentosLotesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmMovimentosLotesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmMovimentosLotesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmMovimentosLotesGroupByOutputType[P]>
            : GetScalarType<T[P], BmMovimentosLotesGroupByOutputType[P]>
        }
      >
    >


  export type BmMovimentosLotesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    op?: boolean
    idBmMovimentosLote?: boolean
    idMovimento?: boolean
    nMovimento?: boolean
    nome?: boolean
    idTipo?: boolean
    tipo?: boolean
    qtt?: boolean
    unidade?: boolean
    lote?: boolean
    BmOpsPorMalha?: boolean | BmOpsPorMalhaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmMovimentosLotes"]>



  export type BmMovimentosLotesSelectScalar = {
    idBm?: boolean
    ref?: boolean
    op?: boolean
    idBmMovimentosLote?: boolean
    idMovimento?: boolean
    nMovimento?: boolean
    nome?: boolean
    idTipo?: boolean
    tipo?: boolean
    qtt?: boolean
    unidade?: boolean
    lote?: boolean
  }

  export type BmMovimentosLotesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "op" | "idBmMovimentosLote" | "idMovimento" | "nMovimento" | "nome" | "idTipo" | "tipo" | "qtt" | "unidade" | "lote", ExtArgs["result"]["bmMovimentosLotes"]>
  export type BmMovimentosLotesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmOpsPorMalha?: boolean | BmOpsPorMalhaDefaultArgs<ExtArgs>
  }

  export type $BmMovimentosLotesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmMovimentosLotes"
    objects: {
      BmOpsPorMalha: Prisma.$BmOpsPorMalhaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      op: number
      idBmMovimentosLote: string
      idMovimento: string
      nMovimento: number
      nome: string
      idTipo: Prisma.Decimal
      tipo: string
      qtt: Prisma.Decimal
      unidade: string
      lote: string
    }, ExtArgs["result"]["bmMovimentosLotes"]>
    composites: {}
  }

  type BmMovimentosLotesGetPayload<S extends boolean | null | undefined | BmMovimentosLotesDefaultArgs> = $Result.GetResult<Prisma.$BmMovimentosLotesPayload, S>

  type BmMovimentosLotesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmMovimentosLotesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmMovimentosLotesCountAggregateInputType | true
    }

  export interface BmMovimentosLotesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmMovimentosLotes'], meta: { name: 'BmMovimentosLotes' } }
    /**
     * Find zero or one BmMovimentosLotes that matches the filter.
     * @param {BmMovimentosLotesFindUniqueArgs} args - Arguments to find a BmMovimentosLotes
     * @example
     * // Get one BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmMovimentosLotesFindUniqueArgs>(args: SelectSubset<T, BmMovimentosLotesFindUniqueArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmMovimentosLotes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmMovimentosLotesFindUniqueOrThrowArgs} args - Arguments to find a BmMovimentosLotes
     * @example
     * // Get one BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmMovimentosLotesFindUniqueOrThrowArgs>(args: SelectSubset<T, BmMovimentosLotesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmMovimentosLotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMovimentosLotesFindFirstArgs} args - Arguments to find a BmMovimentosLotes
     * @example
     * // Get one BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmMovimentosLotesFindFirstArgs>(args?: SelectSubset<T, BmMovimentosLotesFindFirstArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmMovimentosLotes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMovimentosLotesFindFirstOrThrowArgs} args - Arguments to find a BmMovimentosLotes
     * @example
     * // Get one BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmMovimentosLotesFindFirstOrThrowArgs>(args?: SelectSubset<T, BmMovimentosLotesFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmMovimentosLotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMovimentosLotesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.findMany()
     * 
     * // Get first 10 BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmMovimentosLotesWithIdBmOnly = await prisma.bmMovimentosLotes.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmMovimentosLotesFindManyArgs>(args?: SelectSubset<T, BmMovimentosLotesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmMovimentosLotes.
     * @param {BmMovimentosLotesCreateArgs} args - Arguments to create a BmMovimentosLotes.
     * @example
     * // Create one BmMovimentosLotes
     * const BmMovimentosLotes = await prisma.bmMovimentosLotes.create({
     *   data: {
     *     // ... data to create a BmMovimentosLotes
     *   }
     * })
     * 
     */
    create<T extends BmMovimentosLotesCreateArgs>(args: SelectSubset<T, BmMovimentosLotesCreateArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmMovimentosLotes.
     * @param {BmMovimentosLotesCreateManyArgs} args - Arguments to create many BmMovimentosLotes.
     * @example
     * // Create many BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmMovimentosLotesCreateManyArgs>(args?: SelectSubset<T, BmMovimentosLotesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmMovimentosLotes.
     * @param {BmMovimentosLotesDeleteArgs} args - Arguments to delete one BmMovimentosLotes.
     * @example
     * // Delete one BmMovimentosLotes
     * const BmMovimentosLotes = await prisma.bmMovimentosLotes.delete({
     *   where: {
     *     // ... filter to delete one BmMovimentosLotes
     *   }
     * })
     * 
     */
    delete<T extends BmMovimentosLotesDeleteArgs>(args: SelectSubset<T, BmMovimentosLotesDeleteArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmMovimentosLotes.
     * @param {BmMovimentosLotesUpdateArgs} args - Arguments to update one BmMovimentosLotes.
     * @example
     * // Update one BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmMovimentosLotesUpdateArgs>(args: SelectSubset<T, BmMovimentosLotesUpdateArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmMovimentosLotes.
     * @param {BmMovimentosLotesDeleteManyArgs} args - Arguments to filter BmMovimentosLotes to delete.
     * @example
     * // Delete a few BmMovimentosLotes
     * const { count } = await prisma.bmMovimentosLotes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmMovimentosLotesDeleteManyArgs>(args?: SelectSubset<T, BmMovimentosLotesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmMovimentosLotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMovimentosLotesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmMovimentosLotesUpdateManyArgs>(args: SelectSubset<T, BmMovimentosLotesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmMovimentosLotes.
     * @param {BmMovimentosLotesUpsertArgs} args - Arguments to update or create a BmMovimentosLotes.
     * @example
     * // Update or create a BmMovimentosLotes
     * const bmMovimentosLotes = await prisma.bmMovimentosLotes.upsert({
     *   create: {
     *     // ... data to create a BmMovimentosLotes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmMovimentosLotes we want to update
     *   }
     * })
     */
    upsert<T extends BmMovimentosLotesUpsertArgs>(args: SelectSubset<T, BmMovimentosLotesUpsertArgs<ExtArgs>>): Prisma__BmMovimentosLotesClient<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmMovimentosLotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMovimentosLotesCountArgs} args - Arguments to filter BmMovimentosLotes to count.
     * @example
     * // Count the number of BmMovimentosLotes
     * const count = await prisma.bmMovimentosLotes.count({
     *   where: {
     *     // ... the filter for the BmMovimentosLotes we want to count
     *   }
     * })
    **/
    count<T extends BmMovimentosLotesCountArgs>(
      args?: Subset<T, BmMovimentosLotesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmMovimentosLotesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmMovimentosLotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMovimentosLotesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmMovimentosLotesAggregateArgs>(args: Subset<T, BmMovimentosLotesAggregateArgs>): Prisma.PrismaPromise<GetBmMovimentosLotesAggregateType<T>>

    /**
     * Group by BmMovimentosLotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmMovimentosLotesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmMovimentosLotesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmMovimentosLotesGroupByArgs['orderBy'] }
        : { orderBy?: BmMovimentosLotesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmMovimentosLotesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmMovimentosLotesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmMovimentosLotes model
   */
  readonly fields: BmMovimentosLotesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmMovimentosLotes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmMovimentosLotesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmOpsPorMalha<T extends BmOpsPorMalhaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmOpsPorMalhaDefaultArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmMovimentosLotes model
   */ 
  interface BmMovimentosLotesFieldRefs {
    readonly idBm: FieldRef<"BmMovimentosLotes", 'String'>
    readonly ref: FieldRef<"BmMovimentosLotes", 'String'>
    readonly op: FieldRef<"BmMovimentosLotes", 'Int'>
    readonly idBmMovimentosLote: FieldRef<"BmMovimentosLotes", 'String'>
    readonly idMovimento: FieldRef<"BmMovimentosLotes", 'String'>
    readonly nMovimento: FieldRef<"BmMovimentosLotes", 'Int'>
    readonly nome: FieldRef<"BmMovimentosLotes", 'String'>
    readonly idTipo: FieldRef<"BmMovimentosLotes", 'Decimal'>
    readonly tipo: FieldRef<"BmMovimentosLotes", 'String'>
    readonly qtt: FieldRef<"BmMovimentosLotes", 'Decimal'>
    readonly unidade: FieldRef<"BmMovimentosLotes", 'String'>
    readonly lote: FieldRef<"BmMovimentosLotes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmMovimentosLotes findUnique
   */
  export type BmMovimentosLotesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * Filter, which BmMovimentosLotes to fetch.
     */
    where: BmMovimentosLotesWhereUniqueInput
  }

  /**
   * BmMovimentosLotes findUniqueOrThrow
   */
  export type BmMovimentosLotesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * Filter, which BmMovimentosLotes to fetch.
     */
    where: BmMovimentosLotesWhereUniqueInput
  }

  /**
   * BmMovimentosLotes findFirst
   */
  export type BmMovimentosLotesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * Filter, which BmMovimentosLotes to fetch.
     */
    where?: BmMovimentosLotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMovimentosLotes to fetch.
     */
    orderBy?: BmMovimentosLotesOrderByWithRelationInput | BmMovimentosLotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMovimentosLotes.
     */
    cursor?: BmMovimentosLotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMovimentosLotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMovimentosLotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMovimentosLotes.
     */
    distinct?: BmMovimentosLotesScalarFieldEnum | BmMovimentosLotesScalarFieldEnum[]
  }

  /**
   * BmMovimentosLotes findFirstOrThrow
   */
  export type BmMovimentosLotesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * Filter, which BmMovimentosLotes to fetch.
     */
    where?: BmMovimentosLotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMovimentosLotes to fetch.
     */
    orderBy?: BmMovimentosLotesOrderByWithRelationInput | BmMovimentosLotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmMovimentosLotes.
     */
    cursor?: BmMovimentosLotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMovimentosLotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMovimentosLotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmMovimentosLotes.
     */
    distinct?: BmMovimentosLotesScalarFieldEnum | BmMovimentosLotesScalarFieldEnum[]
  }

  /**
   * BmMovimentosLotes findMany
   */
  export type BmMovimentosLotesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * Filter, which BmMovimentosLotes to fetch.
     */
    where?: BmMovimentosLotesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmMovimentosLotes to fetch.
     */
    orderBy?: BmMovimentosLotesOrderByWithRelationInput | BmMovimentosLotesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmMovimentosLotes.
     */
    cursor?: BmMovimentosLotesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmMovimentosLotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmMovimentosLotes.
     */
    skip?: number
    distinct?: BmMovimentosLotesScalarFieldEnum | BmMovimentosLotesScalarFieldEnum[]
  }

  /**
   * BmMovimentosLotes create
   */
  export type BmMovimentosLotesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * The data needed to create a BmMovimentosLotes.
     */
    data: XOR<BmMovimentosLotesCreateInput, BmMovimentosLotesUncheckedCreateInput>
  }

  /**
   * BmMovimentosLotes createMany
   */
  export type BmMovimentosLotesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmMovimentosLotes.
     */
    data: BmMovimentosLotesCreateManyInput | BmMovimentosLotesCreateManyInput[]
  }

  /**
   * BmMovimentosLotes update
   */
  export type BmMovimentosLotesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * The data needed to update a BmMovimentosLotes.
     */
    data: XOR<BmMovimentosLotesUpdateInput, BmMovimentosLotesUncheckedUpdateInput>
    /**
     * Choose, which BmMovimentosLotes to update.
     */
    where: BmMovimentosLotesWhereUniqueInput
  }

  /**
   * BmMovimentosLotes updateMany
   */
  export type BmMovimentosLotesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmMovimentosLotes.
     */
    data: XOR<BmMovimentosLotesUpdateManyMutationInput, BmMovimentosLotesUncheckedUpdateManyInput>
    /**
     * Filter which BmMovimentosLotes to update
     */
    where?: BmMovimentosLotesWhereInput
    /**
     * Limit how many BmMovimentosLotes to update.
     */
    limit?: number
  }

  /**
   * BmMovimentosLotes upsert
   */
  export type BmMovimentosLotesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * The filter to search for the BmMovimentosLotes to update in case it exists.
     */
    where: BmMovimentosLotesWhereUniqueInput
    /**
     * In case the BmMovimentosLotes found by the `where` argument doesn't exist, create a new BmMovimentosLotes with this data.
     */
    create: XOR<BmMovimentosLotesCreateInput, BmMovimentosLotesUncheckedCreateInput>
    /**
     * In case the BmMovimentosLotes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmMovimentosLotesUpdateInput, BmMovimentosLotesUncheckedUpdateInput>
  }

  /**
   * BmMovimentosLotes delete
   */
  export type BmMovimentosLotesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    /**
     * Filter which BmMovimentosLotes to delete.
     */
    where: BmMovimentosLotesWhereUniqueInput
  }

  /**
   * BmMovimentosLotes deleteMany
   */
  export type BmMovimentosLotesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmMovimentosLotes to delete
     */
    where?: BmMovimentosLotesWhereInput
    /**
     * Limit how many BmMovimentosLotes to delete.
     */
    limit?: number
  }

  /**
   * BmMovimentosLotes without action
   */
  export type BmMovimentosLotesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
  }


  /**
   * Model BmOp
   */

  export type AggregateBmOp = {
    _count: BmOpCountAggregateOutputType | null
    _avg: BmOpAvgAggregateOutputType | null
    _sum: BmOpSumAggregateOutputType | null
    _min: BmOpMinAggregateOutputType | null
    _max: BmOpMaxAggregateOutputType | null
  }

  export type BmOpAvgAggregateOutputType = {
    op: number | null
  }

  export type BmOpSumAggregateOutputType = {
    op: number | null
  }

  export type BmOpMinAggregateOutputType = {
    idBm: string | null
    op: number | null
    CreatedAt: Date | null
    foto: string | null
  }

  export type BmOpMaxAggregateOutputType = {
    idBm: string | null
    op: number | null
    CreatedAt: Date | null
    foto: string | null
  }

  export type BmOpCountAggregateOutputType = {
    idBm: number
    op: number
    CreatedAt: number
    foto: number
    _all: number
  }


  export type BmOpAvgAggregateInputType = {
    op?: true
  }

  export type BmOpSumAggregateInputType = {
    op?: true
  }

  export type BmOpMinAggregateInputType = {
    idBm?: true
    op?: true
    CreatedAt?: true
    foto?: true
  }

  export type BmOpMaxAggregateInputType = {
    idBm?: true
    op?: true
    CreatedAt?: true
    foto?: true
  }

  export type BmOpCountAggregateInputType = {
    idBm?: true
    op?: true
    CreatedAt?: true
    foto?: true
    _all?: true
  }

  export type BmOpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOp to aggregate.
     */
    where?: BmOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOps to fetch.
     */
    orderBy?: BmOpOrderByWithRelationInput | BmOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmOps
    **/
    _count?: true | BmOpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmOpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmOpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmOpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmOpMaxAggregateInputType
  }

  export type GetBmOpAggregateType<T extends BmOpAggregateArgs> = {
        [P in keyof T & keyof AggregateBmOp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmOp[P]>
      : GetScalarType<T[P], AggregateBmOp[P]>
  }




  export type BmOpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpWhereInput
    orderBy?: BmOpOrderByWithAggregationInput | BmOpOrderByWithAggregationInput[]
    by: BmOpScalarFieldEnum[] | BmOpScalarFieldEnum
    having?: BmOpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmOpCountAggregateInputType | true
    _avg?: BmOpAvgAggregateInputType
    _sum?: BmOpSumAggregateInputType
    _min?: BmOpMinAggregateInputType
    _max?: BmOpMaxAggregateInputType
  }

  export type BmOpGroupByOutputType = {
    idBm: string
    op: number
    CreatedAt: Date
    foto: string
    _count: BmOpCountAggregateOutputType | null
    _avg: BmOpAvgAggregateOutputType | null
    _sum: BmOpSumAggregateOutputType | null
    _min: BmOpMinAggregateOutputType | null
    _max: BmOpMaxAggregateOutputType | null
  }

  type GetBmOpGroupByPayload<T extends BmOpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmOpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmOpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmOpGroupByOutputType[P]>
            : GetScalarType<T[P], BmOpGroupByOutputType[P]>
        }
      >
    >


  export type BmOpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    op?: boolean
    CreatedAt?: boolean
    foto?: boolean
    Bm?: boolean | BmDefaultArgs<ExtArgs>
    BmOpFaturado?: boolean | BmOp$BmOpFaturadoArgs<ExtArgs>
    BmOpsPorMalha?: boolean | BmOp$BmOpsPorMalhaArgs<ExtArgs>
    _count?: boolean | BmOpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmOp"]>



  export type BmOpSelectScalar = {
    idBm?: boolean
    op?: boolean
    CreatedAt?: boolean
    foto?: boolean
  }

  export type BmOpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "op" | "CreatedAt" | "foto", ExtArgs["result"]["bmOp"]>
  export type BmOpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bm?: boolean | BmDefaultArgs<ExtArgs>
    BmOpFaturado?: boolean | BmOp$BmOpFaturadoArgs<ExtArgs>
    BmOpsPorMalha?: boolean | BmOp$BmOpsPorMalhaArgs<ExtArgs>
    _count?: boolean | BmOpCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmOpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmOp"
    objects: {
      Bm: Prisma.$BmPayload<ExtArgs>
      BmOpFaturado: Prisma.$BmOpFaturadoPayload<ExtArgs>[]
      BmOpsPorMalha: Prisma.$BmOpsPorMalhaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      op: number
      CreatedAt: Date
      foto: string
    }, ExtArgs["result"]["bmOp"]>
    composites: {}
  }

  type BmOpGetPayload<S extends boolean | null | undefined | BmOpDefaultArgs> = $Result.GetResult<Prisma.$BmOpPayload, S>

  type BmOpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmOpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmOpCountAggregateInputType | true
    }

  export interface BmOpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmOp'], meta: { name: 'BmOp' } }
    /**
     * Find zero or one BmOp that matches the filter.
     * @param {BmOpFindUniqueArgs} args - Arguments to find a BmOp
     * @example
     * // Get one BmOp
     * const bmOp = await prisma.bmOp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmOpFindUniqueArgs>(args: SelectSubset<T, BmOpFindUniqueArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmOp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmOpFindUniqueOrThrowArgs} args - Arguments to find a BmOp
     * @example
     * // Get one BmOp
     * const bmOp = await prisma.bmOp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmOpFindUniqueOrThrowArgs>(args: SelectSubset<T, BmOpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmOp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFindFirstArgs} args - Arguments to find a BmOp
     * @example
     * // Get one BmOp
     * const bmOp = await prisma.bmOp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmOpFindFirstArgs>(args?: SelectSubset<T, BmOpFindFirstArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmOp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFindFirstOrThrowArgs} args - Arguments to find a BmOp
     * @example
     * // Get one BmOp
     * const bmOp = await prisma.bmOp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmOpFindFirstOrThrowArgs>(args?: SelectSubset<T, BmOpFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmOps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmOps
     * const bmOps = await prisma.bmOp.findMany()
     * 
     * // Get first 10 BmOps
     * const bmOps = await prisma.bmOp.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmOpWithIdBmOnly = await prisma.bmOp.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmOpFindManyArgs>(args?: SelectSubset<T, BmOpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmOp.
     * @param {BmOpCreateArgs} args - Arguments to create a BmOp.
     * @example
     * // Create one BmOp
     * const BmOp = await prisma.bmOp.create({
     *   data: {
     *     // ... data to create a BmOp
     *   }
     * })
     * 
     */
    create<T extends BmOpCreateArgs>(args: SelectSubset<T, BmOpCreateArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmOps.
     * @param {BmOpCreateManyArgs} args - Arguments to create many BmOps.
     * @example
     * // Create many BmOps
     * const bmOp = await prisma.bmOp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmOpCreateManyArgs>(args?: SelectSubset<T, BmOpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmOp.
     * @param {BmOpDeleteArgs} args - Arguments to delete one BmOp.
     * @example
     * // Delete one BmOp
     * const BmOp = await prisma.bmOp.delete({
     *   where: {
     *     // ... filter to delete one BmOp
     *   }
     * })
     * 
     */
    delete<T extends BmOpDeleteArgs>(args: SelectSubset<T, BmOpDeleteArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmOp.
     * @param {BmOpUpdateArgs} args - Arguments to update one BmOp.
     * @example
     * // Update one BmOp
     * const bmOp = await prisma.bmOp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmOpUpdateArgs>(args: SelectSubset<T, BmOpUpdateArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmOps.
     * @param {BmOpDeleteManyArgs} args - Arguments to filter BmOps to delete.
     * @example
     * // Delete a few BmOps
     * const { count } = await prisma.bmOp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmOpDeleteManyArgs>(args?: SelectSubset<T, BmOpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmOps
     * const bmOp = await prisma.bmOp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmOpUpdateManyArgs>(args: SelectSubset<T, BmOpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmOp.
     * @param {BmOpUpsertArgs} args - Arguments to update or create a BmOp.
     * @example
     * // Update or create a BmOp
     * const bmOp = await prisma.bmOp.upsert({
     *   create: {
     *     // ... data to create a BmOp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmOp we want to update
     *   }
     * })
     */
    upsert<T extends BmOpUpsertArgs>(args: SelectSubset<T, BmOpUpsertArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpCountArgs} args - Arguments to filter BmOps to count.
     * @example
     * // Count the number of BmOps
     * const count = await prisma.bmOp.count({
     *   where: {
     *     // ... the filter for the BmOps we want to count
     *   }
     * })
    **/
    count<T extends BmOpCountArgs>(
      args?: Subset<T, BmOpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmOpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmOpAggregateArgs>(args: Subset<T, BmOpAggregateArgs>): Prisma.PrismaPromise<GetBmOpAggregateType<T>>

    /**
     * Group by BmOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmOpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmOpGroupByArgs['orderBy'] }
        : { orderBy?: BmOpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmOpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmOpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmOp model
   */
  readonly fields: BmOpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmOp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmOpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bm<T extends BmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmDefaultArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmOpFaturado<T extends BmOp$BmOpFaturadoArgs<ExtArgs> = {}>(args?: Subset<T, BmOp$BmOpFaturadoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmOpsPorMalha<T extends BmOp$BmOpsPorMalhaArgs<ExtArgs> = {}>(args?: Subset<T, BmOp$BmOpsPorMalhaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmOp model
   */ 
  interface BmOpFieldRefs {
    readonly idBm: FieldRef<"BmOp", 'String'>
    readonly op: FieldRef<"BmOp", 'Int'>
    readonly CreatedAt: FieldRef<"BmOp", 'DateTime'>
    readonly foto: FieldRef<"BmOp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmOp findUnique
   */
  export type BmOpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * Filter, which BmOp to fetch.
     */
    where: BmOpWhereUniqueInput
  }

  /**
   * BmOp findUniqueOrThrow
   */
  export type BmOpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * Filter, which BmOp to fetch.
     */
    where: BmOpWhereUniqueInput
  }

  /**
   * BmOp findFirst
   */
  export type BmOpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * Filter, which BmOp to fetch.
     */
    where?: BmOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOps to fetch.
     */
    orderBy?: BmOpOrderByWithRelationInput | BmOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOps.
     */
    cursor?: BmOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOps.
     */
    distinct?: BmOpScalarFieldEnum | BmOpScalarFieldEnum[]
  }

  /**
   * BmOp findFirstOrThrow
   */
  export type BmOpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * Filter, which BmOp to fetch.
     */
    where?: BmOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOps to fetch.
     */
    orderBy?: BmOpOrderByWithRelationInput | BmOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOps.
     */
    cursor?: BmOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOps.
     */
    distinct?: BmOpScalarFieldEnum | BmOpScalarFieldEnum[]
  }

  /**
   * BmOp findMany
   */
  export type BmOpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * Filter, which BmOps to fetch.
     */
    where?: BmOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOps to fetch.
     */
    orderBy?: BmOpOrderByWithRelationInput | BmOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmOps.
     */
    cursor?: BmOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOps.
     */
    skip?: number
    distinct?: BmOpScalarFieldEnum | BmOpScalarFieldEnum[]
  }

  /**
   * BmOp create
   */
  export type BmOpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * The data needed to create a BmOp.
     */
    data: XOR<BmOpCreateInput, BmOpUncheckedCreateInput>
  }

  /**
   * BmOp createMany
   */
  export type BmOpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmOps.
     */
    data: BmOpCreateManyInput | BmOpCreateManyInput[]
  }

  /**
   * BmOp update
   */
  export type BmOpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * The data needed to update a BmOp.
     */
    data: XOR<BmOpUpdateInput, BmOpUncheckedUpdateInput>
    /**
     * Choose, which BmOp to update.
     */
    where: BmOpWhereUniqueInput
  }

  /**
   * BmOp updateMany
   */
  export type BmOpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmOps.
     */
    data: XOR<BmOpUpdateManyMutationInput, BmOpUncheckedUpdateManyInput>
    /**
     * Filter which BmOps to update
     */
    where?: BmOpWhereInput
    /**
     * Limit how many BmOps to update.
     */
    limit?: number
  }

  /**
   * BmOp upsert
   */
  export type BmOpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * The filter to search for the BmOp to update in case it exists.
     */
    where: BmOpWhereUniqueInput
    /**
     * In case the BmOp found by the `where` argument doesn't exist, create a new BmOp with this data.
     */
    create: XOR<BmOpCreateInput, BmOpUncheckedCreateInput>
    /**
     * In case the BmOp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmOpUpdateInput, BmOpUncheckedUpdateInput>
  }

  /**
   * BmOp delete
   */
  export type BmOpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
    /**
     * Filter which BmOp to delete.
     */
    where: BmOpWhereUniqueInput
  }

  /**
   * BmOp deleteMany
   */
  export type BmOpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOps to delete
     */
    where?: BmOpWhereInput
    /**
     * Limit how many BmOps to delete.
     */
    limit?: number
  }

  /**
   * BmOp.BmOpFaturado
   */
  export type BmOp$BmOpFaturadoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    where?: BmOpFaturadoWhereInput
    orderBy?: BmOpFaturadoOrderByWithRelationInput | BmOpFaturadoOrderByWithRelationInput[]
    cursor?: BmOpFaturadoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmOpFaturadoScalarFieldEnum | BmOpFaturadoScalarFieldEnum[]
  }

  /**
   * BmOp.BmOpsPorMalha
   */
  export type BmOp$BmOpsPorMalhaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    where?: BmOpsPorMalhaWhereInput
    orderBy?: BmOpsPorMalhaOrderByWithRelationInput | BmOpsPorMalhaOrderByWithRelationInput[]
    cursor?: BmOpsPorMalhaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmOpsPorMalhaScalarFieldEnum | BmOpsPorMalhaScalarFieldEnum[]
  }

  /**
   * BmOp without action
   */
  export type BmOpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOp
     */
    select?: BmOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOp
     */
    omit?: BmOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpInclude<ExtArgs> | null
  }


  /**
   * Model BmOpFaturado
   */

  export type AggregateBmOpFaturado = {
    _count: BmOpFaturadoCountAggregateOutputType | null
    _avg: BmOpFaturadoAvgAggregateOutputType | null
    _sum: BmOpFaturadoSumAggregateOutputType | null
    _min: BmOpFaturadoMinAggregateOutputType | null
    _max: BmOpFaturadoMaxAggregateOutputType | null
  }

  export type BmOpFaturadoAvgAggregateOutputType = {
    op: number | null
    nFatutura: number | null
    qtt: Decimal | null
    pesoLiquido: Decimal | null
    pesoBruto: Decimal | null
  }

  export type BmOpFaturadoSumAggregateOutputType = {
    op: number | null
    nFatutura: number | null
    qtt: Decimal | null
    pesoLiquido: Decimal | null
    pesoBruto: Decimal | null
  }

  export type BmOpFaturadoMinAggregateOutputType = {
    idBm: string | null
    op: number | null
    nFatutura: number | null
    fData: Date | null
    dataFatura: string | null
    refModelo: string | null
    pedido: string | null
    qtt: Decimal | null
    pesoLiquido: Decimal | null
    pesoBruto: Decimal | null
    cmr: string | null
    local: string | null
    obs: string | null
  }

  export type BmOpFaturadoMaxAggregateOutputType = {
    idBm: string | null
    op: number | null
    nFatutura: number | null
    fData: Date | null
    dataFatura: string | null
    refModelo: string | null
    pedido: string | null
    qtt: Decimal | null
    pesoLiquido: Decimal | null
    pesoBruto: Decimal | null
    cmr: string | null
    local: string | null
    obs: string | null
  }

  export type BmOpFaturadoCountAggregateOutputType = {
    idBm: number
    op: number
    nFatutura: number
    fData: number
    dataFatura: number
    refModelo: number
    pedido: number
    qtt: number
    pesoLiquido: number
    pesoBruto: number
    cmr: number
    local: number
    obs: number
    _all: number
  }


  export type BmOpFaturadoAvgAggregateInputType = {
    op?: true
    nFatutura?: true
    qtt?: true
    pesoLiquido?: true
    pesoBruto?: true
  }

  export type BmOpFaturadoSumAggregateInputType = {
    op?: true
    nFatutura?: true
    qtt?: true
    pesoLiquido?: true
    pesoBruto?: true
  }

  export type BmOpFaturadoMinAggregateInputType = {
    idBm?: true
    op?: true
    nFatutura?: true
    fData?: true
    dataFatura?: true
    refModelo?: true
    pedido?: true
    qtt?: true
    pesoLiquido?: true
    pesoBruto?: true
    cmr?: true
    local?: true
    obs?: true
  }

  export type BmOpFaturadoMaxAggregateInputType = {
    idBm?: true
    op?: true
    nFatutura?: true
    fData?: true
    dataFatura?: true
    refModelo?: true
    pedido?: true
    qtt?: true
    pesoLiquido?: true
    pesoBruto?: true
    cmr?: true
    local?: true
    obs?: true
  }

  export type BmOpFaturadoCountAggregateInputType = {
    idBm?: true
    op?: true
    nFatutura?: true
    fData?: true
    dataFatura?: true
    refModelo?: true
    pedido?: true
    qtt?: true
    pesoLiquido?: true
    pesoBruto?: true
    cmr?: true
    local?: true
    obs?: true
    _all?: true
  }

  export type BmOpFaturadoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOpFaturado to aggregate.
     */
    where?: BmOpFaturadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpFaturados to fetch.
     */
    orderBy?: BmOpFaturadoOrderByWithRelationInput | BmOpFaturadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmOpFaturadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpFaturados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpFaturados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmOpFaturados
    **/
    _count?: true | BmOpFaturadoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmOpFaturadoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmOpFaturadoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmOpFaturadoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmOpFaturadoMaxAggregateInputType
  }

  export type GetBmOpFaturadoAggregateType<T extends BmOpFaturadoAggregateArgs> = {
        [P in keyof T & keyof AggregateBmOpFaturado]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmOpFaturado[P]>
      : GetScalarType<T[P], AggregateBmOpFaturado[P]>
  }




  export type BmOpFaturadoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpFaturadoWhereInput
    orderBy?: BmOpFaturadoOrderByWithAggregationInput | BmOpFaturadoOrderByWithAggregationInput[]
    by: BmOpFaturadoScalarFieldEnum[] | BmOpFaturadoScalarFieldEnum
    having?: BmOpFaturadoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmOpFaturadoCountAggregateInputType | true
    _avg?: BmOpFaturadoAvgAggregateInputType
    _sum?: BmOpFaturadoSumAggregateInputType
    _min?: BmOpFaturadoMinAggregateInputType
    _max?: BmOpFaturadoMaxAggregateInputType
  }

  export type BmOpFaturadoGroupByOutputType = {
    idBm: string
    op: number
    nFatutura: number
    fData: Date
    dataFatura: string
    refModelo: string
    pedido: string
    qtt: Decimal
    pesoLiquido: Decimal
    pesoBruto: Decimal
    cmr: string
    local: string
    obs: string | null
    _count: BmOpFaturadoCountAggregateOutputType | null
    _avg: BmOpFaturadoAvgAggregateOutputType | null
    _sum: BmOpFaturadoSumAggregateOutputType | null
    _min: BmOpFaturadoMinAggregateOutputType | null
    _max: BmOpFaturadoMaxAggregateOutputType | null
  }

  type GetBmOpFaturadoGroupByPayload<T extends BmOpFaturadoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmOpFaturadoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmOpFaturadoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmOpFaturadoGroupByOutputType[P]>
            : GetScalarType<T[P], BmOpFaturadoGroupByOutputType[P]>
        }
      >
    >


  export type BmOpFaturadoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    op?: boolean
    nFatutura?: boolean
    fData?: boolean
    dataFatura?: boolean
    refModelo?: boolean
    pedido?: boolean
    qtt?: boolean
    pesoLiquido?: boolean
    pesoBruto?: boolean
    cmr?: boolean
    local?: boolean
    obs?: boolean
    BmOp?: boolean | BmOpDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmOpFaturado"]>



  export type BmOpFaturadoSelectScalar = {
    idBm?: boolean
    op?: boolean
    nFatutura?: boolean
    fData?: boolean
    dataFatura?: boolean
    refModelo?: boolean
    pedido?: boolean
    qtt?: boolean
    pesoLiquido?: boolean
    pesoBruto?: boolean
    cmr?: boolean
    local?: boolean
    obs?: boolean
  }

  export type BmOpFaturadoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "op" | "nFatutura" | "fData" | "dataFatura" | "refModelo" | "pedido" | "qtt" | "pesoLiquido" | "pesoBruto" | "cmr" | "local" | "obs", ExtArgs["result"]["bmOpFaturado"]>
  export type BmOpFaturadoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmOp?: boolean | BmOpDefaultArgs<ExtArgs>
  }

  export type $BmOpFaturadoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmOpFaturado"
    objects: {
      BmOp: Prisma.$BmOpPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      op: number
      nFatutura: number
      fData: Date
      dataFatura: string
      refModelo: string
      pedido: string
      qtt: Prisma.Decimal
      pesoLiquido: Prisma.Decimal
      pesoBruto: Prisma.Decimal
      cmr: string
      local: string
      obs: string | null
    }, ExtArgs["result"]["bmOpFaturado"]>
    composites: {}
  }

  type BmOpFaturadoGetPayload<S extends boolean | null | undefined | BmOpFaturadoDefaultArgs> = $Result.GetResult<Prisma.$BmOpFaturadoPayload, S>

  type BmOpFaturadoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmOpFaturadoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmOpFaturadoCountAggregateInputType | true
    }

  export interface BmOpFaturadoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmOpFaturado'], meta: { name: 'BmOpFaturado' } }
    /**
     * Find zero or one BmOpFaturado that matches the filter.
     * @param {BmOpFaturadoFindUniqueArgs} args - Arguments to find a BmOpFaturado
     * @example
     * // Get one BmOpFaturado
     * const bmOpFaturado = await prisma.bmOpFaturado.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmOpFaturadoFindUniqueArgs>(args: SelectSubset<T, BmOpFaturadoFindUniqueArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmOpFaturado that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmOpFaturadoFindUniqueOrThrowArgs} args - Arguments to find a BmOpFaturado
     * @example
     * // Get one BmOpFaturado
     * const bmOpFaturado = await prisma.bmOpFaturado.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmOpFaturadoFindUniqueOrThrowArgs>(args: SelectSubset<T, BmOpFaturadoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmOpFaturado that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFaturadoFindFirstArgs} args - Arguments to find a BmOpFaturado
     * @example
     * // Get one BmOpFaturado
     * const bmOpFaturado = await prisma.bmOpFaturado.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmOpFaturadoFindFirstArgs>(args?: SelectSubset<T, BmOpFaturadoFindFirstArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmOpFaturado that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFaturadoFindFirstOrThrowArgs} args - Arguments to find a BmOpFaturado
     * @example
     * // Get one BmOpFaturado
     * const bmOpFaturado = await prisma.bmOpFaturado.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmOpFaturadoFindFirstOrThrowArgs>(args?: SelectSubset<T, BmOpFaturadoFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmOpFaturados that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFaturadoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmOpFaturados
     * const bmOpFaturados = await prisma.bmOpFaturado.findMany()
     * 
     * // Get first 10 BmOpFaturados
     * const bmOpFaturados = await prisma.bmOpFaturado.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmOpFaturadoWithIdBmOnly = await prisma.bmOpFaturado.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmOpFaturadoFindManyArgs>(args?: SelectSubset<T, BmOpFaturadoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmOpFaturado.
     * @param {BmOpFaturadoCreateArgs} args - Arguments to create a BmOpFaturado.
     * @example
     * // Create one BmOpFaturado
     * const BmOpFaturado = await prisma.bmOpFaturado.create({
     *   data: {
     *     // ... data to create a BmOpFaturado
     *   }
     * })
     * 
     */
    create<T extends BmOpFaturadoCreateArgs>(args: SelectSubset<T, BmOpFaturadoCreateArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmOpFaturados.
     * @param {BmOpFaturadoCreateManyArgs} args - Arguments to create many BmOpFaturados.
     * @example
     * // Create many BmOpFaturados
     * const bmOpFaturado = await prisma.bmOpFaturado.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmOpFaturadoCreateManyArgs>(args?: SelectSubset<T, BmOpFaturadoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmOpFaturado.
     * @param {BmOpFaturadoDeleteArgs} args - Arguments to delete one BmOpFaturado.
     * @example
     * // Delete one BmOpFaturado
     * const BmOpFaturado = await prisma.bmOpFaturado.delete({
     *   where: {
     *     // ... filter to delete one BmOpFaturado
     *   }
     * })
     * 
     */
    delete<T extends BmOpFaturadoDeleteArgs>(args: SelectSubset<T, BmOpFaturadoDeleteArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmOpFaturado.
     * @param {BmOpFaturadoUpdateArgs} args - Arguments to update one BmOpFaturado.
     * @example
     * // Update one BmOpFaturado
     * const bmOpFaturado = await prisma.bmOpFaturado.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmOpFaturadoUpdateArgs>(args: SelectSubset<T, BmOpFaturadoUpdateArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmOpFaturados.
     * @param {BmOpFaturadoDeleteManyArgs} args - Arguments to filter BmOpFaturados to delete.
     * @example
     * // Delete a few BmOpFaturados
     * const { count } = await prisma.bmOpFaturado.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmOpFaturadoDeleteManyArgs>(args?: SelectSubset<T, BmOpFaturadoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmOpFaturados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFaturadoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmOpFaturados
     * const bmOpFaturado = await prisma.bmOpFaturado.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmOpFaturadoUpdateManyArgs>(args: SelectSubset<T, BmOpFaturadoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmOpFaturado.
     * @param {BmOpFaturadoUpsertArgs} args - Arguments to update or create a BmOpFaturado.
     * @example
     * // Update or create a BmOpFaturado
     * const bmOpFaturado = await prisma.bmOpFaturado.upsert({
     *   create: {
     *     // ... data to create a BmOpFaturado
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmOpFaturado we want to update
     *   }
     * })
     */
    upsert<T extends BmOpFaturadoUpsertArgs>(args: SelectSubset<T, BmOpFaturadoUpsertArgs<ExtArgs>>): Prisma__BmOpFaturadoClient<$Result.GetResult<Prisma.$BmOpFaturadoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmOpFaturados.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFaturadoCountArgs} args - Arguments to filter BmOpFaturados to count.
     * @example
     * // Count the number of BmOpFaturados
     * const count = await prisma.bmOpFaturado.count({
     *   where: {
     *     // ... the filter for the BmOpFaturados we want to count
     *   }
     * })
    **/
    count<T extends BmOpFaturadoCountArgs>(
      args?: Subset<T, BmOpFaturadoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmOpFaturadoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmOpFaturado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFaturadoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmOpFaturadoAggregateArgs>(args: Subset<T, BmOpFaturadoAggregateArgs>): Prisma.PrismaPromise<GetBmOpFaturadoAggregateType<T>>

    /**
     * Group by BmOpFaturado.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpFaturadoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmOpFaturadoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmOpFaturadoGroupByArgs['orderBy'] }
        : { orderBy?: BmOpFaturadoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmOpFaturadoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmOpFaturadoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmOpFaturado model
   */
  readonly fields: BmOpFaturadoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmOpFaturado.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmOpFaturadoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmOp<T extends BmOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmOpDefaultArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmOpFaturado model
   */ 
  interface BmOpFaturadoFieldRefs {
    readonly idBm: FieldRef<"BmOpFaturado", 'String'>
    readonly op: FieldRef<"BmOpFaturado", 'Int'>
    readonly nFatutura: FieldRef<"BmOpFaturado", 'Int'>
    readonly fData: FieldRef<"BmOpFaturado", 'DateTime'>
    readonly dataFatura: FieldRef<"BmOpFaturado", 'String'>
    readonly refModelo: FieldRef<"BmOpFaturado", 'String'>
    readonly pedido: FieldRef<"BmOpFaturado", 'String'>
    readonly qtt: FieldRef<"BmOpFaturado", 'Decimal'>
    readonly pesoLiquido: FieldRef<"BmOpFaturado", 'Decimal'>
    readonly pesoBruto: FieldRef<"BmOpFaturado", 'Decimal'>
    readonly cmr: FieldRef<"BmOpFaturado", 'String'>
    readonly local: FieldRef<"BmOpFaturado", 'String'>
    readonly obs: FieldRef<"BmOpFaturado", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmOpFaturado findUnique
   */
  export type BmOpFaturadoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * Filter, which BmOpFaturado to fetch.
     */
    where: BmOpFaturadoWhereUniqueInput
  }

  /**
   * BmOpFaturado findUniqueOrThrow
   */
  export type BmOpFaturadoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * Filter, which BmOpFaturado to fetch.
     */
    where: BmOpFaturadoWhereUniqueInput
  }

  /**
   * BmOpFaturado findFirst
   */
  export type BmOpFaturadoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * Filter, which BmOpFaturado to fetch.
     */
    where?: BmOpFaturadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpFaturados to fetch.
     */
    orderBy?: BmOpFaturadoOrderByWithRelationInput | BmOpFaturadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOpFaturados.
     */
    cursor?: BmOpFaturadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpFaturados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpFaturados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOpFaturados.
     */
    distinct?: BmOpFaturadoScalarFieldEnum | BmOpFaturadoScalarFieldEnum[]
  }

  /**
   * BmOpFaturado findFirstOrThrow
   */
  export type BmOpFaturadoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * Filter, which BmOpFaturado to fetch.
     */
    where?: BmOpFaturadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpFaturados to fetch.
     */
    orderBy?: BmOpFaturadoOrderByWithRelationInput | BmOpFaturadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOpFaturados.
     */
    cursor?: BmOpFaturadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpFaturados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpFaturados.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOpFaturados.
     */
    distinct?: BmOpFaturadoScalarFieldEnum | BmOpFaturadoScalarFieldEnum[]
  }

  /**
   * BmOpFaturado findMany
   */
  export type BmOpFaturadoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * Filter, which BmOpFaturados to fetch.
     */
    where?: BmOpFaturadoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpFaturados to fetch.
     */
    orderBy?: BmOpFaturadoOrderByWithRelationInput | BmOpFaturadoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmOpFaturados.
     */
    cursor?: BmOpFaturadoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpFaturados from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpFaturados.
     */
    skip?: number
    distinct?: BmOpFaturadoScalarFieldEnum | BmOpFaturadoScalarFieldEnum[]
  }

  /**
   * BmOpFaturado create
   */
  export type BmOpFaturadoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * The data needed to create a BmOpFaturado.
     */
    data: XOR<BmOpFaturadoCreateInput, BmOpFaturadoUncheckedCreateInput>
  }

  /**
   * BmOpFaturado createMany
   */
  export type BmOpFaturadoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmOpFaturados.
     */
    data: BmOpFaturadoCreateManyInput | BmOpFaturadoCreateManyInput[]
  }

  /**
   * BmOpFaturado update
   */
  export type BmOpFaturadoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * The data needed to update a BmOpFaturado.
     */
    data: XOR<BmOpFaturadoUpdateInput, BmOpFaturadoUncheckedUpdateInput>
    /**
     * Choose, which BmOpFaturado to update.
     */
    where: BmOpFaturadoWhereUniqueInput
  }

  /**
   * BmOpFaturado updateMany
   */
  export type BmOpFaturadoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmOpFaturados.
     */
    data: XOR<BmOpFaturadoUpdateManyMutationInput, BmOpFaturadoUncheckedUpdateManyInput>
    /**
     * Filter which BmOpFaturados to update
     */
    where?: BmOpFaturadoWhereInput
    /**
     * Limit how many BmOpFaturados to update.
     */
    limit?: number
  }

  /**
   * BmOpFaturado upsert
   */
  export type BmOpFaturadoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * The filter to search for the BmOpFaturado to update in case it exists.
     */
    where: BmOpFaturadoWhereUniqueInput
    /**
     * In case the BmOpFaturado found by the `where` argument doesn't exist, create a new BmOpFaturado with this data.
     */
    create: XOR<BmOpFaturadoCreateInput, BmOpFaturadoUncheckedCreateInput>
    /**
     * In case the BmOpFaturado was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmOpFaturadoUpdateInput, BmOpFaturadoUncheckedUpdateInput>
  }

  /**
   * BmOpFaturado delete
   */
  export type BmOpFaturadoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
    /**
     * Filter which BmOpFaturado to delete.
     */
    where: BmOpFaturadoWhereUniqueInput
  }

  /**
   * BmOpFaturado deleteMany
   */
  export type BmOpFaturadoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOpFaturados to delete
     */
    where?: BmOpFaturadoWhereInput
    /**
     * Limit how many BmOpFaturados to delete.
     */
    limit?: number
  }

  /**
   * BmOpFaturado without action
   */
  export type BmOpFaturadoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpFaturado
     */
    select?: BmOpFaturadoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpFaturado
     */
    omit?: BmOpFaturadoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpFaturadoInclude<ExtArgs> | null
  }


  /**
   * Model BmOpsPorMalha
   */

  export type AggregateBmOpsPorMalha = {
    _count: BmOpsPorMalhaCountAggregateOutputType | null
    _avg: BmOpsPorMalhaAvgAggregateOutputType | null
    _sum: BmOpsPorMalhaSumAggregateOutputType | null
    _min: BmOpsPorMalhaMinAggregateOutputType | null
    _max: BmOpsPorMalhaMaxAggregateOutputType | null
  }

  export type BmOpsPorMalhaAvgAggregateOutputType = {
    op: number | null
  }

  export type BmOpsPorMalhaSumAggregateOutputType = {
    op: number | null
  }

  export type BmOpsPorMalhaMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    op: number | null
  }

  export type BmOpsPorMalhaMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    op: number | null
  }

  export type BmOpsPorMalhaCountAggregateOutputType = {
    idBm: number
    ref: number
    op: number
    _all: number
  }


  export type BmOpsPorMalhaAvgAggregateInputType = {
    op?: true
  }

  export type BmOpsPorMalhaSumAggregateInputType = {
    op?: true
  }

  export type BmOpsPorMalhaMinAggregateInputType = {
    idBm?: true
    ref?: true
    op?: true
  }

  export type BmOpsPorMalhaMaxAggregateInputType = {
    idBm?: true
    ref?: true
    op?: true
  }

  export type BmOpsPorMalhaCountAggregateInputType = {
    idBm?: true
    ref?: true
    op?: true
    _all?: true
  }

  export type BmOpsPorMalhaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOpsPorMalha to aggregate.
     */
    where?: BmOpsPorMalhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhas to fetch.
     */
    orderBy?: BmOpsPorMalhaOrderByWithRelationInput | BmOpsPorMalhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmOpsPorMalhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmOpsPorMalhas
    **/
    _count?: true | BmOpsPorMalhaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmOpsPorMalhaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmOpsPorMalhaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmOpsPorMalhaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmOpsPorMalhaMaxAggregateInputType
  }

  export type GetBmOpsPorMalhaAggregateType<T extends BmOpsPorMalhaAggregateArgs> = {
        [P in keyof T & keyof AggregateBmOpsPorMalha]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmOpsPorMalha[P]>
      : GetScalarType<T[P], AggregateBmOpsPorMalha[P]>
  }




  export type BmOpsPorMalhaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpsPorMalhaWhereInput
    orderBy?: BmOpsPorMalhaOrderByWithAggregationInput | BmOpsPorMalhaOrderByWithAggregationInput[]
    by: BmOpsPorMalhaScalarFieldEnum[] | BmOpsPorMalhaScalarFieldEnum
    having?: BmOpsPorMalhaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmOpsPorMalhaCountAggregateInputType | true
    _avg?: BmOpsPorMalhaAvgAggregateInputType
    _sum?: BmOpsPorMalhaSumAggregateInputType
    _min?: BmOpsPorMalhaMinAggregateInputType
    _max?: BmOpsPorMalhaMaxAggregateInputType
  }

  export type BmOpsPorMalhaGroupByOutputType = {
    idBm: string
    ref: string
    op: number
    _count: BmOpsPorMalhaCountAggregateOutputType | null
    _avg: BmOpsPorMalhaAvgAggregateOutputType | null
    _sum: BmOpsPorMalhaSumAggregateOutputType | null
    _min: BmOpsPorMalhaMinAggregateOutputType | null
    _max: BmOpsPorMalhaMaxAggregateOutputType | null
  }

  type GetBmOpsPorMalhaGroupByPayload<T extends BmOpsPorMalhaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmOpsPorMalhaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmOpsPorMalhaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmOpsPorMalhaGroupByOutputType[P]>
            : GetScalarType<T[P], BmOpsPorMalhaGroupByOutputType[P]>
        }
      >
    >


  export type BmOpsPorMalhaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    op?: boolean
    BmMovimentosLotes?: boolean | BmOpsPorMalha$BmMovimentosLotesArgs<ExtArgs>
    BmMalhas?: boolean | BmMalhasDefaultArgs<ExtArgs>
    BmOp?: boolean | BmOpDefaultArgs<ExtArgs>
    BmOpsPorMalhaFio?: boolean | BmOpsPorMalha$BmOpsPorMalhaFioArgs<ExtArgs>
    _count?: boolean | BmOpsPorMalhaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmOpsPorMalha"]>



  export type BmOpsPorMalhaSelectScalar = {
    idBm?: boolean
    ref?: boolean
    op?: boolean
  }

  export type BmOpsPorMalhaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "op", ExtArgs["result"]["bmOpsPorMalha"]>
  export type BmOpsPorMalhaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMovimentosLotes?: boolean | BmOpsPorMalha$BmMovimentosLotesArgs<ExtArgs>
    BmMalhas?: boolean | BmMalhasDefaultArgs<ExtArgs>
    BmOp?: boolean | BmOpDefaultArgs<ExtArgs>
    BmOpsPorMalhaFio?: boolean | BmOpsPorMalha$BmOpsPorMalhaFioArgs<ExtArgs>
    _count?: boolean | BmOpsPorMalhaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmOpsPorMalhaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmOpsPorMalha"
    objects: {
      BmMovimentosLotes: Prisma.$BmMovimentosLotesPayload<ExtArgs>[]
      BmMalhas: Prisma.$BmMalhasPayload<ExtArgs>
      BmOp: Prisma.$BmOpPayload<ExtArgs>
      BmOpsPorMalhaFio: Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      op: number
    }, ExtArgs["result"]["bmOpsPorMalha"]>
    composites: {}
  }

  type BmOpsPorMalhaGetPayload<S extends boolean | null | undefined | BmOpsPorMalhaDefaultArgs> = $Result.GetResult<Prisma.$BmOpsPorMalhaPayload, S>

  type BmOpsPorMalhaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmOpsPorMalhaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmOpsPorMalhaCountAggregateInputType | true
    }

  export interface BmOpsPorMalhaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmOpsPorMalha'], meta: { name: 'BmOpsPorMalha' } }
    /**
     * Find zero or one BmOpsPorMalha that matches the filter.
     * @param {BmOpsPorMalhaFindUniqueArgs} args - Arguments to find a BmOpsPorMalha
     * @example
     * // Get one BmOpsPorMalha
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmOpsPorMalhaFindUniqueArgs>(args: SelectSubset<T, BmOpsPorMalhaFindUniqueArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmOpsPorMalha that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmOpsPorMalhaFindUniqueOrThrowArgs} args - Arguments to find a BmOpsPorMalha
     * @example
     * // Get one BmOpsPorMalha
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmOpsPorMalhaFindUniqueOrThrowArgs>(args: SelectSubset<T, BmOpsPorMalhaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmOpsPorMalha that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFindFirstArgs} args - Arguments to find a BmOpsPorMalha
     * @example
     * // Get one BmOpsPorMalha
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmOpsPorMalhaFindFirstArgs>(args?: SelectSubset<T, BmOpsPorMalhaFindFirstArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmOpsPorMalha that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFindFirstOrThrowArgs} args - Arguments to find a BmOpsPorMalha
     * @example
     * // Get one BmOpsPorMalha
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmOpsPorMalhaFindFirstOrThrowArgs>(args?: SelectSubset<T, BmOpsPorMalhaFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmOpsPorMalhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmOpsPorMalhas
     * const bmOpsPorMalhas = await prisma.bmOpsPorMalha.findMany()
     * 
     * // Get first 10 BmOpsPorMalhas
     * const bmOpsPorMalhas = await prisma.bmOpsPorMalha.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmOpsPorMalhaWithIdBmOnly = await prisma.bmOpsPorMalha.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmOpsPorMalhaFindManyArgs>(args?: SelectSubset<T, BmOpsPorMalhaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmOpsPorMalha.
     * @param {BmOpsPorMalhaCreateArgs} args - Arguments to create a BmOpsPorMalha.
     * @example
     * // Create one BmOpsPorMalha
     * const BmOpsPorMalha = await prisma.bmOpsPorMalha.create({
     *   data: {
     *     // ... data to create a BmOpsPorMalha
     *   }
     * })
     * 
     */
    create<T extends BmOpsPorMalhaCreateArgs>(args: SelectSubset<T, BmOpsPorMalhaCreateArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmOpsPorMalhas.
     * @param {BmOpsPorMalhaCreateManyArgs} args - Arguments to create many BmOpsPorMalhas.
     * @example
     * // Create many BmOpsPorMalhas
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmOpsPorMalhaCreateManyArgs>(args?: SelectSubset<T, BmOpsPorMalhaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmOpsPorMalha.
     * @param {BmOpsPorMalhaDeleteArgs} args - Arguments to delete one BmOpsPorMalha.
     * @example
     * // Delete one BmOpsPorMalha
     * const BmOpsPorMalha = await prisma.bmOpsPorMalha.delete({
     *   where: {
     *     // ... filter to delete one BmOpsPorMalha
     *   }
     * })
     * 
     */
    delete<T extends BmOpsPorMalhaDeleteArgs>(args: SelectSubset<T, BmOpsPorMalhaDeleteArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmOpsPorMalha.
     * @param {BmOpsPorMalhaUpdateArgs} args - Arguments to update one BmOpsPorMalha.
     * @example
     * // Update one BmOpsPorMalha
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmOpsPorMalhaUpdateArgs>(args: SelectSubset<T, BmOpsPorMalhaUpdateArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmOpsPorMalhas.
     * @param {BmOpsPorMalhaDeleteManyArgs} args - Arguments to filter BmOpsPorMalhas to delete.
     * @example
     * // Delete a few BmOpsPorMalhas
     * const { count } = await prisma.bmOpsPorMalha.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmOpsPorMalhaDeleteManyArgs>(args?: SelectSubset<T, BmOpsPorMalhaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmOpsPorMalhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmOpsPorMalhas
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmOpsPorMalhaUpdateManyArgs>(args: SelectSubset<T, BmOpsPorMalhaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmOpsPorMalha.
     * @param {BmOpsPorMalhaUpsertArgs} args - Arguments to update or create a BmOpsPorMalha.
     * @example
     * // Update or create a BmOpsPorMalha
     * const bmOpsPorMalha = await prisma.bmOpsPorMalha.upsert({
     *   create: {
     *     // ... data to create a BmOpsPorMalha
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmOpsPorMalha we want to update
     *   }
     * })
     */
    upsert<T extends BmOpsPorMalhaUpsertArgs>(args: SelectSubset<T, BmOpsPorMalhaUpsertArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmOpsPorMalhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaCountArgs} args - Arguments to filter BmOpsPorMalhas to count.
     * @example
     * // Count the number of BmOpsPorMalhas
     * const count = await prisma.bmOpsPorMalha.count({
     *   where: {
     *     // ... the filter for the BmOpsPorMalhas we want to count
     *   }
     * })
    **/
    count<T extends BmOpsPorMalhaCountArgs>(
      args?: Subset<T, BmOpsPorMalhaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmOpsPorMalhaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmOpsPorMalha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmOpsPorMalhaAggregateArgs>(args: Subset<T, BmOpsPorMalhaAggregateArgs>): Prisma.PrismaPromise<GetBmOpsPorMalhaAggregateType<T>>

    /**
     * Group by BmOpsPorMalha.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmOpsPorMalhaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmOpsPorMalhaGroupByArgs['orderBy'] }
        : { orderBy?: BmOpsPorMalhaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmOpsPorMalhaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmOpsPorMalhaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmOpsPorMalha model
   */
  readonly fields: BmOpsPorMalhaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmOpsPorMalha.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmOpsPorMalhaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMovimentosLotes<T extends BmOpsPorMalha$BmMovimentosLotesArgs<ExtArgs> = {}>(args?: Subset<T, BmOpsPorMalha$BmMovimentosLotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMovimentosLotesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmMalhas<T extends BmMalhasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhasDefaultArgs<ExtArgs>>): Prisma__BmMalhasClient<$Result.GetResult<Prisma.$BmMalhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmOp<T extends BmOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmOpDefaultArgs<ExtArgs>>): Prisma__BmOpClient<$Result.GetResult<Prisma.$BmOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmOpsPorMalhaFio<T extends BmOpsPorMalha$BmOpsPorMalhaFioArgs<ExtArgs> = {}>(args?: Subset<T, BmOpsPorMalha$BmOpsPorMalhaFioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmOpsPorMalha model
   */ 
  interface BmOpsPorMalhaFieldRefs {
    readonly idBm: FieldRef<"BmOpsPorMalha", 'String'>
    readonly ref: FieldRef<"BmOpsPorMalha", 'String'>
    readonly op: FieldRef<"BmOpsPorMalha", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BmOpsPorMalha findUnique
   */
  export type BmOpsPorMalhaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalha to fetch.
     */
    where: BmOpsPorMalhaWhereUniqueInput
  }

  /**
   * BmOpsPorMalha findUniqueOrThrow
   */
  export type BmOpsPorMalhaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalha to fetch.
     */
    where: BmOpsPorMalhaWhereUniqueInput
  }

  /**
   * BmOpsPorMalha findFirst
   */
  export type BmOpsPorMalhaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalha to fetch.
     */
    where?: BmOpsPorMalhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhas to fetch.
     */
    orderBy?: BmOpsPorMalhaOrderByWithRelationInput | BmOpsPorMalhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOpsPorMalhas.
     */
    cursor?: BmOpsPorMalhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOpsPorMalhas.
     */
    distinct?: BmOpsPorMalhaScalarFieldEnum | BmOpsPorMalhaScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalha findFirstOrThrow
   */
  export type BmOpsPorMalhaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalha to fetch.
     */
    where?: BmOpsPorMalhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhas to fetch.
     */
    orderBy?: BmOpsPorMalhaOrderByWithRelationInput | BmOpsPorMalhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOpsPorMalhas.
     */
    cursor?: BmOpsPorMalhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOpsPorMalhas.
     */
    distinct?: BmOpsPorMalhaScalarFieldEnum | BmOpsPorMalhaScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalha findMany
   */
  export type BmOpsPorMalhaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalhas to fetch.
     */
    where?: BmOpsPorMalhaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhas to fetch.
     */
    orderBy?: BmOpsPorMalhaOrderByWithRelationInput | BmOpsPorMalhaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmOpsPorMalhas.
     */
    cursor?: BmOpsPorMalhaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhas.
     */
    skip?: number
    distinct?: BmOpsPorMalhaScalarFieldEnum | BmOpsPorMalhaScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalha create
   */
  export type BmOpsPorMalhaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * The data needed to create a BmOpsPorMalha.
     */
    data: XOR<BmOpsPorMalhaCreateInput, BmOpsPorMalhaUncheckedCreateInput>
  }

  /**
   * BmOpsPorMalha createMany
   */
  export type BmOpsPorMalhaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmOpsPorMalhas.
     */
    data: BmOpsPorMalhaCreateManyInput | BmOpsPorMalhaCreateManyInput[]
  }

  /**
   * BmOpsPorMalha update
   */
  export type BmOpsPorMalhaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * The data needed to update a BmOpsPorMalha.
     */
    data: XOR<BmOpsPorMalhaUpdateInput, BmOpsPorMalhaUncheckedUpdateInput>
    /**
     * Choose, which BmOpsPorMalha to update.
     */
    where: BmOpsPorMalhaWhereUniqueInput
  }

  /**
   * BmOpsPorMalha updateMany
   */
  export type BmOpsPorMalhaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmOpsPorMalhas.
     */
    data: XOR<BmOpsPorMalhaUpdateManyMutationInput, BmOpsPorMalhaUncheckedUpdateManyInput>
    /**
     * Filter which BmOpsPorMalhas to update
     */
    where?: BmOpsPorMalhaWhereInput
    /**
     * Limit how many BmOpsPorMalhas to update.
     */
    limit?: number
  }

  /**
   * BmOpsPorMalha upsert
   */
  export type BmOpsPorMalhaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * The filter to search for the BmOpsPorMalha to update in case it exists.
     */
    where: BmOpsPorMalhaWhereUniqueInput
    /**
     * In case the BmOpsPorMalha found by the `where` argument doesn't exist, create a new BmOpsPorMalha with this data.
     */
    create: XOR<BmOpsPorMalhaCreateInput, BmOpsPorMalhaUncheckedCreateInput>
    /**
     * In case the BmOpsPorMalha was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmOpsPorMalhaUpdateInput, BmOpsPorMalhaUncheckedUpdateInput>
  }

  /**
   * BmOpsPorMalha delete
   */
  export type BmOpsPorMalhaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
    /**
     * Filter which BmOpsPorMalha to delete.
     */
    where: BmOpsPorMalhaWhereUniqueInput
  }

  /**
   * BmOpsPorMalha deleteMany
   */
  export type BmOpsPorMalhaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOpsPorMalhas to delete
     */
    where?: BmOpsPorMalhaWhereInput
    /**
     * Limit how many BmOpsPorMalhas to delete.
     */
    limit?: number
  }

  /**
   * BmOpsPorMalha.BmMovimentosLotes
   */
  export type BmOpsPorMalha$BmMovimentosLotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMovimentosLotes
     */
    select?: BmMovimentosLotesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMovimentosLotes
     */
    omit?: BmMovimentosLotesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMovimentosLotesInclude<ExtArgs> | null
    where?: BmMovimentosLotesWhereInput
    orderBy?: BmMovimentosLotesOrderByWithRelationInput | BmMovimentosLotesOrderByWithRelationInput[]
    cursor?: BmMovimentosLotesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMovimentosLotesScalarFieldEnum | BmMovimentosLotesScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalha.BmOpsPorMalhaFio
   */
  export type BmOpsPorMalha$BmOpsPorMalhaFioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    where?: BmOpsPorMalhaFioWhereInput
    orderBy?: BmOpsPorMalhaFioOrderByWithRelationInput | BmOpsPorMalhaFioOrderByWithRelationInput[]
    cursor?: BmOpsPorMalhaFioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmOpsPorMalhaFioScalarFieldEnum | BmOpsPorMalhaFioScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalha without action
   */
  export type BmOpsPorMalhaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalha
     */
    select?: BmOpsPorMalhaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalha
     */
    omit?: BmOpsPorMalhaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaInclude<ExtArgs> | null
  }


  /**
   * Model BmOpsPorMalhaFio
   */

  export type AggregateBmOpsPorMalhaFio = {
    _count: BmOpsPorMalhaFioCountAggregateOutputType | null
    _avg: BmOpsPorMalhaFioAvgAggregateOutputType | null
    _sum: BmOpsPorMalhaFioSumAggregateOutputType | null
    _min: BmOpsPorMalhaFioMinAggregateOutputType | null
    _max: BmOpsPorMalhaFioMaxAggregateOutputType | null
  }

  export type BmOpsPorMalhaFioAvgAggregateOutputType = {
    op: number | null
  }

  export type BmOpsPorMalhaFioSumAggregateOutputType = {
    op: number | null
  }

  export type BmOpsPorMalhaFioMinAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    op: number | null
  }

  export type BmOpsPorMalhaFioMaxAggregateOutputType = {
    idBm: string | null
    ref: string | null
    refOrigem: string | null
    op: number | null
  }

  export type BmOpsPorMalhaFioCountAggregateOutputType = {
    idBm: number
    ref: number
    refOrigem: number
    op: number
    _all: number
  }


  export type BmOpsPorMalhaFioAvgAggregateInputType = {
    op?: true
  }

  export type BmOpsPorMalhaFioSumAggregateInputType = {
    op?: true
  }

  export type BmOpsPorMalhaFioMinAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    op?: true
  }

  export type BmOpsPorMalhaFioMaxAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    op?: true
  }

  export type BmOpsPorMalhaFioCountAggregateInputType = {
    idBm?: true
    ref?: true
    refOrigem?: true
    op?: true
    _all?: true
  }

  export type BmOpsPorMalhaFioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOpsPorMalhaFio to aggregate.
     */
    where?: BmOpsPorMalhaFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhaFios to fetch.
     */
    orderBy?: BmOpsPorMalhaFioOrderByWithRelationInput | BmOpsPorMalhaFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmOpsPorMalhaFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhaFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhaFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmOpsPorMalhaFios
    **/
    _count?: true | BmOpsPorMalhaFioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BmOpsPorMalhaFioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BmOpsPorMalhaFioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmOpsPorMalhaFioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmOpsPorMalhaFioMaxAggregateInputType
  }

  export type GetBmOpsPorMalhaFioAggregateType<T extends BmOpsPorMalhaFioAggregateArgs> = {
        [P in keyof T & keyof AggregateBmOpsPorMalhaFio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmOpsPorMalhaFio[P]>
      : GetScalarType<T[P], AggregateBmOpsPorMalhaFio[P]>
  }




  export type BmOpsPorMalhaFioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmOpsPorMalhaFioWhereInput
    orderBy?: BmOpsPorMalhaFioOrderByWithAggregationInput | BmOpsPorMalhaFioOrderByWithAggregationInput[]
    by: BmOpsPorMalhaFioScalarFieldEnum[] | BmOpsPorMalhaFioScalarFieldEnum
    having?: BmOpsPorMalhaFioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmOpsPorMalhaFioCountAggregateInputType | true
    _avg?: BmOpsPorMalhaFioAvgAggregateInputType
    _sum?: BmOpsPorMalhaFioSumAggregateInputType
    _min?: BmOpsPorMalhaFioMinAggregateInputType
    _max?: BmOpsPorMalhaFioMaxAggregateInputType
  }

  export type BmOpsPorMalhaFioGroupByOutputType = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
    _count: BmOpsPorMalhaFioCountAggregateOutputType | null
    _avg: BmOpsPorMalhaFioAvgAggregateOutputType | null
    _sum: BmOpsPorMalhaFioSumAggregateOutputType | null
    _min: BmOpsPorMalhaFioMinAggregateOutputType | null
    _max: BmOpsPorMalhaFioMaxAggregateOutputType | null
  }

  type GetBmOpsPorMalhaFioGroupByPayload<T extends BmOpsPorMalhaFioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmOpsPorMalhaFioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmOpsPorMalhaFioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmOpsPorMalhaFioGroupByOutputType[P]>
            : GetScalarType<T[P], BmOpsPorMalhaFioGroupByOutputType[P]>
        }
      >
    >


  export type BmOpsPorMalhaFioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    op?: boolean
    BmMalhasFioMovimentos?: boolean | BmOpsPorMalhaFio$BmMalhasFioMovimentosArgs<ExtArgs>
    BmMalhasFio?: boolean | BmMalhasFioDefaultArgs<ExtArgs>
    BmOpsPorMalha?: boolean | BmOpsPorMalhaDefaultArgs<ExtArgs>
    _count?: boolean | BmOpsPorMalhaFioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmOpsPorMalhaFio"]>



  export type BmOpsPorMalhaFioSelectScalar = {
    idBm?: boolean
    ref?: boolean
    refOrigem?: boolean
    op?: boolean
  }

  export type BmOpsPorMalhaFioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "ref" | "refOrigem" | "op", ExtArgs["result"]["bmOpsPorMalhaFio"]>
  export type BmOpsPorMalhaFioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BmMalhasFioMovimentos?: boolean | BmOpsPorMalhaFio$BmMalhasFioMovimentosArgs<ExtArgs>
    BmMalhasFio?: boolean | BmMalhasFioDefaultArgs<ExtArgs>
    BmOpsPorMalha?: boolean | BmOpsPorMalhaDefaultArgs<ExtArgs>
    _count?: boolean | BmOpsPorMalhaFioCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BmOpsPorMalhaFioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmOpsPorMalhaFio"
    objects: {
      BmMalhasFioMovimentos: Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>[]
      BmMalhasFio: Prisma.$BmMalhasFioPayload<ExtArgs>
      BmOpsPorMalha: Prisma.$BmOpsPorMalhaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      ref: string
      refOrigem: string
      op: number
    }, ExtArgs["result"]["bmOpsPorMalhaFio"]>
    composites: {}
  }

  type BmOpsPorMalhaFioGetPayload<S extends boolean | null | undefined | BmOpsPorMalhaFioDefaultArgs> = $Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload, S>

  type BmOpsPorMalhaFioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmOpsPorMalhaFioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmOpsPorMalhaFioCountAggregateInputType | true
    }

  export interface BmOpsPorMalhaFioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmOpsPorMalhaFio'], meta: { name: 'BmOpsPorMalhaFio' } }
    /**
     * Find zero or one BmOpsPorMalhaFio that matches the filter.
     * @param {BmOpsPorMalhaFioFindUniqueArgs} args - Arguments to find a BmOpsPorMalhaFio
     * @example
     * // Get one BmOpsPorMalhaFio
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmOpsPorMalhaFioFindUniqueArgs>(args: SelectSubset<T, BmOpsPorMalhaFioFindUniqueArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmOpsPorMalhaFio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmOpsPorMalhaFioFindUniqueOrThrowArgs} args - Arguments to find a BmOpsPorMalhaFio
     * @example
     * // Get one BmOpsPorMalhaFio
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmOpsPorMalhaFioFindUniqueOrThrowArgs>(args: SelectSubset<T, BmOpsPorMalhaFioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmOpsPorMalhaFio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFioFindFirstArgs} args - Arguments to find a BmOpsPorMalhaFio
     * @example
     * // Get one BmOpsPorMalhaFio
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmOpsPorMalhaFioFindFirstArgs>(args?: SelectSubset<T, BmOpsPorMalhaFioFindFirstArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmOpsPorMalhaFio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFioFindFirstOrThrowArgs} args - Arguments to find a BmOpsPorMalhaFio
     * @example
     * // Get one BmOpsPorMalhaFio
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmOpsPorMalhaFioFindFirstOrThrowArgs>(args?: SelectSubset<T, BmOpsPorMalhaFioFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmOpsPorMalhaFios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmOpsPorMalhaFios
     * const bmOpsPorMalhaFios = await prisma.bmOpsPorMalhaFio.findMany()
     * 
     * // Get first 10 BmOpsPorMalhaFios
     * const bmOpsPorMalhaFios = await prisma.bmOpsPorMalhaFio.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmOpsPorMalhaFioWithIdBmOnly = await prisma.bmOpsPorMalhaFio.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmOpsPorMalhaFioFindManyArgs>(args?: SelectSubset<T, BmOpsPorMalhaFioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmOpsPorMalhaFio.
     * @param {BmOpsPorMalhaFioCreateArgs} args - Arguments to create a BmOpsPorMalhaFio.
     * @example
     * // Create one BmOpsPorMalhaFio
     * const BmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.create({
     *   data: {
     *     // ... data to create a BmOpsPorMalhaFio
     *   }
     * })
     * 
     */
    create<T extends BmOpsPorMalhaFioCreateArgs>(args: SelectSubset<T, BmOpsPorMalhaFioCreateArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmOpsPorMalhaFios.
     * @param {BmOpsPorMalhaFioCreateManyArgs} args - Arguments to create many BmOpsPorMalhaFios.
     * @example
     * // Create many BmOpsPorMalhaFios
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmOpsPorMalhaFioCreateManyArgs>(args?: SelectSubset<T, BmOpsPorMalhaFioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmOpsPorMalhaFio.
     * @param {BmOpsPorMalhaFioDeleteArgs} args - Arguments to delete one BmOpsPorMalhaFio.
     * @example
     * // Delete one BmOpsPorMalhaFio
     * const BmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.delete({
     *   where: {
     *     // ... filter to delete one BmOpsPorMalhaFio
     *   }
     * })
     * 
     */
    delete<T extends BmOpsPorMalhaFioDeleteArgs>(args: SelectSubset<T, BmOpsPorMalhaFioDeleteArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmOpsPorMalhaFio.
     * @param {BmOpsPorMalhaFioUpdateArgs} args - Arguments to update one BmOpsPorMalhaFio.
     * @example
     * // Update one BmOpsPorMalhaFio
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmOpsPorMalhaFioUpdateArgs>(args: SelectSubset<T, BmOpsPorMalhaFioUpdateArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmOpsPorMalhaFios.
     * @param {BmOpsPorMalhaFioDeleteManyArgs} args - Arguments to filter BmOpsPorMalhaFios to delete.
     * @example
     * // Delete a few BmOpsPorMalhaFios
     * const { count } = await prisma.bmOpsPorMalhaFio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmOpsPorMalhaFioDeleteManyArgs>(args?: SelectSubset<T, BmOpsPorMalhaFioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmOpsPorMalhaFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmOpsPorMalhaFios
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmOpsPorMalhaFioUpdateManyArgs>(args: SelectSubset<T, BmOpsPorMalhaFioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmOpsPorMalhaFio.
     * @param {BmOpsPorMalhaFioUpsertArgs} args - Arguments to update or create a BmOpsPorMalhaFio.
     * @example
     * // Update or create a BmOpsPorMalhaFio
     * const bmOpsPorMalhaFio = await prisma.bmOpsPorMalhaFio.upsert({
     *   create: {
     *     // ... data to create a BmOpsPorMalhaFio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmOpsPorMalhaFio we want to update
     *   }
     * })
     */
    upsert<T extends BmOpsPorMalhaFioUpsertArgs>(args: SelectSubset<T, BmOpsPorMalhaFioUpsertArgs<ExtArgs>>): Prisma__BmOpsPorMalhaFioClient<$Result.GetResult<Prisma.$BmOpsPorMalhaFioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmOpsPorMalhaFios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFioCountArgs} args - Arguments to filter BmOpsPorMalhaFios to count.
     * @example
     * // Count the number of BmOpsPorMalhaFios
     * const count = await prisma.bmOpsPorMalhaFio.count({
     *   where: {
     *     // ... the filter for the BmOpsPorMalhaFios we want to count
     *   }
     * })
    **/
    count<T extends BmOpsPorMalhaFioCountArgs>(
      args?: Subset<T, BmOpsPorMalhaFioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmOpsPorMalhaFioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmOpsPorMalhaFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmOpsPorMalhaFioAggregateArgs>(args: Subset<T, BmOpsPorMalhaFioAggregateArgs>): Prisma.PrismaPromise<GetBmOpsPorMalhaFioAggregateType<T>>

    /**
     * Group by BmOpsPorMalhaFio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmOpsPorMalhaFioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmOpsPorMalhaFioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmOpsPorMalhaFioGroupByArgs['orderBy'] }
        : { orderBy?: BmOpsPorMalhaFioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmOpsPorMalhaFioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmOpsPorMalhaFioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmOpsPorMalhaFio model
   */
  readonly fields: BmOpsPorMalhaFioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmOpsPorMalhaFio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmOpsPorMalhaFioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BmMalhasFioMovimentos<T extends BmOpsPorMalhaFio$BmMalhasFioMovimentosArgs<ExtArgs> = {}>(args?: Subset<T, BmOpsPorMalhaFio$BmMalhasFioMovimentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmMalhasFioMovimentosPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    BmMalhasFio<T extends BmMalhasFioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmMalhasFioDefaultArgs<ExtArgs>>): Prisma__BmMalhasFioClient<$Result.GetResult<Prisma.$BmMalhasFioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    BmOpsPorMalha<T extends BmOpsPorMalhaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmOpsPorMalhaDefaultArgs<ExtArgs>>): Prisma__BmOpsPorMalhaClient<$Result.GetResult<Prisma.$BmOpsPorMalhaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmOpsPorMalhaFio model
   */ 
  interface BmOpsPorMalhaFioFieldRefs {
    readonly idBm: FieldRef<"BmOpsPorMalhaFio", 'String'>
    readonly ref: FieldRef<"BmOpsPorMalhaFio", 'String'>
    readonly refOrigem: FieldRef<"BmOpsPorMalhaFio", 'String'>
    readonly op: FieldRef<"BmOpsPorMalhaFio", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BmOpsPorMalhaFio findUnique
   */
  export type BmOpsPorMalhaFioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalhaFio to fetch.
     */
    where: BmOpsPorMalhaFioWhereUniqueInput
  }

  /**
   * BmOpsPorMalhaFio findUniqueOrThrow
   */
  export type BmOpsPorMalhaFioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalhaFio to fetch.
     */
    where: BmOpsPorMalhaFioWhereUniqueInput
  }

  /**
   * BmOpsPorMalhaFio findFirst
   */
  export type BmOpsPorMalhaFioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalhaFio to fetch.
     */
    where?: BmOpsPorMalhaFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhaFios to fetch.
     */
    orderBy?: BmOpsPorMalhaFioOrderByWithRelationInput | BmOpsPorMalhaFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOpsPorMalhaFios.
     */
    cursor?: BmOpsPorMalhaFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhaFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhaFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOpsPorMalhaFios.
     */
    distinct?: BmOpsPorMalhaFioScalarFieldEnum | BmOpsPorMalhaFioScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalhaFio findFirstOrThrow
   */
  export type BmOpsPorMalhaFioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalhaFio to fetch.
     */
    where?: BmOpsPorMalhaFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhaFios to fetch.
     */
    orderBy?: BmOpsPorMalhaFioOrderByWithRelationInput | BmOpsPorMalhaFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmOpsPorMalhaFios.
     */
    cursor?: BmOpsPorMalhaFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhaFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhaFios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmOpsPorMalhaFios.
     */
    distinct?: BmOpsPorMalhaFioScalarFieldEnum | BmOpsPorMalhaFioScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalhaFio findMany
   */
  export type BmOpsPorMalhaFioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * Filter, which BmOpsPorMalhaFios to fetch.
     */
    where?: BmOpsPorMalhaFioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmOpsPorMalhaFios to fetch.
     */
    orderBy?: BmOpsPorMalhaFioOrderByWithRelationInput | BmOpsPorMalhaFioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmOpsPorMalhaFios.
     */
    cursor?: BmOpsPorMalhaFioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmOpsPorMalhaFios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmOpsPorMalhaFios.
     */
    skip?: number
    distinct?: BmOpsPorMalhaFioScalarFieldEnum | BmOpsPorMalhaFioScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalhaFio create
   */
  export type BmOpsPorMalhaFioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * The data needed to create a BmOpsPorMalhaFio.
     */
    data: XOR<BmOpsPorMalhaFioCreateInput, BmOpsPorMalhaFioUncheckedCreateInput>
  }

  /**
   * BmOpsPorMalhaFio createMany
   */
  export type BmOpsPorMalhaFioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmOpsPorMalhaFios.
     */
    data: BmOpsPorMalhaFioCreateManyInput | BmOpsPorMalhaFioCreateManyInput[]
  }

  /**
   * BmOpsPorMalhaFio update
   */
  export type BmOpsPorMalhaFioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * The data needed to update a BmOpsPorMalhaFio.
     */
    data: XOR<BmOpsPorMalhaFioUpdateInput, BmOpsPorMalhaFioUncheckedUpdateInput>
    /**
     * Choose, which BmOpsPorMalhaFio to update.
     */
    where: BmOpsPorMalhaFioWhereUniqueInput
  }

  /**
   * BmOpsPorMalhaFio updateMany
   */
  export type BmOpsPorMalhaFioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmOpsPorMalhaFios.
     */
    data: XOR<BmOpsPorMalhaFioUpdateManyMutationInput, BmOpsPorMalhaFioUncheckedUpdateManyInput>
    /**
     * Filter which BmOpsPorMalhaFios to update
     */
    where?: BmOpsPorMalhaFioWhereInput
    /**
     * Limit how many BmOpsPorMalhaFios to update.
     */
    limit?: number
  }

  /**
   * BmOpsPorMalhaFio upsert
   */
  export type BmOpsPorMalhaFioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * The filter to search for the BmOpsPorMalhaFio to update in case it exists.
     */
    where: BmOpsPorMalhaFioWhereUniqueInput
    /**
     * In case the BmOpsPorMalhaFio found by the `where` argument doesn't exist, create a new BmOpsPorMalhaFio with this data.
     */
    create: XOR<BmOpsPorMalhaFioCreateInput, BmOpsPorMalhaFioUncheckedCreateInput>
    /**
     * In case the BmOpsPorMalhaFio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmOpsPorMalhaFioUpdateInput, BmOpsPorMalhaFioUncheckedUpdateInput>
  }

  /**
   * BmOpsPorMalhaFio delete
   */
  export type BmOpsPorMalhaFioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
    /**
     * Filter which BmOpsPorMalhaFio to delete.
     */
    where: BmOpsPorMalhaFioWhereUniqueInput
  }

  /**
   * BmOpsPorMalhaFio deleteMany
   */
  export type BmOpsPorMalhaFioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmOpsPorMalhaFios to delete
     */
    where?: BmOpsPorMalhaFioWhereInput
    /**
     * Limit how many BmOpsPorMalhaFios to delete.
     */
    limit?: number
  }

  /**
   * BmOpsPorMalhaFio.BmMalhasFioMovimentos
   */
  export type BmOpsPorMalhaFio$BmMalhasFioMovimentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmMalhasFioMovimentos
     */
    select?: BmMalhasFioMovimentosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmMalhasFioMovimentos
     */
    omit?: BmMalhasFioMovimentosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmMalhasFioMovimentosInclude<ExtArgs> | null
    where?: BmMalhasFioMovimentosWhereInput
    orderBy?: BmMalhasFioMovimentosOrderByWithRelationInput | BmMalhasFioMovimentosOrderByWithRelationInput[]
    cursor?: BmMalhasFioMovimentosWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BmMalhasFioMovimentosScalarFieldEnum | BmMalhasFioMovimentosScalarFieldEnum[]
  }

  /**
   * BmOpsPorMalhaFio without action
   */
  export type BmOpsPorMalhaFioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmOpsPorMalhaFio
     */
    select?: BmOpsPorMalhaFioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmOpsPorMalhaFio
     */
    omit?: BmOpsPorMalhaFioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmOpsPorMalhaFioInclude<ExtArgs> | null
  }


  /**
   * Model BmTc
   */

  export type AggregateBmTc = {
    _count: BmTcCountAggregateOutputType | null
    _min: BmTcMinAggregateOutputType | null
    _max: BmTcMaxAggregateOutputType | null
  }

  export type BmTcMinAggregateOutputType = {
    idBm: string | null
    nomeTc: string | null
  }

  export type BmTcMaxAggregateOutputType = {
    idBm: string | null
    nomeTc: string | null
  }

  export type BmTcCountAggregateOutputType = {
    idBm: number
    nomeTc: number
    _all: number
  }


  export type BmTcMinAggregateInputType = {
    idBm?: true
    nomeTc?: true
  }

  export type BmTcMaxAggregateInputType = {
    idBm?: true
    nomeTc?: true
  }

  export type BmTcCountAggregateInputType = {
    idBm?: true
    nomeTc?: true
    _all?: true
  }

  export type BmTcAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmTc to aggregate.
     */
    where?: BmTcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmTcs to fetch.
     */
    orderBy?: BmTcOrderByWithRelationInput | BmTcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BmTcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmTcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmTcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BmTcs
    **/
    _count?: true | BmTcCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BmTcMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BmTcMaxAggregateInputType
  }

  export type GetBmTcAggregateType<T extends BmTcAggregateArgs> = {
        [P in keyof T & keyof AggregateBmTc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBmTc[P]>
      : GetScalarType<T[P], AggregateBmTc[P]>
  }




  export type BmTcGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BmTcWhereInput
    orderBy?: BmTcOrderByWithAggregationInput | BmTcOrderByWithAggregationInput[]
    by: BmTcScalarFieldEnum[] | BmTcScalarFieldEnum
    having?: BmTcScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BmTcCountAggregateInputType | true
    _min?: BmTcMinAggregateInputType
    _max?: BmTcMaxAggregateInputType
  }

  export type BmTcGroupByOutputType = {
    idBm: string
    nomeTc: string
    _count: BmTcCountAggregateOutputType | null
    _min: BmTcMinAggregateOutputType | null
    _max: BmTcMaxAggregateOutputType | null
  }

  type GetBmTcGroupByPayload<T extends BmTcGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BmTcGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BmTcGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BmTcGroupByOutputType[P]>
            : GetScalarType<T[P], BmTcGroupByOutputType[P]>
        }
      >
    >


  export type BmTcSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idBm?: boolean
    nomeTc?: boolean
    Bm?: boolean | BmDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bmTc"]>



  export type BmTcSelectScalar = {
    idBm?: boolean
    nomeTc?: boolean
  }

  export type BmTcOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idBm" | "nomeTc", ExtArgs["result"]["bmTc"]>
  export type BmTcInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Bm?: boolean | BmDefaultArgs<ExtArgs>
  }

  export type $BmTcPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BmTc"
    objects: {
      Bm: Prisma.$BmPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idBm: string
      nomeTc: string
    }, ExtArgs["result"]["bmTc"]>
    composites: {}
  }

  type BmTcGetPayload<S extends boolean | null | undefined | BmTcDefaultArgs> = $Result.GetResult<Prisma.$BmTcPayload, S>

  type BmTcCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BmTcFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BmTcCountAggregateInputType | true
    }

  export interface BmTcDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BmTc'], meta: { name: 'BmTc' } }
    /**
     * Find zero or one BmTc that matches the filter.
     * @param {BmTcFindUniqueArgs} args - Arguments to find a BmTc
     * @example
     * // Get one BmTc
     * const bmTc = await prisma.bmTc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BmTcFindUniqueArgs>(args: SelectSubset<T, BmTcFindUniqueArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one BmTc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BmTcFindUniqueOrThrowArgs} args - Arguments to find a BmTc
     * @example
     * // Get one BmTc
     * const bmTc = await prisma.bmTc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BmTcFindUniqueOrThrowArgs>(args: SelectSubset<T, BmTcFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first BmTc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmTcFindFirstArgs} args - Arguments to find a BmTc
     * @example
     * // Get one BmTc
     * const bmTc = await prisma.bmTc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BmTcFindFirstArgs>(args?: SelectSubset<T, BmTcFindFirstArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first BmTc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmTcFindFirstOrThrowArgs} args - Arguments to find a BmTc
     * @example
     * // Get one BmTc
     * const bmTc = await prisma.bmTc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BmTcFindFirstOrThrowArgs>(args?: SelectSubset<T, BmTcFindFirstOrThrowArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more BmTcs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmTcFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BmTcs
     * const bmTcs = await prisma.bmTc.findMany()
     * 
     * // Get first 10 BmTcs
     * const bmTcs = await prisma.bmTc.findMany({ take: 10 })
     * 
     * // Only select the `idBm`
     * const bmTcWithIdBmOnly = await prisma.bmTc.findMany({ select: { idBm: true } })
     * 
     */
    findMany<T extends BmTcFindManyArgs>(args?: SelectSubset<T, BmTcFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a BmTc.
     * @param {BmTcCreateArgs} args - Arguments to create a BmTc.
     * @example
     * // Create one BmTc
     * const BmTc = await prisma.bmTc.create({
     *   data: {
     *     // ... data to create a BmTc
     *   }
     * })
     * 
     */
    create<T extends BmTcCreateArgs>(args: SelectSubset<T, BmTcCreateArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many BmTcs.
     * @param {BmTcCreateManyArgs} args - Arguments to create many BmTcs.
     * @example
     * // Create many BmTcs
     * const bmTc = await prisma.bmTc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BmTcCreateManyArgs>(args?: SelectSubset<T, BmTcCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a BmTc.
     * @param {BmTcDeleteArgs} args - Arguments to delete one BmTc.
     * @example
     * // Delete one BmTc
     * const BmTc = await prisma.bmTc.delete({
     *   where: {
     *     // ... filter to delete one BmTc
     *   }
     * })
     * 
     */
    delete<T extends BmTcDeleteArgs>(args: SelectSubset<T, BmTcDeleteArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one BmTc.
     * @param {BmTcUpdateArgs} args - Arguments to update one BmTc.
     * @example
     * // Update one BmTc
     * const bmTc = await prisma.bmTc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BmTcUpdateArgs>(args: SelectSubset<T, BmTcUpdateArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more BmTcs.
     * @param {BmTcDeleteManyArgs} args - Arguments to filter BmTcs to delete.
     * @example
     * // Delete a few BmTcs
     * const { count } = await prisma.bmTc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BmTcDeleteManyArgs>(args?: SelectSubset<T, BmTcDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BmTcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmTcUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BmTcs
     * const bmTc = await prisma.bmTc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BmTcUpdateManyArgs>(args: SelectSubset<T, BmTcUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BmTc.
     * @param {BmTcUpsertArgs} args - Arguments to update or create a BmTc.
     * @example
     * // Update or create a BmTc
     * const bmTc = await prisma.bmTc.upsert({
     *   create: {
     *     // ... data to create a BmTc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BmTc we want to update
     *   }
     * })
     */
    upsert<T extends BmTcUpsertArgs>(args: SelectSubset<T, BmTcUpsertArgs<ExtArgs>>): Prisma__BmTcClient<$Result.GetResult<Prisma.$BmTcPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of BmTcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmTcCountArgs} args - Arguments to filter BmTcs to count.
     * @example
     * // Count the number of BmTcs
     * const count = await prisma.bmTc.count({
     *   where: {
     *     // ... the filter for the BmTcs we want to count
     *   }
     * })
    **/
    count<T extends BmTcCountArgs>(
      args?: Subset<T, BmTcCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BmTcCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BmTc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmTcAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BmTcAggregateArgs>(args: Subset<T, BmTcAggregateArgs>): Prisma.PrismaPromise<GetBmTcAggregateType<T>>

    /**
     * Group by BmTc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BmTcGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BmTcGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BmTcGroupByArgs['orderBy'] }
        : { orderBy?: BmTcGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BmTcGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBmTcGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BmTc model
   */
  readonly fields: BmTcFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BmTc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BmTcClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Bm<T extends BmDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BmDefaultArgs<ExtArgs>>): Prisma__BmClient<$Result.GetResult<Prisma.$BmPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BmTc model
   */ 
  interface BmTcFieldRefs {
    readonly idBm: FieldRef<"BmTc", 'String'>
    readonly nomeTc: FieldRef<"BmTc", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BmTc findUnique
   */
  export type BmTcFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * Filter, which BmTc to fetch.
     */
    where: BmTcWhereUniqueInput
  }

  /**
   * BmTc findUniqueOrThrow
   */
  export type BmTcFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * Filter, which BmTc to fetch.
     */
    where: BmTcWhereUniqueInput
  }

  /**
   * BmTc findFirst
   */
  export type BmTcFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * Filter, which BmTc to fetch.
     */
    where?: BmTcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmTcs to fetch.
     */
    orderBy?: BmTcOrderByWithRelationInput | BmTcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmTcs.
     */
    cursor?: BmTcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmTcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmTcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmTcs.
     */
    distinct?: BmTcScalarFieldEnum | BmTcScalarFieldEnum[]
  }

  /**
   * BmTc findFirstOrThrow
   */
  export type BmTcFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * Filter, which BmTc to fetch.
     */
    where?: BmTcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmTcs to fetch.
     */
    orderBy?: BmTcOrderByWithRelationInput | BmTcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BmTcs.
     */
    cursor?: BmTcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmTcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmTcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BmTcs.
     */
    distinct?: BmTcScalarFieldEnum | BmTcScalarFieldEnum[]
  }

  /**
   * BmTc findMany
   */
  export type BmTcFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * Filter, which BmTcs to fetch.
     */
    where?: BmTcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BmTcs to fetch.
     */
    orderBy?: BmTcOrderByWithRelationInput | BmTcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BmTcs.
     */
    cursor?: BmTcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BmTcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BmTcs.
     */
    skip?: number
    distinct?: BmTcScalarFieldEnum | BmTcScalarFieldEnum[]
  }

  /**
   * BmTc create
   */
  export type BmTcCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * The data needed to create a BmTc.
     */
    data: XOR<BmTcCreateInput, BmTcUncheckedCreateInput>
  }

  /**
   * BmTc createMany
   */
  export type BmTcCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BmTcs.
     */
    data: BmTcCreateManyInput | BmTcCreateManyInput[]
  }

  /**
   * BmTc update
   */
  export type BmTcUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * The data needed to update a BmTc.
     */
    data: XOR<BmTcUpdateInput, BmTcUncheckedUpdateInput>
    /**
     * Choose, which BmTc to update.
     */
    where: BmTcWhereUniqueInput
  }

  /**
   * BmTc updateMany
   */
  export type BmTcUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BmTcs.
     */
    data: XOR<BmTcUpdateManyMutationInput, BmTcUncheckedUpdateManyInput>
    /**
     * Filter which BmTcs to update
     */
    where?: BmTcWhereInput
    /**
     * Limit how many BmTcs to update.
     */
    limit?: number
  }

  /**
   * BmTc upsert
   */
  export type BmTcUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * The filter to search for the BmTc to update in case it exists.
     */
    where: BmTcWhereUniqueInput
    /**
     * In case the BmTc found by the `where` argument doesn't exist, create a new BmTc with this data.
     */
    create: XOR<BmTcCreateInput, BmTcUncheckedCreateInput>
    /**
     * In case the BmTc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BmTcUpdateInput, BmTcUncheckedUpdateInput>
  }

  /**
   * BmTc delete
   */
  export type BmTcDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
    /**
     * Filter which BmTc to delete.
     */
    where: BmTcWhereUniqueInput
  }

  /**
   * BmTc deleteMany
   */
  export type BmTcDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BmTcs to delete
     */
    where?: BmTcWhereInput
    /**
     * Limit how many BmTcs to delete.
     */
    limit?: number
  }

  /**
   * BmTc without action
   */
  export type BmTcDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BmTc
     */
    select?: BmTcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BmTc
     */
    omit?: BmTcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BmTcInclude<ExtArgs> | null
  }


  /**
   * Model DataCamiao
   */

  export type AggregateDataCamiao = {
    _count: DataCamiaoCountAggregateOutputType | null
    _avg: DataCamiaoAvgAggregateOutputType | null
    _sum: DataCamiaoSumAggregateOutputType | null
    _min: DataCamiaoMinAggregateOutputType | null
    _max: DataCamiaoMaxAggregateOutputType | null
  }

  export type DataCamiaoAvgAggregateOutputType = {
    quantidade: number | null
    percentagem: number | null
  }

  export type DataCamiaoSumAggregateOutputType = {
    quantidade: number | null
    percentagem: number | null
  }

  export type DataCamiaoMinAggregateOutputType = {
    idPlaneamento: string | null
    IdCamiao: string | null
    nomeUser: string | null
    dataCamiao: Date | null
    quantidade: number | null
    percentagem: number | null
    obs: string | null
  }

  export type DataCamiaoMaxAggregateOutputType = {
    idPlaneamento: string | null
    IdCamiao: string | null
    nomeUser: string | null
    dataCamiao: Date | null
    quantidade: number | null
    percentagem: number | null
    obs: string | null
  }

  export type DataCamiaoCountAggregateOutputType = {
    idPlaneamento: number
    IdCamiao: number
    nomeUser: number
    dataCamiao: number
    quantidade: number
    percentagem: number
    obs: number
    _all: number
  }


  export type DataCamiaoAvgAggregateInputType = {
    quantidade?: true
    percentagem?: true
  }

  export type DataCamiaoSumAggregateInputType = {
    quantidade?: true
    percentagem?: true
  }

  export type DataCamiaoMinAggregateInputType = {
    idPlaneamento?: true
    IdCamiao?: true
    nomeUser?: true
    dataCamiao?: true
    quantidade?: true
    percentagem?: true
    obs?: true
  }

  export type DataCamiaoMaxAggregateInputType = {
    idPlaneamento?: true
    IdCamiao?: true
    nomeUser?: true
    dataCamiao?: true
    quantidade?: true
    percentagem?: true
    obs?: true
  }

  export type DataCamiaoCountAggregateInputType = {
    idPlaneamento?: true
    IdCamiao?: true
    nomeUser?: true
    dataCamiao?: true
    quantidade?: true
    percentagem?: true
    obs?: true
    _all?: true
  }

  export type DataCamiaoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataCamiao to aggregate.
     */
    where?: DataCamiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataCamiaos to fetch.
     */
    orderBy?: DataCamiaoOrderByWithRelationInput | DataCamiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataCamiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataCamiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataCamiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataCamiaos
    **/
    _count?: true | DataCamiaoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataCamiaoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataCamiaoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataCamiaoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataCamiaoMaxAggregateInputType
  }

  export type GetDataCamiaoAggregateType<T extends DataCamiaoAggregateArgs> = {
        [P in keyof T & keyof AggregateDataCamiao]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataCamiao[P]>
      : GetScalarType<T[P], AggregateDataCamiao[P]>
  }




  export type DataCamiaoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataCamiaoWhereInput
    orderBy?: DataCamiaoOrderByWithAggregationInput | DataCamiaoOrderByWithAggregationInput[]
    by: DataCamiaoScalarFieldEnum[] | DataCamiaoScalarFieldEnum
    having?: DataCamiaoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataCamiaoCountAggregateInputType | true
    _avg?: DataCamiaoAvgAggregateInputType
    _sum?: DataCamiaoSumAggregateInputType
    _min?: DataCamiaoMinAggregateInputType
    _max?: DataCamiaoMaxAggregateInputType
  }

  export type DataCamiaoGroupByOutputType = {
    idPlaneamento: string
    IdCamiao: string
    nomeUser: string
    dataCamiao: Date
    quantidade: number
    percentagem: number
    obs: string
    _count: DataCamiaoCountAggregateOutputType | null
    _avg: DataCamiaoAvgAggregateOutputType | null
    _sum: DataCamiaoSumAggregateOutputType | null
    _min: DataCamiaoMinAggregateOutputType | null
    _max: DataCamiaoMaxAggregateOutputType | null
  }

  type GetDataCamiaoGroupByPayload<T extends DataCamiaoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataCamiaoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataCamiaoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataCamiaoGroupByOutputType[P]>
            : GetScalarType<T[P], DataCamiaoGroupByOutputType[P]>
        }
      >
    >


  export type DataCamiaoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    IdCamiao?: boolean
    nomeUser?: boolean
    dataCamiao?: boolean
    quantidade?: boolean
    percentagem?: boolean
    obs?: boolean
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataCamiao"]>



  export type DataCamiaoSelectScalar = {
    idPlaneamento?: boolean
    IdCamiao?: boolean
    nomeUser?: boolean
    dataCamiao?: boolean
    quantidade?: boolean
    percentagem?: boolean
    obs?: boolean
  }

  export type DataCamiaoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "IdCamiao" | "nomeUser" | "dataCamiao" | "quantidade" | "percentagem" | "obs", ExtArgs["result"]["dataCamiao"]>
  export type DataCamiaoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataCamiaoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataCamiao"
    objects: {
      Planeamento: Prisma.$PlaneamentoPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      IdCamiao: string
      nomeUser: string
      dataCamiao: Date
      quantidade: number
      percentagem: number
      obs: string
    }, ExtArgs["result"]["dataCamiao"]>
    composites: {}
  }

  type DataCamiaoGetPayload<S extends boolean | null | undefined | DataCamiaoDefaultArgs> = $Result.GetResult<Prisma.$DataCamiaoPayload, S>

  type DataCamiaoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataCamiaoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataCamiaoCountAggregateInputType | true
    }

  export interface DataCamiaoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataCamiao'], meta: { name: 'DataCamiao' } }
    /**
     * Find zero or one DataCamiao that matches the filter.
     * @param {DataCamiaoFindUniqueArgs} args - Arguments to find a DataCamiao
     * @example
     * // Get one DataCamiao
     * const dataCamiao = await prisma.dataCamiao.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataCamiaoFindUniqueArgs>(args: SelectSubset<T, DataCamiaoFindUniqueArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DataCamiao that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataCamiaoFindUniqueOrThrowArgs} args - Arguments to find a DataCamiao
     * @example
     * // Get one DataCamiao
     * const dataCamiao = await prisma.dataCamiao.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataCamiaoFindUniqueOrThrowArgs>(args: SelectSubset<T, DataCamiaoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DataCamiao that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataCamiaoFindFirstArgs} args - Arguments to find a DataCamiao
     * @example
     * // Get one DataCamiao
     * const dataCamiao = await prisma.dataCamiao.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataCamiaoFindFirstArgs>(args?: SelectSubset<T, DataCamiaoFindFirstArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DataCamiao that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataCamiaoFindFirstOrThrowArgs} args - Arguments to find a DataCamiao
     * @example
     * // Get one DataCamiao
     * const dataCamiao = await prisma.dataCamiao.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataCamiaoFindFirstOrThrowArgs>(args?: SelectSubset<T, DataCamiaoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataCamiaos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataCamiaoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataCamiaos
     * const dataCamiaos = await prisma.dataCamiao.findMany()
     * 
     * // Get first 10 DataCamiaos
     * const dataCamiaos = await prisma.dataCamiao.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const dataCamiaoWithIdPlaneamentoOnly = await prisma.dataCamiao.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends DataCamiaoFindManyArgs>(args?: SelectSubset<T, DataCamiaoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DataCamiao.
     * @param {DataCamiaoCreateArgs} args - Arguments to create a DataCamiao.
     * @example
     * // Create one DataCamiao
     * const DataCamiao = await prisma.dataCamiao.create({
     *   data: {
     *     // ... data to create a DataCamiao
     *   }
     * })
     * 
     */
    create<T extends DataCamiaoCreateArgs>(args: SelectSubset<T, DataCamiaoCreateArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DataCamiaos.
     * @param {DataCamiaoCreateManyArgs} args - Arguments to create many DataCamiaos.
     * @example
     * // Create many DataCamiaos
     * const dataCamiao = await prisma.dataCamiao.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataCamiaoCreateManyArgs>(args?: SelectSubset<T, DataCamiaoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataCamiao.
     * @param {DataCamiaoDeleteArgs} args - Arguments to delete one DataCamiao.
     * @example
     * // Delete one DataCamiao
     * const DataCamiao = await prisma.dataCamiao.delete({
     *   where: {
     *     // ... filter to delete one DataCamiao
     *   }
     * })
     * 
     */
    delete<T extends DataCamiaoDeleteArgs>(args: SelectSubset<T, DataCamiaoDeleteArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DataCamiao.
     * @param {DataCamiaoUpdateArgs} args - Arguments to update one DataCamiao.
     * @example
     * // Update one DataCamiao
     * const dataCamiao = await prisma.dataCamiao.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataCamiaoUpdateArgs>(args: SelectSubset<T, DataCamiaoUpdateArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DataCamiaos.
     * @param {DataCamiaoDeleteManyArgs} args - Arguments to filter DataCamiaos to delete.
     * @example
     * // Delete a few DataCamiaos
     * const { count } = await prisma.dataCamiao.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataCamiaoDeleteManyArgs>(args?: SelectSubset<T, DataCamiaoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataCamiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataCamiaoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataCamiaos
     * const dataCamiao = await prisma.dataCamiao.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataCamiaoUpdateManyArgs>(args: SelectSubset<T, DataCamiaoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataCamiao.
     * @param {DataCamiaoUpsertArgs} args - Arguments to update or create a DataCamiao.
     * @example
     * // Update or create a DataCamiao
     * const dataCamiao = await prisma.dataCamiao.upsert({
     *   create: {
     *     // ... data to create a DataCamiao
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataCamiao we want to update
     *   }
     * })
     */
    upsert<T extends DataCamiaoUpsertArgs>(args: SelectSubset<T, DataCamiaoUpsertArgs<ExtArgs>>): Prisma__DataCamiaoClient<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DataCamiaos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataCamiaoCountArgs} args - Arguments to filter DataCamiaos to count.
     * @example
     * // Count the number of DataCamiaos
     * const count = await prisma.dataCamiao.count({
     *   where: {
     *     // ... the filter for the DataCamiaos we want to count
     *   }
     * })
    **/
    count<T extends DataCamiaoCountArgs>(
      args?: Subset<T, DataCamiaoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataCamiaoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataCamiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataCamiaoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataCamiaoAggregateArgs>(args: Subset<T, DataCamiaoAggregateArgs>): Prisma.PrismaPromise<GetDataCamiaoAggregateType<T>>

    /**
     * Group by DataCamiao.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataCamiaoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataCamiaoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataCamiaoGroupByArgs['orderBy'] }
        : { orderBy?: DataCamiaoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataCamiaoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataCamiaoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataCamiao model
   */
  readonly fields: DataCamiaoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataCamiao.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataCamiaoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Planeamento<T extends PlaneamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaneamentoDefaultArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataCamiao model
   */ 
  interface DataCamiaoFieldRefs {
    readonly idPlaneamento: FieldRef<"DataCamiao", 'String'>
    readonly IdCamiao: FieldRef<"DataCamiao", 'String'>
    readonly nomeUser: FieldRef<"DataCamiao", 'String'>
    readonly dataCamiao: FieldRef<"DataCamiao", 'DateTime'>
    readonly quantidade: FieldRef<"DataCamiao", 'Int'>
    readonly percentagem: FieldRef<"DataCamiao", 'Float'>
    readonly obs: FieldRef<"DataCamiao", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DataCamiao findUnique
   */
  export type DataCamiaoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * Filter, which DataCamiao to fetch.
     */
    where: DataCamiaoWhereUniqueInput
  }

  /**
   * DataCamiao findUniqueOrThrow
   */
  export type DataCamiaoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * Filter, which DataCamiao to fetch.
     */
    where: DataCamiaoWhereUniqueInput
  }

  /**
   * DataCamiao findFirst
   */
  export type DataCamiaoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * Filter, which DataCamiao to fetch.
     */
    where?: DataCamiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataCamiaos to fetch.
     */
    orderBy?: DataCamiaoOrderByWithRelationInput | DataCamiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataCamiaos.
     */
    cursor?: DataCamiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataCamiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataCamiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataCamiaos.
     */
    distinct?: DataCamiaoScalarFieldEnum | DataCamiaoScalarFieldEnum[]
  }

  /**
   * DataCamiao findFirstOrThrow
   */
  export type DataCamiaoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * Filter, which DataCamiao to fetch.
     */
    where?: DataCamiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataCamiaos to fetch.
     */
    orderBy?: DataCamiaoOrderByWithRelationInput | DataCamiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataCamiaos.
     */
    cursor?: DataCamiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataCamiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataCamiaos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataCamiaos.
     */
    distinct?: DataCamiaoScalarFieldEnum | DataCamiaoScalarFieldEnum[]
  }

  /**
   * DataCamiao findMany
   */
  export type DataCamiaoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * Filter, which DataCamiaos to fetch.
     */
    where?: DataCamiaoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataCamiaos to fetch.
     */
    orderBy?: DataCamiaoOrderByWithRelationInput | DataCamiaoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataCamiaos.
     */
    cursor?: DataCamiaoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataCamiaos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataCamiaos.
     */
    skip?: number
    distinct?: DataCamiaoScalarFieldEnum | DataCamiaoScalarFieldEnum[]
  }

  /**
   * DataCamiao create
   */
  export type DataCamiaoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * The data needed to create a DataCamiao.
     */
    data: XOR<DataCamiaoCreateInput, DataCamiaoUncheckedCreateInput>
  }

  /**
   * DataCamiao createMany
   */
  export type DataCamiaoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataCamiaos.
     */
    data: DataCamiaoCreateManyInput | DataCamiaoCreateManyInput[]
  }

  /**
   * DataCamiao update
   */
  export type DataCamiaoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * The data needed to update a DataCamiao.
     */
    data: XOR<DataCamiaoUpdateInput, DataCamiaoUncheckedUpdateInput>
    /**
     * Choose, which DataCamiao to update.
     */
    where: DataCamiaoWhereUniqueInput
  }

  /**
   * DataCamiao updateMany
   */
  export type DataCamiaoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataCamiaos.
     */
    data: XOR<DataCamiaoUpdateManyMutationInput, DataCamiaoUncheckedUpdateManyInput>
    /**
     * Filter which DataCamiaos to update
     */
    where?: DataCamiaoWhereInput
    /**
     * Limit how many DataCamiaos to update.
     */
    limit?: number
  }

  /**
   * DataCamiao upsert
   */
  export type DataCamiaoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * The filter to search for the DataCamiao to update in case it exists.
     */
    where: DataCamiaoWhereUniqueInput
    /**
     * In case the DataCamiao found by the `where` argument doesn't exist, create a new DataCamiao with this data.
     */
    create: XOR<DataCamiaoCreateInput, DataCamiaoUncheckedCreateInput>
    /**
     * In case the DataCamiao was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataCamiaoUpdateInput, DataCamiaoUncheckedUpdateInput>
  }

  /**
   * DataCamiao delete
   */
  export type DataCamiaoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    /**
     * Filter which DataCamiao to delete.
     */
    where: DataCamiaoWhereUniqueInput
  }

  /**
   * DataCamiao deleteMany
   */
  export type DataCamiaoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataCamiaos to delete
     */
    where?: DataCamiaoWhereInput
    /**
     * Limit how many DataCamiaos to delete.
     */
    limit?: number
  }

  /**
   * DataCamiao without action
   */
  export type DataCamiaoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
  }


  /**
   * Model DataEnvio
   */

  export type AggregateDataEnvio = {
    _count: DataEnvioCountAggregateOutputType | null
    _avg: DataEnvioAvgAggregateOutputType | null
    _sum: DataEnvioSumAggregateOutputType | null
    _min: DataEnvioMinAggregateOutputType | null
    _max: DataEnvioMaxAggregateOutputType | null
  }

  export type DataEnvioAvgAggregateOutputType = {
    quantidade: number | null
    percentagem: number | null
  }

  export type DataEnvioSumAggregateOutputType = {
    quantidade: number | null
    percentagem: number | null
  }

  export type DataEnvioMinAggregateOutputType = {
    idPlaneamento: string | null
    idEnvio: string | null
    nomeUser: string | null
    dataEnvio: Date | null
    quantidade: number | null
    percentagem: number | null
    obs: string | null
  }

  export type DataEnvioMaxAggregateOutputType = {
    idPlaneamento: string | null
    idEnvio: string | null
    nomeUser: string | null
    dataEnvio: Date | null
    quantidade: number | null
    percentagem: number | null
    obs: string | null
  }

  export type DataEnvioCountAggregateOutputType = {
    idPlaneamento: number
    idEnvio: number
    nomeUser: number
    dataEnvio: number
    quantidade: number
    percentagem: number
    obs: number
    _all: number
  }


  export type DataEnvioAvgAggregateInputType = {
    quantidade?: true
    percentagem?: true
  }

  export type DataEnvioSumAggregateInputType = {
    quantidade?: true
    percentagem?: true
  }

  export type DataEnvioMinAggregateInputType = {
    idPlaneamento?: true
    idEnvio?: true
    nomeUser?: true
    dataEnvio?: true
    quantidade?: true
    percentagem?: true
    obs?: true
  }

  export type DataEnvioMaxAggregateInputType = {
    idPlaneamento?: true
    idEnvio?: true
    nomeUser?: true
    dataEnvio?: true
    quantidade?: true
    percentagem?: true
    obs?: true
  }

  export type DataEnvioCountAggregateInputType = {
    idPlaneamento?: true
    idEnvio?: true
    nomeUser?: true
    dataEnvio?: true
    quantidade?: true
    percentagem?: true
    obs?: true
    _all?: true
  }

  export type DataEnvioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataEnvio to aggregate.
     */
    where?: DataEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataEnvios to fetch.
     */
    orderBy?: DataEnvioOrderByWithRelationInput | DataEnvioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataEnvios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataEnvios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataEnvios
    **/
    _count?: true | DataEnvioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DataEnvioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DataEnvioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataEnvioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataEnvioMaxAggregateInputType
  }

  export type GetDataEnvioAggregateType<T extends DataEnvioAggregateArgs> = {
        [P in keyof T & keyof AggregateDataEnvio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataEnvio[P]>
      : GetScalarType<T[P], AggregateDataEnvio[P]>
  }




  export type DataEnvioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataEnvioWhereInput
    orderBy?: DataEnvioOrderByWithAggregationInput | DataEnvioOrderByWithAggregationInput[]
    by: DataEnvioScalarFieldEnum[] | DataEnvioScalarFieldEnum
    having?: DataEnvioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataEnvioCountAggregateInputType | true
    _avg?: DataEnvioAvgAggregateInputType
    _sum?: DataEnvioSumAggregateInputType
    _min?: DataEnvioMinAggregateInputType
    _max?: DataEnvioMaxAggregateInputType
  }

  export type DataEnvioGroupByOutputType = {
    idPlaneamento: string
    idEnvio: string
    nomeUser: string
    dataEnvio: Date
    quantidade: number
    percentagem: number
    obs: string
    _count: DataEnvioCountAggregateOutputType | null
    _avg: DataEnvioAvgAggregateOutputType | null
    _sum: DataEnvioSumAggregateOutputType | null
    _min: DataEnvioMinAggregateOutputType | null
    _max: DataEnvioMaxAggregateOutputType | null
  }

  type GetDataEnvioGroupByPayload<T extends DataEnvioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataEnvioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataEnvioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataEnvioGroupByOutputType[P]>
            : GetScalarType<T[P], DataEnvioGroupByOutputType[P]>
        }
      >
    >


  export type DataEnvioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    idEnvio?: boolean
    nomeUser?: boolean
    dataEnvio?: boolean
    quantidade?: boolean
    percentagem?: boolean
    obs?: boolean
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataEnvio"]>



  export type DataEnvioSelectScalar = {
    idPlaneamento?: boolean
    idEnvio?: boolean
    nomeUser?: boolean
    dataEnvio?: boolean
    quantidade?: boolean
    percentagem?: boolean
    obs?: boolean
  }

  export type DataEnvioOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "idEnvio" | "nomeUser" | "dataEnvio" | "quantidade" | "percentagem" | "obs", ExtArgs["result"]["dataEnvio"]>
  export type DataEnvioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DataEnvioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataEnvio"
    objects: {
      Planeamento: Prisma.$PlaneamentoPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      idEnvio: string
      nomeUser: string
      dataEnvio: Date
      quantidade: number
      percentagem: number
      obs: string
    }, ExtArgs["result"]["dataEnvio"]>
    composites: {}
  }

  type DataEnvioGetPayload<S extends boolean | null | undefined | DataEnvioDefaultArgs> = $Result.GetResult<Prisma.$DataEnvioPayload, S>

  type DataEnvioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DataEnvioFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DataEnvioCountAggregateInputType | true
    }

  export interface DataEnvioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataEnvio'], meta: { name: 'DataEnvio' } }
    /**
     * Find zero or one DataEnvio that matches the filter.
     * @param {DataEnvioFindUniqueArgs} args - Arguments to find a DataEnvio
     * @example
     * // Get one DataEnvio
     * const dataEnvio = await prisma.dataEnvio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataEnvioFindUniqueArgs>(args: SelectSubset<T, DataEnvioFindUniqueArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one DataEnvio that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DataEnvioFindUniqueOrThrowArgs} args - Arguments to find a DataEnvio
     * @example
     * // Get one DataEnvio
     * const dataEnvio = await prisma.dataEnvio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataEnvioFindUniqueOrThrowArgs>(args: SelectSubset<T, DataEnvioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first DataEnvio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataEnvioFindFirstArgs} args - Arguments to find a DataEnvio
     * @example
     * // Get one DataEnvio
     * const dataEnvio = await prisma.dataEnvio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataEnvioFindFirstArgs>(args?: SelectSubset<T, DataEnvioFindFirstArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first DataEnvio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataEnvioFindFirstOrThrowArgs} args - Arguments to find a DataEnvio
     * @example
     * // Get one DataEnvio
     * const dataEnvio = await prisma.dataEnvio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataEnvioFindFirstOrThrowArgs>(args?: SelectSubset<T, DataEnvioFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more DataEnvios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataEnvioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataEnvios
     * const dataEnvios = await prisma.dataEnvio.findMany()
     * 
     * // Get first 10 DataEnvios
     * const dataEnvios = await prisma.dataEnvio.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const dataEnvioWithIdPlaneamentoOnly = await prisma.dataEnvio.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends DataEnvioFindManyArgs>(args?: SelectSubset<T, DataEnvioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a DataEnvio.
     * @param {DataEnvioCreateArgs} args - Arguments to create a DataEnvio.
     * @example
     * // Create one DataEnvio
     * const DataEnvio = await prisma.dataEnvio.create({
     *   data: {
     *     // ... data to create a DataEnvio
     *   }
     * })
     * 
     */
    create<T extends DataEnvioCreateArgs>(args: SelectSubset<T, DataEnvioCreateArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many DataEnvios.
     * @param {DataEnvioCreateManyArgs} args - Arguments to create many DataEnvios.
     * @example
     * // Create many DataEnvios
     * const dataEnvio = await prisma.dataEnvio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataEnvioCreateManyArgs>(args?: SelectSubset<T, DataEnvioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DataEnvio.
     * @param {DataEnvioDeleteArgs} args - Arguments to delete one DataEnvio.
     * @example
     * // Delete one DataEnvio
     * const DataEnvio = await prisma.dataEnvio.delete({
     *   where: {
     *     // ... filter to delete one DataEnvio
     *   }
     * })
     * 
     */
    delete<T extends DataEnvioDeleteArgs>(args: SelectSubset<T, DataEnvioDeleteArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one DataEnvio.
     * @param {DataEnvioUpdateArgs} args - Arguments to update one DataEnvio.
     * @example
     * // Update one DataEnvio
     * const dataEnvio = await prisma.dataEnvio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataEnvioUpdateArgs>(args: SelectSubset<T, DataEnvioUpdateArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more DataEnvios.
     * @param {DataEnvioDeleteManyArgs} args - Arguments to filter DataEnvios to delete.
     * @example
     * // Delete a few DataEnvios
     * const { count } = await prisma.dataEnvio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataEnvioDeleteManyArgs>(args?: SelectSubset<T, DataEnvioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataEnvios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataEnvioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataEnvios
     * const dataEnvio = await prisma.dataEnvio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataEnvioUpdateManyArgs>(args: SelectSubset<T, DataEnvioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataEnvio.
     * @param {DataEnvioUpsertArgs} args - Arguments to update or create a DataEnvio.
     * @example
     * // Update or create a DataEnvio
     * const dataEnvio = await prisma.dataEnvio.upsert({
     *   create: {
     *     // ... data to create a DataEnvio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataEnvio we want to update
     *   }
     * })
     */
    upsert<T extends DataEnvioUpsertArgs>(args: SelectSubset<T, DataEnvioUpsertArgs<ExtArgs>>): Prisma__DataEnvioClient<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of DataEnvios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataEnvioCountArgs} args - Arguments to filter DataEnvios to count.
     * @example
     * // Count the number of DataEnvios
     * const count = await prisma.dataEnvio.count({
     *   where: {
     *     // ... the filter for the DataEnvios we want to count
     *   }
     * })
    **/
    count<T extends DataEnvioCountArgs>(
      args?: Subset<T, DataEnvioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataEnvioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataEnvio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataEnvioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataEnvioAggregateArgs>(args: Subset<T, DataEnvioAggregateArgs>): Prisma.PrismaPromise<GetDataEnvioAggregateType<T>>

    /**
     * Group by DataEnvio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataEnvioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataEnvioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataEnvioGroupByArgs['orderBy'] }
        : { orderBy?: DataEnvioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataEnvioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataEnvioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataEnvio model
   */
  readonly fields: DataEnvioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataEnvio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataEnvioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Planeamento<T extends PlaneamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaneamentoDefaultArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataEnvio model
   */ 
  interface DataEnvioFieldRefs {
    readonly idPlaneamento: FieldRef<"DataEnvio", 'String'>
    readonly idEnvio: FieldRef<"DataEnvio", 'String'>
    readonly nomeUser: FieldRef<"DataEnvio", 'String'>
    readonly dataEnvio: FieldRef<"DataEnvio", 'DateTime'>
    readonly quantidade: FieldRef<"DataEnvio", 'Int'>
    readonly percentagem: FieldRef<"DataEnvio", 'Float'>
    readonly obs: FieldRef<"DataEnvio", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DataEnvio findUnique
   */
  export type DataEnvioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * Filter, which DataEnvio to fetch.
     */
    where: DataEnvioWhereUniqueInput
  }

  /**
   * DataEnvio findUniqueOrThrow
   */
  export type DataEnvioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * Filter, which DataEnvio to fetch.
     */
    where: DataEnvioWhereUniqueInput
  }

  /**
   * DataEnvio findFirst
   */
  export type DataEnvioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * Filter, which DataEnvio to fetch.
     */
    where?: DataEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataEnvios to fetch.
     */
    orderBy?: DataEnvioOrderByWithRelationInput | DataEnvioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataEnvios.
     */
    cursor?: DataEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataEnvios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataEnvios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataEnvios.
     */
    distinct?: DataEnvioScalarFieldEnum | DataEnvioScalarFieldEnum[]
  }

  /**
   * DataEnvio findFirstOrThrow
   */
  export type DataEnvioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * Filter, which DataEnvio to fetch.
     */
    where?: DataEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataEnvios to fetch.
     */
    orderBy?: DataEnvioOrderByWithRelationInput | DataEnvioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataEnvios.
     */
    cursor?: DataEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataEnvios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataEnvios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataEnvios.
     */
    distinct?: DataEnvioScalarFieldEnum | DataEnvioScalarFieldEnum[]
  }

  /**
   * DataEnvio findMany
   */
  export type DataEnvioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * Filter, which DataEnvios to fetch.
     */
    where?: DataEnvioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataEnvios to fetch.
     */
    orderBy?: DataEnvioOrderByWithRelationInput | DataEnvioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataEnvios.
     */
    cursor?: DataEnvioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataEnvios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataEnvios.
     */
    skip?: number
    distinct?: DataEnvioScalarFieldEnum | DataEnvioScalarFieldEnum[]
  }

  /**
   * DataEnvio create
   */
  export type DataEnvioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * The data needed to create a DataEnvio.
     */
    data: XOR<DataEnvioCreateInput, DataEnvioUncheckedCreateInput>
  }

  /**
   * DataEnvio createMany
   */
  export type DataEnvioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataEnvios.
     */
    data: DataEnvioCreateManyInput | DataEnvioCreateManyInput[]
  }

  /**
   * DataEnvio update
   */
  export type DataEnvioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * The data needed to update a DataEnvio.
     */
    data: XOR<DataEnvioUpdateInput, DataEnvioUncheckedUpdateInput>
    /**
     * Choose, which DataEnvio to update.
     */
    where: DataEnvioWhereUniqueInput
  }

  /**
   * DataEnvio updateMany
   */
  export type DataEnvioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataEnvios.
     */
    data: XOR<DataEnvioUpdateManyMutationInput, DataEnvioUncheckedUpdateManyInput>
    /**
     * Filter which DataEnvios to update
     */
    where?: DataEnvioWhereInput
    /**
     * Limit how many DataEnvios to update.
     */
    limit?: number
  }

  /**
   * DataEnvio upsert
   */
  export type DataEnvioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * The filter to search for the DataEnvio to update in case it exists.
     */
    where: DataEnvioWhereUniqueInput
    /**
     * In case the DataEnvio found by the `where` argument doesn't exist, create a new DataEnvio with this data.
     */
    create: XOR<DataEnvioCreateInput, DataEnvioUncheckedCreateInput>
    /**
     * In case the DataEnvio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataEnvioUpdateInput, DataEnvioUncheckedUpdateInput>
  }

  /**
   * DataEnvio delete
   */
  export type DataEnvioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    /**
     * Filter which DataEnvio to delete.
     */
    where: DataEnvioWhereUniqueInput
  }

  /**
   * DataEnvio deleteMany
   */
  export type DataEnvioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataEnvios to delete
     */
    where?: DataEnvioWhereInput
    /**
     * Limit how many DataEnvios to delete.
     */
    limit?: number
  }

  /**
   * DataEnvio without action
   */
  export type DataEnvioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
  }


  /**
   * Model Fornecedor
   */

  export type AggregateFornecedor = {
    _count: FornecedorCountAggregateOutputType | null
    _min: FornecedorMinAggregateOutputType | null
    _max: FornecedorMaxAggregateOutputType | null
  }

  export type FornecedorMinAggregateOutputType = {
    idFornecedor: string | null
    nomeFornecedor: string | null
  }

  export type FornecedorMaxAggregateOutputType = {
    idFornecedor: string | null
    nomeFornecedor: string | null
  }

  export type FornecedorCountAggregateOutputType = {
    idFornecedor: number
    nomeFornecedor: number
    _all: number
  }


  export type FornecedorMinAggregateInputType = {
    idFornecedor?: true
    nomeFornecedor?: true
  }

  export type FornecedorMaxAggregateInputType = {
    idFornecedor?: true
    nomeFornecedor?: true
  }

  export type FornecedorCountAggregateInputType = {
    idFornecedor?: true
    nomeFornecedor?: true
    _all?: true
  }

  export type FornecedorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fornecedor to aggregate.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fornecedors
    **/
    _count?: true | FornecedorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FornecedorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FornecedorMaxAggregateInputType
  }

  export type GetFornecedorAggregateType<T extends FornecedorAggregateArgs> = {
        [P in keyof T & keyof AggregateFornecedor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFornecedor[P]>
      : GetScalarType<T[P], AggregateFornecedor[P]>
  }




  export type FornecedorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FornecedorWhereInput
    orderBy?: FornecedorOrderByWithAggregationInput | FornecedorOrderByWithAggregationInput[]
    by: FornecedorScalarFieldEnum[] | FornecedorScalarFieldEnum
    having?: FornecedorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FornecedorCountAggregateInputType | true
    _min?: FornecedorMinAggregateInputType
    _max?: FornecedorMaxAggregateInputType
  }

  export type FornecedorGroupByOutputType = {
    idFornecedor: string
    nomeFornecedor: string
    _count: FornecedorCountAggregateOutputType | null
    _min: FornecedorMinAggregateOutputType | null
    _max: FornecedorMaxAggregateOutputType | null
  }

  type GetFornecedorGroupByPayload<T extends FornecedorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FornecedorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FornecedorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FornecedorGroupByOutputType[P]>
            : GetScalarType<T[P], FornecedorGroupByOutputType[P]>
        }
      >
    >


  export type FornecedorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idFornecedor?: boolean
    nomeFornecedor?: boolean
    Planeamento?: boolean | Fornecedor$PlaneamentoArgs<ExtArgs>
    _count?: boolean | FornecedorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fornecedor"]>



  export type FornecedorSelectScalar = {
    idFornecedor?: boolean
    nomeFornecedor?: boolean
  }

  export type FornecedorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idFornecedor" | "nomeFornecedor", ExtArgs["result"]["fornecedor"]>
  export type FornecedorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planeamento?: boolean | Fornecedor$PlaneamentoArgs<ExtArgs>
    _count?: boolean | FornecedorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FornecedorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fornecedor"
    objects: {
      Planeamento: Prisma.$PlaneamentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idFornecedor: string
      nomeFornecedor: string
    }, ExtArgs["result"]["fornecedor"]>
    composites: {}
  }

  type FornecedorGetPayload<S extends boolean | null | undefined | FornecedorDefaultArgs> = $Result.GetResult<Prisma.$FornecedorPayload, S>

  type FornecedorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FornecedorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FornecedorCountAggregateInputType | true
    }

  export interface FornecedorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fornecedor'], meta: { name: 'Fornecedor' } }
    /**
     * Find zero or one Fornecedor that matches the filter.
     * @param {FornecedorFindUniqueArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FornecedorFindUniqueArgs>(args: SelectSubset<T, FornecedorFindUniqueArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Fornecedor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FornecedorFindUniqueOrThrowArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FornecedorFindUniqueOrThrowArgs>(args: SelectSubset<T, FornecedorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Fornecedor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorFindFirstArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FornecedorFindFirstArgs>(args?: SelectSubset<T, FornecedorFindFirstArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Fornecedor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorFindFirstOrThrowArgs} args - Arguments to find a Fornecedor
     * @example
     * // Get one Fornecedor
     * const fornecedor = await prisma.fornecedor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FornecedorFindFirstOrThrowArgs>(args?: SelectSubset<T, FornecedorFindFirstOrThrowArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Fornecedors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fornecedors
     * const fornecedors = await prisma.fornecedor.findMany()
     * 
     * // Get first 10 Fornecedors
     * const fornecedors = await prisma.fornecedor.findMany({ take: 10 })
     * 
     * // Only select the `idFornecedor`
     * const fornecedorWithIdFornecedorOnly = await prisma.fornecedor.findMany({ select: { idFornecedor: true } })
     * 
     */
    findMany<T extends FornecedorFindManyArgs>(args?: SelectSubset<T, FornecedorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Fornecedor.
     * @param {FornecedorCreateArgs} args - Arguments to create a Fornecedor.
     * @example
     * // Create one Fornecedor
     * const Fornecedor = await prisma.fornecedor.create({
     *   data: {
     *     // ... data to create a Fornecedor
     *   }
     * })
     * 
     */
    create<T extends FornecedorCreateArgs>(args: SelectSubset<T, FornecedorCreateArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Fornecedors.
     * @param {FornecedorCreateManyArgs} args - Arguments to create many Fornecedors.
     * @example
     * // Create many Fornecedors
     * const fornecedor = await prisma.fornecedor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FornecedorCreateManyArgs>(args?: SelectSubset<T, FornecedorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fornecedor.
     * @param {FornecedorDeleteArgs} args - Arguments to delete one Fornecedor.
     * @example
     * // Delete one Fornecedor
     * const Fornecedor = await prisma.fornecedor.delete({
     *   where: {
     *     // ... filter to delete one Fornecedor
     *   }
     * })
     * 
     */
    delete<T extends FornecedorDeleteArgs>(args: SelectSubset<T, FornecedorDeleteArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Fornecedor.
     * @param {FornecedorUpdateArgs} args - Arguments to update one Fornecedor.
     * @example
     * // Update one Fornecedor
     * const fornecedor = await prisma.fornecedor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FornecedorUpdateArgs>(args: SelectSubset<T, FornecedorUpdateArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Fornecedors.
     * @param {FornecedorDeleteManyArgs} args - Arguments to filter Fornecedors to delete.
     * @example
     * // Delete a few Fornecedors
     * const { count } = await prisma.fornecedor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FornecedorDeleteManyArgs>(args?: SelectSubset<T, FornecedorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fornecedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fornecedors
     * const fornecedor = await prisma.fornecedor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FornecedorUpdateManyArgs>(args: SelectSubset<T, FornecedorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fornecedor.
     * @param {FornecedorUpsertArgs} args - Arguments to update or create a Fornecedor.
     * @example
     * // Update or create a Fornecedor
     * const fornecedor = await prisma.fornecedor.upsert({
     *   create: {
     *     // ... data to create a Fornecedor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fornecedor we want to update
     *   }
     * })
     */
    upsert<T extends FornecedorUpsertArgs>(args: SelectSubset<T, FornecedorUpsertArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Fornecedors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorCountArgs} args - Arguments to filter Fornecedors to count.
     * @example
     * // Count the number of Fornecedors
     * const count = await prisma.fornecedor.count({
     *   where: {
     *     // ... the filter for the Fornecedors we want to count
     *   }
     * })
    **/
    count<T extends FornecedorCountArgs>(
      args?: Subset<T, FornecedorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FornecedorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fornecedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FornecedorAggregateArgs>(args: Subset<T, FornecedorAggregateArgs>): Prisma.PrismaPromise<GetFornecedorAggregateType<T>>

    /**
     * Group by Fornecedor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FornecedorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FornecedorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FornecedorGroupByArgs['orderBy'] }
        : { orderBy?: FornecedorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FornecedorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFornecedorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fornecedor model
   */
  readonly fields: FornecedorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fornecedor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FornecedorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Planeamento<T extends Fornecedor$PlaneamentoArgs<ExtArgs> = {}>(args?: Subset<T, Fornecedor$PlaneamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fornecedor model
   */ 
  interface FornecedorFieldRefs {
    readonly idFornecedor: FieldRef<"Fornecedor", 'String'>
    readonly nomeFornecedor: FieldRef<"Fornecedor", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Fornecedor findUnique
   */
  export type FornecedorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor findUniqueOrThrow
   */
  export type FornecedorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor findFirst
   */
  export type FornecedorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fornecedors.
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fornecedors.
     */
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * Fornecedor findFirstOrThrow
   */
  export type FornecedorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedor to fetch.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fornecedors.
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fornecedors.
     */
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * Fornecedor findMany
   */
  export type FornecedorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter, which Fornecedors to fetch.
     */
    where?: FornecedorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fornecedors to fetch.
     */
    orderBy?: FornecedorOrderByWithRelationInput | FornecedorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fornecedors.
     */
    cursor?: FornecedorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fornecedors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fornecedors.
     */
    skip?: number
    distinct?: FornecedorScalarFieldEnum | FornecedorScalarFieldEnum[]
  }

  /**
   * Fornecedor create
   */
  export type FornecedorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * The data needed to create a Fornecedor.
     */
    data: XOR<FornecedorCreateInput, FornecedorUncheckedCreateInput>
  }

  /**
   * Fornecedor createMany
   */
  export type FornecedorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fornecedors.
     */
    data: FornecedorCreateManyInput | FornecedorCreateManyInput[]
  }

  /**
   * Fornecedor update
   */
  export type FornecedorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * The data needed to update a Fornecedor.
     */
    data: XOR<FornecedorUpdateInput, FornecedorUncheckedUpdateInput>
    /**
     * Choose, which Fornecedor to update.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor updateMany
   */
  export type FornecedorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fornecedors.
     */
    data: XOR<FornecedorUpdateManyMutationInput, FornecedorUncheckedUpdateManyInput>
    /**
     * Filter which Fornecedors to update
     */
    where?: FornecedorWhereInput
    /**
     * Limit how many Fornecedors to update.
     */
    limit?: number
  }

  /**
   * Fornecedor upsert
   */
  export type FornecedorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * The filter to search for the Fornecedor to update in case it exists.
     */
    where: FornecedorWhereUniqueInput
    /**
     * In case the Fornecedor found by the `where` argument doesn't exist, create a new Fornecedor with this data.
     */
    create: XOR<FornecedorCreateInput, FornecedorUncheckedCreateInput>
    /**
     * In case the Fornecedor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FornecedorUpdateInput, FornecedorUncheckedUpdateInput>
  }

  /**
   * Fornecedor delete
   */
  export type FornecedorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
    /**
     * Filter which Fornecedor to delete.
     */
    where: FornecedorWhereUniqueInput
  }

  /**
   * Fornecedor deleteMany
   */
  export type FornecedorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fornecedors to delete
     */
    where?: FornecedorWhereInput
    /**
     * Limit how many Fornecedors to delete.
     */
    limit?: number
  }

  /**
   * Fornecedor.Planeamento
   */
  export type Fornecedor$PlaneamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    where?: PlaneamentoWhereInput
    orderBy?: PlaneamentoOrderByWithRelationInput | PlaneamentoOrderByWithRelationInput[]
    cursor?: PlaneamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaneamentoScalarFieldEnum | PlaneamentoScalarFieldEnum[]
  }

  /**
   * Fornecedor without action
   */
  export type FornecedorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fornecedor
     */
    select?: FornecedorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fornecedor
     */
    omit?: FornecedorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FornecedorInclude<ExtArgs> | null
  }


  /**
   * Model Livre
   */

  export type AggregateLivre = {
    _count: LivreCountAggregateOutputType | null
    _avg: LivreAvgAggregateOutputType | null
    _sum: LivreSumAggregateOutputType | null
    _min: LivreMinAggregateOutputType | null
    _max: LivreMaxAggregateOutputType | null
  }

  export type LivreAvgAggregateOutputType = {
    nOp: number | null
    nOrcamento: number | null
    anoOrcamento: number | null
  }

  export type LivreSumAggregateOutputType = {
    nOp: number | null
    nOrcamento: number | null
    anoOrcamento: number | null
  }

  export type LivreMinAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    nomeUser: string | null
    Op: string | null
    nOp: number | null
    orcamentoStamp: string | null
    nOrcamento: number | null
    anoOrcamento: number | null
    desenho: string | null
    modelo: string | null
    cor: string | null
    pedidoCliente: string | null
    imagem: string | null
    cortaPt: boolean | null
  }

  export type LivreMaxAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    nomeUser: string | null
    Op: string | null
    nOp: number | null
    orcamentoStamp: string | null
    nOrcamento: number | null
    anoOrcamento: number | null
    desenho: string | null
    modelo: string | null
    cor: string | null
    pedidoCliente: string | null
    imagem: string | null
    cortaPt: boolean | null
  }

  export type LivreCountAggregateOutputType = {
    idPlaneamento: number
    idLivre: number
    nomeUser: number
    Op: number
    nOp: number
    orcamentoStamp: number
    nOrcamento: number
    anoOrcamento: number
    desenho: number
    modelo: number
    cor: number
    pedidoCliente: number
    imagem: number
    cortaPt: number
    _all: number
  }


  export type LivreAvgAggregateInputType = {
    nOp?: true
    nOrcamento?: true
    anoOrcamento?: true
  }

  export type LivreSumAggregateInputType = {
    nOp?: true
    nOrcamento?: true
    anoOrcamento?: true
  }

  export type LivreMinAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    nomeUser?: true
    Op?: true
    nOp?: true
    orcamentoStamp?: true
    nOrcamento?: true
    anoOrcamento?: true
    desenho?: true
    modelo?: true
    cor?: true
    pedidoCliente?: true
    imagem?: true
    cortaPt?: true
  }

  export type LivreMaxAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    nomeUser?: true
    Op?: true
    nOp?: true
    orcamentoStamp?: true
    nOrcamento?: true
    anoOrcamento?: true
    desenho?: true
    modelo?: true
    cor?: true
    pedidoCliente?: true
    imagem?: true
    cortaPt?: true
  }

  export type LivreCountAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    nomeUser?: true
    Op?: true
    nOp?: true
    orcamentoStamp?: true
    nOrcamento?: true
    anoOrcamento?: true
    desenho?: true
    modelo?: true
    cor?: true
    pedidoCliente?: true
    imagem?: true
    cortaPt?: true
    _all?: true
  }

  export type LivreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Livre to aggregate.
     */
    where?: LivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livres to fetch.
     */
    orderBy?: LivreOrderByWithRelationInput | LivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Livres
    **/
    _count?: true | LivreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LivreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LivreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LivreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LivreMaxAggregateInputType
  }

  export type GetLivreAggregateType<T extends LivreAggregateArgs> = {
        [P in keyof T & keyof AggregateLivre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLivre[P]>
      : GetScalarType<T[P], AggregateLivre[P]>
  }




  export type LivreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LivreWhereInput
    orderBy?: LivreOrderByWithAggregationInput | LivreOrderByWithAggregationInput[]
    by: LivreScalarFieldEnum[] | LivreScalarFieldEnum
    having?: LivreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LivreCountAggregateInputType | true
    _avg?: LivreAvgAggregateInputType
    _sum?: LivreSumAggregateInputType
    _min?: LivreMinAggregateInputType
    _max?: LivreMaxAggregateInputType
  }

  export type LivreGroupByOutputType = {
    idPlaneamento: string
    idLivre: string
    nomeUser: string
    Op: string | null
    nOp: number | null
    orcamentoStamp: string | null
    nOrcamento: number | null
    anoOrcamento: number | null
    desenho: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    _count: LivreCountAggregateOutputType | null
    _avg: LivreAvgAggregateOutputType | null
    _sum: LivreSumAggregateOutputType | null
    _min: LivreMinAggregateOutputType | null
    _max: LivreMaxAggregateOutputType | null
  }

  type GetLivreGroupByPayload<T extends LivreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LivreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LivreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LivreGroupByOutputType[P]>
            : GetScalarType<T[P], LivreGroupByOutputType[P]>
        }
      >
    >


  export type LivreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    idLivre?: boolean
    nomeUser?: boolean
    Op?: boolean
    nOp?: boolean
    orcamentoStamp?: boolean
    nOrcamento?: boolean
    anoOrcamento?: boolean
    desenho?: boolean
    modelo?: boolean
    cor?: boolean
    pedidoCliente?: boolean
    imagem?: boolean
    cortaPt?: boolean
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    OrcamentoLivre?: boolean | Livre$OrcamentoLivreArgs<ExtArgs>
    ServicosEscolhidosLivre?: boolean | Livre$ServicosEscolhidosLivreArgs<ExtArgs>
    _count?: boolean | LivreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["livre"]>



  export type LivreSelectScalar = {
    idPlaneamento?: boolean
    idLivre?: boolean
    nomeUser?: boolean
    Op?: boolean
    nOp?: boolean
    orcamentoStamp?: boolean
    nOrcamento?: boolean
    anoOrcamento?: boolean
    desenho?: boolean
    modelo?: boolean
    cor?: boolean
    pedidoCliente?: boolean
    imagem?: boolean
    cortaPt?: boolean
  }

  export type LivreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "idLivre" | "nomeUser" | "Op" | "nOp" | "orcamentoStamp" | "nOrcamento" | "anoOrcamento" | "desenho" | "modelo" | "cor" | "pedidoCliente" | "imagem" | "cortaPt", ExtArgs["result"]["livre"]>
  export type LivreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    OrcamentoLivre?: boolean | Livre$OrcamentoLivreArgs<ExtArgs>
    ServicosEscolhidosLivre?: boolean | Livre$ServicosEscolhidosLivreArgs<ExtArgs>
    _count?: boolean | LivreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LivrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Livre"
    objects: {
      Planeamento: Prisma.$PlaneamentoPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      OrcamentoLivre: Prisma.$OrcamentoLivrePayload<ExtArgs> | null
      ServicosEscolhidosLivre: Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      idLivre: string
      nomeUser: string
      Op: string | null
      nOp: number | null
      orcamentoStamp: string | null
      nOrcamento: number | null
      anoOrcamento: number | null
      desenho: string | null
      modelo: string
      cor: string
      pedidoCliente: string
      imagem: string
      cortaPt: boolean
    }, ExtArgs["result"]["livre"]>
    composites: {}
  }

  type LivreGetPayload<S extends boolean | null | undefined | LivreDefaultArgs> = $Result.GetResult<Prisma.$LivrePayload, S>

  type LivreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LivreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LivreCountAggregateInputType | true
    }

  export interface LivreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Livre'], meta: { name: 'Livre' } }
    /**
     * Find zero or one Livre that matches the filter.
     * @param {LivreFindUniqueArgs} args - Arguments to find a Livre
     * @example
     * // Get one Livre
     * const livre = await prisma.livre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LivreFindUniqueArgs>(args: SelectSubset<T, LivreFindUniqueArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Livre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LivreFindUniqueOrThrowArgs} args - Arguments to find a Livre
     * @example
     * // Get one Livre
     * const livre = await prisma.livre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LivreFindUniqueOrThrowArgs>(args: SelectSubset<T, LivreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Livre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreFindFirstArgs} args - Arguments to find a Livre
     * @example
     * // Get one Livre
     * const livre = await prisma.livre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LivreFindFirstArgs>(args?: SelectSubset<T, LivreFindFirstArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Livre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreFindFirstOrThrowArgs} args - Arguments to find a Livre
     * @example
     * // Get one Livre
     * const livre = await prisma.livre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LivreFindFirstOrThrowArgs>(args?: SelectSubset<T, LivreFindFirstOrThrowArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Livres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Livres
     * const livres = await prisma.livre.findMany()
     * 
     * // Get first 10 Livres
     * const livres = await prisma.livre.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const livreWithIdPlaneamentoOnly = await prisma.livre.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends LivreFindManyArgs>(args?: SelectSubset<T, LivreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Livre.
     * @param {LivreCreateArgs} args - Arguments to create a Livre.
     * @example
     * // Create one Livre
     * const Livre = await prisma.livre.create({
     *   data: {
     *     // ... data to create a Livre
     *   }
     * })
     * 
     */
    create<T extends LivreCreateArgs>(args: SelectSubset<T, LivreCreateArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Livres.
     * @param {LivreCreateManyArgs} args - Arguments to create many Livres.
     * @example
     * // Create many Livres
     * const livre = await prisma.livre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LivreCreateManyArgs>(args?: SelectSubset<T, LivreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Livre.
     * @param {LivreDeleteArgs} args - Arguments to delete one Livre.
     * @example
     * // Delete one Livre
     * const Livre = await prisma.livre.delete({
     *   where: {
     *     // ... filter to delete one Livre
     *   }
     * })
     * 
     */
    delete<T extends LivreDeleteArgs>(args: SelectSubset<T, LivreDeleteArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Livre.
     * @param {LivreUpdateArgs} args - Arguments to update one Livre.
     * @example
     * // Update one Livre
     * const livre = await prisma.livre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LivreUpdateArgs>(args: SelectSubset<T, LivreUpdateArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Livres.
     * @param {LivreDeleteManyArgs} args - Arguments to filter Livres to delete.
     * @example
     * // Delete a few Livres
     * const { count } = await prisma.livre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LivreDeleteManyArgs>(args?: SelectSubset<T, LivreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Livres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Livres
     * const livre = await prisma.livre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LivreUpdateManyArgs>(args: SelectSubset<T, LivreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Livre.
     * @param {LivreUpsertArgs} args - Arguments to update or create a Livre.
     * @example
     * // Update or create a Livre
     * const livre = await prisma.livre.upsert({
     *   create: {
     *     // ... data to create a Livre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Livre we want to update
     *   }
     * })
     */
    upsert<T extends LivreUpsertArgs>(args: SelectSubset<T, LivreUpsertArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Livres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreCountArgs} args - Arguments to filter Livres to count.
     * @example
     * // Count the number of Livres
     * const count = await prisma.livre.count({
     *   where: {
     *     // ... the filter for the Livres we want to count
     *   }
     * })
    **/
    count<T extends LivreCountArgs>(
      args?: Subset<T, LivreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LivreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Livre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LivreAggregateArgs>(args: Subset<T, LivreAggregateArgs>): Prisma.PrismaPromise<GetLivreAggregateType<T>>

    /**
     * Group by Livre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LivreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LivreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LivreGroupByArgs['orderBy'] }
        : { orderBy?: LivreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LivreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLivreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Livre model
   */
  readonly fields: LivreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Livre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LivreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Planeamento<T extends PlaneamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaneamentoDefaultArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    OrcamentoLivre<T extends Livre$OrcamentoLivreArgs<ExtArgs> = {}>(args?: Subset<T, Livre$OrcamentoLivreArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    ServicosEscolhidosLivre<T extends Livre$ServicosEscolhidosLivreArgs<ExtArgs> = {}>(args?: Subset<T, Livre$ServicosEscolhidosLivreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Livre model
   */ 
  interface LivreFieldRefs {
    readonly idPlaneamento: FieldRef<"Livre", 'String'>
    readonly idLivre: FieldRef<"Livre", 'String'>
    readonly nomeUser: FieldRef<"Livre", 'String'>
    readonly Op: FieldRef<"Livre", 'String'>
    readonly nOp: FieldRef<"Livre", 'Int'>
    readonly orcamentoStamp: FieldRef<"Livre", 'String'>
    readonly nOrcamento: FieldRef<"Livre", 'Int'>
    readonly anoOrcamento: FieldRef<"Livre", 'Int'>
    readonly desenho: FieldRef<"Livre", 'String'>
    readonly modelo: FieldRef<"Livre", 'String'>
    readonly cor: FieldRef<"Livre", 'String'>
    readonly pedidoCliente: FieldRef<"Livre", 'String'>
    readonly imagem: FieldRef<"Livre", 'String'>
    readonly cortaPt: FieldRef<"Livre", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Livre findUnique
   */
  export type LivreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * Filter, which Livre to fetch.
     */
    where: LivreWhereUniqueInput
  }

  /**
   * Livre findUniqueOrThrow
   */
  export type LivreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * Filter, which Livre to fetch.
     */
    where: LivreWhereUniqueInput
  }

  /**
   * Livre findFirst
   */
  export type LivreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * Filter, which Livre to fetch.
     */
    where?: LivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livres to fetch.
     */
    orderBy?: LivreOrderByWithRelationInput | LivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Livres.
     */
    cursor?: LivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Livres.
     */
    distinct?: LivreScalarFieldEnum | LivreScalarFieldEnum[]
  }

  /**
   * Livre findFirstOrThrow
   */
  export type LivreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * Filter, which Livre to fetch.
     */
    where?: LivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livres to fetch.
     */
    orderBy?: LivreOrderByWithRelationInput | LivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Livres.
     */
    cursor?: LivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Livres.
     */
    distinct?: LivreScalarFieldEnum | LivreScalarFieldEnum[]
  }

  /**
   * Livre findMany
   */
  export type LivreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * Filter, which Livres to fetch.
     */
    where?: LivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Livres to fetch.
     */
    orderBy?: LivreOrderByWithRelationInput | LivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Livres.
     */
    cursor?: LivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Livres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Livres.
     */
    skip?: number
    distinct?: LivreScalarFieldEnum | LivreScalarFieldEnum[]
  }

  /**
   * Livre create
   */
  export type LivreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * The data needed to create a Livre.
     */
    data: XOR<LivreCreateInput, LivreUncheckedCreateInput>
  }

  /**
   * Livre createMany
   */
  export type LivreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Livres.
     */
    data: LivreCreateManyInput | LivreCreateManyInput[]
  }

  /**
   * Livre update
   */
  export type LivreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * The data needed to update a Livre.
     */
    data: XOR<LivreUpdateInput, LivreUncheckedUpdateInput>
    /**
     * Choose, which Livre to update.
     */
    where: LivreWhereUniqueInput
  }

  /**
   * Livre updateMany
   */
  export type LivreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Livres.
     */
    data: XOR<LivreUpdateManyMutationInput, LivreUncheckedUpdateManyInput>
    /**
     * Filter which Livres to update
     */
    where?: LivreWhereInput
    /**
     * Limit how many Livres to update.
     */
    limit?: number
  }

  /**
   * Livre upsert
   */
  export type LivreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * The filter to search for the Livre to update in case it exists.
     */
    where: LivreWhereUniqueInput
    /**
     * In case the Livre found by the `where` argument doesn't exist, create a new Livre with this data.
     */
    create: XOR<LivreCreateInput, LivreUncheckedCreateInput>
    /**
     * In case the Livre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LivreUpdateInput, LivreUncheckedUpdateInput>
  }

  /**
   * Livre delete
   */
  export type LivreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    /**
     * Filter which Livre to delete.
     */
    where: LivreWhereUniqueInput
  }

  /**
   * Livre deleteMany
   */
  export type LivreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Livres to delete
     */
    where?: LivreWhereInput
    /**
     * Limit how many Livres to delete.
     */
    limit?: number
  }

  /**
   * Livre.OrcamentoLivre
   */
  export type Livre$OrcamentoLivreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    where?: OrcamentoLivreWhereInput
  }

  /**
   * Livre.ServicosEscolhidosLivre
   */
  export type Livre$ServicosEscolhidosLivreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    where?: ServicosEscolhidosLivreWhereInput
    orderBy?: ServicosEscolhidosLivreOrderByWithRelationInput | ServicosEscolhidosLivreOrderByWithRelationInput[]
    cursor?: ServicosEscolhidosLivreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicosEscolhidosLivreScalarFieldEnum | ServicosEscolhidosLivreScalarFieldEnum[]
  }

  /**
   * Livre without action
   */
  export type LivreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
  }


  /**
   * Model Op
   */

  export type AggregateOp = {
    _count: OpCountAggregateOutputType | null
    _avg: OpAvgAggregateOutputType | null
    _sum: OpSumAggregateOutputType | null
    _min: OpMinAggregateOutputType | null
    _max: OpMaxAggregateOutputType | null
  }

  export type OpAvgAggregateOutputType = {
    nOp: number | null
  }

  export type OpSumAggregateOutputType = {
    nOp: number | null
  }

  export type OpMinAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    nomeUser: string | null
    nOp: number | null
    modelo: string | null
    cor: string | null
    pedidoCliente: string | null
    imagem: string | null
    cortaPt: boolean | null
  }

  export type OpMaxAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    nomeUser: string | null
    nOp: number | null
    modelo: string | null
    cor: string | null
    pedidoCliente: string | null
    imagem: string | null
    cortaPt: boolean | null
  }

  export type OpCountAggregateOutputType = {
    idPlaneamento: number
    Op: number
    nomeUser: number
    nOp: number
    modelo: number
    cor: number
    pedidoCliente: number
    imagem: number
    cortaPt: number
    _all: number
  }


  export type OpAvgAggregateInputType = {
    nOp?: true
  }

  export type OpSumAggregateInputType = {
    nOp?: true
  }

  export type OpMinAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    nomeUser?: true
    nOp?: true
    modelo?: true
    cor?: true
    pedidoCliente?: true
    imagem?: true
    cortaPt?: true
  }

  export type OpMaxAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    nomeUser?: true
    nOp?: true
    modelo?: true
    cor?: true
    pedidoCliente?: true
    imagem?: true
    cortaPt?: true
  }

  export type OpCountAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    nomeUser?: true
    nOp?: true
    modelo?: true
    cor?: true
    pedidoCliente?: true
    imagem?: true
    cortaPt?: true
    _all?: true
  }

  export type OpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Op to aggregate.
     */
    where?: OpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ops to fetch.
     */
    orderBy?: OpOrderByWithRelationInput | OpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Ops
    **/
    _count?: true | OpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OpMaxAggregateInputType
  }

  export type GetOpAggregateType<T extends OpAggregateArgs> = {
        [P in keyof T & keyof AggregateOp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOp[P]>
      : GetScalarType<T[P], AggregateOp[P]>
  }




  export type OpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OpWhereInput
    orderBy?: OpOrderByWithAggregationInput | OpOrderByWithAggregationInput[]
    by: OpScalarFieldEnum[] | OpScalarFieldEnum
    having?: OpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OpCountAggregateInputType | true
    _avg?: OpAvgAggregateInputType
    _sum?: OpSumAggregateInputType
    _min?: OpMinAggregateInputType
    _max?: OpMaxAggregateInputType
  }

  export type OpGroupByOutputType = {
    idPlaneamento: string
    Op: string
    nomeUser: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    _count: OpCountAggregateOutputType | null
    _avg: OpAvgAggregateOutputType | null
    _sum: OpSumAggregateOutputType | null
    _min: OpMinAggregateOutputType | null
    _max: OpMaxAggregateOutputType | null
  }

  type GetOpGroupByPayload<T extends OpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OpGroupByOutputType[P]>
            : GetScalarType<T[P], OpGroupByOutputType[P]>
        }
      >
    >


  export type OpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    Op?: boolean
    nomeUser?: boolean
    nOp?: boolean
    modelo?: boolean
    cor?: boolean
    pedidoCliente?: boolean
    imagem?: boolean
    cortaPt?: boolean
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: boolean | Op$OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpArgs<ExtArgs>
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: boolean | Op$ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpArgs<ExtArgs>
    _count?: boolean | OpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["op"]>



  export type OpSelectScalar = {
    idPlaneamento?: boolean
    Op?: boolean
    nomeUser?: boolean
    nOp?: boolean
    modelo?: boolean
    cor?: boolean
    pedidoCliente?: boolean
    imagem?: boolean
    cortaPt?: boolean
  }

  export type OpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "Op" | "nomeUser" | "nOp" | "modelo" | "cor" | "pedidoCliente" | "imagem" | "cortaPt", ExtArgs["result"]["op"]>
  export type OpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Planeamento?: boolean | PlaneamentoDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: boolean | Op$OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpArgs<ExtArgs>
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: boolean | Op$ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpArgs<ExtArgs>
    _count?: boolean | OpCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Op"
    objects: {
      Planeamento: Prisma.$PlaneamentoPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
      OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp: Prisma.$OrcamentoOpPayload<ExtArgs> | null
      ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp: Prisma.$ServicosEscolhidosOpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      Op: string
      nomeUser: string
      nOp: number
      modelo: string
      cor: string
      pedidoCliente: string
      imagem: string
      cortaPt: boolean
    }, ExtArgs["result"]["op"]>
    composites: {}
  }

  type OpGetPayload<S extends boolean | null | undefined | OpDefaultArgs> = $Result.GetResult<Prisma.$OpPayload, S>

  type OpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OpCountAggregateInputType | true
    }

  export interface OpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Op'], meta: { name: 'Op' } }
    /**
     * Find zero or one Op that matches the filter.
     * @param {OpFindUniqueArgs} args - Arguments to find a Op
     * @example
     * // Get one Op
     * const op = await prisma.op.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OpFindUniqueArgs>(args: SelectSubset<T, OpFindUniqueArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Op that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OpFindUniqueOrThrowArgs} args - Arguments to find a Op
     * @example
     * // Get one Op
     * const op = await prisma.op.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OpFindUniqueOrThrowArgs>(args: SelectSubset<T, OpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Op that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpFindFirstArgs} args - Arguments to find a Op
     * @example
     * // Get one Op
     * const op = await prisma.op.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OpFindFirstArgs>(args?: SelectSubset<T, OpFindFirstArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Op that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpFindFirstOrThrowArgs} args - Arguments to find a Op
     * @example
     * // Get one Op
     * const op = await prisma.op.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OpFindFirstOrThrowArgs>(args?: SelectSubset<T, OpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Ops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ops
     * const ops = await prisma.op.findMany()
     * 
     * // Get first 10 Ops
     * const ops = await prisma.op.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const opWithIdPlaneamentoOnly = await prisma.op.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends OpFindManyArgs>(args?: SelectSubset<T, OpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Op.
     * @param {OpCreateArgs} args - Arguments to create a Op.
     * @example
     * // Create one Op
     * const Op = await prisma.op.create({
     *   data: {
     *     // ... data to create a Op
     *   }
     * })
     * 
     */
    create<T extends OpCreateArgs>(args: SelectSubset<T, OpCreateArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Ops.
     * @param {OpCreateManyArgs} args - Arguments to create many Ops.
     * @example
     * // Create many Ops
     * const op = await prisma.op.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OpCreateManyArgs>(args?: SelectSubset<T, OpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Op.
     * @param {OpDeleteArgs} args - Arguments to delete one Op.
     * @example
     * // Delete one Op
     * const Op = await prisma.op.delete({
     *   where: {
     *     // ... filter to delete one Op
     *   }
     * })
     * 
     */
    delete<T extends OpDeleteArgs>(args: SelectSubset<T, OpDeleteArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Op.
     * @param {OpUpdateArgs} args - Arguments to update one Op.
     * @example
     * // Update one Op
     * const op = await prisma.op.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OpUpdateArgs>(args: SelectSubset<T, OpUpdateArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Ops.
     * @param {OpDeleteManyArgs} args - Arguments to filter Ops to delete.
     * @example
     * // Delete a few Ops
     * const { count } = await prisma.op.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OpDeleteManyArgs>(args?: SelectSubset<T, OpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ops
     * const op = await prisma.op.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OpUpdateManyArgs>(args: SelectSubset<T, OpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Op.
     * @param {OpUpsertArgs} args - Arguments to update or create a Op.
     * @example
     * // Update or create a Op
     * const op = await prisma.op.upsert({
     *   create: {
     *     // ... data to create a Op
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Op we want to update
     *   }
     * })
     */
    upsert<T extends OpUpsertArgs>(args: SelectSubset<T, OpUpsertArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Ops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpCountArgs} args - Arguments to filter Ops to count.
     * @example
     * // Count the number of Ops
     * const count = await prisma.op.count({
     *   where: {
     *     // ... the filter for the Ops we want to count
     *   }
     * })
    **/
    count<T extends OpCountArgs>(
      args?: Subset<T, OpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Op.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OpAggregateArgs>(args: Subset<T, OpAggregateArgs>): Prisma.PrismaPromise<GetOpAggregateType<T>>

    /**
     * Group by Op.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OpGroupByArgs['orderBy'] }
        : { orderBy?: OpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Op model
   */
  readonly fields: OpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Op.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Planeamento<T extends PlaneamentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlaneamentoDefaultArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp<T extends Op$OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpArgs<ExtArgs> = {}>(args?: Subset<T, Op$OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp<T extends Op$ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpArgs<ExtArgs> = {}>(args?: Subset<T, Op$ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Op model
   */ 
  interface OpFieldRefs {
    readonly idPlaneamento: FieldRef<"Op", 'String'>
    readonly Op: FieldRef<"Op", 'String'>
    readonly nomeUser: FieldRef<"Op", 'String'>
    readonly nOp: FieldRef<"Op", 'Int'>
    readonly modelo: FieldRef<"Op", 'String'>
    readonly cor: FieldRef<"Op", 'String'>
    readonly pedidoCliente: FieldRef<"Op", 'String'>
    readonly imagem: FieldRef<"Op", 'String'>
    readonly cortaPt: FieldRef<"Op", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Op findUnique
   */
  export type OpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * Filter, which Op to fetch.
     */
    where: OpWhereUniqueInput
  }

  /**
   * Op findUniqueOrThrow
   */
  export type OpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * Filter, which Op to fetch.
     */
    where: OpWhereUniqueInput
  }

  /**
   * Op findFirst
   */
  export type OpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * Filter, which Op to fetch.
     */
    where?: OpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ops to fetch.
     */
    orderBy?: OpOrderByWithRelationInput | OpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ops.
     */
    cursor?: OpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ops.
     */
    distinct?: OpScalarFieldEnum | OpScalarFieldEnum[]
  }

  /**
   * Op findFirstOrThrow
   */
  export type OpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * Filter, which Op to fetch.
     */
    where?: OpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ops to fetch.
     */
    orderBy?: OpOrderByWithRelationInput | OpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Ops.
     */
    cursor?: OpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Ops.
     */
    distinct?: OpScalarFieldEnum | OpScalarFieldEnum[]
  }

  /**
   * Op findMany
   */
  export type OpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * Filter, which Ops to fetch.
     */
    where?: OpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Ops to fetch.
     */
    orderBy?: OpOrderByWithRelationInput | OpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Ops.
     */
    cursor?: OpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Ops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Ops.
     */
    skip?: number
    distinct?: OpScalarFieldEnum | OpScalarFieldEnum[]
  }

  /**
   * Op create
   */
  export type OpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * The data needed to create a Op.
     */
    data: XOR<OpCreateInput, OpUncheckedCreateInput>
  }

  /**
   * Op createMany
   */
  export type OpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Ops.
     */
    data: OpCreateManyInput | OpCreateManyInput[]
  }

  /**
   * Op update
   */
  export type OpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * The data needed to update a Op.
     */
    data: XOR<OpUpdateInput, OpUncheckedUpdateInput>
    /**
     * Choose, which Op to update.
     */
    where: OpWhereUniqueInput
  }

  /**
   * Op updateMany
   */
  export type OpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Ops.
     */
    data: XOR<OpUpdateManyMutationInput, OpUncheckedUpdateManyInput>
    /**
     * Filter which Ops to update
     */
    where?: OpWhereInput
    /**
     * Limit how many Ops to update.
     */
    limit?: number
  }

  /**
   * Op upsert
   */
  export type OpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * The filter to search for the Op to update in case it exists.
     */
    where: OpWhereUniqueInput
    /**
     * In case the Op found by the `where` argument doesn't exist, create a new Op with this data.
     */
    create: XOR<OpCreateInput, OpUncheckedCreateInput>
    /**
     * In case the Op was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OpUpdateInput, OpUncheckedUpdateInput>
  }

  /**
   * Op delete
   */
  export type OpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    /**
     * Filter which Op to delete.
     */
    where: OpWhereUniqueInput
  }

  /**
   * Op deleteMany
   */
  export type OpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ops to delete
     */
    where?: OpWhereInput
    /**
     * Limit how many Ops to delete.
     */
    limit?: number
  }

  /**
   * Op.OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp
   */
  export type Op$OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    where?: OrcamentoOpWhereInput
  }

  /**
   * Op.ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp
   */
  export type Op$ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    where?: ServicosEscolhidosOpWhereInput
    orderBy?: ServicosEscolhidosOpOrderByWithRelationInput | ServicosEscolhidosOpOrderByWithRelationInput[]
    cursor?: ServicosEscolhidosOpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicosEscolhidosOpScalarFieldEnum | ServicosEscolhidosOpScalarFieldEnum[]
  }

  /**
   * Op without action
   */
  export type OpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
  }


  /**
   * Model OrcamentoLivre
   */

  export type AggregateOrcamentoLivre = {
    _count: OrcamentoLivreCountAggregateOutputType | null
    _avg: OrcamentoLivreAvgAggregateOutputType | null
    _sum: OrcamentoLivreSumAggregateOutputType | null
    _min: OrcamentoLivreMinAggregateOutputType | null
    _max: OrcamentoLivreMaxAggregateOutputType | null
  }

  export type OrcamentoLivreAvgAggregateOutputType = {
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoLivreSumAggregateOutputType = {
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoLivreMinAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    orcamentoStamp: string | null
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoLivreMaxAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    orcamentoStamp: string | null
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoLivreCountAggregateOutputType = {
    idPlaneamento: number
    idLivre: number
    orcamentoStamp: number
    orcamentoNumero: number
    ano: number
    _all: number
  }


  export type OrcamentoLivreAvgAggregateInputType = {
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoLivreSumAggregateInputType = {
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoLivreMinAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    orcamentoStamp?: true
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoLivreMaxAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    orcamentoStamp?: true
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoLivreCountAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    orcamentoStamp?: true
    orcamentoNumero?: true
    ano?: true
    _all?: true
  }

  export type OrcamentoLivreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoLivre to aggregate.
     */
    where?: OrcamentoLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivres to fetch.
     */
    orderBy?: OrcamentoLivreOrderByWithRelationInput | OrcamentoLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrcamentoLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrcamentoLivres
    **/
    _count?: true | OrcamentoLivreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrcamentoLivreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrcamentoLivreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrcamentoLivreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrcamentoLivreMaxAggregateInputType
  }

  export type GetOrcamentoLivreAggregateType<T extends OrcamentoLivreAggregateArgs> = {
        [P in keyof T & keyof AggregateOrcamentoLivre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrcamentoLivre[P]>
      : GetScalarType<T[P], AggregateOrcamentoLivre[P]>
  }




  export type OrcamentoLivreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrcamentoLivreWhereInput
    orderBy?: OrcamentoLivreOrderByWithAggregationInput | OrcamentoLivreOrderByWithAggregationInput[]
    by: OrcamentoLivreScalarFieldEnum[] | OrcamentoLivreScalarFieldEnum
    having?: OrcamentoLivreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrcamentoLivreCountAggregateInputType | true
    _avg?: OrcamentoLivreAvgAggregateInputType
    _sum?: OrcamentoLivreSumAggregateInputType
    _min?: OrcamentoLivreMinAggregateInputType
    _max?: OrcamentoLivreMaxAggregateInputType
  }

  export type OrcamentoLivreGroupByOutputType = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    _count: OrcamentoLivreCountAggregateOutputType | null
    _avg: OrcamentoLivreAvgAggregateOutputType | null
    _sum: OrcamentoLivreSumAggregateOutputType | null
    _min: OrcamentoLivreMinAggregateOutputType | null
    _max: OrcamentoLivreMaxAggregateOutputType | null
  }

  type GetOrcamentoLivreGroupByPayload<T extends OrcamentoLivreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrcamentoLivreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrcamentoLivreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrcamentoLivreGroupByOutputType[P]>
            : GetScalarType<T[P], OrcamentoLivreGroupByOutputType[P]>
        }
      >
    >


  export type OrcamentoLivreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    idLivre?: boolean
    orcamentoStamp?: boolean
    orcamentoNumero?: boolean
    ano?: boolean
    Livre?: boolean | LivreDefaultArgs<ExtArgs>
    OrcamentoLivreLinhas?: boolean | OrcamentoLivre$OrcamentoLivreLinhasArgs<ExtArgs>
    _count?: boolean | OrcamentoLivreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orcamentoLivre"]>



  export type OrcamentoLivreSelectScalar = {
    idPlaneamento?: boolean
    idLivre?: boolean
    orcamentoStamp?: boolean
    orcamentoNumero?: boolean
    ano?: boolean
  }

  export type OrcamentoLivreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "idLivre" | "orcamentoStamp" | "orcamentoNumero" | "ano", ExtArgs["result"]["orcamentoLivre"]>
  export type OrcamentoLivreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Livre?: boolean | LivreDefaultArgs<ExtArgs>
    OrcamentoLivreLinhas?: boolean | OrcamentoLivre$OrcamentoLivreLinhasArgs<ExtArgs>
    _count?: boolean | OrcamentoLivreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrcamentoLivrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrcamentoLivre"
    objects: {
      Livre: Prisma.$LivrePayload<ExtArgs>
      OrcamentoLivreLinhas: Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      idLivre: string
      orcamentoStamp: string
      orcamentoNumero: number
      ano: number
    }, ExtArgs["result"]["orcamentoLivre"]>
    composites: {}
  }

  type OrcamentoLivreGetPayload<S extends boolean | null | undefined | OrcamentoLivreDefaultArgs> = $Result.GetResult<Prisma.$OrcamentoLivrePayload, S>

  type OrcamentoLivreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrcamentoLivreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrcamentoLivreCountAggregateInputType | true
    }

  export interface OrcamentoLivreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrcamentoLivre'], meta: { name: 'OrcamentoLivre' } }
    /**
     * Find zero or one OrcamentoLivre that matches the filter.
     * @param {OrcamentoLivreFindUniqueArgs} args - Arguments to find a OrcamentoLivre
     * @example
     * // Get one OrcamentoLivre
     * const orcamentoLivre = await prisma.orcamentoLivre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrcamentoLivreFindUniqueArgs>(args: SelectSubset<T, OrcamentoLivreFindUniqueArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OrcamentoLivre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrcamentoLivreFindUniqueOrThrowArgs} args - Arguments to find a OrcamentoLivre
     * @example
     * // Get one OrcamentoLivre
     * const orcamentoLivre = await prisma.orcamentoLivre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrcamentoLivreFindUniqueOrThrowArgs>(args: SelectSubset<T, OrcamentoLivreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoLivre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreFindFirstArgs} args - Arguments to find a OrcamentoLivre
     * @example
     * // Get one OrcamentoLivre
     * const orcamentoLivre = await prisma.orcamentoLivre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrcamentoLivreFindFirstArgs>(args?: SelectSubset<T, OrcamentoLivreFindFirstArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoLivre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreFindFirstOrThrowArgs} args - Arguments to find a OrcamentoLivre
     * @example
     * // Get one OrcamentoLivre
     * const orcamentoLivre = await prisma.orcamentoLivre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrcamentoLivreFindFirstOrThrowArgs>(args?: SelectSubset<T, OrcamentoLivreFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OrcamentoLivres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrcamentoLivres
     * const orcamentoLivres = await prisma.orcamentoLivre.findMany()
     * 
     * // Get first 10 OrcamentoLivres
     * const orcamentoLivres = await prisma.orcamentoLivre.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const orcamentoLivreWithIdPlaneamentoOnly = await prisma.orcamentoLivre.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends OrcamentoLivreFindManyArgs>(args?: SelectSubset<T, OrcamentoLivreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OrcamentoLivre.
     * @param {OrcamentoLivreCreateArgs} args - Arguments to create a OrcamentoLivre.
     * @example
     * // Create one OrcamentoLivre
     * const OrcamentoLivre = await prisma.orcamentoLivre.create({
     *   data: {
     *     // ... data to create a OrcamentoLivre
     *   }
     * })
     * 
     */
    create<T extends OrcamentoLivreCreateArgs>(args: SelectSubset<T, OrcamentoLivreCreateArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OrcamentoLivres.
     * @param {OrcamentoLivreCreateManyArgs} args - Arguments to create many OrcamentoLivres.
     * @example
     * // Create many OrcamentoLivres
     * const orcamentoLivre = await prisma.orcamentoLivre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrcamentoLivreCreateManyArgs>(args?: SelectSubset<T, OrcamentoLivreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrcamentoLivre.
     * @param {OrcamentoLivreDeleteArgs} args - Arguments to delete one OrcamentoLivre.
     * @example
     * // Delete one OrcamentoLivre
     * const OrcamentoLivre = await prisma.orcamentoLivre.delete({
     *   where: {
     *     // ... filter to delete one OrcamentoLivre
     *   }
     * })
     * 
     */
    delete<T extends OrcamentoLivreDeleteArgs>(args: SelectSubset<T, OrcamentoLivreDeleteArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OrcamentoLivre.
     * @param {OrcamentoLivreUpdateArgs} args - Arguments to update one OrcamentoLivre.
     * @example
     * // Update one OrcamentoLivre
     * const orcamentoLivre = await prisma.orcamentoLivre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrcamentoLivreUpdateArgs>(args: SelectSubset<T, OrcamentoLivreUpdateArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OrcamentoLivres.
     * @param {OrcamentoLivreDeleteManyArgs} args - Arguments to filter OrcamentoLivres to delete.
     * @example
     * // Delete a few OrcamentoLivres
     * const { count } = await prisma.orcamentoLivre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrcamentoLivreDeleteManyArgs>(args?: SelectSubset<T, OrcamentoLivreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrcamentoLivres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrcamentoLivres
     * const orcamentoLivre = await prisma.orcamentoLivre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrcamentoLivreUpdateManyArgs>(args: SelectSubset<T, OrcamentoLivreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrcamentoLivre.
     * @param {OrcamentoLivreUpsertArgs} args - Arguments to update or create a OrcamentoLivre.
     * @example
     * // Update or create a OrcamentoLivre
     * const orcamentoLivre = await prisma.orcamentoLivre.upsert({
     *   create: {
     *     // ... data to create a OrcamentoLivre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrcamentoLivre we want to update
     *   }
     * })
     */
    upsert<T extends OrcamentoLivreUpsertArgs>(args: SelectSubset<T, OrcamentoLivreUpsertArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OrcamentoLivres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreCountArgs} args - Arguments to filter OrcamentoLivres to count.
     * @example
     * // Count the number of OrcamentoLivres
     * const count = await prisma.orcamentoLivre.count({
     *   where: {
     *     // ... the filter for the OrcamentoLivres we want to count
     *   }
     * })
    **/
    count<T extends OrcamentoLivreCountArgs>(
      args?: Subset<T, OrcamentoLivreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrcamentoLivreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrcamentoLivre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrcamentoLivreAggregateArgs>(args: Subset<T, OrcamentoLivreAggregateArgs>): Prisma.PrismaPromise<GetOrcamentoLivreAggregateType<T>>

    /**
     * Group by OrcamentoLivre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrcamentoLivreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrcamentoLivreGroupByArgs['orderBy'] }
        : { orderBy?: OrcamentoLivreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrcamentoLivreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrcamentoLivreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrcamentoLivre model
   */
  readonly fields: OrcamentoLivreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrcamentoLivre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrcamentoLivreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Livre<T extends LivreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivreDefaultArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    OrcamentoLivreLinhas<T extends OrcamentoLivre$OrcamentoLivreLinhasArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoLivre$OrcamentoLivreLinhasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrcamentoLivre model
   */ 
  interface OrcamentoLivreFieldRefs {
    readonly idPlaneamento: FieldRef<"OrcamentoLivre", 'String'>
    readonly idLivre: FieldRef<"OrcamentoLivre", 'String'>
    readonly orcamentoStamp: FieldRef<"OrcamentoLivre", 'String'>
    readonly orcamentoNumero: FieldRef<"OrcamentoLivre", 'Int'>
    readonly ano: FieldRef<"OrcamentoLivre", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrcamentoLivre findUnique
   */
  export type OrcamentoLivreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivre to fetch.
     */
    where: OrcamentoLivreWhereUniqueInput
  }

  /**
   * OrcamentoLivre findUniqueOrThrow
   */
  export type OrcamentoLivreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivre to fetch.
     */
    where: OrcamentoLivreWhereUniqueInput
  }

  /**
   * OrcamentoLivre findFirst
   */
  export type OrcamentoLivreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivre to fetch.
     */
    where?: OrcamentoLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivres to fetch.
     */
    orderBy?: OrcamentoLivreOrderByWithRelationInput | OrcamentoLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoLivres.
     */
    cursor?: OrcamentoLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoLivres.
     */
    distinct?: OrcamentoLivreScalarFieldEnum | OrcamentoLivreScalarFieldEnum[]
  }

  /**
   * OrcamentoLivre findFirstOrThrow
   */
  export type OrcamentoLivreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivre to fetch.
     */
    where?: OrcamentoLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivres to fetch.
     */
    orderBy?: OrcamentoLivreOrderByWithRelationInput | OrcamentoLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoLivres.
     */
    cursor?: OrcamentoLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoLivres.
     */
    distinct?: OrcamentoLivreScalarFieldEnum | OrcamentoLivreScalarFieldEnum[]
  }

  /**
   * OrcamentoLivre findMany
   */
  export type OrcamentoLivreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivres to fetch.
     */
    where?: OrcamentoLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivres to fetch.
     */
    orderBy?: OrcamentoLivreOrderByWithRelationInput | OrcamentoLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrcamentoLivres.
     */
    cursor?: OrcamentoLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivres.
     */
    skip?: number
    distinct?: OrcamentoLivreScalarFieldEnum | OrcamentoLivreScalarFieldEnum[]
  }

  /**
   * OrcamentoLivre create
   */
  export type OrcamentoLivreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * The data needed to create a OrcamentoLivre.
     */
    data: XOR<OrcamentoLivreCreateInput, OrcamentoLivreUncheckedCreateInput>
  }

  /**
   * OrcamentoLivre createMany
   */
  export type OrcamentoLivreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrcamentoLivres.
     */
    data: OrcamentoLivreCreateManyInput | OrcamentoLivreCreateManyInput[]
  }

  /**
   * OrcamentoLivre update
   */
  export type OrcamentoLivreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * The data needed to update a OrcamentoLivre.
     */
    data: XOR<OrcamentoLivreUpdateInput, OrcamentoLivreUncheckedUpdateInput>
    /**
     * Choose, which OrcamentoLivre to update.
     */
    where: OrcamentoLivreWhereUniqueInput
  }

  /**
   * OrcamentoLivre updateMany
   */
  export type OrcamentoLivreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrcamentoLivres.
     */
    data: XOR<OrcamentoLivreUpdateManyMutationInput, OrcamentoLivreUncheckedUpdateManyInput>
    /**
     * Filter which OrcamentoLivres to update
     */
    where?: OrcamentoLivreWhereInput
    /**
     * Limit how many OrcamentoLivres to update.
     */
    limit?: number
  }

  /**
   * OrcamentoLivre upsert
   */
  export type OrcamentoLivreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * The filter to search for the OrcamentoLivre to update in case it exists.
     */
    where: OrcamentoLivreWhereUniqueInput
    /**
     * In case the OrcamentoLivre found by the `where` argument doesn't exist, create a new OrcamentoLivre with this data.
     */
    create: XOR<OrcamentoLivreCreateInput, OrcamentoLivreUncheckedCreateInput>
    /**
     * In case the OrcamentoLivre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrcamentoLivreUpdateInput, OrcamentoLivreUncheckedUpdateInput>
  }

  /**
   * OrcamentoLivre delete
   */
  export type OrcamentoLivreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
    /**
     * Filter which OrcamentoLivre to delete.
     */
    where: OrcamentoLivreWhereUniqueInput
  }

  /**
   * OrcamentoLivre deleteMany
   */
  export type OrcamentoLivreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoLivres to delete
     */
    where?: OrcamentoLivreWhereInput
    /**
     * Limit how many OrcamentoLivres to delete.
     */
    limit?: number
  }

  /**
   * OrcamentoLivre.OrcamentoLivreLinhas
   */
  export type OrcamentoLivre$OrcamentoLivreLinhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    where?: OrcamentoLivreLinhasWhereInput
    orderBy?: OrcamentoLivreLinhasOrderByWithRelationInput | OrcamentoLivreLinhasOrderByWithRelationInput[]
    cursor?: OrcamentoLivreLinhasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrcamentoLivreLinhasScalarFieldEnum | OrcamentoLivreLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoLivre without action
   */
  export type OrcamentoLivreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivre
     */
    select?: OrcamentoLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivre
     */
    omit?: OrcamentoLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreInclude<ExtArgs> | null
  }


  /**
   * Model OrcamentoLivreLinhas
   */

  export type AggregateOrcamentoLivreLinhas = {
    _count: OrcamentoLivreLinhasCountAggregateOutputType | null
    _avg: OrcamentoLivreLinhasAvgAggregateOutputType | null
    _sum: OrcamentoLivreLinhasSumAggregateOutputType | null
    _min: OrcamentoLivreLinhasMinAggregateOutputType | null
    _max: OrcamentoLivreLinhasMaxAggregateOutputType | null
  }

  export type OrcamentoLivreLinhasAvgAggregateOutputType = {
    ordem: number | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
  }

  export type OrcamentoLivreLinhasSumAggregateOutputType = {
    ordem: number | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
  }

  export type OrcamentoLivreLinhasMinAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    orcamentoStamp: string | null
    orcamentoLinhasStamp: string | null
    orcamentoLinhasStampRecebido: string | null
    ordem: number | null
    design: string | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
    unidade: string | null
  }

  export type OrcamentoLivreLinhasMaxAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    orcamentoStamp: string | null
    orcamentoLinhasStamp: string | null
    orcamentoLinhasStampRecebido: string | null
    ordem: number | null
    design: string | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
    unidade: string | null
  }

  export type OrcamentoLivreLinhasCountAggregateOutputType = {
    idPlaneamento: number
    idLivre: number
    orcamentoStamp: number
    orcamentoLinhasStamp: number
    orcamentoLinhasStampRecebido: number
    ordem: number
    design: number
    custoPeca: number
    edebito: number
    qtt: number
    unidade: number
    _all: number
  }


  export type OrcamentoLivreLinhasAvgAggregateInputType = {
    ordem?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
  }

  export type OrcamentoLivreLinhasSumAggregateInputType = {
    ordem?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
  }

  export type OrcamentoLivreLinhasMinAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    orcamentoStamp?: true
    orcamentoLinhasStamp?: true
    orcamentoLinhasStampRecebido?: true
    ordem?: true
    design?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
    unidade?: true
  }

  export type OrcamentoLivreLinhasMaxAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    orcamentoStamp?: true
    orcamentoLinhasStamp?: true
    orcamentoLinhasStampRecebido?: true
    ordem?: true
    design?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
    unidade?: true
  }

  export type OrcamentoLivreLinhasCountAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    orcamentoStamp?: true
    orcamentoLinhasStamp?: true
    orcamentoLinhasStampRecebido?: true
    ordem?: true
    design?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
    unidade?: true
    _all?: true
  }

  export type OrcamentoLivreLinhasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoLivreLinhas to aggregate.
     */
    where?: OrcamentoLivreLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivreLinhas to fetch.
     */
    orderBy?: OrcamentoLivreLinhasOrderByWithRelationInput | OrcamentoLivreLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrcamentoLivreLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivreLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivreLinhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrcamentoLivreLinhas
    **/
    _count?: true | OrcamentoLivreLinhasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrcamentoLivreLinhasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrcamentoLivreLinhasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrcamentoLivreLinhasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrcamentoLivreLinhasMaxAggregateInputType
  }

  export type GetOrcamentoLivreLinhasAggregateType<T extends OrcamentoLivreLinhasAggregateArgs> = {
        [P in keyof T & keyof AggregateOrcamentoLivreLinhas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrcamentoLivreLinhas[P]>
      : GetScalarType<T[P], AggregateOrcamentoLivreLinhas[P]>
  }




  export type OrcamentoLivreLinhasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrcamentoLivreLinhasWhereInput
    orderBy?: OrcamentoLivreLinhasOrderByWithAggregationInput | OrcamentoLivreLinhasOrderByWithAggregationInput[]
    by: OrcamentoLivreLinhasScalarFieldEnum[] | OrcamentoLivreLinhasScalarFieldEnum
    having?: OrcamentoLivreLinhasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrcamentoLivreLinhasCountAggregateInputType | true
    _avg?: OrcamentoLivreLinhasAvgAggregateInputType
    _sum?: OrcamentoLivreLinhasSumAggregateInputType
    _min?: OrcamentoLivreLinhasMinAggregateInputType
    _max?: OrcamentoLivreLinhasMaxAggregateInputType
  }

  export type OrcamentoLivreLinhasGroupByOutputType = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoLinhasStamp: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    _count: OrcamentoLivreLinhasCountAggregateOutputType | null
    _avg: OrcamentoLivreLinhasAvgAggregateOutputType | null
    _sum: OrcamentoLivreLinhasSumAggregateOutputType | null
    _min: OrcamentoLivreLinhasMinAggregateOutputType | null
    _max: OrcamentoLivreLinhasMaxAggregateOutputType | null
  }

  type GetOrcamentoLivreLinhasGroupByPayload<T extends OrcamentoLivreLinhasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrcamentoLivreLinhasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrcamentoLivreLinhasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrcamentoLivreLinhasGroupByOutputType[P]>
            : GetScalarType<T[P], OrcamentoLivreLinhasGroupByOutputType[P]>
        }
      >
    >


  export type OrcamentoLivreLinhasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    idLivre?: boolean
    orcamentoStamp?: boolean
    orcamentoLinhasStamp?: boolean
    orcamentoLinhasStampRecebido?: boolean
    ordem?: boolean
    design?: boolean
    custoPeca?: boolean
    edebito?: boolean
    qtt?: boolean
    unidade?: boolean
    OrcamentoLivre?: boolean | OrcamentoLivreDefaultArgs<ExtArgs>
    ServicosEscolhidosLivreOrigem?: boolean | OrcamentoLivreLinhas$ServicosEscolhidosLivreOrigemArgs<ExtArgs>
    _count?: boolean | OrcamentoLivreLinhasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orcamentoLivreLinhas"]>



  export type OrcamentoLivreLinhasSelectScalar = {
    idPlaneamento?: boolean
    idLivre?: boolean
    orcamentoStamp?: boolean
    orcamentoLinhasStamp?: boolean
    orcamentoLinhasStampRecebido?: boolean
    ordem?: boolean
    design?: boolean
    custoPeca?: boolean
    edebito?: boolean
    qtt?: boolean
    unidade?: boolean
  }

  export type OrcamentoLivreLinhasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "idLivre" | "orcamentoStamp" | "orcamentoLinhasStamp" | "orcamentoLinhasStampRecebido" | "ordem" | "design" | "custoPeca" | "edebito" | "qtt" | "unidade", ExtArgs["result"]["orcamentoLivreLinhas"]>
  export type OrcamentoLivreLinhasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrcamentoLivre?: boolean | OrcamentoLivreDefaultArgs<ExtArgs>
    ServicosEscolhidosLivreOrigem?: boolean | OrcamentoLivreLinhas$ServicosEscolhidosLivreOrigemArgs<ExtArgs>
    _count?: boolean | OrcamentoLivreLinhasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrcamentoLivreLinhasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrcamentoLivreLinhas"
    objects: {
      OrcamentoLivre: Prisma.$OrcamentoLivrePayload<ExtArgs>
      ServicosEscolhidosLivreOrigem: Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      idLivre: string
      orcamentoStamp: string
      orcamentoLinhasStamp: string
      orcamentoLinhasStampRecebido: string
      ordem: number
      design: string
      custoPeca: number
      edebito: number
      qtt: number
      unidade: string
    }, ExtArgs["result"]["orcamentoLivreLinhas"]>
    composites: {}
  }

  type OrcamentoLivreLinhasGetPayload<S extends boolean | null | undefined | OrcamentoLivreLinhasDefaultArgs> = $Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload, S>

  type OrcamentoLivreLinhasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrcamentoLivreLinhasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrcamentoLivreLinhasCountAggregateInputType | true
    }

  export interface OrcamentoLivreLinhasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrcamentoLivreLinhas'], meta: { name: 'OrcamentoLivreLinhas' } }
    /**
     * Find zero or one OrcamentoLivreLinhas that matches the filter.
     * @param {OrcamentoLivreLinhasFindUniqueArgs} args - Arguments to find a OrcamentoLivreLinhas
     * @example
     * // Get one OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrcamentoLivreLinhasFindUniqueArgs>(args: SelectSubset<T, OrcamentoLivreLinhasFindUniqueArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OrcamentoLivreLinhas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrcamentoLivreLinhasFindUniqueOrThrowArgs} args - Arguments to find a OrcamentoLivreLinhas
     * @example
     * // Get one OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrcamentoLivreLinhasFindUniqueOrThrowArgs>(args: SelectSubset<T, OrcamentoLivreLinhasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoLivreLinhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreLinhasFindFirstArgs} args - Arguments to find a OrcamentoLivreLinhas
     * @example
     * // Get one OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrcamentoLivreLinhasFindFirstArgs>(args?: SelectSubset<T, OrcamentoLivreLinhasFindFirstArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoLivreLinhas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreLinhasFindFirstOrThrowArgs} args - Arguments to find a OrcamentoLivreLinhas
     * @example
     * // Get one OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrcamentoLivreLinhasFindFirstOrThrowArgs>(args?: SelectSubset<T, OrcamentoLivreLinhasFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OrcamentoLivreLinhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreLinhasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.findMany()
     * 
     * // Get first 10 OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const orcamentoLivreLinhasWithIdPlaneamentoOnly = await prisma.orcamentoLivreLinhas.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends OrcamentoLivreLinhasFindManyArgs>(args?: SelectSubset<T, OrcamentoLivreLinhasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OrcamentoLivreLinhas.
     * @param {OrcamentoLivreLinhasCreateArgs} args - Arguments to create a OrcamentoLivreLinhas.
     * @example
     * // Create one OrcamentoLivreLinhas
     * const OrcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.create({
     *   data: {
     *     // ... data to create a OrcamentoLivreLinhas
     *   }
     * })
     * 
     */
    create<T extends OrcamentoLivreLinhasCreateArgs>(args: SelectSubset<T, OrcamentoLivreLinhasCreateArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OrcamentoLivreLinhas.
     * @param {OrcamentoLivreLinhasCreateManyArgs} args - Arguments to create many OrcamentoLivreLinhas.
     * @example
     * // Create many OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrcamentoLivreLinhasCreateManyArgs>(args?: SelectSubset<T, OrcamentoLivreLinhasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrcamentoLivreLinhas.
     * @param {OrcamentoLivreLinhasDeleteArgs} args - Arguments to delete one OrcamentoLivreLinhas.
     * @example
     * // Delete one OrcamentoLivreLinhas
     * const OrcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.delete({
     *   where: {
     *     // ... filter to delete one OrcamentoLivreLinhas
     *   }
     * })
     * 
     */
    delete<T extends OrcamentoLivreLinhasDeleteArgs>(args: SelectSubset<T, OrcamentoLivreLinhasDeleteArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OrcamentoLivreLinhas.
     * @param {OrcamentoLivreLinhasUpdateArgs} args - Arguments to update one OrcamentoLivreLinhas.
     * @example
     * // Update one OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrcamentoLivreLinhasUpdateArgs>(args: SelectSubset<T, OrcamentoLivreLinhasUpdateArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OrcamentoLivreLinhas.
     * @param {OrcamentoLivreLinhasDeleteManyArgs} args - Arguments to filter OrcamentoLivreLinhas to delete.
     * @example
     * // Delete a few OrcamentoLivreLinhas
     * const { count } = await prisma.orcamentoLivreLinhas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrcamentoLivreLinhasDeleteManyArgs>(args?: SelectSubset<T, OrcamentoLivreLinhasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrcamentoLivreLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreLinhasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrcamentoLivreLinhasUpdateManyArgs>(args: SelectSubset<T, OrcamentoLivreLinhasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrcamentoLivreLinhas.
     * @param {OrcamentoLivreLinhasUpsertArgs} args - Arguments to update or create a OrcamentoLivreLinhas.
     * @example
     * // Update or create a OrcamentoLivreLinhas
     * const orcamentoLivreLinhas = await prisma.orcamentoLivreLinhas.upsert({
     *   create: {
     *     // ... data to create a OrcamentoLivreLinhas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrcamentoLivreLinhas we want to update
     *   }
     * })
     */
    upsert<T extends OrcamentoLivreLinhasUpsertArgs>(args: SelectSubset<T, OrcamentoLivreLinhasUpsertArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OrcamentoLivreLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreLinhasCountArgs} args - Arguments to filter OrcamentoLivreLinhas to count.
     * @example
     * // Count the number of OrcamentoLivreLinhas
     * const count = await prisma.orcamentoLivreLinhas.count({
     *   where: {
     *     // ... the filter for the OrcamentoLivreLinhas we want to count
     *   }
     * })
    **/
    count<T extends OrcamentoLivreLinhasCountArgs>(
      args?: Subset<T, OrcamentoLivreLinhasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrcamentoLivreLinhasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrcamentoLivreLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreLinhasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrcamentoLivreLinhasAggregateArgs>(args: Subset<T, OrcamentoLivreLinhasAggregateArgs>): Prisma.PrismaPromise<GetOrcamentoLivreLinhasAggregateType<T>>

    /**
     * Group by OrcamentoLivreLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoLivreLinhasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrcamentoLivreLinhasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrcamentoLivreLinhasGroupByArgs['orderBy'] }
        : { orderBy?: OrcamentoLivreLinhasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrcamentoLivreLinhasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrcamentoLivreLinhasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrcamentoLivreLinhas model
   */
  readonly fields: OrcamentoLivreLinhasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrcamentoLivreLinhas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrcamentoLivreLinhasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrcamentoLivre<T extends OrcamentoLivreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoLivreDefaultArgs<ExtArgs>>): Prisma__OrcamentoLivreClient<$Result.GetResult<Prisma.$OrcamentoLivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ServicosEscolhidosLivreOrigem<T extends OrcamentoLivreLinhas$ServicosEscolhidosLivreOrigemArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoLivreLinhas$ServicosEscolhidosLivreOrigemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrcamentoLivreLinhas model
   */ 
  interface OrcamentoLivreLinhasFieldRefs {
    readonly idPlaneamento: FieldRef<"OrcamentoLivreLinhas", 'String'>
    readonly idLivre: FieldRef<"OrcamentoLivreLinhas", 'String'>
    readonly orcamentoStamp: FieldRef<"OrcamentoLivreLinhas", 'String'>
    readonly orcamentoLinhasStamp: FieldRef<"OrcamentoLivreLinhas", 'String'>
    readonly orcamentoLinhasStampRecebido: FieldRef<"OrcamentoLivreLinhas", 'String'>
    readonly ordem: FieldRef<"OrcamentoLivreLinhas", 'Int'>
    readonly design: FieldRef<"OrcamentoLivreLinhas", 'String'>
    readonly custoPeca: FieldRef<"OrcamentoLivreLinhas", 'Float'>
    readonly edebito: FieldRef<"OrcamentoLivreLinhas", 'Float'>
    readonly qtt: FieldRef<"OrcamentoLivreLinhas", 'Float'>
    readonly unidade: FieldRef<"OrcamentoLivreLinhas", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrcamentoLivreLinhas findUnique
   */
  export type OrcamentoLivreLinhasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivreLinhas to fetch.
     */
    where: OrcamentoLivreLinhasWhereUniqueInput
  }

  /**
   * OrcamentoLivreLinhas findUniqueOrThrow
   */
  export type OrcamentoLivreLinhasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivreLinhas to fetch.
     */
    where: OrcamentoLivreLinhasWhereUniqueInput
  }

  /**
   * OrcamentoLivreLinhas findFirst
   */
  export type OrcamentoLivreLinhasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivreLinhas to fetch.
     */
    where?: OrcamentoLivreLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivreLinhas to fetch.
     */
    orderBy?: OrcamentoLivreLinhasOrderByWithRelationInput | OrcamentoLivreLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoLivreLinhas.
     */
    cursor?: OrcamentoLivreLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivreLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivreLinhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoLivreLinhas.
     */
    distinct?: OrcamentoLivreLinhasScalarFieldEnum | OrcamentoLivreLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoLivreLinhas findFirstOrThrow
   */
  export type OrcamentoLivreLinhasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivreLinhas to fetch.
     */
    where?: OrcamentoLivreLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivreLinhas to fetch.
     */
    orderBy?: OrcamentoLivreLinhasOrderByWithRelationInput | OrcamentoLivreLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoLivreLinhas.
     */
    cursor?: OrcamentoLivreLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivreLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivreLinhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoLivreLinhas.
     */
    distinct?: OrcamentoLivreLinhasScalarFieldEnum | OrcamentoLivreLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoLivreLinhas findMany
   */
  export type OrcamentoLivreLinhasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoLivreLinhas to fetch.
     */
    where?: OrcamentoLivreLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoLivreLinhas to fetch.
     */
    orderBy?: OrcamentoLivreLinhasOrderByWithRelationInput | OrcamentoLivreLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrcamentoLivreLinhas.
     */
    cursor?: OrcamentoLivreLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoLivreLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoLivreLinhas.
     */
    skip?: number
    distinct?: OrcamentoLivreLinhasScalarFieldEnum | OrcamentoLivreLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoLivreLinhas create
   */
  export type OrcamentoLivreLinhasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * The data needed to create a OrcamentoLivreLinhas.
     */
    data: XOR<OrcamentoLivreLinhasCreateInput, OrcamentoLivreLinhasUncheckedCreateInput>
  }

  /**
   * OrcamentoLivreLinhas createMany
   */
  export type OrcamentoLivreLinhasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrcamentoLivreLinhas.
     */
    data: OrcamentoLivreLinhasCreateManyInput | OrcamentoLivreLinhasCreateManyInput[]
  }

  /**
   * OrcamentoLivreLinhas update
   */
  export type OrcamentoLivreLinhasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * The data needed to update a OrcamentoLivreLinhas.
     */
    data: XOR<OrcamentoLivreLinhasUpdateInput, OrcamentoLivreLinhasUncheckedUpdateInput>
    /**
     * Choose, which OrcamentoLivreLinhas to update.
     */
    where: OrcamentoLivreLinhasWhereUniqueInput
  }

  /**
   * OrcamentoLivreLinhas updateMany
   */
  export type OrcamentoLivreLinhasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrcamentoLivreLinhas.
     */
    data: XOR<OrcamentoLivreLinhasUpdateManyMutationInput, OrcamentoLivreLinhasUncheckedUpdateManyInput>
    /**
     * Filter which OrcamentoLivreLinhas to update
     */
    where?: OrcamentoLivreLinhasWhereInput
    /**
     * Limit how many OrcamentoLivreLinhas to update.
     */
    limit?: number
  }

  /**
   * OrcamentoLivreLinhas upsert
   */
  export type OrcamentoLivreLinhasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * The filter to search for the OrcamentoLivreLinhas to update in case it exists.
     */
    where: OrcamentoLivreLinhasWhereUniqueInput
    /**
     * In case the OrcamentoLivreLinhas found by the `where` argument doesn't exist, create a new OrcamentoLivreLinhas with this data.
     */
    create: XOR<OrcamentoLivreLinhasCreateInput, OrcamentoLivreLinhasUncheckedCreateInput>
    /**
     * In case the OrcamentoLivreLinhas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrcamentoLivreLinhasUpdateInput, OrcamentoLivreLinhasUncheckedUpdateInput>
  }

  /**
   * OrcamentoLivreLinhas delete
   */
  export type OrcamentoLivreLinhasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
    /**
     * Filter which OrcamentoLivreLinhas to delete.
     */
    where: OrcamentoLivreLinhasWhereUniqueInput
  }

  /**
   * OrcamentoLivreLinhas deleteMany
   */
  export type OrcamentoLivreLinhasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoLivreLinhas to delete
     */
    where?: OrcamentoLivreLinhasWhereInput
    /**
     * Limit how many OrcamentoLivreLinhas to delete.
     */
    limit?: number
  }

  /**
   * OrcamentoLivreLinhas.ServicosEscolhidosLivreOrigem
   */
  export type OrcamentoLivreLinhas$ServicosEscolhidosLivreOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    where?: ServicosEscolhidosLivreOrigemWhereInput
    orderBy?: ServicosEscolhidosLivreOrigemOrderByWithRelationInput | ServicosEscolhidosLivreOrigemOrderByWithRelationInput[]
    cursor?: ServicosEscolhidosLivreOrigemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicosEscolhidosLivreOrigemScalarFieldEnum | ServicosEscolhidosLivreOrigemScalarFieldEnum[]
  }

  /**
   * OrcamentoLivreLinhas without action
   */
  export type OrcamentoLivreLinhasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoLivreLinhas
     */
    select?: OrcamentoLivreLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoLivreLinhas
     */
    omit?: OrcamentoLivreLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoLivreLinhasInclude<ExtArgs> | null
  }


  /**
   * Model OrcamentoOp
   */

  export type AggregateOrcamentoOp = {
    _count: OrcamentoOpCountAggregateOutputType | null
    _avg: OrcamentoOpAvgAggregateOutputType | null
    _sum: OrcamentoOpSumAggregateOutputType | null
    _min: OrcamentoOpMinAggregateOutputType | null
    _max: OrcamentoOpMaxAggregateOutputType | null
  }

  export type OrcamentoOpAvgAggregateOutputType = {
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoOpSumAggregateOutputType = {
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoOpMinAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    orcamentoStamp: string | null
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoOpMaxAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    orcamentoStamp: string | null
    orcamentoNumero: number | null
    ano: number | null
  }

  export type OrcamentoOpCountAggregateOutputType = {
    idPlaneamento: number
    Op: number
    orcamentoStamp: number
    orcamentoNumero: number
    ano: number
    _all: number
  }


  export type OrcamentoOpAvgAggregateInputType = {
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoOpSumAggregateInputType = {
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoOpMinAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    orcamentoStamp?: true
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoOpMaxAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    orcamentoStamp?: true
    orcamentoNumero?: true
    ano?: true
  }

  export type OrcamentoOpCountAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    orcamentoStamp?: true
    orcamentoNumero?: true
    ano?: true
    _all?: true
  }

  export type OrcamentoOpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoOp to aggregate.
     */
    where?: OrcamentoOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOps to fetch.
     */
    orderBy?: OrcamentoOpOrderByWithRelationInput | OrcamentoOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrcamentoOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrcamentoOps
    **/
    _count?: true | OrcamentoOpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrcamentoOpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrcamentoOpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrcamentoOpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrcamentoOpMaxAggregateInputType
  }

  export type GetOrcamentoOpAggregateType<T extends OrcamentoOpAggregateArgs> = {
        [P in keyof T & keyof AggregateOrcamentoOp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrcamentoOp[P]>
      : GetScalarType<T[P], AggregateOrcamentoOp[P]>
  }




  export type OrcamentoOpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrcamentoOpWhereInput
    orderBy?: OrcamentoOpOrderByWithAggregationInput | OrcamentoOpOrderByWithAggregationInput[]
    by: OrcamentoOpScalarFieldEnum[] | OrcamentoOpScalarFieldEnum
    having?: OrcamentoOpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrcamentoOpCountAggregateInputType | true
    _avg?: OrcamentoOpAvgAggregateInputType
    _sum?: OrcamentoOpSumAggregateInputType
    _min?: OrcamentoOpMinAggregateInputType
    _max?: OrcamentoOpMaxAggregateInputType
  }

  export type OrcamentoOpGroupByOutputType = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    _count: OrcamentoOpCountAggregateOutputType | null
    _avg: OrcamentoOpAvgAggregateOutputType | null
    _sum: OrcamentoOpSumAggregateOutputType | null
    _min: OrcamentoOpMinAggregateOutputType | null
    _max: OrcamentoOpMaxAggregateOutputType | null
  }

  type GetOrcamentoOpGroupByPayload<T extends OrcamentoOpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrcamentoOpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrcamentoOpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrcamentoOpGroupByOutputType[P]>
            : GetScalarType<T[P], OrcamentoOpGroupByOutputType[P]>
        }
      >
    >


  export type OrcamentoOpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    Op?: boolean
    orcamentoStamp?: boolean
    orcamentoNumero?: boolean
    ano?: boolean
    Op_OrcamentoOp_idPlaneamento_OpToOp?: boolean | OpDefaultArgs<ExtArgs>
    OrcamentoOpLinhas?: boolean | OrcamentoOp$OrcamentoOpLinhasArgs<ExtArgs>
    _count?: boolean | OrcamentoOpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orcamentoOp"]>



  export type OrcamentoOpSelectScalar = {
    idPlaneamento?: boolean
    Op?: boolean
    orcamentoStamp?: boolean
    orcamentoNumero?: boolean
    ano?: boolean
  }

  export type OrcamentoOpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "Op" | "orcamentoStamp" | "orcamentoNumero" | "ano", ExtArgs["result"]["orcamentoOp"]>
  export type OrcamentoOpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Op_OrcamentoOp_idPlaneamento_OpToOp?: boolean | OpDefaultArgs<ExtArgs>
    OrcamentoOpLinhas?: boolean | OrcamentoOp$OrcamentoOpLinhasArgs<ExtArgs>
    _count?: boolean | OrcamentoOpCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrcamentoOpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrcamentoOp"
    objects: {
      Op_OrcamentoOp_idPlaneamento_OpToOp: Prisma.$OpPayload<ExtArgs>
      OrcamentoOpLinhas: Prisma.$OrcamentoOpLinhasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      Op: string
      orcamentoStamp: string
      orcamentoNumero: number
      ano: number
    }, ExtArgs["result"]["orcamentoOp"]>
    composites: {}
  }

  type OrcamentoOpGetPayload<S extends boolean | null | undefined | OrcamentoOpDefaultArgs> = $Result.GetResult<Prisma.$OrcamentoOpPayload, S>

  type OrcamentoOpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrcamentoOpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrcamentoOpCountAggregateInputType | true
    }

  export interface OrcamentoOpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrcamentoOp'], meta: { name: 'OrcamentoOp' } }
    /**
     * Find zero or one OrcamentoOp that matches the filter.
     * @param {OrcamentoOpFindUniqueArgs} args - Arguments to find a OrcamentoOp
     * @example
     * // Get one OrcamentoOp
     * const orcamentoOp = await prisma.orcamentoOp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrcamentoOpFindUniqueArgs>(args: SelectSubset<T, OrcamentoOpFindUniqueArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OrcamentoOp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrcamentoOpFindUniqueOrThrowArgs} args - Arguments to find a OrcamentoOp
     * @example
     * // Get one OrcamentoOp
     * const orcamentoOp = await prisma.orcamentoOp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrcamentoOpFindUniqueOrThrowArgs>(args: SelectSubset<T, OrcamentoOpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoOp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpFindFirstArgs} args - Arguments to find a OrcamentoOp
     * @example
     * // Get one OrcamentoOp
     * const orcamentoOp = await prisma.orcamentoOp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrcamentoOpFindFirstArgs>(args?: SelectSubset<T, OrcamentoOpFindFirstArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoOp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpFindFirstOrThrowArgs} args - Arguments to find a OrcamentoOp
     * @example
     * // Get one OrcamentoOp
     * const orcamentoOp = await prisma.orcamentoOp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrcamentoOpFindFirstOrThrowArgs>(args?: SelectSubset<T, OrcamentoOpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OrcamentoOps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrcamentoOps
     * const orcamentoOps = await prisma.orcamentoOp.findMany()
     * 
     * // Get first 10 OrcamentoOps
     * const orcamentoOps = await prisma.orcamentoOp.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const orcamentoOpWithIdPlaneamentoOnly = await prisma.orcamentoOp.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends OrcamentoOpFindManyArgs>(args?: SelectSubset<T, OrcamentoOpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OrcamentoOp.
     * @param {OrcamentoOpCreateArgs} args - Arguments to create a OrcamentoOp.
     * @example
     * // Create one OrcamentoOp
     * const OrcamentoOp = await prisma.orcamentoOp.create({
     *   data: {
     *     // ... data to create a OrcamentoOp
     *   }
     * })
     * 
     */
    create<T extends OrcamentoOpCreateArgs>(args: SelectSubset<T, OrcamentoOpCreateArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OrcamentoOps.
     * @param {OrcamentoOpCreateManyArgs} args - Arguments to create many OrcamentoOps.
     * @example
     * // Create many OrcamentoOps
     * const orcamentoOp = await prisma.orcamentoOp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrcamentoOpCreateManyArgs>(args?: SelectSubset<T, OrcamentoOpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrcamentoOp.
     * @param {OrcamentoOpDeleteArgs} args - Arguments to delete one OrcamentoOp.
     * @example
     * // Delete one OrcamentoOp
     * const OrcamentoOp = await prisma.orcamentoOp.delete({
     *   where: {
     *     // ... filter to delete one OrcamentoOp
     *   }
     * })
     * 
     */
    delete<T extends OrcamentoOpDeleteArgs>(args: SelectSubset<T, OrcamentoOpDeleteArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OrcamentoOp.
     * @param {OrcamentoOpUpdateArgs} args - Arguments to update one OrcamentoOp.
     * @example
     * // Update one OrcamentoOp
     * const orcamentoOp = await prisma.orcamentoOp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrcamentoOpUpdateArgs>(args: SelectSubset<T, OrcamentoOpUpdateArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OrcamentoOps.
     * @param {OrcamentoOpDeleteManyArgs} args - Arguments to filter OrcamentoOps to delete.
     * @example
     * // Delete a few OrcamentoOps
     * const { count } = await prisma.orcamentoOp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrcamentoOpDeleteManyArgs>(args?: SelectSubset<T, OrcamentoOpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrcamentoOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrcamentoOps
     * const orcamentoOp = await prisma.orcamentoOp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrcamentoOpUpdateManyArgs>(args: SelectSubset<T, OrcamentoOpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrcamentoOp.
     * @param {OrcamentoOpUpsertArgs} args - Arguments to update or create a OrcamentoOp.
     * @example
     * // Update or create a OrcamentoOp
     * const orcamentoOp = await prisma.orcamentoOp.upsert({
     *   create: {
     *     // ... data to create a OrcamentoOp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrcamentoOp we want to update
     *   }
     * })
     */
    upsert<T extends OrcamentoOpUpsertArgs>(args: SelectSubset<T, OrcamentoOpUpsertArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OrcamentoOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpCountArgs} args - Arguments to filter OrcamentoOps to count.
     * @example
     * // Count the number of OrcamentoOps
     * const count = await prisma.orcamentoOp.count({
     *   where: {
     *     // ... the filter for the OrcamentoOps we want to count
     *   }
     * })
    **/
    count<T extends OrcamentoOpCountArgs>(
      args?: Subset<T, OrcamentoOpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrcamentoOpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrcamentoOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrcamentoOpAggregateArgs>(args: Subset<T, OrcamentoOpAggregateArgs>): Prisma.PrismaPromise<GetOrcamentoOpAggregateType<T>>

    /**
     * Group by OrcamentoOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrcamentoOpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrcamentoOpGroupByArgs['orderBy'] }
        : { orderBy?: OrcamentoOpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrcamentoOpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrcamentoOpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrcamentoOp model
   */
  readonly fields: OrcamentoOpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrcamentoOp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrcamentoOpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Op_OrcamentoOp_idPlaneamento_OpToOp<T extends OpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpDefaultArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    OrcamentoOpLinhas<T extends OrcamentoOp$OrcamentoOpLinhasArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoOp$OrcamentoOpLinhasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrcamentoOp model
   */ 
  interface OrcamentoOpFieldRefs {
    readonly idPlaneamento: FieldRef<"OrcamentoOp", 'String'>
    readonly Op: FieldRef<"OrcamentoOp", 'String'>
    readonly orcamentoStamp: FieldRef<"OrcamentoOp", 'String'>
    readonly orcamentoNumero: FieldRef<"OrcamentoOp", 'Int'>
    readonly ano: FieldRef<"OrcamentoOp", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrcamentoOp findUnique
   */
  export type OrcamentoOpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOp to fetch.
     */
    where: OrcamentoOpWhereUniqueInput
  }

  /**
   * OrcamentoOp findUniqueOrThrow
   */
  export type OrcamentoOpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOp to fetch.
     */
    where: OrcamentoOpWhereUniqueInput
  }

  /**
   * OrcamentoOp findFirst
   */
  export type OrcamentoOpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOp to fetch.
     */
    where?: OrcamentoOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOps to fetch.
     */
    orderBy?: OrcamentoOpOrderByWithRelationInput | OrcamentoOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoOps.
     */
    cursor?: OrcamentoOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoOps.
     */
    distinct?: OrcamentoOpScalarFieldEnum | OrcamentoOpScalarFieldEnum[]
  }

  /**
   * OrcamentoOp findFirstOrThrow
   */
  export type OrcamentoOpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOp to fetch.
     */
    where?: OrcamentoOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOps to fetch.
     */
    orderBy?: OrcamentoOpOrderByWithRelationInput | OrcamentoOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoOps.
     */
    cursor?: OrcamentoOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoOps.
     */
    distinct?: OrcamentoOpScalarFieldEnum | OrcamentoOpScalarFieldEnum[]
  }

  /**
   * OrcamentoOp findMany
   */
  export type OrcamentoOpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOps to fetch.
     */
    where?: OrcamentoOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOps to fetch.
     */
    orderBy?: OrcamentoOpOrderByWithRelationInput | OrcamentoOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrcamentoOps.
     */
    cursor?: OrcamentoOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOps.
     */
    skip?: number
    distinct?: OrcamentoOpScalarFieldEnum | OrcamentoOpScalarFieldEnum[]
  }

  /**
   * OrcamentoOp create
   */
  export type OrcamentoOpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * The data needed to create a OrcamentoOp.
     */
    data: XOR<OrcamentoOpCreateInput, OrcamentoOpUncheckedCreateInput>
  }

  /**
   * OrcamentoOp createMany
   */
  export type OrcamentoOpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrcamentoOps.
     */
    data: OrcamentoOpCreateManyInput | OrcamentoOpCreateManyInput[]
  }

  /**
   * OrcamentoOp update
   */
  export type OrcamentoOpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * The data needed to update a OrcamentoOp.
     */
    data: XOR<OrcamentoOpUpdateInput, OrcamentoOpUncheckedUpdateInput>
    /**
     * Choose, which OrcamentoOp to update.
     */
    where: OrcamentoOpWhereUniqueInput
  }

  /**
   * OrcamentoOp updateMany
   */
  export type OrcamentoOpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrcamentoOps.
     */
    data: XOR<OrcamentoOpUpdateManyMutationInput, OrcamentoOpUncheckedUpdateManyInput>
    /**
     * Filter which OrcamentoOps to update
     */
    where?: OrcamentoOpWhereInput
    /**
     * Limit how many OrcamentoOps to update.
     */
    limit?: number
  }

  /**
   * OrcamentoOp upsert
   */
  export type OrcamentoOpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * The filter to search for the OrcamentoOp to update in case it exists.
     */
    where: OrcamentoOpWhereUniqueInput
    /**
     * In case the OrcamentoOp found by the `where` argument doesn't exist, create a new OrcamentoOp with this data.
     */
    create: XOR<OrcamentoOpCreateInput, OrcamentoOpUncheckedCreateInput>
    /**
     * In case the OrcamentoOp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrcamentoOpUpdateInput, OrcamentoOpUncheckedUpdateInput>
  }

  /**
   * OrcamentoOp delete
   */
  export type OrcamentoOpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
    /**
     * Filter which OrcamentoOp to delete.
     */
    where: OrcamentoOpWhereUniqueInput
  }

  /**
   * OrcamentoOp deleteMany
   */
  export type OrcamentoOpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoOps to delete
     */
    where?: OrcamentoOpWhereInput
    /**
     * Limit how many OrcamentoOps to delete.
     */
    limit?: number
  }

  /**
   * OrcamentoOp.OrcamentoOpLinhas
   */
  export type OrcamentoOp$OrcamentoOpLinhasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    where?: OrcamentoOpLinhasWhereInput
    orderBy?: OrcamentoOpLinhasOrderByWithRelationInput | OrcamentoOpLinhasOrderByWithRelationInput[]
    cursor?: OrcamentoOpLinhasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrcamentoOpLinhasScalarFieldEnum | OrcamentoOpLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoOp without action
   */
  export type OrcamentoOpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOp
     */
    select?: OrcamentoOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOp
     */
    omit?: OrcamentoOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpInclude<ExtArgs> | null
  }


  /**
   * Model OrcamentoOpLinhas
   */

  export type AggregateOrcamentoOpLinhas = {
    _count: OrcamentoOpLinhasCountAggregateOutputType | null
    _avg: OrcamentoOpLinhasAvgAggregateOutputType | null
    _sum: OrcamentoOpLinhasSumAggregateOutputType | null
    _min: OrcamentoOpLinhasMinAggregateOutputType | null
    _max: OrcamentoOpLinhasMaxAggregateOutputType | null
  }

  export type OrcamentoOpLinhasAvgAggregateOutputType = {
    ordem: number | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
  }

  export type OrcamentoOpLinhasSumAggregateOutputType = {
    ordem: number | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
  }

  export type OrcamentoOpLinhasMinAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    orcamentoStamp: string | null
    orcamentoLinhasStamp: string | null
    orcamentoLinhasStampRecebido: string | null
    ordem: number | null
    design: string | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
    unidade: string | null
  }

  export type OrcamentoOpLinhasMaxAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    orcamentoStamp: string | null
    orcamentoLinhasStamp: string | null
    orcamentoLinhasStampRecebido: string | null
    ordem: number | null
    design: string | null
    custoPeca: number | null
    edebito: number | null
    qtt: number | null
    unidade: string | null
  }

  export type OrcamentoOpLinhasCountAggregateOutputType = {
    idPlaneamento: number
    Op: number
    orcamentoStamp: number
    orcamentoLinhasStamp: number
    orcamentoLinhasStampRecebido: number
    ordem: number
    design: number
    custoPeca: number
    edebito: number
    qtt: number
    unidade: number
    _all: number
  }


  export type OrcamentoOpLinhasAvgAggregateInputType = {
    ordem?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
  }

  export type OrcamentoOpLinhasSumAggregateInputType = {
    ordem?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
  }

  export type OrcamentoOpLinhasMinAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    orcamentoStamp?: true
    orcamentoLinhasStamp?: true
    orcamentoLinhasStampRecebido?: true
    ordem?: true
    design?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
    unidade?: true
  }

  export type OrcamentoOpLinhasMaxAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    orcamentoStamp?: true
    orcamentoLinhasStamp?: true
    orcamentoLinhasStampRecebido?: true
    ordem?: true
    design?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
    unidade?: true
  }

  export type OrcamentoOpLinhasCountAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    orcamentoStamp?: true
    orcamentoLinhasStamp?: true
    orcamentoLinhasStampRecebido?: true
    ordem?: true
    design?: true
    custoPeca?: true
    edebito?: true
    qtt?: true
    unidade?: true
    _all?: true
  }

  export type OrcamentoOpLinhasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoOpLinhas to aggregate.
     */
    where?: OrcamentoOpLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOpLinhas to fetch.
     */
    orderBy?: OrcamentoOpLinhasOrderByWithRelationInput | OrcamentoOpLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrcamentoOpLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOpLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOpLinhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrcamentoOpLinhas
    **/
    _count?: true | OrcamentoOpLinhasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrcamentoOpLinhasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrcamentoOpLinhasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrcamentoOpLinhasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrcamentoOpLinhasMaxAggregateInputType
  }

  export type GetOrcamentoOpLinhasAggregateType<T extends OrcamentoOpLinhasAggregateArgs> = {
        [P in keyof T & keyof AggregateOrcamentoOpLinhas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrcamentoOpLinhas[P]>
      : GetScalarType<T[P], AggregateOrcamentoOpLinhas[P]>
  }




  export type OrcamentoOpLinhasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrcamentoOpLinhasWhereInput
    orderBy?: OrcamentoOpLinhasOrderByWithAggregationInput | OrcamentoOpLinhasOrderByWithAggregationInput[]
    by: OrcamentoOpLinhasScalarFieldEnum[] | OrcamentoOpLinhasScalarFieldEnum
    having?: OrcamentoOpLinhasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrcamentoOpLinhasCountAggregateInputType | true
    _avg?: OrcamentoOpLinhasAvgAggregateInputType
    _sum?: OrcamentoOpLinhasSumAggregateInputType
    _min?: OrcamentoOpLinhasMinAggregateInputType
    _max?: OrcamentoOpLinhasMaxAggregateInputType
  }

  export type OrcamentoOpLinhasGroupByOutputType = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoLinhasStamp: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    _count: OrcamentoOpLinhasCountAggregateOutputType | null
    _avg: OrcamentoOpLinhasAvgAggregateOutputType | null
    _sum: OrcamentoOpLinhasSumAggregateOutputType | null
    _min: OrcamentoOpLinhasMinAggregateOutputType | null
    _max: OrcamentoOpLinhasMaxAggregateOutputType | null
  }

  type GetOrcamentoOpLinhasGroupByPayload<T extends OrcamentoOpLinhasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrcamentoOpLinhasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrcamentoOpLinhasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrcamentoOpLinhasGroupByOutputType[P]>
            : GetScalarType<T[P], OrcamentoOpLinhasGroupByOutputType[P]>
        }
      >
    >


  export type OrcamentoOpLinhasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    Op?: boolean
    orcamentoStamp?: boolean
    orcamentoLinhasStamp?: boolean
    orcamentoLinhasStampRecebido?: boolean
    ordem?: boolean
    design?: boolean
    custoPeca?: boolean
    edebito?: boolean
    qtt?: boolean
    unidade?: boolean
    OrcamentoOp?: boolean | OrcamentoOpDefaultArgs<ExtArgs>
    ServicosEscolhidosOpOrigem?: boolean | OrcamentoOpLinhas$ServicosEscolhidosOpOrigemArgs<ExtArgs>
    _count?: boolean | OrcamentoOpLinhasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orcamentoOpLinhas"]>



  export type OrcamentoOpLinhasSelectScalar = {
    idPlaneamento?: boolean
    Op?: boolean
    orcamentoStamp?: boolean
    orcamentoLinhasStamp?: boolean
    orcamentoLinhasStampRecebido?: boolean
    ordem?: boolean
    design?: boolean
    custoPeca?: boolean
    edebito?: boolean
    qtt?: boolean
    unidade?: boolean
  }

  export type OrcamentoOpLinhasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "Op" | "orcamentoStamp" | "orcamentoLinhasStamp" | "orcamentoLinhasStampRecebido" | "ordem" | "design" | "custoPeca" | "edebito" | "qtt" | "unidade", ExtArgs["result"]["orcamentoOpLinhas"]>
  export type OrcamentoOpLinhasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrcamentoOp?: boolean | OrcamentoOpDefaultArgs<ExtArgs>
    ServicosEscolhidosOpOrigem?: boolean | OrcamentoOpLinhas$ServicosEscolhidosOpOrigemArgs<ExtArgs>
    _count?: boolean | OrcamentoOpLinhasCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrcamentoOpLinhasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrcamentoOpLinhas"
    objects: {
      OrcamentoOp: Prisma.$OrcamentoOpPayload<ExtArgs>
      ServicosEscolhidosOpOrigem: Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      Op: string
      orcamentoStamp: string
      orcamentoLinhasStamp: string
      orcamentoLinhasStampRecebido: string
      ordem: number
      design: string
      custoPeca: number
      edebito: number
      qtt: number
      unidade: string
    }, ExtArgs["result"]["orcamentoOpLinhas"]>
    composites: {}
  }

  type OrcamentoOpLinhasGetPayload<S extends boolean | null | undefined | OrcamentoOpLinhasDefaultArgs> = $Result.GetResult<Prisma.$OrcamentoOpLinhasPayload, S>

  type OrcamentoOpLinhasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrcamentoOpLinhasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrcamentoOpLinhasCountAggregateInputType | true
    }

  export interface OrcamentoOpLinhasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrcamentoOpLinhas'], meta: { name: 'OrcamentoOpLinhas' } }
    /**
     * Find zero or one OrcamentoOpLinhas that matches the filter.
     * @param {OrcamentoOpLinhasFindUniqueArgs} args - Arguments to find a OrcamentoOpLinhas
     * @example
     * // Get one OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrcamentoOpLinhasFindUniqueArgs>(args: SelectSubset<T, OrcamentoOpLinhasFindUniqueArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one OrcamentoOpLinhas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrcamentoOpLinhasFindUniqueOrThrowArgs} args - Arguments to find a OrcamentoOpLinhas
     * @example
     * // Get one OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrcamentoOpLinhasFindUniqueOrThrowArgs>(args: SelectSubset<T, OrcamentoOpLinhasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoOpLinhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpLinhasFindFirstArgs} args - Arguments to find a OrcamentoOpLinhas
     * @example
     * // Get one OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrcamentoOpLinhasFindFirstArgs>(args?: SelectSubset<T, OrcamentoOpLinhasFindFirstArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first OrcamentoOpLinhas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpLinhasFindFirstOrThrowArgs} args - Arguments to find a OrcamentoOpLinhas
     * @example
     * // Get one OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrcamentoOpLinhasFindFirstOrThrowArgs>(args?: SelectSubset<T, OrcamentoOpLinhasFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more OrcamentoOpLinhas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpLinhasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.findMany()
     * 
     * // Get first 10 OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const orcamentoOpLinhasWithIdPlaneamentoOnly = await prisma.orcamentoOpLinhas.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends OrcamentoOpLinhasFindManyArgs>(args?: SelectSubset<T, OrcamentoOpLinhasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a OrcamentoOpLinhas.
     * @param {OrcamentoOpLinhasCreateArgs} args - Arguments to create a OrcamentoOpLinhas.
     * @example
     * // Create one OrcamentoOpLinhas
     * const OrcamentoOpLinhas = await prisma.orcamentoOpLinhas.create({
     *   data: {
     *     // ... data to create a OrcamentoOpLinhas
     *   }
     * })
     * 
     */
    create<T extends OrcamentoOpLinhasCreateArgs>(args: SelectSubset<T, OrcamentoOpLinhasCreateArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many OrcamentoOpLinhas.
     * @param {OrcamentoOpLinhasCreateManyArgs} args - Arguments to create many OrcamentoOpLinhas.
     * @example
     * // Create many OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrcamentoOpLinhasCreateManyArgs>(args?: SelectSubset<T, OrcamentoOpLinhasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrcamentoOpLinhas.
     * @param {OrcamentoOpLinhasDeleteArgs} args - Arguments to delete one OrcamentoOpLinhas.
     * @example
     * // Delete one OrcamentoOpLinhas
     * const OrcamentoOpLinhas = await prisma.orcamentoOpLinhas.delete({
     *   where: {
     *     // ... filter to delete one OrcamentoOpLinhas
     *   }
     * })
     * 
     */
    delete<T extends OrcamentoOpLinhasDeleteArgs>(args: SelectSubset<T, OrcamentoOpLinhasDeleteArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one OrcamentoOpLinhas.
     * @param {OrcamentoOpLinhasUpdateArgs} args - Arguments to update one OrcamentoOpLinhas.
     * @example
     * // Update one OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrcamentoOpLinhasUpdateArgs>(args: SelectSubset<T, OrcamentoOpLinhasUpdateArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more OrcamentoOpLinhas.
     * @param {OrcamentoOpLinhasDeleteManyArgs} args - Arguments to filter OrcamentoOpLinhas to delete.
     * @example
     * // Delete a few OrcamentoOpLinhas
     * const { count } = await prisma.orcamentoOpLinhas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrcamentoOpLinhasDeleteManyArgs>(args?: SelectSubset<T, OrcamentoOpLinhasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrcamentoOpLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpLinhasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrcamentoOpLinhasUpdateManyArgs>(args: SelectSubset<T, OrcamentoOpLinhasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrcamentoOpLinhas.
     * @param {OrcamentoOpLinhasUpsertArgs} args - Arguments to update or create a OrcamentoOpLinhas.
     * @example
     * // Update or create a OrcamentoOpLinhas
     * const orcamentoOpLinhas = await prisma.orcamentoOpLinhas.upsert({
     *   create: {
     *     // ... data to create a OrcamentoOpLinhas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrcamentoOpLinhas we want to update
     *   }
     * })
     */
    upsert<T extends OrcamentoOpLinhasUpsertArgs>(args: SelectSubset<T, OrcamentoOpLinhasUpsertArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of OrcamentoOpLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpLinhasCountArgs} args - Arguments to filter OrcamentoOpLinhas to count.
     * @example
     * // Count the number of OrcamentoOpLinhas
     * const count = await prisma.orcamentoOpLinhas.count({
     *   where: {
     *     // ... the filter for the OrcamentoOpLinhas we want to count
     *   }
     * })
    **/
    count<T extends OrcamentoOpLinhasCountArgs>(
      args?: Subset<T, OrcamentoOpLinhasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrcamentoOpLinhasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrcamentoOpLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpLinhasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrcamentoOpLinhasAggregateArgs>(args: Subset<T, OrcamentoOpLinhasAggregateArgs>): Prisma.PrismaPromise<GetOrcamentoOpLinhasAggregateType<T>>

    /**
     * Group by OrcamentoOpLinhas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrcamentoOpLinhasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrcamentoOpLinhasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrcamentoOpLinhasGroupByArgs['orderBy'] }
        : { orderBy?: OrcamentoOpLinhasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrcamentoOpLinhasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrcamentoOpLinhasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrcamentoOpLinhas model
   */
  readonly fields: OrcamentoOpLinhasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrcamentoOpLinhas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrcamentoOpLinhasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrcamentoOp<T extends OrcamentoOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoOpDefaultArgs<ExtArgs>>): Prisma__OrcamentoOpClient<$Result.GetResult<Prisma.$OrcamentoOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ServicosEscolhidosOpOrigem<T extends OrcamentoOpLinhas$ServicosEscolhidosOpOrigemArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoOpLinhas$ServicosEscolhidosOpOrigemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrcamentoOpLinhas model
   */ 
  interface OrcamentoOpLinhasFieldRefs {
    readonly idPlaneamento: FieldRef<"OrcamentoOpLinhas", 'String'>
    readonly Op: FieldRef<"OrcamentoOpLinhas", 'String'>
    readonly orcamentoStamp: FieldRef<"OrcamentoOpLinhas", 'String'>
    readonly orcamentoLinhasStamp: FieldRef<"OrcamentoOpLinhas", 'String'>
    readonly orcamentoLinhasStampRecebido: FieldRef<"OrcamentoOpLinhas", 'String'>
    readonly ordem: FieldRef<"OrcamentoOpLinhas", 'Int'>
    readonly design: FieldRef<"OrcamentoOpLinhas", 'String'>
    readonly custoPeca: FieldRef<"OrcamentoOpLinhas", 'Float'>
    readonly edebito: FieldRef<"OrcamentoOpLinhas", 'Float'>
    readonly qtt: FieldRef<"OrcamentoOpLinhas", 'Float'>
    readonly unidade: FieldRef<"OrcamentoOpLinhas", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrcamentoOpLinhas findUnique
   */
  export type OrcamentoOpLinhasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOpLinhas to fetch.
     */
    where: OrcamentoOpLinhasWhereUniqueInput
  }

  /**
   * OrcamentoOpLinhas findUniqueOrThrow
   */
  export type OrcamentoOpLinhasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOpLinhas to fetch.
     */
    where: OrcamentoOpLinhasWhereUniqueInput
  }

  /**
   * OrcamentoOpLinhas findFirst
   */
  export type OrcamentoOpLinhasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOpLinhas to fetch.
     */
    where?: OrcamentoOpLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOpLinhas to fetch.
     */
    orderBy?: OrcamentoOpLinhasOrderByWithRelationInput | OrcamentoOpLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoOpLinhas.
     */
    cursor?: OrcamentoOpLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOpLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOpLinhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoOpLinhas.
     */
    distinct?: OrcamentoOpLinhasScalarFieldEnum | OrcamentoOpLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoOpLinhas findFirstOrThrow
   */
  export type OrcamentoOpLinhasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOpLinhas to fetch.
     */
    where?: OrcamentoOpLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOpLinhas to fetch.
     */
    orderBy?: OrcamentoOpLinhasOrderByWithRelationInput | OrcamentoOpLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrcamentoOpLinhas.
     */
    cursor?: OrcamentoOpLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOpLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOpLinhas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrcamentoOpLinhas.
     */
    distinct?: OrcamentoOpLinhasScalarFieldEnum | OrcamentoOpLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoOpLinhas findMany
   */
  export type OrcamentoOpLinhasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * Filter, which OrcamentoOpLinhas to fetch.
     */
    where?: OrcamentoOpLinhasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrcamentoOpLinhas to fetch.
     */
    orderBy?: OrcamentoOpLinhasOrderByWithRelationInput | OrcamentoOpLinhasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrcamentoOpLinhas.
     */
    cursor?: OrcamentoOpLinhasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrcamentoOpLinhas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrcamentoOpLinhas.
     */
    skip?: number
    distinct?: OrcamentoOpLinhasScalarFieldEnum | OrcamentoOpLinhasScalarFieldEnum[]
  }

  /**
   * OrcamentoOpLinhas create
   */
  export type OrcamentoOpLinhasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * The data needed to create a OrcamentoOpLinhas.
     */
    data: XOR<OrcamentoOpLinhasCreateInput, OrcamentoOpLinhasUncheckedCreateInput>
  }

  /**
   * OrcamentoOpLinhas createMany
   */
  export type OrcamentoOpLinhasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrcamentoOpLinhas.
     */
    data: OrcamentoOpLinhasCreateManyInput | OrcamentoOpLinhasCreateManyInput[]
  }

  /**
   * OrcamentoOpLinhas update
   */
  export type OrcamentoOpLinhasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * The data needed to update a OrcamentoOpLinhas.
     */
    data: XOR<OrcamentoOpLinhasUpdateInput, OrcamentoOpLinhasUncheckedUpdateInput>
    /**
     * Choose, which OrcamentoOpLinhas to update.
     */
    where: OrcamentoOpLinhasWhereUniqueInput
  }

  /**
   * OrcamentoOpLinhas updateMany
   */
  export type OrcamentoOpLinhasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrcamentoOpLinhas.
     */
    data: XOR<OrcamentoOpLinhasUpdateManyMutationInput, OrcamentoOpLinhasUncheckedUpdateManyInput>
    /**
     * Filter which OrcamentoOpLinhas to update
     */
    where?: OrcamentoOpLinhasWhereInput
    /**
     * Limit how many OrcamentoOpLinhas to update.
     */
    limit?: number
  }

  /**
   * OrcamentoOpLinhas upsert
   */
  export type OrcamentoOpLinhasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * The filter to search for the OrcamentoOpLinhas to update in case it exists.
     */
    where: OrcamentoOpLinhasWhereUniqueInput
    /**
     * In case the OrcamentoOpLinhas found by the `where` argument doesn't exist, create a new OrcamentoOpLinhas with this data.
     */
    create: XOR<OrcamentoOpLinhasCreateInput, OrcamentoOpLinhasUncheckedCreateInput>
    /**
     * In case the OrcamentoOpLinhas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrcamentoOpLinhasUpdateInput, OrcamentoOpLinhasUncheckedUpdateInput>
  }

  /**
   * OrcamentoOpLinhas delete
   */
  export type OrcamentoOpLinhasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
    /**
     * Filter which OrcamentoOpLinhas to delete.
     */
    where: OrcamentoOpLinhasWhereUniqueInput
  }

  /**
   * OrcamentoOpLinhas deleteMany
   */
  export type OrcamentoOpLinhasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrcamentoOpLinhas to delete
     */
    where?: OrcamentoOpLinhasWhereInput
    /**
     * Limit how many OrcamentoOpLinhas to delete.
     */
    limit?: number
  }

  /**
   * OrcamentoOpLinhas.ServicosEscolhidosOpOrigem
   */
  export type OrcamentoOpLinhas$ServicosEscolhidosOpOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    where?: ServicosEscolhidosOpOrigemWhereInput
    orderBy?: ServicosEscolhidosOpOrigemOrderByWithRelationInput | ServicosEscolhidosOpOrigemOrderByWithRelationInput[]
    cursor?: ServicosEscolhidosOpOrigemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicosEscolhidosOpOrigemScalarFieldEnum | ServicosEscolhidosOpOrigemScalarFieldEnum[]
  }

  /**
   * OrcamentoOpLinhas without action
   */
  export type OrcamentoOpLinhasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrcamentoOpLinhas
     */
    select?: OrcamentoOpLinhasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrcamentoOpLinhas
     */
    omit?: OrcamentoOpLinhasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrcamentoOpLinhasInclude<ExtArgs> | null
  }


  /**
   * Model Papeis
   */

  export type AggregatePapeis = {
    _count: PapeisCountAggregateOutputType | null
    _min: PapeisMinAggregateOutputType | null
    _max: PapeisMaxAggregateOutputType | null
  }

  export type PapeisMinAggregateOutputType = {
    idPapeis: string | null
    descPapel: string | null
  }

  export type PapeisMaxAggregateOutputType = {
    idPapeis: string | null
    descPapel: string | null
  }

  export type PapeisCountAggregateOutputType = {
    idPapeis: number
    descPapel: number
    _all: number
  }


  export type PapeisMinAggregateInputType = {
    idPapeis?: true
    descPapel?: true
  }

  export type PapeisMaxAggregateInputType = {
    idPapeis?: true
    descPapel?: true
  }

  export type PapeisCountAggregateInputType = {
    idPapeis?: true
    descPapel?: true
    _all?: true
  }

  export type PapeisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Papeis to aggregate.
     */
    where?: PapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papeis to fetch.
     */
    orderBy?: PapeisOrderByWithRelationInput | PapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papeis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Papeis
    **/
    _count?: true | PapeisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PapeisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PapeisMaxAggregateInputType
  }

  export type GetPapeisAggregateType<T extends PapeisAggregateArgs> = {
        [P in keyof T & keyof AggregatePapeis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePapeis[P]>
      : GetScalarType<T[P], AggregatePapeis[P]>
  }




  export type PapeisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PapeisWhereInput
    orderBy?: PapeisOrderByWithAggregationInput | PapeisOrderByWithAggregationInput[]
    by: PapeisScalarFieldEnum[] | PapeisScalarFieldEnum
    having?: PapeisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PapeisCountAggregateInputType | true
    _min?: PapeisMinAggregateInputType
    _max?: PapeisMaxAggregateInputType
  }

  export type PapeisGroupByOutputType = {
    idPapeis: string
    descPapel: string
    _count: PapeisCountAggregateOutputType | null
    _min: PapeisMinAggregateOutputType | null
    _max: PapeisMaxAggregateOutputType | null
  }

  type GetPapeisGroupByPayload<T extends PapeisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PapeisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PapeisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PapeisGroupByOutputType[P]>
            : GetScalarType<T[P], PapeisGroupByOutputType[P]>
        }
      >
    >


  export type PapeisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPapeis?: boolean
    descPapel?: boolean
    UserPapeis?: boolean | Papeis$UserPapeisArgs<ExtArgs>
    _count?: boolean | PapeisCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["papeis"]>



  export type PapeisSelectScalar = {
    idPapeis?: boolean
    descPapel?: boolean
  }

  export type PapeisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPapeis" | "descPapel", ExtArgs["result"]["papeis"]>
  export type PapeisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    UserPapeis?: boolean | Papeis$UserPapeisArgs<ExtArgs>
    _count?: boolean | PapeisCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PapeisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Papeis"
    objects: {
      UserPapeis: Prisma.$UserPapeisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPapeis: string
      descPapel: string
    }, ExtArgs["result"]["papeis"]>
    composites: {}
  }

  type PapeisGetPayload<S extends boolean | null | undefined | PapeisDefaultArgs> = $Result.GetResult<Prisma.$PapeisPayload, S>

  type PapeisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PapeisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PapeisCountAggregateInputType | true
    }

  export interface PapeisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Papeis'], meta: { name: 'Papeis' } }
    /**
     * Find zero or one Papeis that matches the filter.
     * @param {PapeisFindUniqueArgs} args - Arguments to find a Papeis
     * @example
     * // Get one Papeis
     * const papeis = await prisma.papeis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PapeisFindUniqueArgs>(args: SelectSubset<T, PapeisFindUniqueArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Papeis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PapeisFindUniqueOrThrowArgs} args - Arguments to find a Papeis
     * @example
     * // Get one Papeis
     * const papeis = await prisma.papeis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PapeisFindUniqueOrThrowArgs>(args: SelectSubset<T, PapeisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Papeis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapeisFindFirstArgs} args - Arguments to find a Papeis
     * @example
     * // Get one Papeis
     * const papeis = await prisma.papeis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PapeisFindFirstArgs>(args?: SelectSubset<T, PapeisFindFirstArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Papeis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapeisFindFirstOrThrowArgs} args - Arguments to find a Papeis
     * @example
     * // Get one Papeis
     * const papeis = await prisma.papeis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PapeisFindFirstOrThrowArgs>(args?: SelectSubset<T, PapeisFindFirstOrThrowArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Papeis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapeisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Papeis
     * const papeis = await prisma.papeis.findMany()
     * 
     * // Get first 10 Papeis
     * const papeis = await prisma.papeis.findMany({ take: 10 })
     * 
     * // Only select the `idPapeis`
     * const papeisWithIdPapeisOnly = await prisma.papeis.findMany({ select: { idPapeis: true } })
     * 
     */
    findMany<T extends PapeisFindManyArgs>(args?: SelectSubset<T, PapeisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Papeis.
     * @param {PapeisCreateArgs} args - Arguments to create a Papeis.
     * @example
     * // Create one Papeis
     * const Papeis = await prisma.papeis.create({
     *   data: {
     *     // ... data to create a Papeis
     *   }
     * })
     * 
     */
    create<T extends PapeisCreateArgs>(args: SelectSubset<T, PapeisCreateArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Papeis.
     * @param {PapeisCreateManyArgs} args - Arguments to create many Papeis.
     * @example
     * // Create many Papeis
     * const papeis = await prisma.papeis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PapeisCreateManyArgs>(args?: SelectSubset<T, PapeisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Papeis.
     * @param {PapeisDeleteArgs} args - Arguments to delete one Papeis.
     * @example
     * // Delete one Papeis
     * const Papeis = await prisma.papeis.delete({
     *   where: {
     *     // ... filter to delete one Papeis
     *   }
     * })
     * 
     */
    delete<T extends PapeisDeleteArgs>(args: SelectSubset<T, PapeisDeleteArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Papeis.
     * @param {PapeisUpdateArgs} args - Arguments to update one Papeis.
     * @example
     * // Update one Papeis
     * const papeis = await prisma.papeis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PapeisUpdateArgs>(args: SelectSubset<T, PapeisUpdateArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Papeis.
     * @param {PapeisDeleteManyArgs} args - Arguments to filter Papeis to delete.
     * @example
     * // Delete a few Papeis
     * const { count } = await prisma.papeis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PapeisDeleteManyArgs>(args?: SelectSubset<T, PapeisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Papeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapeisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Papeis
     * const papeis = await prisma.papeis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PapeisUpdateManyArgs>(args: SelectSubset<T, PapeisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Papeis.
     * @param {PapeisUpsertArgs} args - Arguments to update or create a Papeis.
     * @example
     * // Update or create a Papeis
     * const papeis = await prisma.papeis.upsert({
     *   create: {
     *     // ... data to create a Papeis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Papeis we want to update
     *   }
     * })
     */
    upsert<T extends PapeisUpsertArgs>(args: SelectSubset<T, PapeisUpsertArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Papeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapeisCountArgs} args - Arguments to filter Papeis to count.
     * @example
     * // Count the number of Papeis
     * const count = await prisma.papeis.count({
     *   where: {
     *     // ... the filter for the Papeis we want to count
     *   }
     * })
    **/
    count<T extends PapeisCountArgs>(
      args?: Subset<T, PapeisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PapeisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Papeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapeisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PapeisAggregateArgs>(args: Subset<T, PapeisAggregateArgs>): Prisma.PrismaPromise<GetPapeisAggregateType<T>>

    /**
     * Group by Papeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PapeisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PapeisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PapeisGroupByArgs['orderBy'] }
        : { orderBy?: PapeisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PapeisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPapeisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Papeis model
   */
  readonly fields: PapeisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Papeis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PapeisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    UserPapeis<T extends Papeis$UserPapeisArgs<ExtArgs> = {}>(args?: Subset<T, Papeis$UserPapeisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Papeis model
   */ 
  interface PapeisFieldRefs {
    readonly idPapeis: FieldRef<"Papeis", 'String'>
    readonly descPapel: FieldRef<"Papeis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Papeis findUnique
   */
  export type PapeisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * Filter, which Papeis to fetch.
     */
    where: PapeisWhereUniqueInput
  }

  /**
   * Papeis findUniqueOrThrow
   */
  export type PapeisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * Filter, which Papeis to fetch.
     */
    where: PapeisWhereUniqueInput
  }

  /**
   * Papeis findFirst
   */
  export type PapeisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * Filter, which Papeis to fetch.
     */
    where?: PapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papeis to fetch.
     */
    orderBy?: PapeisOrderByWithRelationInput | PapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Papeis.
     */
    cursor?: PapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papeis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Papeis.
     */
    distinct?: PapeisScalarFieldEnum | PapeisScalarFieldEnum[]
  }

  /**
   * Papeis findFirstOrThrow
   */
  export type PapeisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * Filter, which Papeis to fetch.
     */
    where?: PapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papeis to fetch.
     */
    orderBy?: PapeisOrderByWithRelationInput | PapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Papeis.
     */
    cursor?: PapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papeis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Papeis.
     */
    distinct?: PapeisScalarFieldEnum | PapeisScalarFieldEnum[]
  }

  /**
   * Papeis findMany
   */
  export type PapeisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * Filter, which Papeis to fetch.
     */
    where?: PapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Papeis to fetch.
     */
    orderBy?: PapeisOrderByWithRelationInput | PapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Papeis.
     */
    cursor?: PapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Papeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Papeis.
     */
    skip?: number
    distinct?: PapeisScalarFieldEnum | PapeisScalarFieldEnum[]
  }

  /**
   * Papeis create
   */
  export type PapeisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * The data needed to create a Papeis.
     */
    data: XOR<PapeisCreateInput, PapeisUncheckedCreateInput>
  }

  /**
   * Papeis createMany
   */
  export type PapeisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Papeis.
     */
    data: PapeisCreateManyInput | PapeisCreateManyInput[]
  }

  /**
   * Papeis update
   */
  export type PapeisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * The data needed to update a Papeis.
     */
    data: XOR<PapeisUpdateInput, PapeisUncheckedUpdateInput>
    /**
     * Choose, which Papeis to update.
     */
    where: PapeisWhereUniqueInput
  }

  /**
   * Papeis updateMany
   */
  export type PapeisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Papeis.
     */
    data: XOR<PapeisUpdateManyMutationInput, PapeisUncheckedUpdateManyInput>
    /**
     * Filter which Papeis to update
     */
    where?: PapeisWhereInput
    /**
     * Limit how many Papeis to update.
     */
    limit?: number
  }

  /**
   * Papeis upsert
   */
  export type PapeisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * The filter to search for the Papeis to update in case it exists.
     */
    where: PapeisWhereUniqueInput
    /**
     * In case the Papeis found by the `where` argument doesn't exist, create a new Papeis with this data.
     */
    create: XOR<PapeisCreateInput, PapeisUncheckedCreateInput>
    /**
     * In case the Papeis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PapeisUpdateInput, PapeisUncheckedUpdateInput>
  }

  /**
   * Papeis delete
   */
  export type PapeisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
    /**
     * Filter which Papeis to delete.
     */
    where: PapeisWhereUniqueInput
  }

  /**
   * Papeis deleteMany
   */
  export type PapeisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Papeis to delete
     */
    where?: PapeisWhereInput
    /**
     * Limit how many Papeis to delete.
     */
    limit?: number
  }

  /**
   * Papeis.UserPapeis
   */
  export type Papeis$UserPapeisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    where?: UserPapeisWhereInput
    orderBy?: UserPapeisOrderByWithRelationInput | UserPapeisOrderByWithRelationInput[]
    cursor?: UserPapeisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPapeisScalarFieldEnum | UserPapeisScalarFieldEnum[]
  }

  /**
   * Papeis without action
   */
  export type PapeisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Papeis
     */
    select?: PapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Papeis
     */
    omit?: PapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PapeisInclude<ExtArgs> | null
  }


  /**
   * Model Planeamento
   */

  export type AggregatePlaneamento = {
    _count: PlaneamentoCountAggregateOutputType | null
    _avg: PlaneamentoAvgAggregateOutputType | null
    _sum: PlaneamentoSumAggregateOutputType | null
    _min: PlaneamentoMinAggregateOutputType | null
    _max: PlaneamentoMaxAggregateOutputType | null
  }

  export type PlaneamentoAvgAggregateOutputType = {
    numeroPecas: number | null
  }

  export type PlaneamentoSumAggregateOutputType = {
    numeroPecas: number | null
  }

  export type PlaneamentoMinAggregateOutputType = {
    idPlaneamento: string | null
    nomeUser: string | null
    pais: string | null
    idFornecedor: string | null
    numeroPecas: number | null
    modelo: string | null
    obs: string | null
    cliente: string | null
    dataPrimeiroCamiao: Date | null
    dataPrimeiroEnvio: Date | null
    dataCriacao: Date | null
    dataUltimaAlteracao: Date | null
    envioEnviado: boolean | null
  }

  export type PlaneamentoMaxAggregateOutputType = {
    idPlaneamento: string | null
    nomeUser: string | null
    pais: string | null
    idFornecedor: string | null
    numeroPecas: number | null
    modelo: string | null
    obs: string | null
    cliente: string | null
    dataPrimeiroCamiao: Date | null
    dataPrimeiroEnvio: Date | null
    dataCriacao: Date | null
    dataUltimaAlteracao: Date | null
    envioEnviado: boolean | null
  }

  export type PlaneamentoCountAggregateOutputType = {
    idPlaneamento: number
    nomeUser: number
    pais: number
    idFornecedor: number
    numeroPecas: number
    modelo: number
    obs: number
    cliente: number
    dataPrimeiroCamiao: number
    dataPrimeiroEnvio: number
    dataCriacao: number
    dataUltimaAlteracao: number
    envioEnviado: number
    _all: number
  }


  export type PlaneamentoAvgAggregateInputType = {
    numeroPecas?: true
  }

  export type PlaneamentoSumAggregateInputType = {
    numeroPecas?: true
  }

  export type PlaneamentoMinAggregateInputType = {
    idPlaneamento?: true
    nomeUser?: true
    pais?: true
    idFornecedor?: true
    numeroPecas?: true
    modelo?: true
    obs?: true
    cliente?: true
    dataPrimeiroCamiao?: true
    dataPrimeiroEnvio?: true
    dataCriacao?: true
    dataUltimaAlteracao?: true
    envioEnviado?: true
  }

  export type PlaneamentoMaxAggregateInputType = {
    idPlaneamento?: true
    nomeUser?: true
    pais?: true
    idFornecedor?: true
    numeroPecas?: true
    modelo?: true
    obs?: true
    cliente?: true
    dataPrimeiroCamiao?: true
    dataPrimeiroEnvio?: true
    dataCriacao?: true
    dataUltimaAlteracao?: true
    envioEnviado?: true
  }

  export type PlaneamentoCountAggregateInputType = {
    idPlaneamento?: true
    nomeUser?: true
    pais?: true
    idFornecedor?: true
    numeroPecas?: true
    modelo?: true
    obs?: true
    cliente?: true
    dataPrimeiroCamiao?: true
    dataPrimeiroEnvio?: true
    dataCriacao?: true
    dataUltimaAlteracao?: true
    envioEnviado?: true
    _all?: true
  }

  export type PlaneamentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planeamento to aggregate.
     */
    where?: PlaneamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planeamentos to fetch.
     */
    orderBy?: PlaneamentoOrderByWithRelationInput | PlaneamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlaneamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planeamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planeamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Planeamentos
    **/
    _count?: true | PlaneamentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlaneamentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlaneamentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlaneamentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlaneamentoMaxAggregateInputType
  }

  export type GetPlaneamentoAggregateType<T extends PlaneamentoAggregateArgs> = {
        [P in keyof T & keyof AggregatePlaneamento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlaneamento[P]>
      : GetScalarType<T[P], AggregatePlaneamento[P]>
  }




  export type PlaneamentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlaneamentoWhereInput
    orderBy?: PlaneamentoOrderByWithAggregationInput | PlaneamentoOrderByWithAggregationInput[]
    by: PlaneamentoScalarFieldEnum[] | PlaneamentoScalarFieldEnum
    having?: PlaneamentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlaneamentoCountAggregateInputType | true
    _avg?: PlaneamentoAvgAggregateInputType
    _sum?: PlaneamentoSumAggregateInputType
    _min?: PlaneamentoMinAggregateInputType
    _max?: PlaneamentoMaxAggregateInputType
  }

  export type PlaneamentoGroupByOutputType = {
    idPlaneamento: string
    nomeUser: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao: Date | null
    dataPrimeiroEnvio: Date | null
    dataCriacao: Date
    dataUltimaAlteracao: Date
    envioEnviado: boolean
    _count: PlaneamentoCountAggregateOutputType | null
    _avg: PlaneamentoAvgAggregateOutputType | null
    _sum: PlaneamentoSumAggregateOutputType | null
    _min: PlaneamentoMinAggregateOutputType | null
    _max: PlaneamentoMaxAggregateOutputType | null
  }

  type GetPlaneamentoGroupByPayload<T extends PlaneamentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlaneamentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlaneamentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlaneamentoGroupByOutputType[P]>
            : GetScalarType<T[P], PlaneamentoGroupByOutputType[P]>
        }
      >
    >


  export type PlaneamentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    nomeUser?: boolean
    pais?: boolean
    idFornecedor?: boolean
    numeroPecas?: boolean
    modelo?: boolean
    obs?: boolean
    cliente?: boolean
    dataPrimeiroCamiao?: boolean
    dataPrimeiroEnvio?: boolean
    dataCriacao?: boolean
    dataUltimaAlteracao?: boolean
    envioEnviado?: boolean
    DataCamiao?: boolean | Planeamento$DataCamiaoArgs<ExtArgs>
    DataEnvio?: boolean | Planeamento$DataEnvioArgs<ExtArgs>
    Livre?: boolean | Planeamento$LivreArgs<ExtArgs>
    Op?: boolean | Planeamento$OpArgs<ExtArgs>
    Fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PlaneamentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["planeamento"]>



  export type PlaneamentoSelectScalar = {
    idPlaneamento?: boolean
    nomeUser?: boolean
    pais?: boolean
    idFornecedor?: boolean
    numeroPecas?: boolean
    modelo?: boolean
    obs?: boolean
    cliente?: boolean
    dataPrimeiroCamiao?: boolean
    dataPrimeiroEnvio?: boolean
    dataCriacao?: boolean
    dataUltimaAlteracao?: boolean
    envioEnviado?: boolean
  }

  export type PlaneamentoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "nomeUser" | "pais" | "idFornecedor" | "numeroPecas" | "modelo" | "obs" | "cliente" | "dataPrimeiroCamiao" | "dataPrimeiroEnvio" | "dataCriacao" | "dataUltimaAlteracao" | "envioEnviado", ExtArgs["result"]["planeamento"]>
  export type PlaneamentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DataCamiao?: boolean | Planeamento$DataCamiaoArgs<ExtArgs>
    DataEnvio?: boolean | Planeamento$DataEnvioArgs<ExtArgs>
    Livre?: boolean | Planeamento$LivreArgs<ExtArgs>
    Op?: boolean | Planeamento$OpArgs<ExtArgs>
    Fornecedor?: boolean | FornecedorDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PlaneamentoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PlaneamentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Planeamento"
    objects: {
      DataCamiao: Prisma.$DataCamiaoPayload<ExtArgs>[]
      DataEnvio: Prisma.$DataEnvioPayload<ExtArgs>[]
      Livre: Prisma.$LivrePayload<ExtArgs>[]
      Op: Prisma.$OpPayload<ExtArgs>[]
      Fornecedor: Prisma.$FornecedorPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      nomeUser: string
      pais: string
      idFornecedor: string
      numeroPecas: number
      modelo: string
      obs: string
      cliente: string
      dataPrimeiroCamiao: Date | null
      dataPrimeiroEnvio: Date | null
      dataCriacao: Date
      dataUltimaAlteracao: Date
      envioEnviado: boolean
    }, ExtArgs["result"]["planeamento"]>
    composites: {}
  }

  type PlaneamentoGetPayload<S extends boolean | null | undefined | PlaneamentoDefaultArgs> = $Result.GetResult<Prisma.$PlaneamentoPayload, S>

  type PlaneamentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlaneamentoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlaneamentoCountAggregateInputType | true
    }

  export interface PlaneamentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Planeamento'], meta: { name: 'Planeamento' } }
    /**
     * Find zero or one Planeamento that matches the filter.
     * @param {PlaneamentoFindUniqueArgs} args - Arguments to find a Planeamento
     * @example
     * // Get one Planeamento
     * const planeamento = await prisma.planeamento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlaneamentoFindUniqueArgs>(args: SelectSubset<T, PlaneamentoFindUniqueArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Planeamento that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlaneamentoFindUniqueOrThrowArgs} args - Arguments to find a Planeamento
     * @example
     * // Get one Planeamento
     * const planeamento = await prisma.planeamento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlaneamentoFindUniqueOrThrowArgs>(args: SelectSubset<T, PlaneamentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Planeamento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneamentoFindFirstArgs} args - Arguments to find a Planeamento
     * @example
     * // Get one Planeamento
     * const planeamento = await prisma.planeamento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlaneamentoFindFirstArgs>(args?: SelectSubset<T, PlaneamentoFindFirstArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Planeamento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneamentoFindFirstOrThrowArgs} args - Arguments to find a Planeamento
     * @example
     * // Get one Planeamento
     * const planeamento = await prisma.planeamento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlaneamentoFindFirstOrThrowArgs>(args?: SelectSubset<T, PlaneamentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Planeamentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneamentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Planeamentos
     * const planeamentos = await prisma.planeamento.findMany()
     * 
     * // Get first 10 Planeamentos
     * const planeamentos = await prisma.planeamento.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const planeamentoWithIdPlaneamentoOnly = await prisma.planeamento.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends PlaneamentoFindManyArgs>(args?: SelectSubset<T, PlaneamentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Planeamento.
     * @param {PlaneamentoCreateArgs} args - Arguments to create a Planeamento.
     * @example
     * // Create one Planeamento
     * const Planeamento = await prisma.planeamento.create({
     *   data: {
     *     // ... data to create a Planeamento
     *   }
     * })
     * 
     */
    create<T extends PlaneamentoCreateArgs>(args: SelectSubset<T, PlaneamentoCreateArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Planeamentos.
     * @param {PlaneamentoCreateManyArgs} args - Arguments to create many Planeamentos.
     * @example
     * // Create many Planeamentos
     * const planeamento = await prisma.planeamento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlaneamentoCreateManyArgs>(args?: SelectSubset<T, PlaneamentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Planeamento.
     * @param {PlaneamentoDeleteArgs} args - Arguments to delete one Planeamento.
     * @example
     * // Delete one Planeamento
     * const Planeamento = await prisma.planeamento.delete({
     *   where: {
     *     // ... filter to delete one Planeamento
     *   }
     * })
     * 
     */
    delete<T extends PlaneamentoDeleteArgs>(args: SelectSubset<T, PlaneamentoDeleteArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Planeamento.
     * @param {PlaneamentoUpdateArgs} args - Arguments to update one Planeamento.
     * @example
     * // Update one Planeamento
     * const planeamento = await prisma.planeamento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlaneamentoUpdateArgs>(args: SelectSubset<T, PlaneamentoUpdateArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Planeamentos.
     * @param {PlaneamentoDeleteManyArgs} args - Arguments to filter Planeamentos to delete.
     * @example
     * // Delete a few Planeamentos
     * const { count } = await prisma.planeamento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlaneamentoDeleteManyArgs>(args?: SelectSubset<T, PlaneamentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Planeamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneamentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Planeamentos
     * const planeamento = await prisma.planeamento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlaneamentoUpdateManyArgs>(args: SelectSubset<T, PlaneamentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Planeamento.
     * @param {PlaneamentoUpsertArgs} args - Arguments to update or create a Planeamento.
     * @example
     * // Update or create a Planeamento
     * const planeamento = await prisma.planeamento.upsert({
     *   create: {
     *     // ... data to create a Planeamento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Planeamento we want to update
     *   }
     * })
     */
    upsert<T extends PlaneamentoUpsertArgs>(args: SelectSubset<T, PlaneamentoUpsertArgs<ExtArgs>>): Prisma__PlaneamentoClient<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Planeamentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneamentoCountArgs} args - Arguments to filter Planeamentos to count.
     * @example
     * // Count the number of Planeamentos
     * const count = await prisma.planeamento.count({
     *   where: {
     *     // ... the filter for the Planeamentos we want to count
     *   }
     * })
    **/
    count<T extends PlaneamentoCountArgs>(
      args?: Subset<T, PlaneamentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlaneamentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Planeamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneamentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlaneamentoAggregateArgs>(args: Subset<T, PlaneamentoAggregateArgs>): Prisma.PrismaPromise<GetPlaneamentoAggregateType<T>>

    /**
     * Group by Planeamento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlaneamentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlaneamentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlaneamentoGroupByArgs['orderBy'] }
        : { orderBy?: PlaneamentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlaneamentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlaneamentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Planeamento model
   */
  readonly fields: PlaneamentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Planeamento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlaneamentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DataCamiao<T extends Planeamento$DataCamiaoArgs<ExtArgs> = {}>(args?: Subset<T, Planeamento$DataCamiaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DataEnvio<T extends Planeamento$DataEnvioArgs<ExtArgs> = {}>(args?: Subset<T, Planeamento$DataEnvioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Livre<T extends Planeamento$LivreArgs<ExtArgs> = {}>(args?: Subset<T, Planeamento$LivreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Op<T extends Planeamento$OpArgs<ExtArgs> = {}>(args?: Subset<T, Planeamento$OpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Fornecedor<T extends FornecedorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FornecedorDefaultArgs<ExtArgs>>): Prisma__FornecedorClient<$Result.GetResult<Prisma.$FornecedorPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Planeamento model
   */ 
  interface PlaneamentoFieldRefs {
    readonly idPlaneamento: FieldRef<"Planeamento", 'String'>
    readonly nomeUser: FieldRef<"Planeamento", 'String'>
    readonly pais: FieldRef<"Planeamento", 'String'>
    readonly idFornecedor: FieldRef<"Planeamento", 'String'>
    readonly numeroPecas: FieldRef<"Planeamento", 'Int'>
    readonly modelo: FieldRef<"Planeamento", 'String'>
    readonly obs: FieldRef<"Planeamento", 'String'>
    readonly cliente: FieldRef<"Planeamento", 'String'>
    readonly dataPrimeiroCamiao: FieldRef<"Planeamento", 'DateTime'>
    readonly dataPrimeiroEnvio: FieldRef<"Planeamento", 'DateTime'>
    readonly dataCriacao: FieldRef<"Planeamento", 'DateTime'>
    readonly dataUltimaAlteracao: FieldRef<"Planeamento", 'DateTime'>
    readonly envioEnviado: FieldRef<"Planeamento", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Planeamento findUnique
   */
  export type PlaneamentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * Filter, which Planeamento to fetch.
     */
    where: PlaneamentoWhereUniqueInput
  }

  /**
   * Planeamento findUniqueOrThrow
   */
  export type PlaneamentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * Filter, which Planeamento to fetch.
     */
    where: PlaneamentoWhereUniqueInput
  }

  /**
   * Planeamento findFirst
   */
  export type PlaneamentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * Filter, which Planeamento to fetch.
     */
    where?: PlaneamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planeamentos to fetch.
     */
    orderBy?: PlaneamentoOrderByWithRelationInput | PlaneamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Planeamentos.
     */
    cursor?: PlaneamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planeamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planeamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Planeamentos.
     */
    distinct?: PlaneamentoScalarFieldEnum | PlaneamentoScalarFieldEnum[]
  }

  /**
   * Planeamento findFirstOrThrow
   */
  export type PlaneamentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * Filter, which Planeamento to fetch.
     */
    where?: PlaneamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planeamentos to fetch.
     */
    orderBy?: PlaneamentoOrderByWithRelationInput | PlaneamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Planeamentos.
     */
    cursor?: PlaneamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planeamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planeamentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Planeamentos.
     */
    distinct?: PlaneamentoScalarFieldEnum | PlaneamentoScalarFieldEnum[]
  }

  /**
   * Planeamento findMany
   */
  export type PlaneamentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * Filter, which Planeamentos to fetch.
     */
    where?: PlaneamentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Planeamentos to fetch.
     */
    orderBy?: PlaneamentoOrderByWithRelationInput | PlaneamentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Planeamentos.
     */
    cursor?: PlaneamentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Planeamentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Planeamentos.
     */
    skip?: number
    distinct?: PlaneamentoScalarFieldEnum | PlaneamentoScalarFieldEnum[]
  }

  /**
   * Planeamento create
   */
  export type PlaneamentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Planeamento.
     */
    data: XOR<PlaneamentoCreateInput, PlaneamentoUncheckedCreateInput>
  }

  /**
   * Planeamento createMany
   */
  export type PlaneamentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Planeamentos.
     */
    data: PlaneamentoCreateManyInput | PlaneamentoCreateManyInput[]
  }

  /**
   * Planeamento update
   */
  export type PlaneamentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Planeamento.
     */
    data: XOR<PlaneamentoUpdateInput, PlaneamentoUncheckedUpdateInput>
    /**
     * Choose, which Planeamento to update.
     */
    where: PlaneamentoWhereUniqueInput
  }

  /**
   * Planeamento updateMany
   */
  export type PlaneamentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Planeamentos.
     */
    data: XOR<PlaneamentoUpdateManyMutationInput, PlaneamentoUncheckedUpdateManyInput>
    /**
     * Filter which Planeamentos to update
     */
    where?: PlaneamentoWhereInput
    /**
     * Limit how many Planeamentos to update.
     */
    limit?: number
  }

  /**
   * Planeamento upsert
   */
  export type PlaneamentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Planeamento to update in case it exists.
     */
    where: PlaneamentoWhereUniqueInput
    /**
     * In case the Planeamento found by the `where` argument doesn't exist, create a new Planeamento with this data.
     */
    create: XOR<PlaneamentoCreateInput, PlaneamentoUncheckedCreateInput>
    /**
     * In case the Planeamento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlaneamentoUpdateInput, PlaneamentoUncheckedUpdateInput>
  }

  /**
   * Planeamento delete
   */
  export type PlaneamentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    /**
     * Filter which Planeamento to delete.
     */
    where: PlaneamentoWhereUniqueInput
  }

  /**
   * Planeamento deleteMany
   */
  export type PlaneamentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Planeamentos to delete
     */
    where?: PlaneamentoWhereInput
    /**
     * Limit how many Planeamentos to delete.
     */
    limit?: number
  }

  /**
   * Planeamento.DataCamiao
   */
  export type Planeamento$DataCamiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    where?: DataCamiaoWhereInput
    orderBy?: DataCamiaoOrderByWithRelationInput | DataCamiaoOrderByWithRelationInput[]
    cursor?: DataCamiaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataCamiaoScalarFieldEnum | DataCamiaoScalarFieldEnum[]
  }

  /**
   * Planeamento.DataEnvio
   */
  export type Planeamento$DataEnvioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    where?: DataEnvioWhereInput
    orderBy?: DataEnvioOrderByWithRelationInput | DataEnvioOrderByWithRelationInput[]
    cursor?: DataEnvioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataEnvioScalarFieldEnum | DataEnvioScalarFieldEnum[]
  }

  /**
   * Planeamento.Livre
   */
  export type Planeamento$LivreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    where?: LivreWhereInput
    orderBy?: LivreOrderByWithRelationInput | LivreOrderByWithRelationInput[]
    cursor?: LivreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivreScalarFieldEnum | LivreScalarFieldEnum[]
  }

  /**
   * Planeamento.Op
   */
  export type Planeamento$OpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    where?: OpWhereInput
    orderBy?: OpOrderByWithRelationInput | OpOrderByWithRelationInput[]
    cursor?: OpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpScalarFieldEnum | OpScalarFieldEnum[]
  }

  /**
   * Planeamento without action
   */
  export type PlaneamentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
  }


  /**
   * Model ServicosEscolhidosLivre
   */

  export type AggregateServicosEscolhidosLivre = {
    _count: ServicosEscolhidosLivreCountAggregateOutputType | null
    _avg: ServicosEscolhidosLivreAvgAggregateOutputType | null
    _sum: ServicosEscolhidosLivreSumAggregateOutputType | null
    _min: ServicosEscolhidosLivreMinAggregateOutputType | null
    _max: ServicosEscolhidosLivreMaxAggregateOutputType | null
  }

  export type ServicosEscolhidosLivreAvgAggregateOutputType = {
    qtt: number | null
    preco: number | null
    valor: number | null
  }

  export type ServicosEscolhidosLivreSumAggregateOutputType = {
    qtt: number | null
    preco: number | null
    valor: number | null
  }

  export type ServicosEscolhidosLivreMinAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    idServicoEscolhido: string | null
    nome: string | null
    qtt: number | null
    preco: number | null
    valor: number | null
    unidade: string | null
    obs: string | null
  }

  export type ServicosEscolhidosLivreMaxAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    idServicoEscolhido: string | null
    nome: string | null
    qtt: number | null
    preco: number | null
    valor: number | null
    unidade: string | null
    obs: string | null
  }

  export type ServicosEscolhidosLivreCountAggregateOutputType = {
    idPlaneamento: number
    idLivre: number
    idServicoEscolhido: number
    nome: number
    qtt: number
    preco: number
    valor: number
    unidade: number
    obs: number
    _all: number
  }


  export type ServicosEscolhidosLivreAvgAggregateInputType = {
    qtt?: true
    preco?: true
    valor?: true
  }

  export type ServicosEscolhidosLivreSumAggregateInputType = {
    qtt?: true
    preco?: true
    valor?: true
  }

  export type ServicosEscolhidosLivreMinAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    idServicoEscolhido?: true
    nome?: true
    qtt?: true
    preco?: true
    valor?: true
    unidade?: true
    obs?: true
  }

  export type ServicosEscolhidosLivreMaxAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    idServicoEscolhido?: true
    nome?: true
    qtt?: true
    preco?: true
    valor?: true
    unidade?: true
    obs?: true
  }

  export type ServicosEscolhidosLivreCountAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    idServicoEscolhido?: true
    nome?: true
    qtt?: true
    preco?: true
    valor?: true
    unidade?: true
    obs?: true
    _all?: true
  }

  export type ServicosEscolhidosLivreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosLivre to aggregate.
     */
    where?: ServicosEscolhidosLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivres to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrderByWithRelationInput | ServicosEscolhidosLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicosEscolhidosLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicosEscolhidosLivres
    **/
    _count?: true | ServicosEscolhidosLivreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicosEscolhidosLivreAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicosEscolhidosLivreSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicosEscolhidosLivreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicosEscolhidosLivreMaxAggregateInputType
  }

  export type GetServicosEscolhidosLivreAggregateType<T extends ServicosEscolhidosLivreAggregateArgs> = {
        [P in keyof T & keyof AggregateServicosEscolhidosLivre]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicosEscolhidosLivre[P]>
      : GetScalarType<T[P], AggregateServicosEscolhidosLivre[P]>
  }




  export type ServicosEscolhidosLivreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosLivreWhereInput
    orderBy?: ServicosEscolhidosLivreOrderByWithAggregationInput | ServicosEscolhidosLivreOrderByWithAggregationInput[]
    by: ServicosEscolhidosLivreScalarFieldEnum[] | ServicosEscolhidosLivreScalarFieldEnum
    having?: ServicosEscolhidosLivreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicosEscolhidosLivreCountAggregateInputType | true
    _avg?: ServicosEscolhidosLivreAvgAggregateInputType
    _sum?: ServicosEscolhidosLivreSumAggregateInputType
    _min?: ServicosEscolhidosLivreMinAggregateInputType
    _max?: ServicosEscolhidosLivreMaxAggregateInputType
  }

  export type ServicosEscolhidosLivreGroupByOutputType = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    _count: ServicosEscolhidosLivreCountAggregateOutputType | null
    _avg: ServicosEscolhidosLivreAvgAggregateOutputType | null
    _sum: ServicosEscolhidosLivreSumAggregateOutputType | null
    _min: ServicosEscolhidosLivreMinAggregateOutputType | null
    _max: ServicosEscolhidosLivreMaxAggregateOutputType | null
  }

  type GetServicosEscolhidosLivreGroupByPayload<T extends ServicosEscolhidosLivreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicosEscolhidosLivreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicosEscolhidosLivreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicosEscolhidosLivreGroupByOutputType[P]>
            : GetScalarType<T[P], ServicosEscolhidosLivreGroupByOutputType[P]>
        }
      >
    >


  export type ServicosEscolhidosLivreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    idLivre?: boolean
    idServicoEscolhido?: boolean
    nome?: boolean
    qtt?: boolean
    preco?: boolean
    valor?: boolean
    unidade?: boolean
    obs?: boolean
    Livre?: boolean | LivreDefaultArgs<ExtArgs>
    ServicosEscolhidosLivreOrigem?: boolean | ServicosEscolhidosLivre$ServicosEscolhidosLivreOrigemArgs<ExtArgs>
    _count?: boolean | ServicosEscolhidosLivreCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicosEscolhidosLivre"]>



  export type ServicosEscolhidosLivreSelectScalar = {
    idPlaneamento?: boolean
    idLivre?: boolean
    idServicoEscolhido?: boolean
    nome?: boolean
    qtt?: boolean
    preco?: boolean
    valor?: boolean
    unidade?: boolean
    obs?: boolean
  }

  export type ServicosEscolhidosLivreOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "idLivre" | "idServicoEscolhido" | "nome" | "qtt" | "preco" | "valor" | "unidade" | "obs", ExtArgs["result"]["servicosEscolhidosLivre"]>
  export type ServicosEscolhidosLivreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Livre?: boolean | LivreDefaultArgs<ExtArgs>
    ServicosEscolhidosLivreOrigem?: boolean | ServicosEscolhidosLivre$ServicosEscolhidosLivreOrigemArgs<ExtArgs>
    _count?: boolean | ServicosEscolhidosLivreCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicosEscolhidosLivrePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicosEscolhidosLivre"
    objects: {
      Livre: Prisma.$LivrePayload<ExtArgs>
      ServicosEscolhidosLivreOrigem: Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      idLivre: string
      idServicoEscolhido: string
      nome: string
      qtt: number
      preco: number
      valor: number
      unidade: string
      obs: string
    }, ExtArgs["result"]["servicosEscolhidosLivre"]>
    composites: {}
  }

  type ServicosEscolhidosLivreGetPayload<S extends boolean | null | undefined | ServicosEscolhidosLivreDefaultArgs> = $Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload, S>

  type ServicosEscolhidosLivreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicosEscolhidosLivreFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicosEscolhidosLivreCountAggregateInputType | true
    }

  export interface ServicosEscolhidosLivreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicosEscolhidosLivre'], meta: { name: 'ServicosEscolhidosLivre' } }
    /**
     * Find zero or one ServicosEscolhidosLivre that matches the filter.
     * @param {ServicosEscolhidosLivreFindUniqueArgs} args - Arguments to find a ServicosEscolhidosLivre
     * @example
     * // Get one ServicosEscolhidosLivre
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicosEscolhidosLivreFindUniqueArgs>(args: SelectSubset<T, ServicosEscolhidosLivreFindUniqueArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ServicosEscolhidosLivre that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicosEscolhidosLivreFindUniqueOrThrowArgs} args - Arguments to find a ServicosEscolhidosLivre
     * @example
     * // Get one ServicosEscolhidosLivre
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicosEscolhidosLivreFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicosEscolhidosLivreFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosLivre that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreFindFirstArgs} args - Arguments to find a ServicosEscolhidosLivre
     * @example
     * // Get one ServicosEscolhidosLivre
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicosEscolhidosLivreFindFirstArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreFindFirstArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosLivre that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreFindFirstOrThrowArgs} args - Arguments to find a ServicosEscolhidosLivre
     * @example
     * // Get one ServicosEscolhidosLivre
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicosEscolhidosLivreFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ServicosEscolhidosLivres that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicosEscolhidosLivres
     * const servicosEscolhidosLivres = await prisma.servicosEscolhidosLivre.findMany()
     * 
     * // Get first 10 ServicosEscolhidosLivres
     * const servicosEscolhidosLivres = await prisma.servicosEscolhidosLivre.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const servicosEscolhidosLivreWithIdPlaneamentoOnly = await prisma.servicosEscolhidosLivre.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends ServicosEscolhidosLivreFindManyArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ServicosEscolhidosLivre.
     * @param {ServicosEscolhidosLivreCreateArgs} args - Arguments to create a ServicosEscolhidosLivre.
     * @example
     * // Create one ServicosEscolhidosLivre
     * const ServicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.create({
     *   data: {
     *     // ... data to create a ServicosEscolhidosLivre
     *   }
     * })
     * 
     */
    create<T extends ServicosEscolhidosLivreCreateArgs>(args: SelectSubset<T, ServicosEscolhidosLivreCreateArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ServicosEscolhidosLivres.
     * @param {ServicosEscolhidosLivreCreateManyArgs} args - Arguments to create many ServicosEscolhidosLivres.
     * @example
     * // Create many ServicosEscolhidosLivres
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicosEscolhidosLivreCreateManyArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServicosEscolhidosLivre.
     * @param {ServicosEscolhidosLivreDeleteArgs} args - Arguments to delete one ServicosEscolhidosLivre.
     * @example
     * // Delete one ServicosEscolhidosLivre
     * const ServicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.delete({
     *   where: {
     *     // ... filter to delete one ServicosEscolhidosLivre
     *   }
     * })
     * 
     */
    delete<T extends ServicosEscolhidosLivreDeleteArgs>(args: SelectSubset<T, ServicosEscolhidosLivreDeleteArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ServicosEscolhidosLivre.
     * @param {ServicosEscolhidosLivreUpdateArgs} args - Arguments to update one ServicosEscolhidosLivre.
     * @example
     * // Update one ServicosEscolhidosLivre
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicosEscolhidosLivreUpdateArgs>(args: SelectSubset<T, ServicosEscolhidosLivreUpdateArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ServicosEscolhidosLivres.
     * @param {ServicosEscolhidosLivreDeleteManyArgs} args - Arguments to filter ServicosEscolhidosLivres to delete.
     * @example
     * // Delete a few ServicosEscolhidosLivres
     * const { count } = await prisma.servicosEscolhidosLivre.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicosEscolhidosLivreDeleteManyArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicosEscolhidosLivres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicosEscolhidosLivres
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicosEscolhidosLivreUpdateManyArgs>(args: SelectSubset<T, ServicosEscolhidosLivreUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicosEscolhidosLivre.
     * @param {ServicosEscolhidosLivreUpsertArgs} args - Arguments to update or create a ServicosEscolhidosLivre.
     * @example
     * // Update or create a ServicosEscolhidosLivre
     * const servicosEscolhidosLivre = await prisma.servicosEscolhidosLivre.upsert({
     *   create: {
     *     // ... data to create a ServicosEscolhidosLivre
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicosEscolhidosLivre we want to update
     *   }
     * })
     */
    upsert<T extends ServicosEscolhidosLivreUpsertArgs>(args: SelectSubset<T, ServicosEscolhidosLivreUpsertArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ServicosEscolhidosLivres.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreCountArgs} args - Arguments to filter ServicosEscolhidosLivres to count.
     * @example
     * // Count the number of ServicosEscolhidosLivres
     * const count = await prisma.servicosEscolhidosLivre.count({
     *   where: {
     *     // ... the filter for the ServicosEscolhidosLivres we want to count
     *   }
     * })
    **/
    count<T extends ServicosEscolhidosLivreCountArgs>(
      args?: Subset<T, ServicosEscolhidosLivreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicosEscolhidosLivreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicosEscolhidosLivre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicosEscolhidosLivreAggregateArgs>(args: Subset<T, ServicosEscolhidosLivreAggregateArgs>): Prisma.PrismaPromise<GetServicosEscolhidosLivreAggregateType<T>>

    /**
     * Group by ServicosEscolhidosLivre.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicosEscolhidosLivreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicosEscolhidosLivreGroupByArgs['orderBy'] }
        : { orderBy?: ServicosEscolhidosLivreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicosEscolhidosLivreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicosEscolhidosLivreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicosEscolhidosLivre model
   */
  readonly fields: ServicosEscolhidosLivreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicosEscolhidosLivre.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicosEscolhidosLivreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Livre<T extends LivreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LivreDefaultArgs<ExtArgs>>): Prisma__LivreClient<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ServicosEscolhidosLivreOrigem<T extends ServicosEscolhidosLivre$ServicosEscolhidosLivreOrigemArgs<ExtArgs> = {}>(args?: Subset<T, ServicosEscolhidosLivre$ServicosEscolhidosLivreOrigemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicosEscolhidosLivre model
   */ 
  interface ServicosEscolhidosLivreFieldRefs {
    readonly idPlaneamento: FieldRef<"ServicosEscolhidosLivre", 'String'>
    readonly idLivre: FieldRef<"ServicosEscolhidosLivre", 'String'>
    readonly idServicoEscolhido: FieldRef<"ServicosEscolhidosLivre", 'String'>
    readonly nome: FieldRef<"ServicosEscolhidosLivre", 'String'>
    readonly qtt: FieldRef<"ServicosEscolhidosLivre", 'Float'>
    readonly preco: FieldRef<"ServicosEscolhidosLivre", 'Float'>
    readonly valor: FieldRef<"ServicosEscolhidosLivre", 'Float'>
    readonly unidade: FieldRef<"ServicosEscolhidosLivre", 'String'>
    readonly obs: FieldRef<"ServicosEscolhidosLivre", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServicosEscolhidosLivre findUnique
   */
  export type ServicosEscolhidosLivreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivre to fetch.
     */
    where: ServicosEscolhidosLivreWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivre findUniqueOrThrow
   */
  export type ServicosEscolhidosLivreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivre to fetch.
     */
    where: ServicosEscolhidosLivreWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivre findFirst
   */
  export type ServicosEscolhidosLivreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivre to fetch.
     */
    where?: ServicosEscolhidosLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivres to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrderByWithRelationInput | ServicosEscolhidosLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosLivres.
     */
    cursor?: ServicosEscolhidosLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosLivres.
     */
    distinct?: ServicosEscolhidosLivreScalarFieldEnum | ServicosEscolhidosLivreScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosLivre findFirstOrThrow
   */
  export type ServicosEscolhidosLivreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivre to fetch.
     */
    where?: ServicosEscolhidosLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivres to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrderByWithRelationInput | ServicosEscolhidosLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosLivres.
     */
    cursor?: ServicosEscolhidosLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivres.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosLivres.
     */
    distinct?: ServicosEscolhidosLivreScalarFieldEnum | ServicosEscolhidosLivreScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosLivre findMany
   */
  export type ServicosEscolhidosLivreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivres to fetch.
     */
    where?: ServicosEscolhidosLivreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivres to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrderByWithRelationInput | ServicosEscolhidosLivreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicosEscolhidosLivres.
     */
    cursor?: ServicosEscolhidosLivreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivres from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivres.
     */
    skip?: number
    distinct?: ServicosEscolhidosLivreScalarFieldEnum | ServicosEscolhidosLivreScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosLivre create
   */
  export type ServicosEscolhidosLivreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicosEscolhidosLivre.
     */
    data: XOR<ServicosEscolhidosLivreCreateInput, ServicosEscolhidosLivreUncheckedCreateInput>
  }

  /**
   * ServicosEscolhidosLivre createMany
   */
  export type ServicosEscolhidosLivreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicosEscolhidosLivres.
     */
    data: ServicosEscolhidosLivreCreateManyInput | ServicosEscolhidosLivreCreateManyInput[]
  }

  /**
   * ServicosEscolhidosLivre update
   */
  export type ServicosEscolhidosLivreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicosEscolhidosLivre.
     */
    data: XOR<ServicosEscolhidosLivreUpdateInput, ServicosEscolhidosLivreUncheckedUpdateInput>
    /**
     * Choose, which ServicosEscolhidosLivre to update.
     */
    where: ServicosEscolhidosLivreWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivre updateMany
   */
  export type ServicosEscolhidosLivreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicosEscolhidosLivres.
     */
    data: XOR<ServicosEscolhidosLivreUpdateManyMutationInput, ServicosEscolhidosLivreUncheckedUpdateManyInput>
    /**
     * Filter which ServicosEscolhidosLivres to update
     */
    where?: ServicosEscolhidosLivreWhereInput
    /**
     * Limit how many ServicosEscolhidosLivres to update.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosLivre upsert
   */
  export type ServicosEscolhidosLivreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicosEscolhidosLivre to update in case it exists.
     */
    where: ServicosEscolhidosLivreWhereUniqueInput
    /**
     * In case the ServicosEscolhidosLivre found by the `where` argument doesn't exist, create a new ServicosEscolhidosLivre with this data.
     */
    create: XOR<ServicosEscolhidosLivreCreateInput, ServicosEscolhidosLivreUncheckedCreateInput>
    /**
     * In case the ServicosEscolhidosLivre was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicosEscolhidosLivreUpdateInput, ServicosEscolhidosLivreUncheckedUpdateInput>
  }

  /**
   * ServicosEscolhidosLivre delete
   */
  export type ServicosEscolhidosLivreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
    /**
     * Filter which ServicosEscolhidosLivre to delete.
     */
    where: ServicosEscolhidosLivreWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivre deleteMany
   */
  export type ServicosEscolhidosLivreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosLivres to delete
     */
    where?: ServicosEscolhidosLivreWhereInput
    /**
     * Limit how many ServicosEscolhidosLivres to delete.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosLivre.ServicosEscolhidosLivreOrigem
   */
  export type ServicosEscolhidosLivre$ServicosEscolhidosLivreOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    where?: ServicosEscolhidosLivreOrigemWhereInput
    orderBy?: ServicosEscolhidosLivreOrigemOrderByWithRelationInput | ServicosEscolhidosLivreOrigemOrderByWithRelationInput[]
    cursor?: ServicosEscolhidosLivreOrigemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicosEscolhidosLivreOrigemScalarFieldEnum | ServicosEscolhidosLivreOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosLivre without action
   */
  export type ServicosEscolhidosLivreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivre
     */
    select?: ServicosEscolhidosLivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivre
     */
    omit?: ServicosEscolhidosLivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreInclude<ExtArgs> | null
  }


  /**
   * Model ServicosEscolhidosLivreOrigem
   */

  export type AggregateServicosEscolhidosLivreOrigem = {
    _count: ServicosEscolhidosLivreOrigemCountAggregateOutputType | null
    _min: ServicosEscolhidosLivreOrigemMinAggregateOutputType | null
    _max: ServicosEscolhidosLivreOrigemMaxAggregateOutputType | null
  }

  export type ServicosEscolhidosLivreOrigemMinAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    idServicoEscolhido: string | null
    orcamentoLinhasStamp: string | null
  }

  export type ServicosEscolhidosLivreOrigemMaxAggregateOutputType = {
    idPlaneamento: string | null
    idLivre: string | null
    idServicoEscolhido: string | null
    orcamentoLinhasStamp: string | null
  }

  export type ServicosEscolhidosLivreOrigemCountAggregateOutputType = {
    idPlaneamento: number
    idLivre: number
    idServicoEscolhido: number
    orcamentoLinhasStamp: number
    _all: number
  }


  export type ServicosEscolhidosLivreOrigemMinAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    idServicoEscolhido?: true
    orcamentoLinhasStamp?: true
  }

  export type ServicosEscolhidosLivreOrigemMaxAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    idServicoEscolhido?: true
    orcamentoLinhasStamp?: true
  }

  export type ServicosEscolhidosLivreOrigemCountAggregateInputType = {
    idPlaneamento?: true
    idLivre?: true
    idServicoEscolhido?: true
    orcamentoLinhasStamp?: true
    _all?: true
  }

  export type ServicosEscolhidosLivreOrigemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosLivreOrigem to aggregate.
     */
    where?: ServicosEscolhidosLivreOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivreOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrigemOrderByWithRelationInput | ServicosEscolhidosLivreOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicosEscolhidosLivreOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivreOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivreOrigems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicosEscolhidosLivreOrigems
    **/
    _count?: true | ServicosEscolhidosLivreOrigemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicosEscolhidosLivreOrigemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicosEscolhidosLivreOrigemMaxAggregateInputType
  }

  export type GetServicosEscolhidosLivreOrigemAggregateType<T extends ServicosEscolhidosLivreOrigemAggregateArgs> = {
        [P in keyof T & keyof AggregateServicosEscolhidosLivreOrigem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicosEscolhidosLivreOrigem[P]>
      : GetScalarType<T[P], AggregateServicosEscolhidosLivreOrigem[P]>
  }




  export type ServicosEscolhidosLivreOrigemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosLivreOrigemWhereInput
    orderBy?: ServicosEscolhidosLivreOrigemOrderByWithAggregationInput | ServicosEscolhidosLivreOrigemOrderByWithAggregationInput[]
    by: ServicosEscolhidosLivreOrigemScalarFieldEnum[] | ServicosEscolhidosLivreOrigemScalarFieldEnum
    having?: ServicosEscolhidosLivreOrigemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicosEscolhidosLivreOrigemCountAggregateInputType | true
    _min?: ServicosEscolhidosLivreOrigemMinAggregateInputType
    _max?: ServicosEscolhidosLivreOrigemMaxAggregateInputType
  }

  export type ServicosEscolhidosLivreOrigemGroupByOutputType = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
    _count: ServicosEscolhidosLivreOrigemCountAggregateOutputType | null
    _min: ServicosEscolhidosLivreOrigemMinAggregateOutputType | null
    _max: ServicosEscolhidosLivreOrigemMaxAggregateOutputType | null
  }

  type GetServicosEscolhidosLivreOrigemGroupByPayload<T extends ServicosEscolhidosLivreOrigemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicosEscolhidosLivreOrigemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicosEscolhidosLivreOrigemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicosEscolhidosLivreOrigemGroupByOutputType[P]>
            : GetScalarType<T[P], ServicosEscolhidosLivreOrigemGroupByOutputType[P]>
        }
      >
    >


  export type ServicosEscolhidosLivreOrigemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    idLivre?: boolean
    idServicoEscolhido?: boolean
    orcamentoLinhasStamp?: boolean
    OrcamentoLivreLinhas?: boolean | OrcamentoLivreLinhasDefaultArgs<ExtArgs>
    ServicosEscolhidosLivre?: boolean | ServicosEscolhidosLivreDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicosEscolhidosLivreOrigem"]>



  export type ServicosEscolhidosLivreOrigemSelectScalar = {
    idPlaneamento?: boolean
    idLivre?: boolean
    idServicoEscolhido?: boolean
    orcamentoLinhasStamp?: boolean
  }

  export type ServicosEscolhidosLivreOrigemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "idLivre" | "idServicoEscolhido" | "orcamentoLinhasStamp", ExtArgs["result"]["servicosEscolhidosLivreOrigem"]>
  export type ServicosEscolhidosLivreOrigemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrcamentoLivreLinhas?: boolean | OrcamentoLivreLinhasDefaultArgs<ExtArgs>
    ServicosEscolhidosLivre?: boolean | ServicosEscolhidosLivreDefaultArgs<ExtArgs>
  }

  export type $ServicosEscolhidosLivreOrigemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicosEscolhidosLivreOrigem"
    objects: {
      OrcamentoLivreLinhas: Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>
      ServicosEscolhidosLivre: Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      idLivre: string
      idServicoEscolhido: string
      orcamentoLinhasStamp: string
    }, ExtArgs["result"]["servicosEscolhidosLivreOrigem"]>
    composites: {}
  }

  type ServicosEscolhidosLivreOrigemGetPayload<S extends boolean | null | undefined | ServicosEscolhidosLivreOrigemDefaultArgs> = $Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload, S>

  type ServicosEscolhidosLivreOrigemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicosEscolhidosLivreOrigemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicosEscolhidosLivreOrigemCountAggregateInputType | true
    }

  export interface ServicosEscolhidosLivreOrigemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicosEscolhidosLivreOrigem'], meta: { name: 'ServicosEscolhidosLivreOrigem' } }
    /**
     * Find zero or one ServicosEscolhidosLivreOrigem that matches the filter.
     * @param {ServicosEscolhidosLivreOrigemFindUniqueArgs} args - Arguments to find a ServicosEscolhidosLivreOrigem
     * @example
     * // Get one ServicosEscolhidosLivreOrigem
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicosEscolhidosLivreOrigemFindUniqueArgs>(args: SelectSubset<T, ServicosEscolhidosLivreOrigemFindUniqueArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ServicosEscolhidosLivreOrigem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicosEscolhidosLivreOrigemFindUniqueOrThrowArgs} args - Arguments to find a ServicosEscolhidosLivreOrigem
     * @example
     * // Get one ServicosEscolhidosLivreOrigem
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicosEscolhidosLivreOrigemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicosEscolhidosLivreOrigemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosLivreOrigem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreOrigemFindFirstArgs} args - Arguments to find a ServicosEscolhidosLivreOrigem
     * @example
     * // Get one ServicosEscolhidosLivreOrigem
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicosEscolhidosLivreOrigemFindFirstArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreOrigemFindFirstArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosLivreOrigem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreOrigemFindFirstOrThrowArgs} args - Arguments to find a ServicosEscolhidosLivreOrigem
     * @example
     * // Get one ServicosEscolhidosLivreOrigem
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicosEscolhidosLivreOrigemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreOrigemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ServicosEscolhidosLivreOrigems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreOrigemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicosEscolhidosLivreOrigems
     * const servicosEscolhidosLivreOrigems = await prisma.servicosEscolhidosLivreOrigem.findMany()
     * 
     * // Get first 10 ServicosEscolhidosLivreOrigems
     * const servicosEscolhidosLivreOrigems = await prisma.servicosEscolhidosLivreOrigem.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const servicosEscolhidosLivreOrigemWithIdPlaneamentoOnly = await prisma.servicosEscolhidosLivreOrigem.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends ServicosEscolhidosLivreOrigemFindManyArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreOrigemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ServicosEscolhidosLivreOrigem.
     * @param {ServicosEscolhidosLivreOrigemCreateArgs} args - Arguments to create a ServicosEscolhidosLivreOrigem.
     * @example
     * // Create one ServicosEscolhidosLivreOrigem
     * const ServicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.create({
     *   data: {
     *     // ... data to create a ServicosEscolhidosLivreOrigem
     *   }
     * })
     * 
     */
    create<T extends ServicosEscolhidosLivreOrigemCreateArgs>(args: SelectSubset<T, ServicosEscolhidosLivreOrigemCreateArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ServicosEscolhidosLivreOrigems.
     * @param {ServicosEscolhidosLivreOrigemCreateManyArgs} args - Arguments to create many ServicosEscolhidosLivreOrigems.
     * @example
     * // Create many ServicosEscolhidosLivreOrigems
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicosEscolhidosLivreOrigemCreateManyArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreOrigemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServicosEscolhidosLivreOrigem.
     * @param {ServicosEscolhidosLivreOrigemDeleteArgs} args - Arguments to delete one ServicosEscolhidosLivreOrigem.
     * @example
     * // Delete one ServicosEscolhidosLivreOrigem
     * const ServicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.delete({
     *   where: {
     *     // ... filter to delete one ServicosEscolhidosLivreOrigem
     *   }
     * })
     * 
     */
    delete<T extends ServicosEscolhidosLivreOrigemDeleteArgs>(args: SelectSubset<T, ServicosEscolhidosLivreOrigemDeleteArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ServicosEscolhidosLivreOrigem.
     * @param {ServicosEscolhidosLivreOrigemUpdateArgs} args - Arguments to update one ServicosEscolhidosLivreOrigem.
     * @example
     * // Update one ServicosEscolhidosLivreOrigem
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicosEscolhidosLivreOrigemUpdateArgs>(args: SelectSubset<T, ServicosEscolhidosLivreOrigemUpdateArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ServicosEscolhidosLivreOrigems.
     * @param {ServicosEscolhidosLivreOrigemDeleteManyArgs} args - Arguments to filter ServicosEscolhidosLivreOrigems to delete.
     * @example
     * // Delete a few ServicosEscolhidosLivreOrigems
     * const { count } = await prisma.servicosEscolhidosLivreOrigem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicosEscolhidosLivreOrigemDeleteManyArgs>(args?: SelectSubset<T, ServicosEscolhidosLivreOrigemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicosEscolhidosLivreOrigems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreOrigemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicosEscolhidosLivreOrigems
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicosEscolhidosLivreOrigemUpdateManyArgs>(args: SelectSubset<T, ServicosEscolhidosLivreOrigemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicosEscolhidosLivreOrigem.
     * @param {ServicosEscolhidosLivreOrigemUpsertArgs} args - Arguments to update or create a ServicosEscolhidosLivreOrigem.
     * @example
     * // Update or create a ServicosEscolhidosLivreOrigem
     * const servicosEscolhidosLivreOrigem = await prisma.servicosEscolhidosLivreOrigem.upsert({
     *   create: {
     *     // ... data to create a ServicosEscolhidosLivreOrigem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicosEscolhidosLivreOrigem we want to update
     *   }
     * })
     */
    upsert<T extends ServicosEscolhidosLivreOrigemUpsertArgs>(args: SelectSubset<T, ServicosEscolhidosLivreOrigemUpsertArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivreOrigemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ServicosEscolhidosLivreOrigems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreOrigemCountArgs} args - Arguments to filter ServicosEscolhidosLivreOrigems to count.
     * @example
     * // Count the number of ServicosEscolhidosLivreOrigems
     * const count = await prisma.servicosEscolhidosLivreOrigem.count({
     *   where: {
     *     // ... the filter for the ServicosEscolhidosLivreOrigems we want to count
     *   }
     * })
    **/
    count<T extends ServicosEscolhidosLivreOrigemCountArgs>(
      args?: Subset<T, ServicosEscolhidosLivreOrigemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicosEscolhidosLivreOrigemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicosEscolhidosLivreOrigem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreOrigemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicosEscolhidosLivreOrigemAggregateArgs>(args: Subset<T, ServicosEscolhidosLivreOrigemAggregateArgs>): Prisma.PrismaPromise<GetServicosEscolhidosLivreOrigemAggregateType<T>>

    /**
     * Group by ServicosEscolhidosLivreOrigem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosLivreOrigemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicosEscolhidosLivreOrigemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicosEscolhidosLivreOrigemGroupByArgs['orderBy'] }
        : { orderBy?: ServicosEscolhidosLivreOrigemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicosEscolhidosLivreOrigemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicosEscolhidosLivreOrigemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicosEscolhidosLivreOrigem model
   */
  readonly fields: ServicosEscolhidosLivreOrigemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicosEscolhidosLivreOrigem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicosEscolhidosLivreOrigemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrcamentoLivreLinhas<T extends OrcamentoLivreLinhasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoLivreLinhasDefaultArgs<ExtArgs>>): Prisma__OrcamentoLivreLinhasClient<$Result.GetResult<Prisma.$OrcamentoLivreLinhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ServicosEscolhidosLivre<T extends ServicosEscolhidosLivreDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicosEscolhidosLivreDefaultArgs<ExtArgs>>): Prisma__ServicosEscolhidosLivreClient<$Result.GetResult<Prisma.$ServicosEscolhidosLivrePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicosEscolhidosLivreOrigem model
   */ 
  interface ServicosEscolhidosLivreOrigemFieldRefs {
    readonly idPlaneamento: FieldRef<"ServicosEscolhidosLivreOrigem", 'String'>
    readonly idLivre: FieldRef<"ServicosEscolhidosLivreOrigem", 'String'>
    readonly idServicoEscolhido: FieldRef<"ServicosEscolhidosLivreOrigem", 'String'>
    readonly orcamentoLinhasStamp: FieldRef<"ServicosEscolhidosLivreOrigem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServicosEscolhidosLivreOrigem findUnique
   */
  export type ServicosEscolhidosLivreOrigemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivreOrigem to fetch.
     */
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivreOrigem findUniqueOrThrow
   */
  export type ServicosEscolhidosLivreOrigemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivreOrigem to fetch.
     */
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivreOrigem findFirst
   */
  export type ServicosEscolhidosLivreOrigemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivreOrigem to fetch.
     */
    where?: ServicosEscolhidosLivreOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivreOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrigemOrderByWithRelationInput | ServicosEscolhidosLivreOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosLivreOrigems.
     */
    cursor?: ServicosEscolhidosLivreOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivreOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivreOrigems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosLivreOrigems.
     */
    distinct?: ServicosEscolhidosLivreOrigemScalarFieldEnum | ServicosEscolhidosLivreOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosLivreOrigem findFirstOrThrow
   */
  export type ServicosEscolhidosLivreOrigemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivreOrigem to fetch.
     */
    where?: ServicosEscolhidosLivreOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivreOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrigemOrderByWithRelationInput | ServicosEscolhidosLivreOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosLivreOrigems.
     */
    cursor?: ServicosEscolhidosLivreOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivreOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivreOrigems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosLivreOrigems.
     */
    distinct?: ServicosEscolhidosLivreOrigemScalarFieldEnum | ServicosEscolhidosLivreOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosLivreOrigem findMany
   */
  export type ServicosEscolhidosLivreOrigemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosLivreOrigems to fetch.
     */
    where?: ServicosEscolhidosLivreOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosLivreOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosLivreOrigemOrderByWithRelationInput | ServicosEscolhidosLivreOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicosEscolhidosLivreOrigems.
     */
    cursor?: ServicosEscolhidosLivreOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosLivreOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosLivreOrigems.
     */
    skip?: number
    distinct?: ServicosEscolhidosLivreOrigemScalarFieldEnum | ServicosEscolhidosLivreOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosLivreOrigem create
   */
  export type ServicosEscolhidosLivreOrigemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicosEscolhidosLivreOrigem.
     */
    data: XOR<ServicosEscolhidosLivreOrigemCreateInput, ServicosEscolhidosLivreOrigemUncheckedCreateInput>
  }

  /**
   * ServicosEscolhidosLivreOrigem createMany
   */
  export type ServicosEscolhidosLivreOrigemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicosEscolhidosLivreOrigems.
     */
    data: ServicosEscolhidosLivreOrigemCreateManyInput | ServicosEscolhidosLivreOrigemCreateManyInput[]
  }

  /**
   * ServicosEscolhidosLivreOrigem update
   */
  export type ServicosEscolhidosLivreOrigemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicosEscolhidosLivreOrigem.
     */
    data: XOR<ServicosEscolhidosLivreOrigemUpdateInput, ServicosEscolhidosLivreOrigemUncheckedUpdateInput>
    /**
     * Choose, which ServicosEscolhidosLivreOrigem to update.
     */
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivreOrigem updateMany
   */
  export type ServicosEscolhidosLivreOrigemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicosEscolhidosLivreOrigems.
     */
    data: XOR<ServicosEscolhidosLivreOrigemUpdateManyMutationInput, ServicosEscolhidosLivreOrigemUncheckedUpdateManyInput>
    /**
     * Filter which ServicosEscolhidosLivreOrigems to update
     */
    where?: ServicosEscolhidosLivreOrigemWhereInput
    /**
     * Limit how many ServicosEscolhidosLivreOrigems to update.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosLivreOrigem upsert
   */
  export type ServicosEscolhidosLivreOrigemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicosEscolhidosLivreOrigem to update in case it exists.
     */
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
    /**
     * In case the ServicosEscolhidosLivreOrigem found by the `where` argument doesn't exist, create a new ServicosEscolhidosLivreOrigem with this data.
     */
    create: XOR<ServicosEscolhidosLivreOrigemCreateInput, ServicosEscolhidosLivreOrigemUncheckedCreateInput>
    /**
     * In case the ServicosEscolhidosLivreOrigem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicosEscolhidosLivreOrigemUpdateInput, ServicosEscolhidosLivreOrigemUncheckedUpdateInput>
  }

  /**
   * ServicosEscolhidosLivreOrigem delete
   */
  export type ServicosEscolhidosLivreOrigemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
    /**
     * Filter which ServicosEscolhidosLivreOrigem to delete.
     */
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosLivreOrigem deleteMany
   */
  export type ServicosEscolhidosLivreOrigemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosLivreOrigems to delete
     */
    where?: ServicosEscolhidosLivreOrigemWhereInput
    /**
     * Limit how many ServicosEscolhidosLivreOrigems to delete.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosLivreOrigem without action
   */
  export type ServicosEscolhidosLivreOrigemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosLivreOrigem
     */
    select?: ServicosEscolhidosLivreOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosLivreOrigem
     */
    omit?: ServicosEscolhidosLivreOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosLivreOrigemInclude<ExtArgs> | null
  }


  /**
   * Model ServicosEscolhidosOp
   */

  export type AggregateServicosEscolhidosOp = {
    _count: ServicosEscolhidosOpCountAggregateOutputType | null
    _avg: ServicosEscolhidosOpAvgAggregateOutputType | null
    _sum: ServicosEscolhidosOpSumAggregateOutputType | null
    _min: ServicosEscolhidosOpMinAggregateOutputType | null
    _max: ServicosEscolhidosOpMaxAggregateOutputType | null
  }

  export type ServicosEscolhidosOpAvgAggregateOutputType = {
    qtt: number | null
    preco: number | null
    valor: number | null
  }

  export type ServicosEscolhidosOpSumAggregateOutputType = {
    qtt: number | null
    preco: number | null
    valor: number | null
  }

  export type ServicosEscolhidosOpMinAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    idServicoEscolhido: string | null
    nome: string | null
    qtt: number | null
    preco: number | null
    valor: number | null
    unidade: string | null
    obs: string | null
  }

  export type ServicosEscolhidosOpMaxAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    idServicoEscolhido: string | null
    nome: string | null
    qtt: number | null
    preco: number | null
    valor: number | null
    unidade: string | null
    obs: string | null
  }

  export type ServicosEscolhidosOpCountAggregateOutputType = {
    idPlaneamento: number
    Op: number
    idServicoEscolhido: number
    nome: number
    qtt: number
    preco: number
    valor: number
    unidade: number
    obs: number
    _all: number
  }


  export type ServicosEscolhidosOpAvgAggregateInputType = {
    qtt?: true
    preco?: true
    valor?: true
  }

  export type ServicosEscolhidosOpSumAggregateInputType = {
    qtt?: true
    preco?: true
    valor?: true
  }

  export type ServicosEscolhidosOpMinAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    idServicoEscolhido?: true
    nome?: true
    qtt?: true
    preco?: true
    valor?: true
    unidade?: true
    obs?: true
  }

  export type ServicosEscolhidosOpMaxAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    idServicoEscolhido?: true
    nome?: true
    qtt?: true
    preco?: true
    valor?: true
    unidade?: true
    obs?: true
  }

  export type ServicosEscolhidosOpCountAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    idServicoEscolhido?: true
    nome?: true
    qtt?: true
    preco?: true
    valor?: true
    unidade?: true
    obs?: true
    _all?: true
  }

  export type ServicosEscolhidosOpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosOp to aggregate.
     */
    where?: ServicosEscolhidosOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOps to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrderByWithRelationInput | ServicosEscolhidosOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicosEscolhidosOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicosEscolhidosOps
    **/
    _count?: true | ServicosEscolhidosOpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicosEscolhidosOpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicosEscolhidosOpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicosEscolhidosOpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicosEscolhidosOpMaxAggregateInputType
  }

  export type GetServicosEscolhidosOpAggregateType<T extends ServicosEscolhidosOpAggregateArgs> = {
        [P in keyof T & keyof AggregateServicosEscolhidosOp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicosEscolhidosOp[P]>
      : GetScalarType<T[P], AggregateServicosEscolhidosOp[P]>
  }




  export type ServicosEscolhidosOpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosOpWhereInput
    orderBy?: ServicosEscolhidosOpOrderByWithAggregationInput | ServicosEscolhidosOpOrderByWithAggregationInput[]
    by: ServicosEscolhidosOpScalarFieldEnum[] | ServicosEscolhidosOpScalarFieldEnum
    having?: ServicosEscolhidosOpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicosEscolhidosOpCountAggregateInputType | true
    _avg?: ServicosEscolhidosOpAvgAggregateInputType
    _sum?: ServicosEscolhidosOpSumAggregateInputType
    _min?: ServicosEscolhidosOpMinAggregateInputType
    _max?: ServicosEscolhidosOpMaxAggregateInputType
  }

  export type ServicosEscolhidosOpGroupByOutputType = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    _count: ServicosEscolhidosOpCountAggregateOutputType | null
    _avg: ServicosEscolhidosOpAvgAggregateOutputType | null
    _sum: ServicosEscolhidosOpSumAggregateOutputType | null
    _min: ServicosEscolhidosOpMinAggregateOutputType | null
    _max: ServicosEscolhidosOpMaxAggregateOutputType | null
  }

  type GetServicosEscolhidosOpGroupByPayload<T extends ServicosEscolhidosOpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicosEscolhidosOpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicosEscolhidosOpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicosEscolhidosOpGroupByOutputType[P]>
            : GetScalarType<T[P], ServicosEscolhidosOpGroupByOutputType[P]>
        }
      >
    >


  export type ServicosEscolhidosOpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    Op?: boolean
    idServicoEscolhido?: boolean
    nome?: boolean
    qtt?: boolean
    preco?: boolean
    valor?: boolean
    unidade?: boolean
    obs?: boolean
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp?: boolean | OpDefaultArgs<ExtArgs>
    ServicosEscolhidosOpOrigem?: boolean | ServicosEscolhidosOp$ServicosEscolhidosOpOrigemArgs<ExtArgs>
    _count?: boolean | ServicosEscolhidosOpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicosEscolhidosOp"]>



  export type ServicosEscolhidosOpSelectScalar = {
    idPlaneamento?: boolean
    Op?: boolean
    idServicoEscolhido?: boolean
    nome?: boolean
    qtt?: boolean
    preco?: boolean
    valor?: boolean
    unidade?: boolean
    obs?: boolean
  }

  export type ServicosEscolhidosOpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "Op" | "idServicoEscolhido" | "nome" | "qtt" | "preco" | "valor" | "unidade" | "obs", ExtArgs["result"]["servicosEscolhidosOp"]>
  export type ServicosEscolhidosOpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp?: boolean | OpDefaultArgs<ExtArgs>
    ServicosEscolhidosOpOrigem?: boolean | ServicosEscolhidosOp$ServicosEscolhidosOpOrigemArgs<ExtArgs>
    _count?: boolean | ServicosEscolhidosOpCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicosEscolhidosOpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicosEscolhidosOp"
    objects: {
      Op_ServicosEscolhidosOp_idPlaneamento_OpToOp: Prisma.$OpPayload<ExtArgs>
      ServicosEscolhidosOpOrigem: Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      Op: string
      idServicoEscolhido: string
      nome: string
      qtt: number
      preco: number
      valor: number
      unidade: string
      obs: string
    }, ExtArgs["result"]["servicosEscolhidosOp"]>
    composites: {}
  }

  type ServicosEscolhidosOpGetPayload<S extends boolean | null | undefined | ServicosEscolhidosOpDefaultArgs> = $Result.GetResult<Prisma.$ServicosEscolhidosOpPayload, S>

  type ServicosEscolhidosOpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicosEscolhidosOpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicosEscolhidosOpCountAggregateInputType | true
    }

  export interface ServicosEscolhidosOpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicosEscolhidosOp'], meta: { name: 'ServicosEscolhidosOp' } }
    /**
     * Find zero or one ServicosEscolhidosOp that matches the filter.
     * @param {ServicosEscolhidosOpFindUniqueArgs} args - Arguments to find a ServicosEscolhidosOp
     * @example
     * // Get one ServicosEscolhidosOp
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicosEscolhidosOpFindUniqueArgs>(args: SelectSubset<T, ServicosEscolhidosOpFindUniqueArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ServicosEscolhidosOp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicosEscolhidosOpFindUniqueOrThrowArgs} args - Arguments to find a ServicosEscolhidosOp
     * @example
     * // Get one ServicosEscolhidosOp
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicosEscolhidosOpFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicosEscolhidosOpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosOp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpFindFirstArgs} args - Arguments to find a ServicosEscolhidosOp
     * @example
     * // Get one ServicosEscolhidosOp
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicosEscolhidosOpFindFirstArgs>(args?: SelectSubset<T, ServicosEscolhidosOpFindFirstArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosOp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpFindFirstOrThrowArgs} args - Arguments to find a ServicosEscolhidosOp
     * @example
     * // Get one ServicosEscolhidosOp
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicosEscolhidosOpFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicosEscolhidosOpFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ServicosEscolhidosOps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicosEscolhidosOps
     * const servicosEscolhidosOps = await prisma.servicosEscolhidosOp.findMany()
     * 
     * // Get first 10 ServicosEscolhidosOps
     * const servicosEscolhidosOps = await prisma.servicosEscolhidosOp.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const servicosEscolhidosOpWithIdPlaneamentoOnly = await prisma.servicosEscolhidosOp.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends ServicosEscolhidosOpFindManyArgs>(args?: SelectSubset<T, ServicosEscolhidosOpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ServicosEscolhidosOp.
     * @param {ServicosEscolhidosOpCreateArgs} args - Arguments to create a ServicosEscolhidosOp.
     * @example
     * // Create one ServicosEscolhidosOp
     * const ServicosEscolhidosOp = await prisma.servicosEscolhidosOp.create({
     *   data: {
     *     // ... data to create a ServicosEscolhidosOp
     *   }
     * })
     * 
     */
    create<T extends ServicosEscolhidosOpCreateArgs>(args: SelectSubset<T, ServicosEscolhidosOpCreateArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ServicosEscolhidosOps.
     * @param {ServicosEscolhidosOpCreateManyArgs} args - Arguments to create many ServicosEscolhidosOps.
     * @example
     * // Create many ServicosEscolhidosOps
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicosEscolhidosOpCreateManyArgs>(args?: SelectSubset<T, ServicosEscolhidosOpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServicosEscolhidosOp.
     * @param {ServicosEscolhidosOpDeleteArgs} args - Arguments to delete one ServicosEscolhidosOp.
     * @example
     * // Delete one ServicosEscolhidosOp
     * const ServicosEscolhidosOp = await prisma.servicosEscolhidosOp.delete({
     *   where: {
     *     // ... filter to delete one ServicosEscolhidosOp
     *   }
     * })
     * 
     */
    delete<T extends ServicosEscolhidosOpDeleteArgs>(args: SelectSubset<T, ServicosEscolhidosOpDeleteArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ServicosEscolhidosOp.
     * @param {ServicosEscolhidosOpUpdateArgs} args - Arguments to update one ServicosEscolhidosOp.
     * @example
     * // Update one ServicosEscolhidosOp
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicosEscolhidosOpUpdateArgs>(args: SelectSubset<T, ServicosEscolhidosOpUpdateArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ServicosEscolhidosOps.
     * @param {ServicosEscolhidosOpDeleteManyArgs} args - Arguments to filter ServicosEscolhidosOps to delete.
     * @example
     * // Delete a few ServicosEscolhidosOps
     * const { count } = await prisma.servicosEscolhidosOp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicosEscolhidosOpDeleteManyArgs>(args?: SelectSubset<T, ServicosEscolhidosOpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicosEscolhidosOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicosEscolhidosOps
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicosEscolhidosOpUpdateManyArgs>(args: SelectSubset<T, ServicosEscolhidosOpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicosEscolhidosOp.
     * @param {ServicosEscolhidosOpUpsertArgs} args - Arguments to update or create a ServicosEscolhidosOp.
     * @example
     * // Update or create a ServicosEscolhidosOp
     * const servicosEscolhidosOp = await prisma.servicosEscolhidosOp.upsert({
     *   create: {
     *     // ... data to create a ServicosEscolhidosOp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicosEscolhidosOp we want to update
     *   }
     * })
     */
    upsert<T extends ServicosEscolhidosOpUpsertArgs>(args: SelectSubset<T, ServicosEscolhidosOpUpsertArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ServicosEscolhidosOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpCountArgs} args - Arguments to filter ServicosEscolhidosOps to count.
     * @example
     * // Count the number of ServicosEscolhidosOps
     * const count = await prisma.servicosEscolhidosOp.count({
     *   where: {
     *     // ... the filter for the ServicosEscolhidosOps we want to count
     *   }
     * })
    **/
    count<T extends ServicosEscolhidosOpCountArgs>(
      args?: Subset<T, ServicosEscolhidosOpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicosEscolhidosOpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicosEscolhidosOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicosEscolhidosOpAggregateArgs>(args: Subset<T, ServicosEscolhidosOpAggregateArgs>): Prisma.PrismaPromise<GetServicosEscolhidosOpAggregateType<T>>

    /**
     * Group by ServicosEscolhidosOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicosEscolhidosOpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicosEscolhidosOpGroupByArgs['orderBy'] }
        : { orderBy?: ServicosEscolhidosOpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicosEscolhidosOpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicosEscolhidosOpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicosEscolhidosOp model
   */
  readonly fields: ServicosEscolhidosOpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicosEscolhidosOp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicosEscolhidosOpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp<T extends OpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OpDefaultArgs<ExtArgs>>): Prisma__OpClient<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ServicosEscolhidosOpOrigem<T extends ServicosEscolhidosOp$ServicosEscolhidosOpOrigemArgs<ExtArgs> = {}>(args?: Subset<T, ServicosEscolhidosOp$ServicosEscolhidosOpOrigemArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicosEscolhidosOp model
   */ 
  interface ServicosEscolhidosOpFieldRefs {
    readonly idPlaneamento: FieldRef<"ServicosEscolhidosOp", 'String'>
    readonly Op: FieldRef<"ServicosEscolhidosOp", 'String'>
    readonly idServicoEscolhido: FieldRef<"ServicosEscolhidosOp", 'String'>
    readonly nome: FieldRef<"ServicosEscolhidosOp", 'String'>
    readonly qtt: FieldRef<"ServicosEscolhidosOp", 'Float'>
    readonly preco: FieldRef<"ServicosEscolhidosOp", 'Float'>
    readonly valor: FieldRef<"ServicosEscolhidosOp", 'Float'>
    readonly unidade: FieldRef<"ServicosEscolhidosOp", 'String'>
    readonly obs: FieldRef<"ServicosEscolhidosOp", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServicosEscolhidosOp findUnique
   */
  export type ServicosEscolhidosOpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOp to fetch.
     */
    where: ServicosEscolhidosOpWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOp findUniqueOrThrow
   */
  export type ServicosEscolhidosOpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOp to fetch.
     */
    where: ServicosEscolhidosOpWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOp findFirst
   */
  export type ServicosEscolhidosOpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOp to fetch.
     */
    where?: ServicosEscolhidosOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOps to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrderByWithRelationInput | ServicosEscolhidosOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosOps.
     */
    cursor?: ServicosEscolhidosOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosOps.
     */
    distinct?: ServicosEscolhidosOpScalarFieldEnum | ServicosEscolhidosOpScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosOp findFirstOrThrow
   */
  export type ServicosEscolhidosOpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOp to fetch.
     */
    where?: ServicosEscolhidosOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOps to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrderByWithRelationInput | ServicosEscolhidosOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosOps.
     */
    cursor?: ServicosEscolhidosOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosOps.
     */
    distinct?: ServicosEscolhidosOpScalarFieldEnum | ServicosEscolhidosOpScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosOp findMany
   */
  export type ServicosEscolhidosOpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOps to fetch.
     */
    where?: ServicosEscolhidosOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOps to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrderByWithRelationInput | ServicosEscolhidosOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicosEscolhidosOps.
     */
    cursor?: ServicosEscolhidosOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOps.
     */
    skip?: number
    distinct?: ServicosEscolhidosOpScalarFieldEnum | ServicosEscolhidosOpScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosOp create
   */
  export type ServicosEscolhidosOpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicosEscolhidosOp.
     */
    data: XOR<ServicosEscolhidosOpCreateInput, ServicosEscolhidosOpUncheckedCreateInput>
  }

  /**
   * ServicosEscolhidosOp createMany
   */
  export type ServicosEscolhidosOpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicosEscolhidosOps.
     */
    data: ServicosEscolhidosOpCreateManyInput | ServicosEscolhidosOpCreateManyInput[]
  }

  /**
   * ServicosEscolhidosOp update
   */
  export type ServicosEscolhidosOpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicosEscolhidosOp.
     */
    data: XOR<ServicosEscolhidosOpUpdateInput, ServicosEscolhidosOpUncheckedUpdateInput>
    /**
     * Choose, which ServicosEscolhidosOp to update.
     */
    where: ServicosEscolhidosOpWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOp updateMany
   */
  export type ServicosEscolhidosOpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicosEscolhidosOps.
     */
    data: XOR<ServicosEscolhidosOpUpdateManyMutationInput, ServicosEscolhidosOpUncheckedUpdateManyInput>
    /**
     * Filter which ServicosEscolhidosOps to update
     */
    where?: ServicosEscolhidosOpWhereInput
    /**
     * Limit how many ServicosEscolhidosOps to update.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosOp upsert
   */
  export type ServicosEscolhidosOpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicosEscolhidosOp to update in case it exists.
     */
    where: ServicosEscolhidosOpWhereUniqueInput
    /**
     * In case the ServicosEscolhidosOp found by the `where` argument doesn't exist, create a new ServicosEscolhidosOp with this data.
     */
    create: XOR<ServicosEscolhidosOpCreateInput, ServicosEscolhidosOpUncheckedCreateInput>
    /**
     * In case the ServicosEscolhidosOp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicosEscolhidosOpUpdateInput, ServicosEscolhidosOpUncheckedUpdateInput>
  }

  /**
   * ServicosEscolhidosOp delete
   */
  export type ServicosEscolhidosOpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
    /**
     * Filter which ServicosEscolhidosOp to delete.
     */
    where: ServicosEscolhidosOpWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOp deleteMany
   */
  export type ServicosEscolhidosOpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosOps to delete
     */
    where?: ServicosEscolhidosOpWhereInput
    /**
     * Limit how many ServicosEscolhidosOps to delete.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosOp.ServicosEscolhidosOpOrigem
   */
  export type ServicosEscolhidosOp$ServicosEscolhidosOpOrigemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    where?: ServicosEscolhidosOpOrigemWhereInput
    orderBy?: ServicosEscolhidosOpOrigemOrderByWithRelationInput | ServicosEscolhidosOpOrigemOrderByWithRelationInput[]
    cursor?: ServicosEscolhidosOpOrigemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicosEscolhidosOpOrigemScalarFieldEnum | ServicosEscolhidosOpOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosOp without action
   */
  export type ServicosEscolhidosOpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOp
     */
    select?: ServicosEscolhidosOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOp
     */
    omit?: ServicosEscolhidosOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpInclude<ExtArgs> | null
  }


  /**
   * Model ServicosEscolhidosOpOrigem
   */

  export type AggregateServicosEscolhidosOpOrigem = {
    _count: ServicosEscolhidosOpOrigemCountAggregateOutputType | null
    _min: ServicosEscolhidosOpOrigemMinAggregateOutputType | null
    _max: ServicosEscolhidosOpOrigemMaxAggregateOutputType | null
  }

  export type ServicosEscolhidosOpOrigemMinAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    idServicoEscolhido: string | null
    orcamentoLinhasStamp: string | null
  }

  export type ServicosEscolhidosOpOrigemMaxAggregateOutputType = {
    idPlaneamento: string | null
    Op: string | null
    idServicoEscolhido: string | null
    orcamentoLinhasStamp: string | null
  }

  export type ServicosEscolhidosOpOrigemCountAggregateOutputType = {
    idPlaneamento: number
    Op: number
    idServicoEscolhido: number
    orcamentoLinhasStamp: number
    _all: number
  }


  export type ServicosEscolhidosOpOrigemMinAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    idServicoEscolhido?: true
    orcamentoLinhasStamp?: true
  }

  export type ServicosEscolhidosOpOrigemMaxAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    idServicoEscolhido?: true
    orcamentoLinhasStamp?: true
  }

  export type ServicosEscolhidosOpOrigemCountAggregateInputType = {
    idPlaneamento?: true
    Op?: true
    idServicoEscolhido?: true
    orcamentoLinhasStamp?: true
    _all?: true
  }

  export type ServicosEscolhidosOpOrigemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosOpOrigem to aggregate.
     */
    where?: ServicosEscolhidosOpOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOpOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrigemOrderByWithRelationInput | ServicosEscolhidosOpOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicosEscolhidosOpOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOpOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOpOrigems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicosEscolhidosOpOrigems
    **/
    _count?: true | ServicosEscolhidosOpOrigemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicosEscolhidosOpOrigemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicosEscolhidosOpOrigemMaxAggregateInputType
  }

  export type GetServicosEscolhidosOpOrigemAggregateType<T extends ServicosEscolhidosOpOrigemAggregateArgs> = {
        [P in keyof T & keyof AggregateServicosEscolhidosOpOrigem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicosEscolhidosOpOrigem[P]>
      : GetScalarType<T[P], AggregateServicosEscolhidosOpOrigem[P]>
  }




  export type ServicosEscolhidosOpOrigemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicosEscolhidosOpOrigemWhereInput
    orderBy?: ServicosEscolhidosOpOrigemOrderByWithAggregationInput | ServicosEscolhidosOpOrigemOrderByWithAggregationInput[]
    by: ServicosEscolhidosOpOrigemScalarFieldEnum[] | ServicosEscolhidosOpOrigemScalarFieldEnum
    having?: ServicosEscolhidosOpOrigemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicosEscolhidosOpOrigemCountAggregateInputType | true
    _min?: ServicosEscolhidosOpOrigemMinAggregateInputType
    _max?: ServicosEscolhidosOpOrigemMaxAggregateInputType
  }

  export type ServicosEscolhidosOpOrigemGroupByOutputType = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
    _count: ServicosEscolhidosOpOrigemCountAggregateOutputType | null
    _min: ServicosEscolhidosOpOrigemMinAggregateOutputType | null
    _max: ServicosEscolhidosOpOrigemMaxAggregateOutputType | null
  }

  type GetServicosEscolhidosOpOrigemGroupByPayload<T extends ServicosEscolhidosOpOrigemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicosEscolhidosOpOrigemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicosEscolhidosOpOrigemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicosEscolhidosOpOrigemGroupByOutputType[P]>
            : GetScalarType<T[P], ServicosEscolhidosOpOrigemGroupByOutputType[P]>
        }
      >
    >


  export type ServicosEscolhidosOpOrigemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPlaneamento?: boolean
    Op?: boolean
    idServicoEscolhido?: boolean
    orcamentoLinhasStamp?: boolean
    OrcamentoOpLinhas?: boolean | OrcamentoOpLinhasDefaultArgs<ExtArgs>
    ServicosEscolhidosOp?: boolean | ServicosEscolhidosOpDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicosEscolhidosOpOrigem"]>



  export type ServicosEscolhidosOpOrigemSelectScalar = {
    idPlaneamento?: boolean
    Op?: boolean
    idServicoEscolhido?: boolean
    orcamentoLinhasStamp?: boolean
  }

  export type ServicosEscolhidosOpOrigemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPlaneamento" | "Op" | "idServicoEscolhido" | "orcamentoLinhasStamp", ExtArgs["result"]["servicosEscolhidosOpOrigem"]>
  export type ServicosEscolhidosOpOrigemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    OrcamentoOpLinhas?: boolean | OrcamentoOpLinhasDefaultArgs<ExtArgs>
    ServicosEscolhidosOp?: boolean | ServicosEscolhidosOpDefaultArgs<ExtArgs>
  }

  export type $ServicosEscolhidosOpOrigemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicosEscolhidosOpOrigem"
    objects: {
      OrcamentoOpLinhas: Prisma.$OrcamentoOpLinhasPayload<ExtArgs>
      ServicosEscolhidosOp: Prisma.$ServicosEscolhidosOpPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPlaneamento: string
      Op: string
      idServicoEscolhido: string
      orcamentoLinhasStamp: string
    }, ExtArgs["result"]["servicosEscolhidosOpOrigem"]>
    composites: {}
  }

  type ServicosEscolhidosOpOrigemGetPayload<S extends boolean | null | undefined | ServicosEscolhidosOpOrigemDefaultArgs> = $Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload, S>

  type ServicosEscolhidosOpOrigemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicosEscolhidosOpOrigemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicosEscolhidosOpOrigemCountAggregateInputType | true
    }

  export interface ServicosEscolhidosOpOrigemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicosEscolhidosOpOrigem'], meta: { name: 'ServicosEscolhidosOpOrigem' } }
    /**
     * Find zero or one ServicosEscolhidosOpOrigem that matches the filter.
     * @param {ServicosEscolhidosOpOrigemFindUniqueArgs} args - Arguments to find a ServicosEscolhidosOpOrigem
     * @example
     * // Get one ServicosEscolhidosOpOrigem
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicosEscolhidosOpOrigemFindUniqueArgs>(args: SelectSubset<T, ServicosEscolhidosOpOrigemFindUniqueArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ServicosEscolhidosOpOrigem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicosEscolhidosOpOrigemFindUniqueOrThrowArgs} args - Arguments to find a ServicosEscolhidosOpOrigem
     * @example
     * // Get one ServicosEscolhidosOpOrigem
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicosEscolhidosOpOrigemFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicosEscolhidosOpOrigemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosOpOrigem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpOrigemFindFirstArgs} args - Arguments to find a ServicosEscolhidosOpOrigem
     * @example
     * // Get one ServicosEscolhidosOpOrigem
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicosEscolhidosOpOrigemFindFirstArgs>(args?: SelectSubset<T, ServicosEscolhidosOpOrigemFindFirstArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ServicosEscolhidosOpOrigem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpOrigemFindFirstOrThrowArgs} args - Arguments to find a ServicosEscolhidosOpOrigem
     * @example
     * // Get one ServicosEscolhidosOpOrigem
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicosEscolhidosOpOrigemFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicosEscolhidosOpOrigemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ServicosEscolhidosOpOrigems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpOrigemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicosEscolhidosOpOrigems
     * const servicosEscolhidosOpOrigems = await prisma.servicosEscolhidosOpOrigem.findMany()
     * 
     * // Get first 10 ServicosEscolhidosOpOrigems
     * const servicosEscolhidosOpOrigems = await prisma.servicosEscolhidosOpOrigem.findMany({ take: 10 })
     * 
     * // Only select the `idPlaneamento`
     * const servicosEscolhidosOpOrigemWithIdPlaneamentoOnly = await prisma.servicosEscolhidosOpOrigem.findMany({ select: { idPlaneamento: true } })
     * 
     */
    findMany<T extends ServicosEscolhidosOpOrigemFindManyArgs>(args?: SelectSubset<T, ServicosEscolhidosOpOrigemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ServicosEscolhidosOpOrigem.
     * @param {ServicosEscolhidosOpOrigemCreateArgs} args - Arguments to create a ServicosEscolhidosOpOrigem.
     * @example
     * // Create one ServicosEscolhidosOpOrigem
     * const ServicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.create({
     *   data: {
     *     // ... data to create a ServicosEscolhidosOpOrigem
     *   }
     * })
     * 
     */
    create<T extends ServicosEscolhidosOpOrigemCreateArgs>(args: SelectSubset<T, ServicosEscolhidosOpOrigemCreateArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ServicosEscolhidosOpOrigems.
     * @param {ServicosEscolhidosOpOrigemCreateManyArgs} args - Arguments to create many ServicosEscolhidosOpOrigems.
     * @example
     * // Create many ServicosEscolhidosOpOrigems
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicosEscolhidosOpOrigemCreateManyArgs>(args?: SelectSubset<T, ServicosEscolhidosOpOrigemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServicosEscolhidosOpOrigem.
     * @param {ServicosEscolhidosOpOrigemDeleteArgs} args - Arguments to delete one ServicosEscolhidosOpOrigem.
     * @example
     * // Delete one ServicosEscolhidosOpOrigem
     * const ServicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.delete({
     *   where: {
     *     // ... filter to delete one ServicosEscolhidosOpOrigem
     *   }
     * })
     * 
     */
    delete<T extends ServicosEscolhidosOpOrigemDeleteArgs>(args: SelectSubset<T, ServicosEscolhidosOpOrigemDeleteArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ServicosEscolhidosOpOrigem.
     * @param {ServicosEscolhidosOpOrigemUpdateArgs} args - Arguments to update one ServicosEscolhidosOpOrigem.
     * @example
     * // Update one ServicosEscolhidosOpOrigem
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicosEscolhidosOpOrigemUpdateArgs>(args: SelectSubset<T, ServicosEscolhidosOpOrigemUpdateArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ServicosEscolhidosOpOrigems.
     * @param {ServicosEscolhidosOpOrigemDeleteManyArgs} args - Arguments to filter ServicosEscolhidosOpOrigems to delete.
     * @example
     * // Delete a few ServicosEscolhidosOpOrigems
     * const { count } = await prisma.servicosEscolhidosOpOrigem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicosEscolhidosOpOrigemDeleteManyArgs>(args?: SelectSubset<T, ServicosEscolhidosOpOrigemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicosEscolhidosOpOrigems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpOrigemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicosEscolhidosOpOrigems
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicosEscolhidosOpOrigemUpdateManyArgs>(args: SelectSubset<T, ServicosEscolhidosOpOrigemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicosEscolhidosOpOrigem.
     * @param {ServicosEscolhidosOpOrigemUpsertArgs} args - Arguments to update or create a ServicosEscolhidosOpOrigem.
     * @example
     * // Update or create a ServicosEscolhidosOpOrigem
     * const servicosEscolhidosOpOrigem = await prisma.servicosEscolhidosOpOrigem.upsert({
     *   create: {
     *     // ... data to create a ServicosEscolhidosOpOrigem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicosEscolhidosOpOrigem we want to update
     *   }
     * })
     */
    upsert<T extends ServicosEscolhidosOpOrigemUpsertArgs>(args: SelectSubset<T, ServicosEscolhidosOpOrigemUpsertArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpOrigemClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpOrigemPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ServicosEscolhidosOpOrigems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpOrigemCountArgs} args - Arguments to filter ServicosEscolhidosOpOrigems to count.
     * @example
     * // Count the number of ServicosEscolhidosOpOrigems
     * const count = await prisma.servicosEscolhidosOpOrigem.count({
     *   where: {
     *     // ... the filter for the ServicosEscolhidosOpOrigems we want to count
     *   }
     * })
    **/
    count<T extends ServicosEscolhidosOpOrigemCountArgs>(
      args?: Subset<T, ServicosEscolhidosOpOrigemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicosEscolhidosOpOrigemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicosEscolhidosOpOrigem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpOrigemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicosEscolhidosOpOrigemAggregateArgs>(args: Subset<T, ServicosEscolhidosOpOrigemAggregateArgs>): Prisma.PrismaPromise<GetServicosEscolhidosOpOrigemAggregateType<T>>

    /**
     * Group by ServicosEscolhidosOpOrigem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicosEscolhidosOpOrigemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicosEscolhidosOpOrigemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicosEscolhidosOpOrigemGroupByArgs['orderBy'] }
        : { orderBy?: ServicosEscolhidosOpOrigemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicosEscolhidosOpOrigemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicosEscolhidosOpOrigemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicosEscolhidosOpOrigem model
   */
  readonly fields: ServicosEscolhidosOpOrigemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicosEscolhidosOpOrigem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicosEscolhidosOpOrigemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    OrcamentoOpLinhas<T extends OrcamentoOpLinhasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrcamentoOpLinhasDefaultArgs<ExtArgs>>): Prisma__OrcamentoOpLinhasClient<$Result.GetResult<Prisma.$OrcamentoOpLinhasPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    ServicosEscolhidosOp<T extends ServicosEscolhidosOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServicosEscolhidosOpDefaultArgs<ExtArgs>>): Prisma__ServicosEscolhidosOpClient<$Result.GetResult<Prisma.$ServicosEscolhidosOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicosEscolhidosOpOrigem model
   */ 
  interface ServicosEscolhidosOpOrigemFieldRefs {
    readonly idPlaneamento: FieldRef<"ServicosEscolhidosOpOrigem", 'String'>
    readonly Op: FieldRef<"ServicosEscolhidosOpOrigem", 'String'>
    readonly idServicoEscolhido: FieldRef<"ServicosEscolhidosOpOrigem", 'String'>
    readonly orcamentoLinhasStamp: FieldRef<"ServicosEscolhidosOpOrigem", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServicosEscolhidosOpOrigem findUnique
   */
  export type ServicosEscolhidosOpOrigemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOpOrigem to fetch.
     */
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOpOrigem findUniqueOrThrow
   */
  export type ServicosEscolhidosOpOrigemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOpOrigem to fetch.
     */
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOpOrigem findFirst
   */
  export type ServicosEscolhidosOpOrigemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOpOrigem to fetch.
     */
    where?: ServicosEscolhidosOpOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOpOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrigemOrderByWithRelationInput | ServicosEscolhidosOpOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosOpOrigems.
     */
    cursor?: ServicosEscolhidosOpOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOpOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOpOrigems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosOpOrigems.
     */
    distinct?: ServicosEscolhidosOpOrigemScalarFieldEnum | ServicosEscolhidosOpOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosOpOrigem findFirstOrThrow
   */
  export type ServicosEscolhidosOpOrigemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOpOrigem to fetch.
     */
    where?: ServicosEscolhidosOpOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOpOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrigemOrderByWithRelationInput | ServicosEscolhidosOpOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicosEscolhidosOpOrigems.
     */
    cursor?: ServicosEscolhidosOpOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOpOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOpOrigems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicosEscolhidosOpOrigems.
     */
    distinct?: ServicosEscolhidosOpOrigemScalarFieldEnum | ServicosEscolhidosOpOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosOpOrigem findMany
   */
  export type ServicosEscolhidosOpOrigemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * Filter, which ServicosEscolhidosOpOrigems to fetch.
     */
    where?: ServicosEscolhidosOpOrigemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicosEscolhidosOpOrigems to fetch.
     */
    orderBy?: ServicosEscolhidosOpOrigemOrderByWithRelationInput | ServicosEscolhidosOpOrigemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicosEscolhidosOpOrigems.
     */
    cursor?: ServicosEscolhidosOpOrigemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicosEscolhidosOpOrigems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicosEscolhidosOpOrigems.
     */
    skip?: number
    distinct?: ServicosEscolhidosOpOrigemScalarFieldEnum | ServicosEscolhidosOpOrigemScalarFieldEnum[]
  }

  /**
   * ServicosEscolhidosOpOrigem create
   */
  export type ServicosEscolhidosOpOrigemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicosEscolhidosOpOrigem.
     */
    data: XOR<ServicosEscolhidosOpOrigemCreateInput, ServicosEscolhidosOpOrigemUncheckedCreateInput>
  }

  /**
   * ServicosEscolhidosOpOrigem createMany
   */
  export type ServicosEscolhidosOpOrigemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicosEscolhidosOpOrigems.
     */
    data: ServicosEscolhidosOpOrigemCreateManyInput | ServicosEscolhidosOpOrigemCreateManyInput[]
  }

  /**
   * ServicosEscolhidosOpOrigem update
   */
  export type ServicosEscolhidosOpOrigemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicosEscolhidosOpOrigem.
     */
    data: XOR<ServicosEscolhidosOpOrigemUpdateInput, ServicosEscolhidosOpOrigemUncheckedUpdateInput>
    /**
     * Choose, which ServicosEscolhidosOpOrigem to update.
     */
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOpOrigem updateMany
   */
  export type ServicosEscolhidosOpOrigemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicosEscolhidosOpOrigems.
     */
    data: XOR<ServicosEscolhidosOpOrigemUpdateManyMutationInput, ServicosEscolhidosOpOrigemUncheckedUpdateManyInput>
    /**
     * Filter which ServicosEscolhidosOpOrigems to update
     */
    where?: ServicosEscolhidosOpOrigemWhereInput
    /**
     * Limit how many ServicosEscolhidosOpOrigems to update.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosOpOrigem upsert
   */
  export type ServicosEscolhidosOpOrigemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicosEscolhidosOpOrigem to update in case it exists.
     */
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
    /**
     * In case the ServicosEscolhidosOpOrigem found by the `where` argument doesn't exist, create a new ServicosEscolhidosOpOrigem with this data.
     */
    create: XOR<ServicosEscolhidosOpOrigemCreateInput, ServicosEscolhidosOpOrigemUncheckedCreateInput>
    /**
     * In case the ServicosEscolhidosOpOrigem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicosEscolhidosOpOrigemUpdateInput, ServicosEscolhidosOpOrigemUncheckedUpdateInput>
  }

  /**
   * ServicosEscolhidosOpOrigem delete
   */
  export type ServicosEscolhidosOpOrigemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
    /**
     * Filter which ServicosEscolhidosOpOrigem to delete.
     */
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
  }

  /**
   * ServicosEscolhidosOpOrigem deleteMany
   */
  export type ServicosEscolhidosOpOrigemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicosEscolhidosOpOrigems to delete
     */
    where?: ServicosEscolhidosOpOrigemWhereInput
    /**
     * Limit how many ServicosEscolhidosOpOrigems to delete.
     */
    limit?: number
  }

  /**
   * ServicosEscolhidosOpOrigem without action
   */
  export type ServicosEscolhidosOpOrigemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicosEscolhidosOpOrigem
     */
    select?: ServicosEscolhidosOpOrigemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicosEscolhidosOpOrigem
     */
    omit?: ServicosEscolhidosOpOrigemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicosEscolhidosOpOrigemInclude<ExtArgs> | null
  }


  /**
   * Model sysdiagrams
   */

  export type AggregateSysdiagrams = {
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  export type SysdiagramsAvgAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsSumAggregateOutputType = {
    principal_id: number | null
    diagram_id: number | null
    version: number | null
  }

  export type SysdiagramsMinAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsMaxAggregateOutputType = {
    name: string | null
    principal_id: number | null
    diagram_id: number | null
    version: number | null
    definition: Uint8Array | null
  }

  export type SysdiagramsCountAggregateOutputType = {
    name: number
    principal_id: number
    diagram_id: number
    version: number
    definition: number
    _all: number
  }


  export type SysdiagramsAvgAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsSumAggregateInputType = {
    principal_id?: true
    diagram_id?: true
    version?: true
  }

  export type SysdiagramsMinAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsMaxAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
  }

  export type SysdiagramsCountAggregateInputType = {
    name?: true
    principal_id?: true
    diagram_id?: true
    version?: true
    definition?: true
    _all?: true
  }

  export type SysdiagramsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to aggregate.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sysdiagrams
    **/
    _count?: true | SysdiagramsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SysdiagramsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SysdiagramsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SysdiagramsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type GetSysdiagramsAggregateType<T extends SysdiagramsAggregateArgs> = {
        [P in keyof T & keyof AggregateSysdiagrams]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSysdiagrams[P]>
      : GetScalarType<T[P], AggregateSysdiagrams[P]>
  }




  export type sysdiagramsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sysdiagramsWhereInput
    orderBy?: sysdiagramsOrderByWithAggregationInput | sysdiagramsOrderByWithAggregationInput[]
    by: SysdiagramsScalarFieldEnum[] | SysdiagramsScalarFieldEnum
    having?: sysdiagramsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SysdiagramsCountAggregateInputType | true
    _avg?: SysdiagramsAvgAggregateInputType
    _sum?: SysdiagramsSumAggregateInputType
    _min?: SysdiagramsMinAggregateInputType
    _max?: SysdiagramsMaxAggregateInputType
  }

  export type SysdiagramsGroupByOutputType = {
    name: string
    principal_id: number
    diagram_id: number
    version: number | null
    definition: Uint8Array | null
    _count: SysdiagramsCountAggregateOutputType | null
    _avg: SysdiagramsAvgAggregateOutputType | null
    _sum: SysdiagramsSumAggregateOutputType | null
    _min: SysdiagramsMinAggregateOutputType | null
    _max: SysdiagramsMaxAggregateOutputType | null
  }

  type GetSysdiagramsGroupByPayload<T extends sysdiagramsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SysdiagramsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SysdiagramsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
            : GetScalarType<T[P], SysdiagramsGroupByOutputType[P]>
        }
      >
    >


  export type sysdiagramsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }, ExtArgs["result"]["sysdiagrams"]>



  export type sysdiagramsSelectScalar = {
    name?: boolean
    principal_id?: boolean
    diagram_id?: boolean
    version?: boolean
    definition?: boolean
  }

  export type sysdiagramsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "principal_id" | "diagram_id" | "version" | "definition", ExtArgs["result"]["sysdiagrams"]>

  export type $sysdiagramsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sysdiagrams"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      name: string
      principal_id: number
      diagram_id: number
      version: number | null
      definition: Uint8Array | null
    }, ExtArgs["result"]["sysdiagrams"]>
    composites: {}
  }

  type sysdiagramsGetPayload<S extends boolean | null | undefined | sysdiagramsDefaultArgs> = $Result.GetResult<Prisma.$sysdiagramsPayload, S>

  type sysdiagramsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sysdiagramsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SysdiagramsCountAggregateInputType | true
    }

  export interface sysdiagramsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sysdiagrams'], meta: { name: 'sysdiagrams' } }
    /**
     * Find zero or one Sysdiagrams that matches the filter.
     * @param {sysdiagramsFindUniqueArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sysdiagramsFindUniqueArgs>(args: SelectSubset<T, sysdiagramsFindUniqueArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Sysdiagrams that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sysdiagramsFindUniqueOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sysdiagramsFindUniqueOrThrowArgs>(args: SelectSubset<T, sysdiagramsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sysdiagramsFindFirstArgs>(args?: SelectSubset<T, sysdiagramsFindFirstArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Sysdiagrams that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindFirstOrThrowArgs} args - Arguments to find a Sysdiagrams
     * @example
     * // Get one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sysdiagramsFindFirstOrThrowArgs>(args?: SelectSubset<T, sysdiagramsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Sysdiagrams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany()
     * 
     * // Get first 10 Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const sysdiagramsWithNameOnly = await prisma.sysdiagrams.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends sysdiagramsFindManyArgs>(args?: SelectSubset<T, sysdiagramsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Sysdiagrams.
     * @param {sysdiagramsCreateArgs} args - Arguments to create a Sysdiagrams.
     * @example
     * // Create one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.create({
     *   data: {
     *     // ... data to create a Sysdiagrams
     *   }
     * })
     * 
     */
    create<T extends sysdiagramsCreateArgs>(args: SelectSubset<T, sysdiagramsCreateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Sysdiagrams.
     * @param {sysdiagramsCreateManyArgs} args - Arguments to create many Sysdiagrams.
     * @example
     * // Create many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sysdiagramsCreateManyArgs>(args?: SelectSubset<T, sysdiagramsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sysdiagrams.
     * @param {sysdiagramsDeleteArgs} args - Arguments to delete one Sysdiagrams.
     * @example
     * // Delete one Sysdiagrams
     * const Sysdiagrams = await prisma.sysdiagrams.delete({
     *   where: {
     *     // ... filter to delete one Sysdiagrams
     *   }
     * })
     * 
     */
    delete<T extends sysdiagramsDeleteArgs>(args: SelectSubset<T, sysdiagramsDeleteArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Sysdiagrams.
     * @param {sysdiagramsUpdateArgs} args - Arguments to update one Sysdiagrams.
     * @example
     * // Update one Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sysdiagramsUpdateArgs>(args: SelectSubset<T, sysdiagramsUpdateArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Sysdiagrams.
     * @param {sysdiagramsDeleteManyArgs} args - Arguments to filter Sysdiagrams to delete.
     * @example
     * // Delete a few Sysdiagrams
     * const { count } = await prisma.sysdiagrams.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sysdiagramsDeleteManyArgs>(args?: SelectSubset<T, sysdiagramsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sysdiagramsUpdateManyArgs>(args: SelectSubset<T, sysdiagramsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sysdiagrams.
     * @param {sysdiagramsUpsertArgs} args - Arguments to update or create a Sysdiagrams.
     * @example
     * // Update or create a Sysdiagrams
     * const sysdiagrams = await prisma.sysdiagrams.upsert({
     *   create: {
     *     // ... data to create a Sysdiagrams
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to update
     *   }
     * })
     */
    upsert<T extends sysdiagramsUpsertArgs>(args: SelectSubset<T, sysdiagramsUpsertArgs<ExtArgs>>): Prisma__sysdiagramsClient<$Result.GetResult<Prisma.$sysdiagramsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsCountArgs} args - Arguments to filter Sysdiagrams to count.
     * @example
     * // Count the number of Sysdiagrams
     * const count = await prisma.sysdiagrams.count({
     *   where: {
     *     // ... the filter for the Sysdiagrams we want to count
     *   }
     * })
    **/
    count<T extends sysdiagramsCountArgs>(
      args?: Subset<T, sysdiagramsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SysdiagramsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SysdiagramsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SysdiagramsAggregateArgs>(args: Subset<T, SysdiagramsAggregateArgs>): Prisma.PrismaPromise<GetSysdiagramsAggregateType<T>>

    /**
     * Group by Sysdiagrams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sysdiagramsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sysdiagramsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sysdiagramsGroupByArgs['orderBy'] }
        : { orderBy?: sysdiagramsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sysdiagramsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSysdiagramsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sysdiagrams model
   */
  readonly fields: sysdiagramsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sysdiagrams.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sysdiagramsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sysdiagrams model
   */ 
  interface sysdiagramsFieldRefs {
    readonly name: FieldRef<"sysdiagrams", 'String'>
    readonly principal_id: FieldRef<"sysdiagrams", 'Int'>
    readonly diagram_id: FieldRef<"sysdiagrams", 'Int'>
    readonly version: FieldRef<"sysdiagrams", 'Int'>
    readonly definition: FieldRef<"sysdiagrams", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * sysdiagrams findUnique
   */
  export type sysdiagramsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findUniqueOrThrow
   */
  export type sysdiagramsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams findFirst
   */
  export type sysdiagramsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findFirstOrThrow
   */
  export type sysdiagramsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sysdiagrams.
     */
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams findMany
   */
  export type sysdiagramsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter, which sysdiagrams to fetch.
     */
    where?: sysdiagramsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sysdiagrams to fetch.
     */
    orderBy?: sysdiagramsOrderByWithRelationInput | sysdiagramsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sysdiagrams.
     */
    cursor?: sysdiagramsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sysdiagrams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sysdiagrams.
     */
    skip?: number
    distinct?: SysdiagramsScalarFieldEnum | SysdiagramsScalarFieldEnum[]
  }

  /**
   * sysdiagrams create
   */
  export type sysdiagramsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to create a sysdiagrams.
     */
    data: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
  }

  /**
   * sysdiagrams createMany
   */
  export type sysdiagramsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sysdiagrams.
     */
    data: sysdiagramsCreateManyInput | sysdiagramsCreateManyInput[]
  }

  /**
   * sysdiagrams update
   */
  export type sysdiagramsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The data needed to update a sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
    /**
     * Choose, which sysdiagrams to update.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams updateMany
   */
  export type sysdiagramsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sysdiagrams.
     */
    data: XOR<sysdiagramsUpdateManyMutationInput, sysdiagramsUncheckedUpdateManyInput>
    /**
     * Filter which sysdiagrams to update
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to update.
     */
    limit?: number
  }

  /**
   * sysdiagrams upsert
   */
  export type sysdiagramsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * The filter to search for the sysdiagrams to update in case it exists.
     */
    where: sysdiagramsWhereUniqueInput
    /**
     * In case the sysdiagrams found by the `where` argument doesn't exist, create a new sysdiagrams with this data.
     */
    create: XOR<sysdiagramsCreateInput, sysdiagramsUncheckedCreateInput>
    /**
     * In case the sysdiagrams was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sysdiagramsUpdateInput, sysdiagramsUncheckedUpdateInput>
  }

  /**
   * sysdiagrams delete
   */
  export type sysdiagramsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
    /**
     * Filter which sysdiagrams to delete.
     */
    where: sysdiagramsWhereUniqueInput
  }

  /**
   * sysdiagrams deleteMany
   */
  export type sysdiagramsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sysdiagrams to delete
     */
    where?: sysdiagramsWhereInput
    /**
     * Limit how many sysdiagrams to delete.
     */
    limit?: number
  }

  /**
   * sysdiagrams without action
   */
  export type sysdiagramsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sysdiagrams
     */
    select?: sysdiagramsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sysdiagrams
     */
    omit?: sysdiagramsOmit<ExtArgs> | null
  }


  /**
   * Model Tc
   */

  export type AggregateTc = {
    _count: TcCountAggregateOutputType | null
    _min: TcMinAggregateOutputType | null
    _max: TcMaxAggregateOutputType | null
  }

  export type TcMinAggregateOutputType = {
    idTc: string | null
    fechado: boolean | null
    createdAt: Date | null
  }

  export type TcMaxAggregateOutputType = {
    idTc: string | null
    fechado: boolean | null
    createdAt: Date | null
  }

  export type TcCountAggregateOutputType = {
    idTc: number
    fechado: number
    createdAt: number
    _all: number
  }


  export type TcMinAggregateInputType = {
    idTc?: true
    fechado?: true
    createdAt?: true
  }

  export type TcMaxAggregateInputType = {
    idTc?: true
    fechado?: true
    createdAt?: true
  }

  export type TcCountAggregateInputType = {
    idTc?: true
    fechado?: true
    createdAt?: true
    _all?: true
  }

  export type TcAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tc to aggregate.
     */
    where?: TcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tcs to fetch.
     */
    orderBy?: TcOrderByWithRelationInput | TcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tcs
    **/
    _count?: true | TcCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TcMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TcMaxAggregateInputType
  }

  export type GetTcAggregateType<T extends TcAggregateArgs> = {
        [P in keyof T & keyof AggregateTc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTc[P]>
      : GetScalarType<T[P], AggregateTc[P]>
  }




  export type TcGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcWhereInput
    orderBy?: TcOrderByWithAggregationInput | TcOrderByWithAggregationInput[]
    by: TcScalarFieldEnum[] | TcScalarFieldEnum
    having?: TcScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TcCountAggregateInputType | true
    _min?: TcMinAggregateInputType
    _max?: TcMaxAggregateInputType
  }

  export type TcGroupByOutputType = {
    idTc: string
    fechado: boolean
    createdAt: Date
    _count: TcCountAggregateOutputType | null
    _min: TcMinAggregateOutputType | null
    _max: TcMaxAggregateOutputType | null
  }

  type GetTcGroupByPayload<T extends TcGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TcGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TcGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TcGroupByOutputType[P]>
            : GetScalarType<T[P], TcGroupByOutputType[P]>
        }
      >
    >


  export type TcSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idTc?: boolean
    fechado?: boolean
    createdAt?: boolean
    TcOp?: boolean | Tc$TcOpArgs<ExtArgs>
    _count?: boolean | TcCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tc"]>



  export type TcSelectScalar = {
    idTc?: boolean
    fechado?: boolean
    createdAt?: boolean
  }

  export type TcOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idTc" | "fechado" | "createdAt", ExtArgs["result"]["tc"]>
  export type TcInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcOp?: boolean | Tc$TcOpArgs<ExtArgs>
    _count?: boolean | TcCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TcPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tc"
    objects: {
      TcOp: Prisma.$TcOpPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idTc: string
      fechado: boolean
      createdAt: Date
    }, ExtArgs["result"]["tc"]>
    composites: {}
  }

  type TcGetPayload<S extends boolean | null | undefined | TcDefaultArgs> = $Result.GetResult<Prisma.$TcPayload, S>

  type TcCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TcFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TcCountAggregateInputType | true
    }

  export interface TcDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tc'], meta: { name: 'Tc' } }
    /**
     * Find zero or one Tc that matches the filter.
     * @param {TcFindUniqueArgs} args - Arguments to find a Tc
     * @example
     * // Get one Tc
     * const tc = await prisma.tc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TcFindUniqueArgs>(args: SelectSubset<T, TcFindUniqueArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TcFindUniqueOrThrowArgs} args - Arguments to find a Tc
     * @example
     * // Get one Tc
     * const tc = await prisma.tc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TcFindUniqueOrThrowArgs>(args: SelectSubset<T, TcFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcFindFirstArgs} args - Arguments to find a Tc
     * @example
     * // Get one Tc
     * const tc = await prisma.tc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TcFindFirstArgs>(args?: SelectSubset<T, TcFindFirstArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcFindFirstOrThrowArgs} args - Arguments to find a Tc
     * @example
     * // Get one Tc
     * const tc = await prisma.tc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TcFindFirstOrThrowArgs>(args?: SelectSubset<T, TcFindFirstOrThrowArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tcs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tcs
     * const tcs = await prisma.tc.findMany()
     * 
     * // Get first 10 Tcs
     * const tcs = await prisma.tc.findMany({ take: 10 })
     * 
     * // Only select the `idTc`
     * const tcWithIdTcOnly = await prisma.tc.findMany({ select: { idTc: true } })
     * 
     */
    findMany<T extends TcFindManyArgs>(args?: SelectSubset<T, TcFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tc.
     * @param {TcCreateArgs} args - Arguments to create a Tc.
     * @example
     * // Create one Tc
     * const Tc = await prisma.tc.create({
     *   data: {
     *     // ... data to create a Tc
     *   }
     * })
     * 
     */
    create<T extends TcCreateArgs>(args: SelectSubset<T, TcCreateArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tcs.
     * @param {TcCreateManyArgs} args - Arguments to create many Tcs.
     * @example
     * // Create many Tcs
     * const tc = await prisma.tc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TcCreateManyArgs>(args?: SelectSubset<T, TcCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tc.
     * @param {TcDeleteArgs} args - Arguments to delete one Tc.
     * @example
     * // Delete one Tc
     * const Tc = await prisma.tc.delete({
     *   where: {
     *     // ... filter to delete one Tc
     *   }
     * })
     * 
     */
    delete<T extends TcDeleteArgs>(args: SelectSubset<T, TcDeleteArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tc.
     * @param {TcUpdateArgs} args - Arguments to update one Tc.
     * @example
     * // Update one Tc
     * const tc = await prisma.tc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TcUpdateArgs>(args: SelectSubset<T, TcUpdateArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tcs.
     * @param {TcDeleteManyArgs} args - Arguments to filter Tcs to delete.
     * @example
     * // Delete a few Tcs
     * const { count } = await prisma.tc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TcDeleteManyArgs>(args?: SelectSubset<T, TcDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tcs
     * const tc = await prisma.tc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TcUpdateManyArgs>(args: SelectSubset<T, TcUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tc.
     * @param {TcUpsertArgs} args - Arguments to update or create a Tc.
     * @example
     * // Update or create a Tc
     * const tc = await prisma.tc.upsert({
     *   create: {
     *     // ... data to create a Tc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tc we want to update
     *   }
     * })
     */
    upsert<T extends TcUpsertArgs>(args: SelectSubset<T, TcUpsertArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCountArgs} args - Arguments to filter Tcs to count.
     * @example
     * // Count the number of Tcs
     * const count = await prisma.tc.count({
     *   where: {
     *     // ... the filter for the Tcs we want to count
     *   }
     * })
    **/
    count<T extends TcCountArgs>(
      args?: Subset<T, TcCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TcCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TcAggregateArgs>(args: Subset<T, TcAggregateArgs>): Prisma.PrismaPromise<GetTcAggregateType<T>>

    /**
     * Group by Tc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TcGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TcGroupByArgs['orderBy'] }
        : { orderBy?: TcGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TcGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTcGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tc model
   */
  readonly fields: TcFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TcClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TcOp<T extends Tc$TcOpArgs<ExtArgs> = {}>(args?: Subset<T, Tc$TcOpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tc model
   */ 
  interface TcFieldRefs {
    readonly idTc: FieldRef<"Tc", 'String'>
    readonly fechado: FieldRef<"Tc", 'Boolean'>
    readonly createdAt: FieldRef<"Tc", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tc findUnique
   */
  export type TcFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * Filter, which Tc to fetch.
     */
    where: TcWhereUniqueInput
  }

  /**
   * Tc findUniqueOrThrow
   */
  export type TcFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * Filter, which Tc to fetch.
     */
    where: TcWhereUniqueInput
  }

  /**
   * Tc findFirst
   */
  export type TcFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * Filter, which Tc to fetch.
     */
    where?: TcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tcs to fetch.
     */
    orderBy?: TcOrderByWithRelationInput | TcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tcs.
     */
    cursor?: TcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tcs.
     */
    distinct?: TcScalarFieldEnum | TcScalarFieldEnum[]
  }

  /**
   * Tc findFirstOrThrow
   */
  export type TcFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * Filter, which Tc to fetch.
     */
    where?: TcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tcs to fetch.
     */
    orderBy?: TcOrderByWithRelationInput | TcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tcs.
     */
    cursor?: TcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tcs.
     */
    distinct?: TcScalarFieldEnum | TcScalarFieldEnum[]
  }

  /**
   * Tc findMany
   */
  export type TcFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * Filter, which Tcs to fetch.
     */
    where?: TcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tcs to fetch.
     */
    orderBy?: TcOrderByWithRelationInput | TcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tcs.
     */
    cursor?: TcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tcs.
     */
    skip?: number
    distinct?: TcScalarFieldEnum | TcScalarFieldEnum[]
  }

  /**
   * Tc create
   */
  export type TcCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * The data needed to create a Tc.
     */
    data?: XOR<TcCreateInput, TcUncheckedCreateInput>
  }

  /**
   * Tc createMany
   */
  export type TcCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tcs.
     */
    data: TcCreateManyInput | TcCreateManyInput[]
  }

  /**
   * Tc update
   */
  export type TcUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * The data needed to update a Tc.
     */
    data: XOR<TcUpdateInput, TcUncheckedUpdateInput>
    /**
     * Choose, which Tc to update.
     */
    where: TcWhereUniqueInput
  }

  /**
   * Tc updateMany
   */
  export type TcUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tcs.
     */
    data: XOR<TcUpdateManyMutationInput, TcUncheckedUpdateManyInput>
    /**
     * Filter which Tcs to update
     */
    where?: TcWhereInput
    /**
     * Limit how many Tcs to update.
     */
    limit?: number
  }

  /**
   * Tc upsert
   */
  export type TcUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * The filter to search for the Tc to update in case it exists.
     */
    where: TcWhereUniqueInput
    /**
     * In case the Tc found by the `where` argument doesn't exist, create a new Tc with this data.
     */
    create: XOR<TcCreateInput, TcUncheckedCreateInput>
    /**
     * In case the Tc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TcUpdateInput, TcUncheckedUpdateInput>
  }

  /**
   * Tc delete
   */
  export type TcDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
    /**
     * Filter which Tc to delete.
     */
    where: TcWhereUniqueInput
  }

  /**
   * Tc deleteMany
   */
  export type TcDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tcs to delete
     */
    where?: TcWhereInput
    /**
     * Limit how many Tcs to delete.
     */
    limit?: number
  }

  /**
   * Tc.TcOp
   */
  export type Tc$TcOpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    where?: TcOpWhereInput
    orderBy?: TcOpOrderByWithRelationInput | TcOpOrderByWithRelationInput[]
    cursor?: TcOpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcOpScalarFieldEnum | TcOpScalarFieldEnum[]
  }

  /**
   * Tc without action
   */
  export type TcDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tc
     */
    select?: TcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tc
     */
    omit?: TcOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcInclude<ExtArgs> | null
  }


  /**
   * Model TcCompraConteudo
   */

  export type AggregateTcCompraConteudo = {
    _count: TcCompraConteudoCountAggregateOutputType | null
    _avg: TcCompraConteudoAvgAggregateOutputType | null
    _sum: TcCompraConteudoSumAggregateOutputType | null
    _min: TcCompraConteudoMinAggregateOutputType | null
    _max: TcCompraConteudoMaxAggregateOutputType | null
  }

  export type TcCompraConteudoAvgAggregateOutputType = {
    qtt: Decimal | null
    largura: Decimal | null
    gramagem: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoSumAggregateOutputType = {
    qtt: Decimal | null
    largura: Decimal | null
    gramagem: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoMinAggregateOutputType = {
    idCompra: string | null
    idConteudoCompraPhc: string | null
    refTipo: string | null
    ref: string | null
    design: string | null
    qtt: Decimal | null
    cor: string | null
    tam: string | null
    unidade: string | null
    largura: Decimal | null
    gramagem: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoMaxAggregateOutputType = {
    idCompra: string | null
    idConteudoCompraPhc: string | null
    refTipo: string | null
    ref: string | null
    design: string | null
    qtt: Decimal | null
    cor: string | null
    tam: string | null
    unidade: string | null
    largura: Decimal | null
    gramagem: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoCountAggregateOutputType = {
    idCompra: number
    idConteudoCompraPhc: number
    refTipo: number
    ref: number
    design: number
    qtt: number
    cor: number
    tam: number
    unidade: number
    largura: number
    gramagem: number
    op: number
    _all: number
  }


  export type TcCompraConteudoAvgAggregateInputType = {
    qtt?: true
    largura?: true
    gramagem?: true
    op?: true
  }

  export type TcCompraConteudoSumAggregateInputType = {
    qtt?: true
    largura?: true
    gramagem?: true
    op?: true
  }

  export type TcCompraConteudoMinAggregateInputType = {
    idCompra?: true
    idConteudoCompraPhc?: true
    refTipo?: true
    ref?: true
    design?: true
    qtt?: true
    cor?: true
    tam?: true
    unidade?: true
    largura?: true
    gramagem?: true
    op?: true
  }

  export type TcCompraConteudoMaxAggregateInputType = {
    idCompra?: true
    idConteudoCompraPhc?: true
    refTipo?: true
    ref?: true
    design?: true
    qtt?: true
    cor?: true
    tam?: true
    unidade?: true
    largura?: true
    gramagem?: true
    op?: true
  }

  export type TcCompraConteudoCountAggregateInputType = {
    idCompra?: true
    idConteudoCompraPhc?: true
    refTipo?: true
    ref?: true
    design?: true
    qtt?: true
    cor?: true
    tam?: true
    unidade?: true
    largura?: true
    gramagem?: true
    op?: true
    _all?: true
  }

  export type TcCompraConteudoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcCompraConteudo to aggregate.
     */
    where?: TcCompraConteudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudos to fetch.
     */
    orderBy?: TcCompraConteudoOrderByWithRelationInput | TcCompraConteudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TcCompraConteudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TcCompraConteudos
    **/
    _count?: true | TcCompraConteudoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TcCompraConteudoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TcCompraConteudoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TcCompraConteudoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TcCompraConteudoMaxAggregateInputType
  }

  export type GetTcCompraConteudoAggregateType<T extends TcCompraConteudoAggregateArgs> = {
        [P in keyof T & keyof AggregateTcCompraConteudo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTcCompraConteudo[P]>
      : GetScalarType<T[P], AggregateTcCompraConteudo[P]>
  }




  export type TcCompraConteudoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoWhereInput
    orderBy?: TcCompraConteudoOrderByWithAggregationInput | TcCompraConteudoOrderByWithAggregationInput[]
    by: TcCompraConteudoScalarFieldEnum[] | TcCompraConteudoScalarFieldEnum
    having?: TcCompraConteudoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TcCompraConteudoCountAggregateInputType | true
    _avg?: TcCompraConteudoAvgAggregateInputType
    _sum?: TcCompraConteudoSumAggregateInputType
    _min?: TcCompraConteudoMinAggregateInputType
    _max?: TcCompraConteudoMaxAggregateInputType
  }

  export type TcCompraConteudoGroupByOutputType = {
    idCompra: string
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal
    cor: string
    tam: string
    unidade: string
    largura: Decimal
    gramagem: Decimal
    op: number
    _count: TcCompraConteudoCountAggregateOutputType | null
    _avg: TcCompraConteudoAvgAggregateOutputType | null
    _sum: TcCompraConteudoSumAggregateOutputType | null
    _min: TcCompraConteudoMinAggregateOutputType | null
    _max: TcCompraConteudoMaxAggregateOutputType | null
  }

  type GetTcCompraConteudoGroupByPayload<T extends TcCompraConteudoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TcCompraConteudoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TcCompraConteudoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TcCompraConteudoGroupByOutputType[P]>
            : GetScalarType<T[P], TcCompraConteudoGroupByOutputType[P]>
        }
      >
    >


  export type TcCompraConteudoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCompra?: boolean
    idConteudoCompraPhc?: boolean
    refTipo?: boolean
    ref?: boolean
    design?: boolean
    qtt?: boolean
    cor?: boolean
    tam?: boolean
    unidade?: boolean
    largura?: boolean
    gramagem?: boolean
    op?: boolean
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
    TcOpCompra?: boolean | TcOpCompraDefaultArgs<ExtArgs>
    TcCompraConteudoEntrada?: boolean | TcCompraConteudo$TcCompraConteudoEntradaArgs<ExtArgs>
    _count?: boolean | TcCompraConteudoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tcCompraConteudo"]>



  export type TcCompraConteudoSelectScalar = {
    idCompra?: boolean
    idConteudoCompraPhc?: boolean
    refTipo?: boolean
    ref?: boolean
    design?: boolean
    qtt?: boolean
    cor?: boolean
    tam?: boolean
    unidade?: boolean
    largura?: boolean
    gramagem?: boolean
    op?: boolean
  }

  export type TcCompraConteudoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idCompra" | "idConteudoCompraPhc" | "refTipo" | "ref" | "design" | "qtt" | "cor" | "tam" | "unidade" | "largura" | "gramagem" | "op", ExtArgs["result"]["tcCompraConteudo"]>
  export type TcCompraConteudoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
    TcOpCompra?: boolean | TcOpCompraDefaultArgs<ExtArgs>
    TcCompraConteudoEntrada?: boolean | TcCompraConteudo$TcCompraConteudoEntradaArgs<ExtArgs>
    _count?: boolean | TcCompraConteudoCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TcCompraConteudoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TcCompraConteudo"
    objects: {
      TcOp: Prisma.$TcOpPayload<ExtArgs>
      TcOpCompra: Prisma.$TcOpCompraPayload<ExtArgs>
      TcCompraConteudoEntrada: Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idCompra: string
      idConteudoCompraPhc: string
      refTipo: string
      ref: string
      design: string
      qtt: Prisma.Decimal
      cor: string
      tam: string
      unidade: string
      largura: Prisma.Decimal
      gramagem: Prisma.Decimal
      op: number
    }, ExtArgs["result"]["tcCompraConteudo"]>
    composites: {}
  }

  type TcCompraConteudoGetPayload<S extends boolean | null | undefined | TcCompraConteudoDefaultArgs> = $Result.GetResult<Prisma.$TcCompraConteudoPayload, S>

  type TcCompraConteudoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TcCompraConteudoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TcCompraConteudoCountAggregateInputType | true
    }

  export interface TcCompraConteudoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TcCompraConteudo'], meta: { name: 'TcCompraConteudo' } }
    /**
     * Find zero or one TcCompraConteudo that matches the filter.
     * @param {TcCompraConteudoFindUniqueArgs} args - Arguments to find a TcCompraConteudo
     * @example
     * // Get one TcCompraConteudo
     * const tcCompraConteudo = await prisma.tcCompraConteudo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TcCompraConteudoFindUniqueArgs>(args: SelectSubset<T, TcCompraConteudoFindUniqueArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TcCompraConteudo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TcCompraConteudoFindUniqueOrThrowArgs} args - Arguments to find a TcCompraConteudo
     * @example
     * // Get one TcCompraConteudo
     * const tcCompraConteudo = await prisma.tcCompraConteudo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TcCompraConteudoFindUniqueOrThrowArgs>(args: SelectSubset<T, TcCompraConteudoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TcCompraConteudo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoFindFirstArgs} args - Arguments to find a TcCompraConteudo
     * @example
     * // Get one TcCompraConteudo
     * const tcCompraConteudo = await prisma.tcCompraConteudo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TcCompraConteudoFindFirstArgs>(args?: SelectSubset<T, TcCompraConteudoFindFirstArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TcCompraConteudo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoFindFirstOrThrowArgs} args - Arguments to find a TcCompraConteudo
     * @example
     * // Get one TcCompraConteudo
     * const tcCompraConteudo = await prisma.tcCompraConteudo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TcCompraConteudoFindFirstOrThrowArgs>(args?: SelectSubset<T, TcCompraConteudoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TcCompraConteudos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TcCompraConteudos
     * const tcCompraConteudos = await prisma.tcCompraConteudo.findMany()
     * 
     * // Get first 10 TcCompraConteudos
     * const tcCompraConteudos = await prisma.tcCompraConteudo.findMany({ take: 10 })
     * 
     * // Only select the `idCompra`
     * const tcCompraConteudoWithIdCompraOnly = await prisma.tcCompraConteudo.findMany({ select: { idCompra: true } })
     * 
     */
    findMany<T extends TcCompraConteudoFindManyArgs>(args?: SelectSubset<T, TcCompraConteudoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TcCompraConteudo.
     * @param {TcCompraConteudoCreateArgs} args - Arguments to create a TcCompraConteudo.
     * @example
     * // Create one TcCompraConteudo
     * const TcCompraConteudo = await prisma.tcCompraConteudo.create({
     *   data: {
     *     // ... data to create a TcCompraConteudo
     *   }
     * })
     * 
     */
    create<T extends TcCompraConteudoCreateArgs>(args: SelectSubset<T, TcCompraConteudoCreateArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TcCompraConteudos.
     * @param {TcCompraConteudoCreateManyArgs} args - Arguments to create many TcCompraConteudos.
     * @example
     * // Create many TcCompraConteudos
     * const tcCompraConteudo = await prisma.tcCompraConteudo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TcCompraConteudoCreateManyArgs>(args?: SelectSubset<T, TcCompraConteudoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TcCompraConteudo.
     * @param {TcCompraConteudoDeleteArgs} args - Arguments to delete one TcCompraConteudo.
     * @example
     * // Delete one TcCompraConteudo
     * const TcCompraConteudo = await prisma.tcCompraConteudo.delete({
     *   where: {
     *     // ... filter to delete one TcCompraConteudo
     *   }
     * })
     * 
     */
    delete<T extends TcCompraConteudoDeleteArgs>(args: SelectSubset<T, TcCompraConteudoDeleteArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TcCompraConteudo.
     * @param {TcCompraConteudoUpdateArgs} args - Arguments to update one TcCompraConteudo.
     * @example
     * // Update one TcCompraConteudo
     * const tcCompraConteudo = await prisma.tcCompraConteudo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TcCompraConteudoUpdateArgs>(args: SelectSubset<T, TcCompraConteudoUpdateArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TcCompraConteudos.
     * @param {TcCompraConteudoDeleteManyArgs} args - Arguments to filter TcCompraConteudos to delete.
     * @example
     * // Delete a few TcCompraConteudos
     * const { count } = await prisma.tcCompraConteudo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TcCompraConteudoDeleteManyArgs>(args?: SelectSubset<T, TcCompraConteudoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TcCompraConteudos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TcCompraConteudos
     * const tcCompraConteudo = await prisma.tcCompraConteudo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TcCompraConteudoUpdateManyArgs>(args: SelectSubset<T, TcCompraConteudoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TcCompraConteudo.
     * @param {TcCompraConteudoUpsertArgs} args - Arguments to update or create a TcCompraConteudo.
     * @example
     * // Update or create a TcCompraConteudo
     * const tcCompraConteudo = await prisma.tcCompraConteudo.upsert({
     *   create: {
     *     // ... data to create a TcCompraConteudo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TcCompraConteudo we want to update
     *   }
     * })
     */
    upsert<T extends TcCompraConteudoUpsertArgs>(args: SelectSubset<T, TcCompraConteudoUpsertArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TcCompraConteudos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoCountArgs} args - Arguments to filter TcCompraConteudos to count.
     * @example
     * // Count the number of TcCompraConteudos
     * const count = await prisma.tcCompraConteudo.count({
     *   where: {
     *     // ... the filter for the TcCompraConteudos we want to count
     *   }
     * })
    **/
    count<T extends TcCompraConteudoCountArgs>(
      args?: Subset<T, TcCompraConteudoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TcCompraConteudoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TcCompraConteudo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TcCompraConteudoAggregateArgs>(args: Subset<T, TcCompraConteudoAggregateArgs>): Prisma.PrismaPromise<GetTcCompraConteudoAggregateType<T>>

    /**
     * Group by TcCompraConteudo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TcCompraConteudoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TcCompraConteudoGroupByArgs['orderBy'] }
        : { orderBy?: TcCompraConteudoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TcCompraConteudoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTcCompraConteudoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TcCompraConteudo model
   */
  readonly fields: TcCompraConteudoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TcCompraConteudo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TcCompraConteudoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TcOp<T extends TcOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcOpDefaultArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TcOpCompra<T extends TcOpCompraDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcOpCompraDefaultArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TcCompraConteudoEntrada<T extends TcCompraConteudo$TcCompraConteudoEntradaArgs<ExtArgs> = {}>(args?: Subset<T, TcCompraConteudo$TcCompraConteudoEntradaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TcCompraConteudo model
   */ 
  interface TcCompraConteudoFieldRefs {
    readonly idCompra: FieldRef<"TcCompraConteudo", 'String'>
    readonly idConteudoCompraPhc: FieldRef<"TcCompraConteudo", 'String'>
    readonly refTipo: FieldRef<"TcCompraConteudo", 'String'>
    readonly ref: FieldRef<"TcCompraConteudo", 'String'>
    readonly design: FieldRef<"TcCompraConteudo", 'String'>
    readonly qtt: FieldRef<"TcCompraConteudo", 'Decimal'>
    readonly cor: FieldRef<"TcCompraConteudo", 'String'>
    readonly tam: FieldRef<"TcCompraConteudo", 'String'>
    readonly unidade: FieldRef<"TcCompraConteudo", 'String'>
    readonly largura: FieldRef<"TcCompraConteudo", 'Decimal'>
    readonly gramagem: FieldRef<"TcCompraConteudo", 'Decimal'>
    readonly op: FieldRef<"TcCompraConteudo", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TcCompraConteudo findUnique
   */
  export type TcCompraConteudoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudo to fetch.
     */
    where: TcCompraConteudoWhereUniqueInput
  }

  /**
   * TcCompraConteudo findUniqueOrThrow
   */
  export type TcCompraConteudoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudo to fetch.
     */
    where: TcCompraConteudoWhereUniqueInput
  }

  /**
   * TcCompraConteudo findFirst
   */
  export type TcCompraConteudoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudo to fetch.
     */
    where?: TcCompraConteudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudos to fetch.
     */
    orderBy?: TcCompraConteudoOrderByWithRelationInput | TcCompraConteudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcCompraConteudos.
     */
    cursor?: TcCompraConteudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcCompraConteudos.
     */
    distinct?: TcCompraConteudoScalarFieldEnum | TcCompraConteudoScalarFieldEnum[]
  }

  /**
   * TcCompraConteudo findFirstOrThrow
   */
  export type TcCompraConteudoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudo to fetch.
     */
    where?: TcCompraConteudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudos to fetch.
     */
    orderBy?: TcCompraConteudoOrderByWithRelationInput | TcCompraConteudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcCompraConteudos.
     */
    cursor?: TcCompraConteudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcCompraConteudos.
     */
    distinct?: TcCompraConteudoScalarFieldEnum | TcCompraConteudoScalarFieldEnum[]
  }

  /**
   * TcCompraConteudo findMany
   */
  export type TcCompraConteudoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudos to fetch.
     */
    where?: TcCompraConteudoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudos to fetch.
     */
    orderBy?: TcCompraConteudoOrderByWithRelationInput | TcCompraConteudoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TcCompraConteudos.
     */
    cursor?: TcCompraConteudoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudos.
     */
    skip?: number
    distinct?: TcCompraConteudoScalarFieldEnum | TcCompraConteudoScalarFieldEnum[]
  }

  /**
   * TcCompraConteudo create
   */
  export type TcCompraConteudoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * The data needed to create a TcCompraConteudo.
     */
    data: XOR<TcCompraConteudoCreateInput, TcCompraConteudoUncheckedCreateInput>
  }

  /**
   * TcCompraConteudo createMany
   */
  export type TcCompraConteudoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TcCompraConteudos.
     */
    data: TcCompraConteudoCreateManyInput | TcCompraConteudoCreateManyInput[]
  }

  /**
   * TcCompraConteudo update
   */
  export type TcCompraConteudoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * The data needed to update a TcCompraConteudo.
     */
    data: XOR<TcCompraConteudoUpdateInput, TcCompraConteudoUncheckedUpdateInput>
    /**
     * Choose, which TcCompraConteudo to update.
     */
    where: TcCompraConteudoWhereUniqueInput
  }

  /**
   * TcCompraConteudo updateMany
   */
  export type TcCompraConteudoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TcCompraConteudos.
     */
    data: XOR<TcCompraConteudoUpdateManyMutationInput, TcCompraConteudoUncheckedUpdateManyInput>
    /**
     * Filter which TcCompraConteudos to update
     */
    where?: TcCompraConteudoWhereInput
    /**
     * Limit how many TcCompraConteudos to update.
     */
    limit?: number
  }

  /**
   * TcCompraConteudo upsert
   */
  export type TcCompraConteudoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * The filter to search for the TcCompraConteudo to update in case it exists.
     */
    where: TcCompraConteudoWhereUniqueInput
    /**
     * In case the TcCompraConteudo found by the `where` argument doesn't exist, create a new TcCompraConteudo with this data.
     */
    create: XOR<TcCompraConteudoCreateInput, TcCompraConteudoUncheckedCreateInput>
    /**
     * In case the TcCompraConteudo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TcCompraConteudoUpdateInput, TcCompraConteudoUncheckedUpdateInput>
  }

  /**
   * TcCompraConteudo delete
   */
  export type TcCompraConteudoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    /**
     * Filter which TcCompraConteudo to delete.
     */
    where: TcCompraConteudoWhereUniqueInput
  }

  /**
   * TcCompraConteudo deleteMany
   */
  export type TcCompraConteudoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcCompraConteudos to delete
     */
    where?: TcCompraConteudoWhereInput
    /**
     * Limit how many TcCompraConteudos to delete.
     */
    limit?: number
  }

  /**
   * TcCompraConteudo.TcCompraConteudoEntrada
   */
  export type TcCompraConteudo$TcCompraConteudoEntradaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    where?: TcCompraConteudoEntradaWhereInput
    orderBy?: TcCompraConteudoEntradaOrderByWithRelationInput | TcCompraConteudoEntradaOrderByWithRelationInput[]
    cursor?: TcCompraConteudoEntradaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcCompraConteudoEntradaScalarFieldEnum | TcCompraConteudoEntradaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudo without action
   */
  export type TcCompraConteudoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
  }


  /**
   * Model TcCompraConteudoEntrada
   */

  export type AggregateTcCompraConteudoEntrada = {
    _count: TcCompraConteudoEntradaCountAggregateOutputType | null
    _avg: TcCompraConteudoEntradaAvgAggregateOutputType | null
    _sum: TcCompraConteudoEntradaSumAggregateOutputType | null
    _min: TcCompraConteudoEntradaMinAggregateOutputType | null
    _max: TcCompraConteudoEntradaMaxAggregateOutputType | null
  }

  export type TcCompraConteudoEntradaAvgAggregateOutputType = {
    nEntrada: number | null
    qtt: Decimal | null
    largura: Decimal | null
    gramagem: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoEntradaSumAggregateOutputType = {
    nEntrada: number | null
    qtt: Decimal | null
    largura: Decimal | null
    gramagem: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoEntradaMinAggregateOutputType = {
    idConteudoEntradaPhc: string | null
    idConteudoCompraPhc: string | null
    nEntrada: number | null
    Nguia: string | null
    dataEntrada: Date | null
    dataEntradaString: string | null
    qtt: Decimal | null
    cor: string | null
    tam: string | null
    unidade: string | null
    largura: Decimal | null
    gramagem: Decimal | null
    lote: string | null
    op: number | null
  }

  export type TcCompraConteudoEntradaMaxAggregateOutputType = {
    idConteudoEntradaPhc: string | null
    idConteudoCompraPhc: string | null
    nEntrada: number | null
    Nguia: string | null
    dataEntrada: Date | null
    dataEntradaString: string | null
    qtt: Decimal | null
    cor: string | null
    tam: string | null
    unidade: string | null
    largura: Decimal | null
    gramagem: Decimal | null
    lote: string | null
    op: number | null
  }

  export type TcCompraConteudoEntradaCountAggregateOutputType = {
    idConteudoEntradaPhc: number
    idConteudoCompraPhc: number
    nEntrada: number
    Nguia: number
    dataEntrada: number
    dataEntradaString: number
    qtt: number
    cor: number
    tam: number
    unidade: number
    largura: number
    gramagem: number
    lote: number
    op: number
    _all: number
  }


  export type TcCompraConteudoEntradaAvgAggregateInputType = {
    nEntrada?: true
    qtt?: true
    largura?: true
    gramagem?: true
    op?: true
  }

  export type TcCompraConteudoEntradaSumAggregateInputType = {
    nEntrada?: true
    qtt?: true
    largura?: true
    gramagem?: true
    op?: true
  }

  export type TcCompraConteudoEntradaMinAggregateInputType = {
    idConteudoEntradaPhc?: true
    idConteudoCompraPhc?: true
    nEntrada?: true
    Nguia?: true
    dataEntrada?: true
    dataEntradaString?: true
    qtt?: true
    cor?: true
    tam?: true
    unidade?: true
    largura?: true
    gramagem?: true
    lote?: true
    op?: true
  }

  export type TcCompraConteudoEntradaMaxAggregateInputType = {
    idConteudoEntradaPhc?: true
    idConteudoCompraPhc?: true
    nEntrada?: true
    Nguia?: true
    dataEntrada?: true
    dataEntradaString?: true
    qtt?: true
    cor?: true
    tam?: true
    unidade?: true
    largura?: true
    gramagem?: true
    lote?: true
    op?: true
  }

  export type TcCompraConteudoEntradaCountAggregateInputType = {
    idConteudoEntradaPhc?: true
    idConteudoCompraPhc?: true
    nEntrada?: true
    Nguia?: true
    dataEntrada?: true
    dataEntradaString?: true
    qtt?: true
    cor?: true
    tam?: true
    unidade?: true
    largura?: true
    gramagem?: true
    lote?: true
    op?: true
    _all?: true
  }

  export type TcCompraConteudoEntradaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcCompraConteudoEntrada to aggregate.
     */
    where?: TcCompraConteudoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaOrderByWithRelationInput | TcCompraConteudoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TcCompraConteudoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TcCompraConteudoEntradas
    **/
    _count?: true | TcCompraConteudoEntradaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TcCompraConteudoEntradaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TcCompraConteudoEntradaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TcCompraConteudoEntradaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TcCompraConteudoEntradaMaxAggregateInputType
  }

  export type GetTcCompraConteudoEntradaAggregateType<T extends TcCompraConteudoEntradaAggregateArgs> = {
        [P in keyof T & keyof AggregateTcCompraConteudoEntrada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTcCompraConteudoEntrada[P]>
      : GetScalarType<T[P], AggregateTcCompraConteudoEntrada[P]>
  }




  export type TcCompraConteudoEntradaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoEntradaWhereInput
    orderBy?: TcCompraConteudoEntradaOrderByWithAggregationInput | TcCompraConteudoEntradaOrderByWithAggregationInput[]
    by: TcCompraConteudoEntradaScalarFieldEnum[] | TcCompraConteudoEntradaScalarFieldEnum
    having?: TcCompraConteudoEntradaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TcCompraConteudoEntradaCountAggregateInputType | true
    _avg?: TcCompraConteudoEntradaAvgAggregateInputType
    _sum?: TcCompraConteudoEntradaSumAggregateInputType
    _min?: TcCompraConteudoEntradaMinAggregateInputType
    _max?: TcCompraConteudoEntradaMaxAggregateInputType
  }

  export type TcCompraConteudoEntradaGroupByOutputType = {
    idConteudoEntradaPhc: string
    idConteudoCompraPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date
    dataEntradaString: string
    qtt: Decimal
    cor: string
    tam: string
    unidade: string
    largura: Decimal
    gramagem: Decimal
    lote: string
    op: number
    _count: TcCompraConteudoEntradaCountAggregateOutputType | null
    _avg: TcCompraConteudoEntradaAvgAggregateOutputType | null
    _sum: TcCompraConteudoEntradaSumAggregateOutputType | null
    _min: TcCompraConteudoEntradaMinAggregateOutputType | null
    _max: TcCompraConteudoEntradaMaxAggregateOutputType | null
  }

  type GetTcCompraConteudoEntradaGroupByPayload<T extends TcCompraConteudoEntradaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TcCompraConteudoEntradaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TcCompraConteudoEntradaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TcCompraConteudoEntradaGroupByOutputType[P]>
            : GetScalarType<T[P], TcCompraConteudoEntradaGroupByOutputType[P]>
        }
      >
    >


  export type TcCompraConteudoEntradaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idConteudoEntradaPhc?: boolean
    idConteudoCompraPhc?: boolean
    nEntrada?: boolean
    Nguia?: boolean
    dataEntrada?: boolean
    dataEntradaString?: boolean
    qtt?: boolean
    cor?: boolean
    tam?: boolean
    unidade?: boolean
    largura?: boolean
    gramagem?: boolean
    lote?: boolean
    op?: boolean
    TcCompraConteudo?: boolean | TcCompraConteudoDefaultArgs<ExtArgs>
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
    TcCompraConteudoEntradaFaturada?: boolean | TcCompraConteudoEntrada$TcCompraConteudoEntradaFaturadaArgs<ExtArgs>
    _count?: boolean | TcCompraConteudoEntradaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tcCompraConteudoEntrada"]>



  export type TcCompraConteudoEntradaSelectScalar = {
    idConteudoEntradaPhc?: boolean
    idConteudoCompraPhc?: boolean
    nEntrada?: boolean
    Nguia?: boolean
    dataEntrada?: boolean
    dataEntradaString?: boolean
    qtt?: boolean
    cor?: boolean
    tam?: boolean
    unidade?: boolean
    largura?: boolean
    gramagem?: boolean
    lote?: boolean
    op?: boolean
  }

  export type TcCompraConteudoEntradaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idConteudoEntradaPhc" | "idConteudoCompraPhc" | "nEntrada" | "Nguia" | "dataEntrada" | "dataEntradaString" | "qtt" | "cor" | "tam" | "unidade" | "largura" | "gramagem" | "lote" | "op", ExtArgs["result"]["tcCompraConteudoEntrada"]>
  export type TcCompraConteudoEntradaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudo?: boolean | TcCompraConteudoDefaultArgs<ExtArgs>
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
    TcCompraConteudoEntradaFaturada?: boolean | TcCompraConteudoEntrada$TcCompraConteudoEntradaFaturadaArgs<ExtArgs>
    _count?: boolean | TcCompraConteudoEntradaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TcCompraConteudoEntradaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TcCompraConteudoEntrada"
    objects: {
      TcCompraConteudo: Prisma.$TcCompraConteudoPayload<ExtArgs>
      TcOp: Prisma.$TcOpPayload<ExtArgs>
      TcCompraConteudoEntradaFaturada: Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idConteudoEntradaPhc: string
      idConteudoCompraPhc: string
      nEntrada: number
      Nguia: string
      dataEntrada: Date
      dataEntradaString: string
      qtt: Prisma.Decimal
      cor: string
      tam: string
      unidade: string
      largura: Prisma.Decimal
      gramagem: Prisma.Decimal
      lote: string
      op: number
    }, ExtArgs["result"]["tcCompraConteudoEntrada"]>
    composites: {}
  }

  type TcCompraConteudoEntradaGetPayload<S extends boolean | null | undefined | TcCompraConteudoEntradaDefaultArgs> = $Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload, S>

  type TcCompraConteudoEntradaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TcCompraConteudoEntradaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TcCompraConteudoEntradaCountAggregateInputType | true
    }

  export interface TcCompraConteudoEntradaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TcCompraConteudoEntrada'], meta: { name: 'TcCompraConteudoEntrada' } }
    /**
     * Find zero or one TcCompraConteudoEntrada that matches the filter.
     * @param {TcCompraConteudoEntradaFindUniqueArgs} args - Arguments to find a TcCompraConteudoEntrada
     * @example
     * // Get one TcCompraConteudoEntrada
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TcCompraConteudoEntradaFindUniqueArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFindUniqueArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TcCompraConteudoEntrada that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TcCompraConteudoEntradaFindUniqueOrThrowArgs} args - Arguments to find a TcCompraConteudoEntrada
     * @example
     * // Get one TcCompraConteudoEntrada
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TcCompraConteudoEntradaFindUniqueOrThrowArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TcCompraConteudoEntrada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFindFirstArgs} args - Arguments to find a TcCompraConteudoEntrada
     * @example
     * // Get one TcCompraConteudoEntrada
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TcCompraConteudoEntradaFindFirstArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFindFirstArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TcCompraConteudoEntrada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFindFirstOrThrowArgs} args - Arguments to find a TcCompraConteudoEntrada
     * @example
     * // Get one TcCompraConteudoEntrada
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TcCompraConteudoEntradaFindFirstOrThrowArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TcCompraConteudoEntradas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TcCompraConteudoEntradas
     * const tcCompraConteudoEntradas = await prisma.tcCompraConteudoEntrada.findMany()
     * 
     * // Get first 10 TcCompraConteudoEntradas
     * const tcCompraConteudoEntradas = await prisma.tcCompraConteudoEntrada.findMany({ take: 10 })
     * 
     * // Only select the `idConteudoEntradaPhc`
     * const tcCompraConteudoEntradaWithIdConteudoEntradaPhcOnly = await prisma.tcCompraConteudoEntrada.findMany({ select: { idConteudoEntradaPhc: true } })
     * 
     */
    findMany<T extends TcCompraConteudoEntradaFindManyArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TcCompraConteudoEntrada.
     * @param {TcCompraConteudoEntradaCreateArgs} args - Arguments to create a TcCompraConteudoEntrada.
     * @example
     * // Create one TcCompraConteudoEntrada
     * const TcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.create({
     *   data: {
     *     // ... data to create a TcCompraConteudoEntrada
     *   }
     * })
     * 
     */
    create<T extends TcCompraConteudoEntradaCreateArgs>(args: SelectSubset<T, TcCompraConteudoEntradaCreateArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TcCompraConteudoEntradas.
     * @param {TcCompraConteudoEntradaCreateManyArgs} args - Arguments to create many TcCompraConteudoEntradas.
     * @example
     * // Create many TcCompraConteudoEntradas
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TcCompraConteudoEntradaCreateManyArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TcCompraConteudoEntrada.
     * @param {TcCompraConteudoEntradaDeleteArgs} args - Arguments to delete one TcCompraConteudoEntrada.
     * @example
     * // Delete one TcCompraConteudoEntrada
     * const TcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.delete({
     *   where: {
     *     // ... filter to delete one TcCompraConteudoEntrada
     *   }
     * })
     * 
     */
    delete<T extends TcCompraConteudoEntradaDeleteArgs>(args: SelectSubset<T, TcCompraConteudoEntradaDeleteArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TcCompraConteudoEntrada.
     * @param {TcCompraConteudoEntradaUpdateArgs} args - Arguments to update one TcCompraConteudoEntrada.
     * @example
     * // Update one TcCompraConteudoEntrada
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TcCompraConteudoEntradaUpdateArgs>(args: SelectSubset<T, TcCompraConteudoEntradaUpdateArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TcCompraConteudoEntradas.
     * @param {TcCompraConteudoEntradaDeleteManyArgs} args - Arguments to filter TcCompraConteudoEntradas to delete.
     * @example
     * // Delete a few TcCompraConteudoEntradas
     * const { count } = await prisma.tcCompraConteudoEntrada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TcCompraConteudoEntradaDeleteManyArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TcCompraConteudoEntradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TcCompraConteudoEntradas
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TcCompraConteudoEntradaUpdateManyArgs>(args: SelectSubset<T, TcCompraConteudoEntradaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TcCompraConteudoEntrada.
     * @param {TcCompraConteudoEntradaUpsertArgs} args - Arguments to update or create a TcCompraConteudoEntrada.
     * @example
     * // Update or create a TcCompraConteudoEntrada
     * const tcCompraConteudoEntrada = await prisma.tcCompraConteudoEntrada.upsert({
     *   create: {
     *     // ... data to create a TcCompraConteudoEntrada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TcCompraConteudoEntrada we want to update
     *   }
     * })
     */
    upsert<T extends TcCompraConteudoEntradaUpsertArgs>(args: SelectSubset<T, TcCompraConteudoEntradaUpsertArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TcCompraConteudoEntradas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaCountArgs} args - Arguments to filter TcCompraConteudoEntradas to count.
     * @example
     * // Count the number of TcCompraConteudoEntradas
     * const count = await prisma.tcCompraConteudoEntrada.count({
     *   where: {
     *     // ... the filter for the TcCompraConteudoEntradas we want to count
     *   }
     * })
    **/
    count<T extends TcCompraConteudoEntradaCountArgs>(
      args?: Subset<T, TcCompraConteudoEntradaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TcCompraConteudoEntradaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TcCompraConteudoEntrada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TcCompraConteudoEntradaAggregateArgs>(args: Subset<T, TcCompraConteudoEntradaAggregateArgs>): Prisma.PrismaPromise<GetTcCompraConteudoEntradaAggregateType<T>>

    /**
     * Group by TcCompraConteudoEntrada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TcCompraConteudoEntradaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TcCompraConteudoEntradaGroupByArgs['orderBy'] }
        : { orderBy?: TcCompraConteudoEntradaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TcCompraConteudoEntradaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTcCompraConteudoEntradaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TcCompraConteudoEntrada model
   */
  readonly fields: TcCompraConteudoEntradaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TcCompraConteudoEntrada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TcCompraConteudoEntradaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TcCompraConteudo<T extends TcCompraConteudoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcCompraConteudoDefaultArgs<ExtArgs>>): Prisma__TcCompraConteudoClient<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TcOp<T extends TcOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcOpDefaultArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TcCompraConteudoEntradaFaturada<T extends TcCompraConteudoEntrada$TcCompraConteudoEntradaFaturadaArgs<ExtArgs> = {}>(args?: Subset<T, TcCompraConteudoEntrada$TcCompraConteudoEntradaFaturadaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TcCompraConteudoEntrada model
   */ 
  interface TcCompraConteudoEntradaFieldRefs {
    readonly idConteudoEntradaPhc: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly idConteudoCompraPhc: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly nEntrada: FieldRef<"TcCompraConteudoEntrada", 'Int'>
    readonly Nguia: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly dataEntrada: FieldRef<"TcCompraConteudoEntrada", 'DateTime'>
    readonly dataEntradaString: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly qtt: FieldRef<"TcCompraConteudoEntrada", 'Decimal'>
    readonly cor: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly tam: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly unidade: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly largura: FieldRef<"TcCompraConteudoEntrada", 'Decimal'>
    readonly gramagem: FieldRef<"TcCompraConteudoEntrada", 'Decimal'>
    readonly lote: FieldRef<"TcCompraConteudoEntrada", 'String'>
    readonly op: FieldRef<"TcCompraConteudoEntrada", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TcCompraConteudoEntrada findUnique
   */
  export type TcCompraConteudoEntradaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntrada to fetch.
     */
    where: TcCompraConteudoEntradaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntrada findUniqueOrThrow
   */
  export type TcCompraConteudoEntradaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntrada to fetch.
     */
    where: TcCompraConteudoEntradaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntrada findFirst
   */
  export type TcCompraConteudoEntradaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntrada to fetch.
     */
    where?: TcCompraConteudoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaOrderByWithRelationInput | TcCompraConteudoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcCompraConteudoEntradas.
     */
    cursor?: TcCompraConteudoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcCompraConteudoEntradas.
     */
    distinct?: TcCompraConteudoEntradaScalarFieldEnum | TcCompraConteudoEntradaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudoEntrada findFirstOrThrow
   */
  export type TcCompraConteudoEntradaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntrada to fetch.
     */
    where?: TcCompraConteudoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaOrderByWithRelationInput | TcCompraConteudoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcCompraConteudoEntradas.
     */
    cursor?: TcCompraConteudoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcCompraConteudoEntradas.
     */
    distinct?: TcCompraConteudoEntradaScalarFieldEnum | TcCompraConteudoEntradaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudoEntrada findMany
   */
  export type TcCompraConteudoEntradaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntradas to fetch.
     */
    where?: TcCompraConteudoEntradaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaOrderByWithRelationInput | TcCompraConteudoEntradaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TcCompraConteudoEntradas.
     */
    cursor?: TcCompraConteudoEntradaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradas.
     */
    skip?: number
    distinct?: TcCompraConteudoEntradaScalarFieldEnum | TcCompraConteudoEntradaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudoEntrada create
   */
  export type TcCompraConteudoEntradaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * The data needed to create a TcCompraConteudoEntrada.
     */
    data: XOR<TcCompraConteudoEntradaCreateInput, TcCompraConteudoEntradaUncheckedCreateInput>
  }

  /**
   * TcCompraConteudoEntrada createMany
   */
  export type TcCompraConteudoEntradaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TcCompraConteudoEntradas.
     */
    data: TcCompraConteudoEntradaCreateManyInput | TcCompraConteudoEntradaCreateManyInput[]
  }

  /**
   * TcCompraConteudoEntrada update
   */
  export type TcCompraConteudoEntradaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * The data needed to update a TcCompraConteudoEntrada.
     */
    data: XOR<TcCompraConteudoEntradaUpdateInput, TcCompraConteudoEntradaUncheckedUpdateInput>
    /**
     * Choose, which TcCompraConteudoEntrada to update.
     */
    where: TcCompraConteudoEntradaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntrada updateMany
   */
  export type TcCompraConteudoEntradaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TcCompraConteudoEntradas.
     */
    data: XOR<TcCompraConteudoEntradaUpdateManyMutationInput, TcCompraConteudoEntradaUncheckedUpdateManyInput>
    /**
     * Filter which TcCompraConteudoEntradas to update
     */
    where?: TcCompraConteudoEntradaWhereInput
    /**
     * Limit how many TcCompraConteudoEntradas to update.
     */
    limit?: number
  }

  /**
   * TcCompraConteudoEntrada upsert
   */
  export type TcCompraConteudoEntradaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * The filter to search for the TcCompraConteudoEntrada to update in case it exists.
     */
    where: TcCompraConteudoEntradaWhereUniqueInput
    /**
     * In case the TcCompraConteudoEntrada found by the `where` argument doesn't exist, create a new TcCompraConteudoEntrada with this data.
     */
    create: XOR<TcCompraConteudoEntradaCreateInput, TcCompraConteudoEntradaUncheckedCreateInput>
    /**
     * In case the TcCompraConteudoEntrada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TcCompraConteudoEntradaUpdateInput, TcCompraConteudoEntradaUncheckedUpdateInput>
  }

  /**
   * TcCompraConteudoEntrada delete
   */
  export type TcCompraConteudoEntradaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    /**
     * Filter which TcCompraConteudoEntrada to delete.
     */
    where: TcCompraConteudoEntradaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntrada deleteMany
   */
  export type TcCompraConteudoEntradaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcCompraConteudoEntradas to delete
     */
    where?: TcCompraConteudoEntradaWhereInput
    /**
     * Limit how many TcCompraConteudoEntradas to delete.
     */
    limit?: number
  }

  /**
   * TcCompraConteudoEntrada.TcCompraConteudoEntradaFaturada
   */
  export type TcCompraConteudoEntrada$TcCompraConteudoEntradaFaturadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    orderBy?: TcCompraConteudoEntradaFaturadaOrderByWithRelationInput | TcCompraConteudoEntradaFaturadaOrderByWithRelationInput[]
    cursor?: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcCompraConteudoEntradaFaturadaScalarFieldEnum | TcCompraConteudoEntradaFaturadaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudoEntrada without action
   */
  export type TcCompraConteudoEntradaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
  }


  /**
   * Model TcCompraConteudoEntradaFaturada
   */

  export type AggregateTcCompraConteudoEntradaFaturada = {
    _count: TcCompraConteudoEntradaFaturadaCountAggregateOutputType | null
    _avg: TcCompraConteudoEntradaFaturadaAvgAggregateOutputType | null
    _sum: TcCompraConteudoEntradaFaturadaSumAggregateOutputType | null
    _min: TcCompraConteudoEntradaFaturadaMinAggregateOutputType | null
    _max: TcCompraConteudoEntradaFaturadaMaxAggregateOutputType | null
  }

  export type TcCompraConteudoEntradaFaturadaAvgAggregateOutputType = {
    nGuiaPhc: number | null
    qtt: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoEntradaFaturadaSumAggregateOutputType = {
    nGuiaPhc: number | null
    qtt: Decimal | null
    op: number | null
  }

  export type TcCompraConteudoEntradaFaturadaMinAggregateOutputType = {
    idFaturaPhc: string | null
    idConteudoEntradaPhc: string | null
    nGuiaPhc: number | null
    nFatura: string | null
    dataFatura: Date | null
    dataFaturaString: string | null
    qtt: Decimal | null
    unidade: string | null
    lote: string | null
    op: number | null
  }

  export type TcCompraConteudoEntradaFaturadaMaxAggregateOutputType = {
    idFaturaPhc: string | null
    idConteudoEntradaPhc: string | null
    nGuiaPhc: number | null
    nFatura: string | null
    dataFatura: Date | null
    dataFaturaString: string | null
    qtt: Decimal | null
    unidade: string | null
    lote: string | null
    op: number | null
  }

  export type TcCompraConteudoEntradaFaturadaCountAggregateOutputType = {
    idFaturaPhc: number
    idConteudoEntradaPhc: number
    nGuiaPhc: number
    nFatura: number
    dataFatura: number
    dataFaturaString: number
    qtt: number
    unidade: number
    lote: number
    op: number
    _all: number
  }


  export type TcCompraConteudoEntradaFaturadaAvgAggregateInputType = {
    nGuiaPhc?: true
    qtt?: true
    op?: true
  }

  export type TcCompraConteudoEntradaFaturadaSumAggregateInputType = {
    nGuiaPhc?: true
    qtt?: true
    op?: true
  }

  export type TcCompraConteudoEntradaFaturadaMinAggregateInputType = {
    idFaturaPhc?: true
    idConteudoEntradaPhc?: true
    nGuiaPhc?: true
    nFatura?: true
    dataFatura?: true
    dataFaturaString?: true
    qtt?: true
    unidade?: true
    lote?: true
    op?: true
  }

  export type TcCompraConteudoEntradaFaturadaMaxAggregateInputType = {
    idFaturaPhc?: true
    idConteudoEntradaPhc?: true
    nGuiaPhc?: true
    nFatura?: true
    dataFatura?: true
    dataFaturaString?: true
    qtt?: true
    unidade?: true
    lote?: true
    op?: true
  }

  export type TcCompraConteudoEntradaFaturadaCountAggregateInputType = {
    idFaturaPhc?: true
    idConteudoEntradaPhc?: true
    nGuiaPhc?: true
    nFatura?: true
    dataFatura?: true
    dataFaturaString?: true
    qtt?: true
    unidade?: true
    lote?: true
    op?: true
    _all?: true
  }

  export type TcCompraConteudoEntradaFaturadaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcCompraConteudoEntradaFaturada to aggregate.
     */
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradaFaturadas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaFaturadaOrderByWithRelationInput | TcCompraConteudoEntradaFaturadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradaFaturadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradaFaturadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TcCompraConteudoEntradaFaturadas
    **/
    _count?: true | TcCompraConteudoEntradaFaturadaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TcCompraConteudoEntradaFaturadaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TcCompraConteudoEntradaFaturadaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TcCompraConteudoEntradaFaturadaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TcCompraConteudoEntradaFaturadaMaxAggregateInputType
  }

  export type GetTcCompraConteudoEntradaFaturadaAggregateType<T extends TcCompraConteudoEntradaFaturadaAggregateArgs> = {
        [P in keyof T & keyof AggregateTcCompraConteudoEntradaFaturada]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTcCompraConteudoEntradaFaturada[P]>
      : GetScalarType<T[P], AggregateTcCompraConteudoEntradaFaturada[P]>
  }




  export type TcCompraConteudoEntradaFaturadaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    orderBy?: TcCompraConteudoEntradaFaturadaOrderByWithAggregationInput | TcCompraConteudoEntradaFaturadaOrderByWithAggregationInput[]
    by: TcCompraConteudoEntradaFaturadaScalarFieldEnum[] | TcCompraConteudoEntradaFaturadaScalarFieldEnum
    having?: TcCompraConteudoEntradaFaturadaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TcCompraConteudoEntradaFaturadaCountAggregateInputType | true
    _avg?: TcCompraConteudoEntradaFaturadaAvgAggregateInputType
    _sum?: TcCompraConteudoEntradaFaturadaSumAggregateInputType
    _min?: TcCompraConteudoEntradaFaturadaMinAggregateInputType
    _max?: TcCompraConteudoEntradaFaturadaMaxAggregateInputType
  }

  export type TcCompraConteudoEntradaFaturadaGroupByOutputType = {
    idFaturaPhc: string
    idConteudoEntradaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date
    dataFaturaString: string
    qtt: Decimal
    unidade: string
    lote: string
    op: number
    _count: TcCompraConteudoEntradaFaturadaCountAggregateOutputType | null
    _avg: TcCompraConteudoEntradaFaturadaAvgAggregateOutputType | null
    _sum: TcCompraConteudoEntradaFaturadaSumAggregateOutputType | null
    _min: TcCompraConteudoEntradaFaturadaMinAggregateOutputType | null
    _max: TcCompraConteudoEntradaFaturadaMaxAggregateOutputType | null
  }

  type GetTcCompraConteudoEntradaFaturadaGroupByPayload<T extends TcCompraConteudoEntradaFaturadaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TcCompraConteudoEntradaFaturadaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TcCompraConteudoEntradaFaturadaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TcCompraConteudoEntradaFaturadaGroupByOutputType[P]>
            : GetScalarType<T[P], TcCompraConteudoEntradaFaturadaGroupByOutputType[P]>
        }
      >
    >


  export type TcCompraConteudoEntradaFaturadaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idFaturaPhc?: boolean
    idConteudoEntradaPhc?: boolean
    nGuiaPhc?: boolean
    nFatura?: boolean
    dataFatura?: boolean
    dataFaturaString?: boolean
    qtt?: boolean
    unidade?: boolean
    lote?: boolean
    op?: boolean
    TcCompraConteudoEntrada?: boolean | TcCompraConteudoEntradaDefaultArgs<ExtArgs>
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tcCompraConteudoEntradaFaturada"]>



  export type TcCompraConteudoEntradaFaturadaSelectScalar = {
    idFaturaPhc?: boolean
    idConteudoEntradaPhc?: boolean
    nGuiaPhc?: boolean
    nFatura?: boolean
    dataFatura?: boolean
    dataFaturaString?: boolean
    qtt?: boolean
    unidade?: boolean
    lote?: boolean
    op?: boolean
  }

  export type TcCompraConteudoEntradaFaturadaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idFaturaPhc" | "idConteudoEntradaPhc" | "nGuiaPhc" | "nFatura" | "dataFatura" | "dataFaturaString" | "qtt" | "unidade" | "lote" | "op", ExtArgs["result"]["tcCompraConteudoEntradaFaturada"]>
  export type TcCompraConteudoEntradaFaturadaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudoEntrada?: boolean | TcCompraConteudoEntradaDefaultArgs<ExtArgs>
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
  }

  export type $TcCompraConteudoEntradaFaturadaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TcCompraConteudoEntradaFaturada"
    objects: {
      TcCompraConteudoEntrada: Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>
      TcOp: Prisma.$TcOpPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idFaturaPhc: string
      idConteudoEntradaPhc: string
      nGuiaPhc: number
      nFatura: string
      dataFatura: Date
      dataFaturaString: string
      qtt: Prisma.Decimal
      unidade: string
      lote: string
      op: number
    }, ExtArgs["result"]["tcCompraConteudoEntradaFaturada"]>
    composites: {}
  }

  type TcCompraConteudoEntradaFaturadaGetPayload<S extends boolean | null | undefined | TcCompraConteudoEntradaFaturadaDefaultArgs> = $Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload, S>

  type TcCompraConteudoEntradaFaturadaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TcCompraConteudoEntradaFaturadaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TcCompraConteudoEntradaFaturadaCountAggregateInputType | true
    }

  export interface TcCompraConteudoEntradaFaturadaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TcCompraConteudoEntradaFaturada'], meta: { name: 'TcCompraConteudoEntradaFaturada' } }
    /**
     * Find zero or one TcCompraConteudoEntradaFaturada that matches the filter.
     * @param {TcCompraConteudoEntradaFaturadaFindUniqueArgs} args - Arguments to find a TcCompraConteudoEntradaFaturada
     * @example
     * // Get one TcCompraConteudoEntradaFaturada
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TcCompraConteudoEntradaFaturadaFindUniqueArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFaturadaFindUniqueArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TcCompraConteudoEntradaFaturada that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TcCompraConteudoEntradaFaturadaFindUniqueOrThrowArgs} args - Arguments to find a TcCompraConteudoEntradaFaturada
     * @example
     * // Get one TcCompraConteudoEntradaFaturada
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TcCompraConteudoEntradaFaturadaFindUniqueOrThrowArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFaturadaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TcCompraConteudoEntradaFaturada that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFaturadaFindFirstArgs} args - Arguments to find a TcCompraConteudoEntradaFaturada
     * @example
     * // Get one TcCompraConteudoEntradaFaturada
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TcCompraConteudoEntradaFaturadaFindFirstArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFaturadaFindFirstArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TcCompraConteudoEntradaFaturada that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFaturadaFindFirstOrThrowArgs} args - Arguments to find a TcCompraConteudoEntradaFaturada
     * @example
     * // Get one TcCompraConteudoEntradaFaturada
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TcCompraConteudoEntradaFaturadaFindFirstOrThrowArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFaturadaFindFirstOrThrowArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TcCompraConteudoEntradaFaturadas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFaturadaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TcCompraConteudoEntradaFaturadas
     * const tcCompraConteudoEntradaFaturadas = await prisma.tcCompraConteudoEntradaFaturada.findMany()
     * 
     * // Get first 10 TcCompraConteudoEntradaFaturadas
     * const tcCompraConteudoEntradaFaturadas = await prisma.tcCompraConteudoEntradaFaturada.findMany({ take: 10 })
     * 
     * // Only select the `idFaturaPhc`
     * const tcCompraConteudoEntradaFaturadaWithIdFaturaPhcOnly = await prisma.tcCompraConteudoEntradaFaturada.findMany({ select: { idFaturaPhc: true } })
     * 
     */
    findMany<T extends TcCompraConteudoEntradaFaturadaFindManyArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFaturadaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TcCompraConteudoEntradaFaturada.
     * @param {TcCompraConteudoEntradaFaturadaCreateArgs} args - Arguments to create a TcCompraConteudoEntradaFaturada.
     * @example
     * // Create one TcCompraConteudoEntradaFaturada
     * const TcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.create({
     *   data: {
     *     // ... data to create a TcCompraConteudoEntradaFaturada
     *   }
     * })
     * 
     */
    create<T extends TcCompraConteudoEntradaFaturadaCreateArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFaturadaCreateArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TcCompraConteudoEntradaFaturadas.
     * @param {TcCompraConteudoEntradaFaturadaCreateManyArgs} args - Arguments to create many TcCompraConteudoEntradaFaturadas.
     * @example
     * // Create many TcCompraConteudoEntradaFaturadas
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TcCompraConteudoEntradaFaturadaCreateManyArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFaturadaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TcCompraConteudoEntradaFaturada.
     * @param {TcCompraConteudoEntradaFaturadaDeleteArgs} args - Arguments to delete one TcCompraConteudoEntradaFaturada.
     * @example
     * // Delete one TcCompraConteudoEntradaFaturada
     * const TcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.delete({
     *   where: {
     *     // ... filter to delete one TcCompraConteudoEntradaFaturada
     *   }
     * })
     * 
     */
    delete<T extends TcCompraConteudoEntradaFaturadaDeleteArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFaturadaDeleteArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TcCompraConteudoEntradaFaturada.
     * @param {TcCompraConteudoEntradaFaturadaUpdateArgs} args - Arguments to update one TcCompraConteudoEntradaFaturada.
     * @example
     * // Update one TcCompraConteudoEntradaFaturada
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TcCompraConteudoEntradaFaturadaUpdateArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFaturadaUpdateArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TcCompraConteudoEntradaFaturadas.
     * @param {TcCompraConteudoEntradaFaturadaDeleteManyArgs} args - Arguments to filter TcCompraConteudoEntradaFaturadas to delete.
     * @example
     * // Delete a few TcCompraConteudoEntradaFaturadas
     * const { count } = await prisma.tcCompraConteudoEntradaFaturada.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TcCompraConteudoEntradaFaturadaDeleteManyArgs>(args?: SelectSubset<T, TcCompraConteudoEntradaFaturadaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TcCompraConteudoEntradaFaturadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFaturadaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TcCompraConteudoEntradaFaturadas
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TcCompraConteudoEntradaFaturadaUpdateManyArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFaturadaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TcCompraConteudoEntradaFaturada.
     * @param {TcCompraConteudoEntradaFaturadaUpsertArgs} args - Arguments to update or create a TcCompraConteudoEntradaFaturada.
     * @example
     * // Update or create a TcCompraConteudoEntradaFaturada
     * const tcCompraConteudoEntradaFaturada = await prisma.tcCompraConteudoEntradaFaturada.upsert({
     *   create: {
     *     // ... data to create a TcCompraConteudoEntradaFaturada
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TcCompraConteudoEntradaFaturada we want to update
     *   }
     * })
     */
    upsert<T extends TcCompraConteudoEntradaFaturadaUpsertArgs>(args: SelectSubset<T, TcCompraConteudoEntradaFaturadaUpsertArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaFaturadaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TcCompraConteudoEntradaFaturadas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFaturadaCountArgs} args - Arguments to filter TcCompraConteudoEntradaFaturadas to count.
     * @example
     * // Count the number of TcCompraConteudoEntradaFaturadas
     * const count = await prisma.tcCompraConteudoEntradaFaturada.count({
     *   where: {
     *     // ... the filter for the TcCompraConteudoEntradaFaturadas we want to count
     *   }
     * })
    **/
    count<T extends TcCompraConteudoEntradaFaturadaCountArgs>(
      args?: Subset<T, TcCompraConteudoEntradaFaturadaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TcCompraConteudoEntradaFaturadaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TcCompraConteudoEntradaFaturada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFaturadaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TcCompraConteudoEntradaFaturadaAggregateArgs>(args: Subset<T, TcCompraConteudoEntradaFaturadaAggregateArgs>): Prisma.PrismaPromise<GetTcCompraConteudoEntradaFaturadaAggregateType<T>>

    /**
     * Group by TcCompraConteudoEntradaFaturada.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcCompraConteudoEntradaFaturadaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TcCompraConteudoEntradaFaturadaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TcCompraConteudoEntradaFaturadaGroupByArgs['orderBy'] }
        : { orderBy?: TcCompraConteudoEntradaFaturadaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TcCompraConteudoEntradaFaturadaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTcCompraConteudoEntradaFaturadaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TcCompraConteudoEntradaFaturada model
   */
  readonly fields: TcCompraConteudoEntradaFaturadaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TcCompraConteudoEntradaFaturada.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TcCompraConteudoEntradaFaturadaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TcCompraConteudoEntrada<T extends TcCompraConteudoEntradaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcCompraConteudoEntradaDefaultArgs<ExtArgs>>): Prisma__TcCompraConteudoEntradaClient<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TcOp<T extends TcOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcOpDefaultArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TcCompraConteudoEntradaFaturada model
   */ 
  interface TcCompraConteudoEntradaFaturadaFieldRefs {
    readonly idFaturaPhc: FieldRef<"TcCompraConteudoEntradaFaturada", 'String'>
    readonly idConteudoEntradaPhc: FieldRef<"TcCompraConteudoEntradaFaturada", 'String'>
    readonly nGuiaPhc: FieldRef<"TcCompraConteudoEntradaFaturada", 'Int'>
    readonly nFatura: FieldRef<"TcCompraConteudoEntradaFaturada", 'String'>
    readonly dataFatura: FieldRef<"TcCompraConteudoEntradaFaturada", 'DateTime'>
    readonly dataFaturaString: FieldRef<"TcCompraConteudoEntradaFaturada", 'String'>
    readonly qtt: FieldRef<"TcCompraConteudoEntradaFaturada", 'Decimal'>
    readonly unidade: FieldRef<"TcCompraConteudoEntradaFaturada", 'String'>
    readonly lote: FieldRef<"TcCompraConteudoEntradaFaturada", 'String'>
    readonly op: FieldRef<"TcCompraConteudoEntradaFaturada", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TcCompraConteudoEntradaFaturada findUnique
   */
  export type TcCompraConteudoEntradaFaturadaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntradaFaturada to fetch.
     */
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntradaFaturada findUniqueOrThrow
   */
  export type TcCompraConteudoEntradaFaturadaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntradaFaturada to fetch.
     */
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntradaFaturada findFirst
   */
  export type TcCompraConteudoEntradaFaturadaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntradaFaturada to fetch.
     */
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradaFaturadas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaFaturadaOrderByWithRelationInput | TcCompraConteudoEntradaFaturadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcCompraConteudoEntradaFaturadas.
     */
    cursor?: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradaFaturadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradaFaturadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcCompraConteudoEntradaFaturadas.
     */
    distinct?: TcCompraConteudoEntradaFaturadaScalarFieldEnum | TcCompraConteudoEntradaFaturadaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudoEntradaFaturada findFirstOrThrow
   */
  export type TcCompraConteudoEntradaFaturadaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntradaFaturada to fetch.
     */
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradaFaturadas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaFaturadaOrderByWithRelationInput | TcCompraConteudoEntradaFaturadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcCompraConteudoEntradaFaturadas.
     */
    cursor?: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradaFaturadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradaFaturadas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcCompraConteudoEntradaFaturadas.
     */
    distinct?: TcCompraConteudoEntradaFaturadaScalarFieldEnum | TcCompraConteudoEntradaFaturadaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudoEntradaFaturada findMany
   */
  export type TcCompraConteudoEntradaFaturadaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * Filter, which TcCompraConteudoEntradaFaturadas to fetch.
     */
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcCompraConteudoEntradaFaturadas to fetch.
     */
    orderBy?: TcCompraConteudoEntradaFaturadaOrderByWithRelationInput | TcCompraConteudoEntradaFaturadaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TcCompraConteudoEntradaFaturadas.
     */
    cursor?: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcCompraConteudoEntradaFaturadas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcCompraConteudoEntradaFaturadas.
     */
    skip?: number
    distinct?: TcCompraConteudoEntradaFaturadaScalarFieldEnum | TcCompraConteudoEntradaFaturadaScalarFieldEnum[]
  }

  /**
   * TcCompraConteudoEntradaFaturada create
   */
  export type TcCompraConteudoEntradaFaturadaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * The data needed to create a TcCompraConteudoEntradaFaturada.
     */
    data: XOR<TcCompraConteudoEntradaFaturadaCreateInput, TcCompraConteudoEntradaFaturadaUncheckedCreateInput>
  }

  /**
   * TcCompraConteudoEntradaFaturada createMany
   */
  export type TcCompraConteudoEntradaFaturadaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TcCompraConteudoEntradaFaturadas.
     */
    data: TcCompraConteudoEntradaFaturadaCreateManyInput | TcCompraConteudoEntradaFaturadaCreateManyInput[]
  }

  /**
   * TcCompraConteudoEntradaFaturada update
   */
  export type TcCompraConteudoEntradaFaturadaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * The data needed to update a TcCompraConteudoEntradaFaturada.
     */
    data: XOR<TcCompraConteudoEntradaFaturadaUpdateInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateInput>
    /**
     * Choose, which TcCompraConteudoEntradaFaturada to update.
     */
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntradaFaturada updateMany
   */
  export type TcCompraConteudoEntradaFaturadaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TcCompraConteudoEntradaFaturadas.
     */
    data: XOR<TcCompraConteudoEntradaFaturadaUpdateManyMutationInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateManyInput>
    /**
     * Filter which TcCompraConteudoEntradaFaturadas to update
     */
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    /**
     * Limit how many TcCompraConteudoEntradaFaturadas to update.
     */
    limit?: number
  }

  /**
   * TcCompraConteudoEntradaFaturada upsert
   */
  export type TcCompraConteudoEntradaFaturadaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * The filter to search for the TcCompraConteudoEntradaFaturada to update in case it exists.
     */
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    /**
     * In case the TcCompraConteudoEntradaFaturada found by the `where` argument doesn't exist, create a new TcCompraConteudoEntradaFaturada with this data.
     */
    create: XOR<TcCompraConteudoEntradaFaturadaCreateInput, TcCompraConteudoEntradaFaturadaUncheckedCreateInput>
    /**
     * In case the TcCompraConteudoEntradaFaturada was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TcCompraConteudoEntradaFaturadaUpdateInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateInput>
  }

  /**
   * TcCompraConteudoEntradaFaturada delete
   */
  export type TcCompraConteudoEntradaFaturadaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    /**
     * Filter which TcCompraConteudoEntradaFaturada to delete.
     */
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
  }

  /**
   * TcCompraConteudoEntradaFaturada deleteMany
   */
  export type TcCompraConteudoEntradaFaturadaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcCompraConteudoEntradaFaturadas to delete
     */
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    /**
     * Limit how many TcCompraConteudoEntradaFaturadas to delete.
     */
    limit?: number
  }

  /**
   * TcCompraConteudoEntradaFaturada without action
   */
  export type TcCompraConteudoEntradaFaturadaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
  }


  /**
   * Model TcOp
   */

  export type AggregateTcOp = {
    _count: TcOpCountAggregateOutputType | null
    _avg: TcOpAvgAggregateOutputType | null
    _sum: TcOpSumAggregateOutputType | null
    _min: TcOpMinAggregateOutputType | null
    _max: TcOpMaxAggregateOutputType | null
  }

  export type TcOpAvgAggregateOutputType = {
    op: number | null
  }

  export type TcOpSumAggregateOutputType = {
    op: number | null
  }

  export type TcOpMinAggregateOutputType = {
    idTc: string | null
    op: number | null
    foto: string | null
    createdAt: Date | null
  }

  export type TcOpMaxAggregateOutputType = {
    idTc: string | null
    op: number | null
    foto: string | null
    createdAt: Date | null
  }

  export type TcOpCountAggregateOutputType = {
    idTc: number
    op: number
    foto: number
    createdAt: number
    _all: number
  }


  export type TcOpAvgAggregateInputType = {
    op?: true
  }

  export type TcOpSumAggregateInputType = {
    op?: true
  }

  export type TcOpMinAggregateInputType = {
    idTc?: true
    op?: true
    foto?: true
    createdAt?: true
  }

  export type TcOpMaxAggregateInputType = {
    idTc?: true
    op?: true
    foto?: true
    createdAt?: true
  }

  export type TcOpCountAggregateInputType = {
    idTc?: true
    op?: true
    foto?: true
    createdAt?: true
    _all?: true
  }

  export type TcOpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcOp to aggregate.
     */
    where?: TcOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOps to fetch.
     */
    orderBy?: TcOpOrderByWithRelationInput | TcOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TcOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TcOps
    **/
    _count?: true | TcOpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TcOpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TcOpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TcOpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TcOpMaxAggregateInputType
  }

  export type GetTcOpAggregateType<T extends TcOpAggregateArgs> = {
        [P in keyof T & keyof AggregateTcOp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTcOp[P]>
      : GetScalarType<T[P], AggregateTcOp[P]>
  }




  export type TcOpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcOpWhereInput
    orderBy?: TcOpOrderByWithAggregationInput | TcOpOrderByWithAggregationInput[]
    by: TcOpScalarFieldEnum[] | TcOpScalarFieldEnum
    having?: TcOpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TcOpCountAggregateInputType | true
    _avg?: TcOpAvgAggregateInputType
    _sum?: TcOpSumAggregateInputType
    _min?: TcOpMinAggregateInputType
    _max?: TcOpMaxAggregateInputType
  }

  export type TcOpGroupByOutputType = {
    idTc: string
    op: number
    foto: string
    createdAt: Date
    _count: TcOpCountAggregateOutputType | null
    _avg: TcOpAvgAggregateOutputType | null
    _sum: TcOpSumAggregateOutputType | null
    _min: TcOpMinAggregateOutputType | null
    _max: TcOpMaxAggregateOutputType | null
  }

  type GetTcOpGroupByPayload<T extends TcOpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TcOpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TcOpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TcOpGroupByOutputType[P]>
            : GetScalarType<T[P], TcOpGroupByOutputType[P]>
        }
      >
    >


  export type TcOpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idTc?: boolean
    op?: boolean
    foto?: boolean
    createdAt?: boolean
    TcCompraConteudo?: boolean | TcOp$TcCompraConteudoArgs<ExtArgs>
    TcCompraConteudoEntrada?: boolean | TcOp$TcCompraConteudoEntradaArgs<ExtArgs>
    TcCompraConteudoEntradaFaturada?: boolean | TcOp$TcCompraConteudoEntradaFaturadaArgs<ExtArgs>
    Tc?: boolean | TcDefaultArgs<ExtArgs>
    TcOpCompra?: boolean | TcOp$TcOpCompraArgs<ExtArgs>
    _count?: boolean | TcOpCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tcOp"]>



  export type TcOpSelectScalar = {
    idTc?: boolean
    op?: boolean
    foto?: boolean
    createdAt?: boolean
  }

  export type TcOpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idTc" | "op" | "foto" | "createdAt", ExtArgs["result"]["tcOp"]>
  export type TcOpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudo?: boolean | TcOp$TcCompraConteudoArgs<ExtArgs>
    TcCompraConteudoEntrada?: boolean | TcOp$TcCompraConteudoEntradaArgs<ExtArgs>
    TcCompraConteudoEntradaFaturada?: boolean | TcOp$TcCompraConteudoEntradaFaturadaArgs<ExtArgs>
    Tc?: boolean | TcDefaultArgs<ExtArgs>
    TcOpCompra?: boolean | TcOp$TcOpCompraArgs<ExtArgs>
    _count?: boolean | TcOpCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TcOpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TcOp"
    objects: {
      TcCompraConteudo: Prisma.$TcCompraConteudoPayload<ExtArgs>[]
      TcCompraConteudoEntrada: Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>[]
      TcCompraConteudoEntradaFaturada: Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>[]
      Tc: Prisma.$TcPayload<ExtArgs>
      TcOpCompra: Prisma.$TcOpCompraPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      idTc: string
      op: number
      foto: string
      createdAt: Date
    }, ExtArgs["result"]["tcOp"]>
    composites: {}
  }

  type TcOpGetPayload<S extends boolean | null | undefined | TcOpDefaultArgs> = $Result.GetResult<Prisma.$TcOpPayload, S>

  type TcOpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TcOpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TcOpCountAggregateInputType | true
    }

  export interface TcOpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TcOp'], meta: { name: 'TcOp' } }
    /**
     * Find zero or one TcOp that matches the filter.
     * @param {TcOpFindUniqueArgs} args - Arguments to find a TcOp
     * @example
     * // Get one TcOp
     * const tcOp = await prisma.tcOp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TcOpFindUniqueArgs>(args: SelectSubset<T, TcOpFindUniqueArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TcOp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TcOpFindUniqueOrThrowArgs} args - Arguments to find a TcOp
     * @example
     * // Get one TcOp
     * const tcOp = await prisma.tcOp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TcOpFindUniqueOrThrowArgs>(args: SelectSubset<T, TcOpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TcOp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpFindFirstArgs} args - Arguments to find a TcOp
     * @example
     * // Get one TcOp
     * const tcOp = await prisma.tcOp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TcOpFindFirstArgs>(args?: SelectSubset<T, TcOpFindFirstArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TcOp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpFindFirstOrThrowArgs} args - Arguments to find a TcOp
     * @example
     * // Get one TcOp
     * const tcOp = await prisma.tcOp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TcOpFindFirstOrThrowArgs>(args?: SelectSubset<T, TcOpFindFirstOrThrowArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TcOps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TcOps
     * const tcOps = await prisma.tcOp.findMany()
     * 
     * // Get first 10 TcOps
     * const tcOps = await prisma.tcOp.findMany({ take: 10 })
     * 
     * // Only select the `idTc`
     * const tcOpWithIdTcOnly = await prisma.tcOp.findMany({ select: { idTc: true } })
     * 
     */
    findMany<T extends TcOpFindManyArgs>(args?: SelectSubset<T, TcOpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TcOp.
     * @param {TcOpCreateArgs} args - Arguments to create a TcOp.
     * @example
     * // Create one TcOp
     * const TcOp = await prisma.tcOp.create({
     *   data: {
     *     // ... data to create a TcOp
     *   }
     * })
     * 
     */
    create<T extends TcOpCreateArgs>(args: SelectSubset<T, TcOpCreateArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TcOps.
     * @param {TcOpCreateManyArgs} args - Arguments to create many TcOps.
     * @example
     * // Create many TcOps
     * const tcOp = await prisma.tcOp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TcOpCreateManyArgs>(args?: SelectSubset<T, TcOpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TcOp.
     * @param {TcOpDeleteArgs} args - Arguments to delete one TcOp.
     * @example
     * // Delete one TcOp
     * const TcOp = await prisma.tcOp.delete({
     *   where: {
     *     // ... filter to delete one TcOp
     *   }
     * })
     * 
     */
    delete<T extends TcOpDeleteArgs>(args: SelectSubset<T, TcOpDeleteArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TcOp.
     * @param {TcOpUpdateArgs} args - Arguments to update one TcOp.
     * @example
     * // Update one TcOp
     * const tcOp = await prisma.tcOp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TcOpUpdateArgs>(args: SelectSubset<T, TcOpUpdateArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TcOps.
     * @param {TcOpDeleteManyArgs} args - Arguments to filter TcOps to delete.
     * @example
     * // Delete a few TcOps
     * const { count } = await prisma.tcOp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TcOpDeleteManyArgs>(args?: SelectSubset<T, TcOpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TcOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TcOps
     * const tcOp = await prisma.tcOp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TcOpUpdateManyArgs>(args: SelectSubset<T, TcOpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TcOp.
     * @param {TcOpUpsertArgs} args - Arguments to update or create a TcOp.
     * @example
     * // Update or create a TcOp
     * const tcOp = await prisma.tcOp.upsert({
     *   create: {
     *     // ... data to create a TcOp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TcOp we want to update
     *   }
     * })
     */
    upsert<T extends TcOpUpsertArgs>(args: SelectSubset<T, TcOpUpsertArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TcOps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCountArgs} args - Arguments to filter TcOps to count.
     * @example
     * // Count the number of TcOps
     * const count = await prisma.tcOp.count({
     *   where: {
     *     // ... the filter for the TcOps we want to count
     *   }
     * })
    **/
    count<T extends TcOpCountArgs>(
      args?: Subset<T, TcOpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TcOpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TcOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TcOpAggregateArgs>(args: Subset<T, TcOpAggregateArgs>): Prisma.PrismaPromise<GetTcOpAggregateType<T>>

    /**
     * Group by TcOp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TcOpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TcOpGroupByArgs['orderBy'] }
        : { orderBy?: TcOpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TcOpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTcOpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TcOp model
   */
  readonly fields: TcOpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TcOp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TcOpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TcCompraConteudo<T extends TcOp$TcCompraConteudoArgs<ExtArgs> = {}>(args?: Subset<T, TcOp$TcCompraConteudoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TcCompraConteudoEntrada<T extends TcOp$TcCompraConteudoEntradaArgs<ExtArgs> = {}>(args?: Subset<T, TcOp$TcCompraConteudoEntradaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoEntradaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TcCompraConteudoEntradaFaturada<T extends TcOp$TcCompraConteudoEntradaFaturadaArgs<ExtArgs> = {}>(args?: Subset<T, TcOp$TcCompraConteudoEntradaFaturadaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoEntradaFaturadaPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Tc<T extends TcDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcDefaultArgs<ExtArgs>>): Prisma__TcClient<$Result.GetResult<Prisma.$TcPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    TcOpCompra<T extends TcOp$TcOpCompraArgs<ExtArgs> = {}>(args?: Subset<T, TcOp$TcOpCompraArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TcOp model
   */ 
  interface TcOpFieldRefs {
    readonly idTc: FieldRef<"TcOp", 'String'>
    readonly op: FieldRef<"TcOp", 'Int'>
    readonly foto: FieldRef<"TcOp", 'String'>
    readonly createdAt: FieldRef<"TcOp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TcOp findUnique
   */
  export type TcOpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * Filter, which TcOp to fetch.
     */
    where: TcOpWhereUniqueInput
  }

  /**
   * TcOp findUniqueOrThrow
   */
  export type TcOpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * Filter, which TcOp to fetch.
     */
    where: TcOpWhereUniqueInput
  }

  /**
   * TcOp findFirst
   */
  export type TcOpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * Filter, which TcOp to fetch.
     */
    where?: TcOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOps to fetch.
     */
    orderBy?: TcOpOrderByWithRelationInput | TcOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcOps.
     */
    cursor?: TcOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcOps.
     */
    distinct?: TcOpScalarFieldEnum | TcOpScalarFieldEnum[]
  }

  /**
   * TcOp findFirstOrThrow
   */
  export type TcOpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * Filter, which TcOp to fetch.
     */
    where?: TcOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOps to fetch.
     */
    orderBy?: TcOpOrderByWithRelationInput | TcOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcOps.
     */
    cursor?: TcOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcOps.
     */
    distinct?: TcOpScalarFieldEnum | TcOpScalarFieldEnum[]
  }

  /**
   * TcOp findMany
   */
  export type TcOpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * Filter, which TcOps to fetch.
     */
    where?: TcOpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOps to fetch.
     */
    orderBy?: TcOpOrderByWithRelationInput | TcOpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TcOps.
     */
    cursor?: TcOpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOps.
     */
    skip?: number
    distinct?: TcOpScalarFieldEnum | TcOpScalarFieldEnum[]
  }

  /**
   * TcOp create
   */
  export type TcOpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * The data needed to create a TcOp.
     */
    data: XOR<TcOpCreateInput, TcOpUncheckedCreateInput>
  }

  /**
   * TcOp createMany
   */
  export type TcOpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TcOps.
     */
    data: TcOpCreateManyInput | TcOpCreateManyInput[]
  }

  /**
   * TcOp update
   */
  export type TcOpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * The data needed to update a TcOp.
     */
    data: XOR<TcOpUpdateInput, TcOpUncheckedUpdateInput>
    /**
     * Choose, which TcOp to update.
     */
    where: TcOpWhereUniqueInput
  }

  /**
   * TcOp updateMany
   */
  export type TcOpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TcOps.
     */
    data: XOR<TcOpUpdateManyMutationInput, TcOpUncheckedUpdateManyInput>
    /**
     * Filter which TcOps to update
     */
    where?: TcOpWhereInput
    /**
     * Limit how many TcOps to update.
     */
    limit?: number
  }

  /**
   * TcOp upsert
   */
  export type TcOpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * The filter to search for the TcOp to update in case it exists.
     */
    where: TcOpWhereUniqueInput
    /**
     * In case the TcOp found by the `where` argument doesn't exist, create a new TcOp with this data.
     */
    create: XOR<TcOpCreateInput, TcOpUncheckedCreateInput>
    /**
     * In case the TcOp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TcOpUpdateInput, TcOpUncheckedUpdateInput>
  }

  /**
   * TcOp delete
   */
  export type TcOpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
    /**
     * Filter which TcOp to delete.
     */
    where: TcOpWhereUniqueInput
  }

  /**
   * TcOp deleteMany
   */
  export type TcOpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcOps to delete
     */
    where?: TcOpWhereInput
    /**
     * Limit how many TcOps to delete.
     */
    limit?: number
  }

  /**
   * TcOp.TcCompraConteudo
   */
  export type TcOp$TcCompraConteudoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    where?: TcCompraConteudoWhereInput
    orderBy?: TcCompraConteudoOrderByWithRelationInput | TcCompraConteudoOrderByWithRelationInput[]
    cursor?: TcCompraConteudoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcCompraConteudoScalarFieldEnum | TcCompraConteudoScalarFieldEnum[]
  }

  /**
   * TcOp.TcCompraConteudoEntrada
   */
  export type TcOp$TcCompraConteudoEntradaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntrada
     */
    select?: TcCompraConteudoEntradaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntrada
     */
    omit?: TcCompraConteudoEntradaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaInclude<ExtArgs> | null
    where?: TcCompraConteudoEntradaWhereInput
    orderBy?: TcCompraConteudoEntradaOrderByWithRelationInput | TcCompraConteudoEntradaOrderByWithRelationInput[]
    cursor?: TcCompraConteudoEntradaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcCompraConteudoEntradaScalarFieldEnum | TcCompraConteudoEntradaScalarFieldEnum[]
  }

  /**
   * TcOp.TcCompraConteudoEntradaFaturada
   */
  export type TcOp$TcCompraConteudoEntradaFaturadaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudoEntradaFaturada
     */
    select?: TcCompraConteudoEntradaFaturadaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudoEntradaFaturada
     */
    omit?: TcCompraConteudoEntradaFaturadaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoEntradaFaturadaInclude<ExtArgs> | null
    where?: TcCompraConteudoEntradaFaturadaWhereInput
    orderBy?: TcCompraConteudoEntradaFaturadaOrderByWithRelationInput | TcCompraConteudoEntradaFaturadaOrderByWithRelationInput[]
    cursor?: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcCompraConteudoEntradaFaturadaScalarFieldEnum | TcCompraConteudoEntradaFaturadaScalarFieldEnum[]
  }

  /**
   * TcOp.TcOpCompra
   */
  export type TcOp$TcOpCompraArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    where?: TcOpCompraWhereInput
    orderBy?: TcOpCompraOrderByWithRelationInput | TcOpCompraOrderByWithRelationInput[]
    cursor?: TcOpCompraWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcOpCompraScalarFieldEnum | TcOpCompraScalarFieldEnum[]
  }

  /**
   * TcOp without action
   */
  export type TcOpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOp
     */
    select?: TcOpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOp
     */
    omit?: TcOpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpInclude<ExtArgs> | null
  }


  /**
   * Model TcOpCompra
   */

  export type AggregateTcOpCompra = {
    _count: TcOpCompraCountAggregateOutputType | null
    _avg: TcOpCompraAvgAggregateOutputType | null
    _sum: TcOpCompraSumAggregateOutputType | null
    _min: TcOpCompraMinAggregateOutputType | null
    _max: TcOpCompraMaxAggregateOutputType | null
  }

  export type TcOpCompraAvgAggregateOutputType = {
    nCompra: number | null
    op: number | null
  }

  export type TcOpCompraSumAggregateOutputType = {
    nCompra: number | null
    op: number | null
  }

  export type TcOpCompraMinAggregateOutputType = {
    idCompra: string | null
    idCompraPhc: string | null
    nCompra: number | null
    nome: string | null
    dataCompra: Date | null
    dataCompraString: string | null
    op: number | null
  }

  export type TcOpCompraMaxAggregateOutputType = {
    idCompra: string | null
    idCompraPhc: string | null
    nCompra: number | null
    nome: string | null
    dataCompra: Date | null
    dataCompraString: string | null
    op: number | null
  }

  export type TcOpCompraCountAggregateOutputType = {
    idCompra: number
    idCompraPhc: number
    nCompra: number
    nome: number
    dataCompra: number
    dataCompraString: number
    op: number
    _all: number
  }


  export type TcOpCompraAvgAggregateInputType = {
    nCompra?: true
    op?: true
  }

  export type TcOpCompraSumAggregateInputType = {
    nCompra?: true
    op?: true
  }

  export type TcOpCompraMinAggregateInputType = {
    idCompra?: true
    idCompraPhc?: true
    nCompra?: true
    nome?: true
    dataCompra?: true
    dataCompraString?: true
    op?: true
  }

  export type TcOpCompraMaxAggregateInputType = {
    idCompra?: true
    idCompraPhc?: true
    nCompra?: true
    nome?: true
    dataCompra?: true
    dataCompraString?: true
    op?: true
  }

  export type TcOpCompraCountAggregateInputType = {
    idCompra?: true
    idCompraPhc?: true
    nCompra?: true
    nome?: true
    dataCompra?: true
    dataCompraString?: true
    op?: true
    _all?: true
  }

  export type TcOpCompraAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcOpCompra to aggregate.
     */
    where?: TcOpCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOpCompras to fetch.
     */
    orderBy?: TcOpCompraOrderByWithRelationInput | TcOpCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TcOpCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOpCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOpCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TcOpCompras
    **/
    _count?: true | TcOpCompraCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TcOpCompraAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TcOpCompraSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TcOpCompraMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TcOpCompraMaxAggregateInputType
  }

  export type GetTcOpCompraAggregateType<T extends TcOpCompraAggregateArgs> = {
        [P in keyof T & keyof AggregateTcOpCompra]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTcOpCompra[P]>
      : GetScalarType<T[P], AggregateTcOpCompra[P]>
  }




  export type TcOpCompraGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TcOpCompraWhereInput
    orderBy?: TcOpCompraOrderByWithAggregationInput | TcOpCompraOrderByWithAggregationInput[]
    by: TcOpCompraScalarFieldEnum[] | TcOpCompraScalarFieldEnum
    having?: TcOpCompraScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TcOpCompraCountAggregateInputType | true
    _avg?: TcOpCompraAvgAggregateInputType
    _sum?: TcOpCompraSumAggregateInputType
    _min?: TcOpCompraMinAggregateInputType
    _max?: TcOpCompraMaxAggregateInputType
  }

  export type TcOpCompraGroupByOutputType = {
    idCompra: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date
    dataCompraString: string
    op: number
    _count: TcOpCompraCountAggregateOutputType | null
    _avg: TcOpCompraAvgAggregateOutputType | null
    _sum: TcOpCompraSumAggregateOutputType | null
    _min: TcOpCompraMinAggregateOutputType | null
    _max: TcOpCompraMaxAggregateOutputType | null
  }

  type GetTcOpCompraGroupByPayload<T extends TcOpCompraGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TcOpCompraGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TcOpCompraGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TcOpCompraGroupByOutputType[P]>
            : GetScalarType<T[P], TcOpCompraGroupByOutputType[P]>
        }
      >
    >


  export type TcOpCompraSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idCompra?: boolean
    idCompraPhc?: boolean
    nCompra?: boolean
    nome?: boolean
    dataCompra?: boolean
    dataCompraString?: boolean
    op?: boolean
    TcCompraConteudo?: boolean | TcOpCompra$TcCompraConteudoArgs<ExtArgs>
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
    _count?: boolean | TcOpCompraCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tcOpCompra"]>



  export type TcOpCompraSelectScalar = {
    idCompra?: boolean
    idCompraPhc?: boolean
    nCompra?: boolean
    nome?: boolean
    dataCompra?: boolean
    dataCompraString?: boolean
    op?: boolean
  }

  export type TcOpCompraOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idCompra" | "idCompraPhc" | "nCompra" | "nome" | "dataCompra" | "dataCompraString" | "op", ExtArgs["result"]["tcOpCompra"]>
  export type TcOpCompraInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    TcCompraConteudo?: boolean | TcOpCompra$TcCompraConteudoArgs<ExtArgs>
    TcOp?: boolean | TcOpDefaultArgs<ExtArgs>
    _count?: boolean | TcOpCompraCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TcOpCompraPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TcOpCompra"
    objects: {
      TcCompraConteudo: Prisma.$TcCompraConteudoPayload<ExtArgs>[]
      TcOp: Prisma.$TcOpPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idCompra: string
      idCompraPhc: string
      nCompra: number
      nome: string
      dataCompra: Date
      dataCompraString: string
      op: number
    }, ExtArgs["result"]["tcOpCompra"]>
    composites: {}
  }

  type TcOpCompraGetPayload<S extends boolean | null | undefined | TcOpCompraDefaultArgs> = $Result.GetResult<Prisma.$TcOpCompraPayload, S>

  type TcOpCompraCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TcOpCompraFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TcOpCompraCountAggregateInputType | true
    }

  export interface TcOpCompraDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TcOpCompra'], meta: { name: 'TcOpCompra' } }
    /**
     * Find zero or one TcOpCompra that matches the filter.
     * @param {TcOpCompraFindUniqueArgs} args - Arguments to find a TcOpCompra
     * @example
     * // Get one TcOpCompra
     * const tcOpCompra = await prisma.tcOpCompra.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TcOpCompraFindUniqueArgs>(args: SelectSubset<T, TcOpCompraFindUniqueArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one TcOpCompra that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TcOpCompraFindUniqueOrThrowArgs} args - Arguments to find a TcOpCompra
     * @example
     * // Get one TcOpCompra
     * const tcOpCompra = await prisma.tcOpCompra.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TcOpCompraFindUniqueOrThrowArgs>(args: SelectSubset<T, TcOpCompraFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first TcOpCompra that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCompraFindFirstArgs} args - Arguments to find a TcOpCompra
     * @example
     * // Get one TcOpCompra
     * const tcOpCompra = await prisma.tcOpCompra.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TcOpCompraFindFirstArgs>(args?: SelectSubset<T, TcOpCompraFindFirstArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first TcOpCompra that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCompraFindFirstOrThrowArgs} args - Arguments to find a TcOpCompra
     * @example
     * // Get one TcOpCompra
     * const tcOpCompra = await prisma.tcOpCompra.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TcOpCompraFindFirstOrThrowArgs>(args?: SelectSubset<T, TcOpCompraFindFirstOrThrowArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more TcOpCompras that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCompraFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TcOpCompras
     * const tcOpCompras = await prisma.tcOpCompra.findMany()
     * 
     * // Get first 10 TcOpCompras
     * const tcOpCompras = await prisma.tcOpCompra.findMany({ take: 10 })
     * 
     * // Only select the `idCompra`
     * const tcOpCompraWithIdCompraOnly = await prisma.tcOpCompra.findMany({ select: { idCompra: true } })
     * 
     */
    findMany<T extends TcOpCompraFindManyArgs>(args?: SelectSubset<T, TcOpCompraFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a TcOpCompra.
     * @param {TcOpCompraCreateArgs} args - Arguments to create a TcOpCompra.
     * @example
     * // Create one TcOpCompra
     * const TcOpCompra = await prisma.tcOpCompra.create({
     *   data: {
     *     // ... data to create a TcOpCompra
     *   }
     * })
     * 
     */
    create<T extends TcOpCompraCreateArgs>(args: SelectSubset<T, TcOpCompraCreateArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many TcOpCompras.
     * @param {TcOpCompraCreateManyArgs} args - Arguments to create many TcOpCompras.
     * @example
     * // Create many TcOpCompras
     * const tcOpCompra = await prisma.tcOpCompra.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TcOpCompraCreateManyArgs>(args?: SelectSubset<T, TcOpCompraCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TcOpCompra.
     * @param {TcOpCompraDeleteArgs} args - Arguments to delete one TcOpCompra.
     * @example
     * // Delete one TcOpCompra
     * const TcOpCompra = await prisma.tcOpCompra.delete({
     *   where: {
     *     // ... filter to delete one TcOpCompra
     *   }
     * })
     * 
     */
    delete<T extends TcOpCompraDeleteArgs>(args: SelectSubset<T, TcOpCompraDeleteArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one TcOpCompra.
     * @param {TcOpCompraUpdateArgs} args - Arguments to update one TcOpCompra.
     * @example
     * // Update one TcOpCompra
     * const tcOpCompra = await prisma.tcOpCompra.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TcOpCompraUpdateArgs>(args: SelectSubset<T, TcOpCompraUpdateArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more TcOpCompras.
     * @param {TcOpCompraDeleteManyArgs} args - Arguments to filter TcOpCompras to delete.
     * @example
     * // Delete a few TcOpCompras
     * const { count } = await prisma.tcOpCompra.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TcOpCompraDeleteManyArgs>(args?: SelectSubset<T, TcOpCompraDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TcOpCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCompraUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TcOpCompras
     * const tcOpCompra = await prisma.tcOpCompra.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TcOpCompraUpdateManyArgs>(args: SelectSubset<T, TcOpCompraUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TcOpCompra.
     * @param {TcOpCompraUpsertArgs} args - Arguments to update or create a TcOpCompra.
     * @example
     * // Update or create a TcOpCompra
     * const tcOpCompra = await prisma.tcOpCompra.upsert({
     *   create: {
     *     // ... data to create a TcOpCompra
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TcOpCompra we want to update
     *   }
     * })
     */
    upsert<T extends TcOpCompraUpsertArgs>(args: SelectSubset<T, TcOpCompraUpsertArgs<ExtArgs>>): Prisma__TcOpCompraClient<$Result.GetResult<Prisma.$TcOpCompraPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of TcOpCompras.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCompraCountArgs} args - Arguments to filter TcOpCompras to count.
     * @example
     * // Count the number of TcOpCompras
     * const count = await prisma.tcOpCompra.count({
     *   where: {
     *     // ... the filter for the TcOpCompras we want to count
     *   }
     * })
    **/
    count<T extends TcOpCompraCountArgs>(
      args?: Subset<T, TcOpCompraCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TcOpCompraCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TcOpCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCompraAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TcOpCompraAggregateArgs>(args: Subset<T, TcOpCompraAggregateArgs>): Prisma.PrismaPromise<GetTcOpCompraAggregateType<T>>

    /**
     * Group by TcOpCompra.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TcOpCompraGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TcOpCompraGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TcOpCompraGroupByArgs['orderBy'] }
        : { orderBy?: TcOpCompraGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TcOpCompraGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTcOpCompraGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TcOpCompra model
   */
  readonly fields: TcOpCompraFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TcOpCompra.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TcOpCompraClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    TcCompraConteudo<T extends TcOpCompra$TcCompraConteudoArgs<ExtArgs> = {}>(args?: Subset<T, TcOpCompra$TcCompraConteudoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TcCompraConteudoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    TcOp<T extends TcOpDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TcOpDefaultArgs<ExtArgs>>): Prisma__TcOpClient<$Result.GetResult<Prisma.$TcOpPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TcOpCompra model
   */ 
  interface TcOpCompraFieldRefs {
    readonly idCompra: FieldRef<"TcOpCompra", 'String'>
    readonly idCompraPhc: FieldRef<"TcOpCompra", 'String'>
    readonly nCompra: FieldRef<"TcOpCompra", 'Int'>
    readonly nome: FieldRef<"TcOpCompra", 'String'>
    readonly dataCompra: FieldRef<"TcOpCompra", 'DateTime'>
    readonly dataCompraString: FieldRef<"TcOpCompra", 'String'>
    readonly op: FieldRef<"TcOpCompra", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TcOpCompra findUnique
   */
  export type TcOpCompraFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * Filter, which TcOpCompra to fetch.
     */
    where: TcOpCompraWhereUniqueInput
  }

  /**
   * TcOpCompra findUniqueOrThrow
   */
  export type TcOpCompraFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * Filter, which TcOpCompra to fetch.
     */
    where: TcOpCompraWhereUniqueInput
  }

  /**
   * TcOpCompra findFirst
   */
  export type TcOpCompraFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * Filter, which TcOpCompra to fetch.
     */
    where?: TcOpCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOpCompras to fetch.
     */
    orderBy?: TcOpCompraOrderByWithRelationInput | TcOpCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcOpCompras.
     */
    cursor?: TcOpCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOpCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOpCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcOpCompras.
     */
    distinct?: TcOpCompraScalarFieldEnum | TcOpCompraScalarFieldEnum[]
  }

  /**
   * TcOpCompra findFirstOrThrow
   */
  export type TcOpCompraFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * Filter, which TcOpCompra to fetch.
     */
    where?: TcOpCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOpCompras to fetch.
     */
    orderBy?: TcOpCompraOrderByWithRelationInput | TcOpCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TcOpCompras.
     */
    cursor?: TcOpCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOpCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOpCompras.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TcOpCompras.
     */
    distinct?: TcOpCompraScalarFieldEnum | TcOpCompraScalarFieldEnum[]
  }

  /**
   * TcOpCompra findMany
   */
  export type TcOpCompraFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * Filter, which TcOpCompras to fetch.
     */
    where?: TcOpCompraWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TcOpCompras to fetch.
     */
    orderBy?: TcOpCompraOrderByWithRelationInput | TcOpCompraOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TcOpCompras.
     */
    cursor?: TcOpCompraWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TcOpCompras from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TcOpCompras.
     */
    skip?: number
    distinct?: TcOpCompraScalarFieldEnum | TcOpCompraScalarFieldEnum[]
  }

  /**
   * TcOpCompra create
   */
  export type TcOpCompraCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * The data needed to create a TcOpCompra.
     */
    data: XOR<TcOpCompraCreateInput, TcOpCompraUncheckedCreateInput>
  }

  /**
   * TcOpCompra createMany
   */
  export type TcOpCompraCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TcOpCompras.
     */
    data: TcOpCompraCreateManyInput | TcOpCompraCreateManyInput[]
  }

  /**
   * TcOpCompra update
   */
  export type TcOpCompraUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * The data needed to update a TcOpCompra.
     */
    data: XOR<TcOpCompraUpdateInput, TcOpCompraUncheckedUpdateInput>
    /**
     * Choose, which TcOpCompra to update.
     */
    where: TcOpCompraWhereUniqueInput
  }

  /**
   * TcOpCompra updateMany
   */
  export type TcOpCompraUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TcOpCompras.
     */
    data: XOR<TcOpCompraUpdateManyMutationInput, TcOpCompraUncheckedUpdateManyInput>
    /**
     * Filter which TcOpCompras to update
     */
    where?: TcOpCompraWhereInput
    /**
     * Limit how many TcOpCompras to update.
     */
    limit?: number
  }

  /**
   * TcOpCompra upsert
   */
  export type TcOpCompraUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * The filter to search for the TcOpCompra to update in case it exists.
     */
    where: TcOpCompraWhereUniqueInput
    /**
     * In case the TcOpCompra found by the `where` argument doesn't exist, create a new TcOpCompra with this data.
     */
    create: XOR<TcOpCompraCreateInput, TcOpCompraUncheckedCreateInput>
    /**
     * In case the TcOpCompra was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TcOpCompraUpdateInput, TcOpCompraUncheckedUpdateInput>
  }

  /**
   * TcOpCompra delete
   */
  export type TcOpCompraDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
    /**
     * Filter which TcOpCompra to delete.
     */
    where: TcOpCompraWhereUniqueInput
  }

  /**
   * TcOpCompra deleteMany
   */
  export type TcOpCompraDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TcOpCompras to delete
     */
    where?: TcOpCompraWhereInput
    /**
     * Limit how many TcOpCompras to delete.
     */
    limit?: number
  }

  /**
   * TcOpCompra.TcCompraConteudo
   */
  export type TcOpCompra$TcCompraConteudoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcCompraConteudo
     */
    select?: TcCompraConteudoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcCompraConteudo
     */
    omit?: TcCompraConteudoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcCompraConteudoInclude<ExtArgs> | null
    where?: TcCompraConteudoWhereInput
    orderBy?: TcCompraConteudoOrderByWithRelationInput | TcCompraConteudoOrderByWithRelationInput[]
    cursor?: TcCompraConteudoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TcCompraConteudoScalarFieldEnum | TcCompraConteudoScalarFieldEnum[]
  }

  /**
   * TcOpCompra without action
   */
  export type TcOpCompraDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TcOpCompra
     */
    select?: TcOpCompraSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TcOpCompra
     */
    omit?: TcOpCompraOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TcOpCompraInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    nomeUser: string | null
    pHashed: string | null
    nome: string | null
    apelido: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    nomeUser: string | null
    pHashed: string | null
    nome: string | null
    apelido: string | null
    email: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    nomeUser: number
    pHashed: number
    nome: number
    apelido: number
    email: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    nomeUser?: true
    pHashed?: true
    nome?: true
    apelido?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    nomeUser?: true
    pHashed?: true
    nome?: true
    apelido?: true
    email?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    nomeUser?: true
    pHashed?: true
    nome?: true
    apelido?: true
    email?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    nomeUser?: boolean
    pHashed?: boolean
    nome?: boolean
    apelido?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    DataCamiao?: boolean | User$DataCamiaoArgs<ExtArgs>
    DataEnvio?: boolean | User$DataEnvioArgs<ExtArgs>
    Livre?: boolean | User$LivreArgs<ExtArgs>
    Op?: boolean | User$OpArgs<ExtArgs>
    Planeamento?: boolean | User$PlaneamentoArgs<ExtArgs>
    UserPapeis?: boolean | User$UserPapeisArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    nomeUser?: boolean
    pHashed?: boolean
    nome?: boolean
    apelido?: boolean
    email?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"nomeUser" | "pHashed" | "nome" | "apelido" | "email" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    DataCamiao?: boolean | User$DataCamiaoArgs<ExtArgs>
    DataEnvio?: boolean | User$DataEnvioArgs<ExtArgs>
    Livre?: boolean | User$LivreArgs<ExtArgs>
    Op?: boolean | User$OpArgs<ExtArgs>
    Planeamento?: boolean | User$PlaneamentoArgs<ExtArgs>
    UserPapeis?: boolean | User$UserPapeisArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      DataCamiao: Prisma.$DataCamiaoPayload<ExtArgs>[]
      DataEnvio: Prisma.$DataEnvioPayload<ExtArgs>[]
      Livre: Prisma.$LivrePayload<ExtArgs>[]
      Op: Prisma.$OpPayload<ExtArgs>[]
      Planeamento: Prisma.$PlaneamentoPayload<ExtArgs>[]
      UserPapeis: Prisma.$UserPapeisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      nomeUser: string
      pHashed: string
      nome: string
      apelido: string
      email: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `nomeUser`
     * const userWithNomeUserOnly = await prisma.user.findMany({ select: { nomeUser: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    DataCamiao<T extends User$DataCamiaoArgs<ExtArgs> = {}>(args?: Subset<T, User$DataCamiaoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataCamiaoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    DataEnvio<T extends User$DataEnvioArgs<ExtArgs> = {}>(args?: Subset<T, User$DataEnvioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataEnvioPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Livre<T extends User$LivreArgs<ExtArgs> = {}>(args?: Subset<T, User$LivreArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LivrePayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Op<T extends User$OpArgs<ExtArgs> = {}>(args?: Subset<T, User$OpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OpPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    Planeamento<T extends User$PlaneamentoArgs<ExtArgs> = {}>(args?: Subset<T, User$PlaneamentoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlaneamentoPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    UserPapeis<T extends User$UserPapeisArgs<ExtArgs> = {}>(args?: Subset<T, User$UserPapeisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly nomeUser: FieldRef<"User", 'String'>
    readonly pHashed: FieldRef<"User", 'String'>
    readonly nome: FieldRef<"User", 'String'>
    readonly apelido: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.DataCamiao
   */
  export type User$DataCamiaoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataCamiao
     */
    select?: DataCamiaoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataCamiao
     */
    omit?: DataCamiaoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataCamiaoInclude<ExtArgs> | null
    where?: DataCamiaoWhereInput
    orderBy?: DataCamiaoOrderByWithRelationInput | DataCamiaoOrderByWithRelationInput[]
    cursor?: DataCamiaoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataCamiaoScalarFieldEnum | DataCamiaoScalarFieldEnum[]
  }

  /**
   * User.DataEnvio
   */
  export type User$DataEnvioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataEnvio
     */
    select?: DataEnvioSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DataEnvio
     */
    omit?: DataEnvioOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataEnvioInclude<ExtArgs> | null
    where?: DataEnvioWhereInput
    orderBy?: DataEnvioOrderByWithRelationInput | DataEnvioOrderByWithRelationInput[]
    cursor?: DataEnvioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataEnvioScalarFieldEnum | DataEnvioScalarFieldEnum[]
  }

  /**
   * User.Livre
   */
  export type User$LivreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Livre
     */
    select?: LivreSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Livre
     */
    omit?: LivreOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LivreInclude<ExtArgs> | null
    where?: LivreWhereInput
    orderBy?: LivreOrderByWithRelationInput | LivreOrderByWithRelationInput[]
    cursor?: LivreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LivreScalarFieldEnum | LivreScalarFieldEnum[]
  }

  /**
   * User.Op
   */
  export type User$OpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Op
     */
    select?: OpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Op
     */
    omit?: OpOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OpInclude<ExtArgs> | null
    where?: OpWhereInput
    orderBy?: OpOrderByWithRelationInput | OpOrderByWithRelationInput[]
    cursor?: OpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OpScalarFieldEnum | OpScalarFieldEnum[]
  }

  /**
   * User.Planeamento
   */
  export type User$PlaneamentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Planeamento
     */
    select?: PlaneamentoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Planeamento
     */
    omit?: PlaneamentoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlaneamentoInclude<ExtArgs> | null
    where?: PlaneamentoWhereInput
    orderBy?: PlaneamentoOrderByWithRelationInput | PlaneamentoOrderByWithRelationInput[]
    cursor?: PlaneamentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlaneamentoScalarFieldEnum | PlaneamentoScalarFieldEnum[]
  }

  /**
   * User.UserPapeis
   */
  export type User$UserPapeisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    where?: UserPapeisWhereInput
    orderBy?: UserPapeisOrderByWithRelationInput | UserPapeisOrderByWithRelationInput[]
    cursor?: UserPapeisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserPapeisScalarFieldEnum | UserPapeisScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserPapeis
   */

  export type AggregateUserPapeis = {
    _count: UserPapeisCountAggregateOutputType | null
    _min: UserPapeisMinAggregateOutputType | null
    _max: UserPapeisMaxAggregateOutputType | null
  }

  export type UserPapeisMinAggregateOutputType = {
    idPapel: string | null
    nomeUser: string | null
  }

  export type UserPapeisMaxAggregateOutputType = {
    idPapel: string | null
    nomeUser: string | null
  }

  export type UserPapeisCountAggregateOutputType = {
    idPapel: number
    nomeUser: number
    _all: number
  }


  export type UserPapeisMinAggregateInputType = {
    idPapel?: true
    nomeUser?: true
  }

  export type UserPapeisMaxAggregateInputType = {
    idPapel?: true
    nomeUser?: true
  }

  export type UserPapeisCountAggregateInputType = {
    idPapel?: true
    nomeUser?: true
    _all?: true
  }

  export type UserPapeisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPapeis to aggregate.
     */
    where?: UserPapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPapeis to fetch.
     */
    orderBy?: UserPapeisOrderByWithRelationInput | UserPapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPapeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPapeis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPapeis
    **/
    _count?: true | UserPapeisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPapeisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPapeisMaxAggregateInputType
  }

  export type GetUserPapeisAggregateType<T extends UserPapeisAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPapeis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPapeis[P]>
      : GetScalarType<T[P], AggregateUserPapeis[P]>
  }




  export type UserPapeisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPapeisWhereInput
    orderBy?: UserPapeisOrderByWithAggregationInput | UserPapeisOrderByWithAggregationInput[]
    by: UserPapeisScalarFieldEnum[] | UserPapeisScalarFieldEnum
    having?: UserPapeisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPapeisCountAggregateInputType | true
    _min?: UserPapeisMinAggregateInputType
    _max?: UserPapeisMaxAggregateInputType
  }

  export type UserPapeisGroupByOutputType = {
    idPapel: string
    nomeUser: string
    _count: UserPapeisCountAggregateOutputType | null
    _min: UserPapeisMinAggregateOutputType | null
    _max: UserPapeisMaxAggregateOutputType | null
  }

  type GetUserPapeisGroupByPayload<T extends UserPapeisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPapeisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPapeisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPapeisGroupByOutputType[P]>
            : GetScalarType<T[P], UserPapeisGroupByOutputType[P]>
        }
      >
    >


  export type UserPapeisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    idPapel?: boolean
    nomeUser?: boolean
    Papeis?: boolean | PapeisDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPapeis"]>



  export type UserPapeisSelectScalar = {
    idPapel?: boolean
    nomeUser?: boolean
  }

  export type UserPapeisOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"idPapel" | "nomeUser", ExtArgs["result"]["userPapeis"]>
  export type UserPapeisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Papeis?: boolean | PapeisDefaultArgs<ExtArgs>
    User?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPapeisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPapeis"
    objects: {
      Papeis: Prisma.$PapeisPayload<ExtArgs>
      User: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      idPapel: string
      nomeUser: string
    }, ExtArgs["result"]["userPapeis"]>
    composites: {}
  }

  type UserPapeisGetPayload<S extends boolean | null | undefined | UserPapeisDefaultArgs> = $Result.GetResult<Prisma.$UserPapeisPayload, S>

  type UserPapeisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPapeisFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPapeisCountAggregateInputType | true
    }

  export interface UserPapeisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPapeis'], meta: { name: 'UserPapeis' } }
    /**
     * Find zero or one UserPapeis that matches the filter.
     * @param {UserPapeisFindUniqueArgs} args - Arguments to find a UserPapeis
     * @example
     * // Get one UserPapeis
     * const userPapeis = await prisma.userPapeis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPapeisFindUniqueArgs>(args: SelectSubset<T, UserPapeisFindUniqueArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserPapeis that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPapeisFindUniqueOrThrowArgs} args - Arguments to find a UserPapeis
     * @example
     * // Get one UserPapeis
     * const userPapeis = await prisma.userPapeis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPapeisFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPapeisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserPapeis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPapeisFindFirstArgs} args - Arguments to find a UserPapeis
     * @example
     * // Get one UserPapeis
     * const userPapeis = await prisma.userPapeis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPapeisFindFirstArgs>(args?: SelectSubset<T, UserPapeisFindFirstArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserPapeis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPapeisFindFirstOrThrowArgs} args - Arguments to find a UserPapeis
     * @example
     * // Get one UserPapeis
     * const userPapeis = await prisma.userPapeis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPapeisFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPapeisFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserPapeis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPapeisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPapeis
     * const userPapeis = await prisma.userPapeis.findMany()
     * 
     * // Get first 10 UserPapeis
     * const userPapeis = await prisma.userPapeis.findMany({ take: 10 })
     * 
     * // Only select the `idPapel`
     * const userPapeisWithIdPapelOnly = await prisma.userPapeis.findMany({ select: { idPapel: true } })
     * 
     */
    findMany<T extends UserPapeisFindManyArgs>(args?: SelectSubset<T, UserPapeisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserPapeis.
     * @param {UserPapeisCreateArgs} args - Arguments to create a UserPapeis.
     * @example
     * // Create one UserPapeis
     * const UserPapeis = await prisma.userPapeis.create({
     *   data: {
     *     // ... data to create a UserPapeis
     *   }
     * })
     * 
     */
    create<T extends UserPapeisCreateArgs>(args: SelectSubset<T, UserPapeisCreateArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserPapeis.
     * @param {UserPapeisCreateManyArgs} args - Arguments to create many UserPapeis.
     * @example
     * // Create many UserPapeis
     * const userPapeis = await prisma.userPapeis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPapeisCreateManyArgs>(args?: SelectSubset<T, UserPapeisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserPapeis.
     * @param {UserPapeisDeleteArgs} args - Arguments to delete one UserPapeis.
     * @example
     * // Delete one UserPapeis
     * const UserPapeis = await prisma.userPapeis.delete({
     *   where: {
     *     // ... filter to delete one UserPapeis
     *   }
     * })
     * 
     */
    delete<T extends UserPapeisDeleteArgs>(args: SelectSubset<T, UserPapeisDeleteArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserPapeis.
     * @param {UserPapeisUpdateArgs} args - Arguments to update one UserPapeis.
     * @example
     * // Update one UserPapeis
     * const userPapeis = await prisma.userPapeis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPapeisUpdateArgs>(args: SelectSubset<T, UserPapeisUpdateArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserPapeis.
     * @param {UserPapeisDeleteManyArgs} args - Arguments to filter UserPapeis to delete.
     * @example
     * // Delete a few UserPapeis
     * const { count } = await prisma.userPapeis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPapeisDeleteManyArgs>(args?: SelectSubset<T, UserPapeisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPapeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPapeisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPapeis
     * const userPapeis = await prisma.userPapeis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPapeisUpdateManyArgs>(args: SelectSubset<T, UserPapeisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserPapeis.
     * @param {UserPapeisUpsertArgs} args - Arguments to update or create a UserPapeis.
     * @example
     * // Update or create a UserPapeis
     * const userPapeis = await prisma.userPapeis.upsert({
     *   create: {
     *     // ... data to create a UserPapeis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPapeis we want to update
     *   }
     * })
     */
    upsert<T extends UserPapeisUpsertArgs>(args: SelectSubset<T, UserPapeisUpsertArgs<ExtArgs>>): Prisma__UserPapeisClient<$Result.GetResult<Prisma.$UserPapeisPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserPapeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPapeisCountArgs} args - Arguments to filter UserPapeis to count.
     * @example
     * // Count the number of UserPapeis
     * const count = await prisma.userPapeis.count({
     *   where: {
     *     // ... the filter for the UserPapeis we want to count
     *   }
     * })
    **/
    count<T extends UserPapeisCountArgs>(
      args?: Subset<T, UserPapeisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPapeisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPapeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPapeisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPapeisAggregateArgs>(args: Subset<T, UserPapeisAggregateArgs>): Prisma.PrismaPromise<GetUserPapeisAggregateType<T>>

    /**
     * Group by UserPapeis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPapeisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPapeisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPapeisGroupByArgs['orderBy'] }
        : { orderBy?: UserPapeisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPapeisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPapeisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPapeis model
   */
  readonly fields: UserPapeisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPapeis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPapeisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Papeis<T extends PapeisDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PapeisDefaultArgs<ExtArgs>>): Prisma__PapeisClient<$Result.GetResult<Prisma.$PapeisPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPapeis model
   */ 
  interface UserPapeisFieldRefs {
    readonly idPapel: FieldRef<"UserPapeis", 'String'>
    readonly nomeUser: FieldRef<"UserPapeis", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserPapeis findUnique
   */
  export type UserPapeisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * Filter, which UserPapeis to fetch.
     */
    where: UserPapeisWhereUniqueInput
  }

  /**
   * UserPapeis findUniqueOrThrow
   */
  export type UserPapeisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * Filter, which UserPapeis to fetch.
     */
    where: UserPapeisWhereUniqueInput
  }

  /**
   * UserPapeis findFirst
   */
  export type UserPapeisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * Filter, which UserPapeis to fetch.
     */
    where?: UserPapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPapeis to fetch.
     */
    orderBy?: UserPapeisOrderByWithRelationInput | UserPapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPapeis.
     */
    cursor?: UserPapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPapeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPapeis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPapeis.
     */
    distinct?: UserPapeisScalarFieldEnum | UserPapeisScalarFieldEnum[]
  }

  /**
   * UserPapeis findFirstOrThrow
   */
  export type UserPapeisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * Filter, which UserPapeis to fetch.
     */
    where?: UserPapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPapeis to fetch.
     */
    orderBy?: UserPapeisOrderByWithRelationInput | UserPapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPapeis.
     */
    cursor?: UserPapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPapeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPapeis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPapeis.
     */
    distinct?: UserPapeisScalarFieldEnum | UserPapeisScalarFieldEnum[]
  }

  /**
   * UserPapeis findMany
   */
  export type UserPapeisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * Filter, which UserPapeis to fetch.
     */
    where?: UserPapeisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPapeis to fetch.
     */
    orderBy?: UserPapeisOrderByWithRelationInput | UserPapeisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPapeis.
     */
    cursor?: UserPapeisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPapeis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPapeis.
     */
    skip?: number
    distinct?: UserPapeisScalarFieldEnum | UserPapeisScalarFieldEnum[]
  }

  /**
   * UserPapeis create
   */
  export type UserPapeisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPapeis.
     */
    data: XOR<UserPapeisCreateInput, UserPapeisUncheckedCreateInput>
  }

  /**
   * UserPapeis createMany
   */
  export type UserPapeisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPapeis.
     */
    data: UserPapeisCreateManyInput | UserPapeisCreateManyInput[]
  }

  /**
   * UserPapeis update
   */
  export type UserPapeisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPapeis.
     */
    data: XOR<UserPapeisUpdateInput, UserPapeisUncheckedUpdateInput>
    /**
     * Choose, which UserPapeis to update.
     */
    where: UserPapeisWhereUniqueInput
  }

  /**
   * UserPapeis updateMany
   */
  export type UserPapeisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPapeis.
     */
    data: XOR<UserPapeisUpdateManyMutationInput, UserPapeisUncheckedUpdateManyInput>
    /**
     * Filter which UserPapeis to update
     */
    where?: UserPapeisWhereInput
    /**
     * Limit how many UserPapeis to update.
     */
    limit?: number
  }

  /**
   * UserPapeis upsert
   */
  export type UserPapeisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPapeis to update in case it exists.
     */
    where: UserPapeisWhereUniqueInput
    /**
     * In case the UserPapeis found by the `where` argument doesn't exist, create a new UserPapeis with this data.
     */
    create: XOR<UserPapeisCreateInput, UserPapeisUncheckedCreateInput>
    /**
     * In case the UserPapeis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPapeisUpdateInput, UserPapeisUncheckedUpdateInput>
  }

  /**
   * UserPapeis delete
   */
  export type UserPapeisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
    /**
     * Filter which UserPapeis to delete.
     */
    where: UserPapeisWhereUniqueInput
  }

  /**
   * UserPapeis deleteMany
   */
  export type UserPapeisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPapeis to delete
     */
    where?: UserPapeisWhereInput
    /**
     * Limit how many UserPapeis to delete.
     */
    limit?: number
  }

  /**
   * UserPapeis without action
   */
  export type UserPapeisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPapeis
     */
    select?: UserPapeisSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPapeis
     */
    omit?: UserPapeisOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPapeisInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable',
    Snapshot: 'Snapshot'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BmScalarFieldEnum: {
    idBm: 'idBm',
    composicao: 'composicao',
    fechado: 'fechado',
    CreatedAt: 'CreatedAt'
  };

  export type BmScalarFieldEnum = (typeof BmScalarFieldEnum)[keyof typeof BmScalarFieldEnum]


  export const BmFioComposicaoScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    refOrigem: 'refOrigem',
    idComposicao: 'idComposicao',
    qtt: 'qtt'
  };

  export type BmFioComposicaoScalarFieldEnum = (typeof BmFioComposicaoScalarFieldEnum)[keyof typeof BmFioComposicaoScalarFieldEnum]


  export const BmIdBmComposicaoScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    idComposicao: 'idComposicao',
    qtt: 'qtt'
  };

  export type BmIdBmComposicaoScalarFieldEnum = (typeof BmIdBmComposicaoScalarFieldEnum)[keyof typeof BmIdBmComposicaoScalarFieldEnum]


  export const BmMalhasScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    malha: 'malha',
    grupo: 'grupo',
    subGrupo: 'subGrupo',
    qtdePedida: 'qtdePedida',
    qtdeEntrada: 'qtdeEntrada',
    qtdeEntradaSeUnidade: 'qtdeEntradaSeUnidade',
    defeitosStock: 'defeitosStock',
    sobras: 'sobras',
    unidade: 'unidade',
    lote: 'lote'
  };

  export type BmMalhasScalarFieldEnum = (typeof BmMalhasScalarFieldEnum)[keyof typeof BmMalhasScalarFieldEnum]


  export const BmMalhasFioScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    refOrigem: 'refOrigem',
    fio: 'fio',
    grupo: 'grupo',
    subGrupo: 'subGrupo',
    qtdePedida: 'qtdePedida',
    qtdeEntrada: 'qtdeEntrada',
    defeitosStock: 'defeitosStock',
    sobras: 'sobras',
    unidade: 'unidade',
    lote: 'lote'
  };

  export type BmMalhasFioScalarFieldEnum = (typeof BmMalhasFioScalarFieldEnum)[keyof typeof BmMalhasFioScalarFieldEnum]


  export const BmMalhasFioMovimentosScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    refOrigem: 'refOrigem',
    op: 'op',
    idBmMovimentosLote: 'idBmMovimentosLote',
    idMovimento: 'idMovimento',
    nMovimento: 'nMovimento',
    nome: 'nome',
    idTipo: 'idTipo',
    tipo: 'tipo',
    qtt: 'qtt',
    unidade: 'unidade',
    lote: 'lote'
  };

  export type BmMalhasFioMovimentosScalarFieldEnum = (typeof BmMalhasFioMovimentosScalarFieldEnum)[keyof typeof BmMalhasFioMovimentosScalarFieldEnum]


  export const BmMateriaisScalarFieldEnum: {
    grupo: 'grupo',
    subGrupo: 'subGrupo'
  };

  export type BmMateriaisScalarFieldEnum = (typeof BmMateriaisScalarFieldEnum)[keyof typeof BmMateriaisScalarFieldEnum]


  export const BmMateriaisComposicaoScalarFieldEnum: {
    idComposicao: 'idComposicao',
    composicao: 'composicao',
    composicaoAbreviatura: 'composicaoAbreviatura',
    ordem: 'ordem',
    inactivo: 'inactivo'
  };

  export type BmMateriaisComposicaoScalarFieldEnum = (typeof BmMateriaisComposicaoScalarFieldEnum)[keyof typeof BmMateriaisComposicaoScalarFieldEnum]


  export const BmMateriaisFioScalarFieldEnum: {
    grupo: 'grupo',
    subGrupo: 'subGrupo'
  };

  export type BmMateriaisFioScalarFieldEnum = (typeof BmMateriaisFioScalarFieldEnum)[keyof typeof BmMateriaisFioScalarFieldEnum]


  export const BmMaterialGrupoScalarFieldEnum: {
    grupo: 'grupo',
    grupoDescricao: 'grupoDescricao'
  };

  export type BmMaterialGrupoScalarFieldEnum = (typeof BmMaterialGrupoScalarFieldEnum)[keyof typeof BmMaterialGrupoScalarFieldEnum]


  export const BmMaterialGrupoFioScalarFieldEnum: {
    grupo: 'grupo',
    grupoDescricao: 'grupoDescricao'
  };

  export type BmMaterialGrupoFioScalarFieldEnum = (typeof BmMaterialGrupoFioScalarFieldEnum)[keyof typeof BmMaterialGrupoFioScalarFieldEnum]


  export const BmMaterialSubGrupoScalarFieldEnum: {
    subGrupo: 'subGrupo',
    subGrupoDescricao: 'subGrupoDescricao'
  };

  export type BmMaterialSubGrupoScalarFieldEnum = (typeof BmMaterialSubGrupoScalarFieldEnum)[keyof typeof BmMaterialSubGrupoScalarFieldEnum]


  export const BmMaterialSubGrupoFioScalarFieldEnum: {
    subGrupo: 'subGrupo',
    subGrupoDescricao: 'subGrupoDescricao'
  };

  export type BmMaterialSubGrupoFioScalarFieldEnum = (typeof BmMaterialSubGrupoFioScalarFieldEnum)[keyof typeof BmMaterialSubGrupoFioScalarFieldEnum]


  export const BmMovimentosLotesScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    op: 'op',
    idBmMovimentosLote: 'idBmMovimentosLote',
    idMovimento: 'idMovimento',
    nMovimento: 'nMovimento',
    nome: 'nome',
    idTipo: 'idTipo',
    tipo: 'tipo',
    qtt: 'qtt',
    unidade: 'unidade',
    lote: 'lote'
  };

  export type BmMovimentosLotesScalarFieldEnum = (typeof BmMovimentosLotesScalarFieldEnum)[keyof typeof BmMovimentosLotesScalarFieldEnum]


  export const BmOpScalarFieldEnum: {
    idBm: 'idBm',
    op: 'op',
    CreatedAt: 'CreatedAt',
    foto: 'foto'
  };

  export type BmOpScalarFieldEnum = (typeof BmOpScalarFieldEnum)[keyof typeof BmOpScalarFieldEnum]


  export const BmOpFaturadoScalarFieldEnum: {
    idBm: 'idBm',
    op: 'op',
    nFatutura: 'nFatutura',
    fData: 'fData',
    dataFatura: 'dataFatura',
    refModelo: 'refModelo',
    pedido: 'pedido',
    qtt: 'qtt',
    pesoLiquido: 'pesoLiquido',
    pesoBruto: 'pesoBruto',
    cmr: 'cmr',
    local: 'local',
    obs: 'obs'
  };

  export type BmOpFaturadoScalarFieldEnum = (typeof BmOpFaturadoScalarFieldEnum)[keyof typeof BmOpFaturadoScalarFieldEnum]


  export const BmOpsPorMalhaScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    op: 'op'
  };

  export type BmOpsPorMalhaScalarFieldEnum = (typeof BmOpsPorMalhaScalarFieldEnum)[keyof typeof BmOpsPorMalhaScalarFieldEnum]


  export const BmOpsPorMalhaFioScalarFieldEnum: {
    idBm: 'idBm',
    ref: 'ref',
    refOrigem: 'refOrigem',
    op: 'op'
  };

  export type BmOpsPorMalhaFioScalarFieldEnum = (typeof BmOpsPorMalhaFioScalarFieldEnum)[keyof typeof BmOpsPorMalhaFioScalarFieldEnum]


  export const BmTcScalarFieldEnum: {
    idBm: 'idBm',
    nomeTc: 'nomeTc'
  };

  export type BmTcScalarFieldEnum = (typeof BmTcScalarFieldEnum)[keyof typeof BmTcScalarFieldEnum]


  export const DataCamiaoScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    IdCamiao: 'IdCamiao',
    nomeUser: 'nomeUser',
    dataCamiao: 'dataCamiao',
    quantidade: 'quantidade',
    percentagem: 'percentagem',
    obs: 'obs'
  };

  export type DataCamiaoScalarFieldEnum = (typeof DataCamiaoScalarFieldEnum)[keyof typeof DataCamiaoScalarFieldEnum]


  export const DataEnvioScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    idEnvio: 'idEnvio',
    nomeUser: 'nomeUser',
    dataEnvio: 'dataEnvio',
    quantidade: 'quantidade',
    percentagem: 'percentagem',
    obs: 'obs'
  };

  export type DataEnvioScalarFieldEnum = (typeof DataEnvioScalarFieldEnum)[keyof typeof DataEnvioScalarFieldEnum]


  export const FornecedorScalarFieldEnum: {
    idFornecedor: 'idFornecedor',
    nomeFornecedor: 'nomeFornecedor'
  };

  export type FornecedorScalarFieldEnum = (typeof FornecedorScalarFieldEnum)[keyof typeof FornecedorScalarFieldEnum]


  export const LivreScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    idLivre: 'idLivre',
    nomeUser: 'nomeUser',
    Op: 'Op',
    nOp: 'nOp',
    orcamentoStamp: 'orcamentoStamp',
    nOrcamento: 'nOrcamento',
    anoOrcamento: 'anoOrcamento',
    desenho: 'desenho',
    modelo: 'modelo',
    cor: 'cor',
    pedidoCliente: 'pedidoCliente',
    imagem: 'imagem',
    cortaPt: 'cortaPt'
  };

  export type LivreScalarFieldEnum = (typeof LivreScalarFieldEnum)[keyof typeof LivreScalarFieldEnum]


  export const OpScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    Op: 'Op',
    nomeUser: 'nomeUser',
    nOp: 'nOp',
    modelo: 'modelo',
    cor: 'cor',
    pedidoCliente: 'pedidoCliente',
    imagem: 'imagem',
    cortaPt: 'cortaPt'
  };

  export type OpScalarFieldEnum = (typeof OpScalarFieldEnum)[keyof typeof OpScalarFieldEnum]


  export const OrcamentoLivreScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    idLivre: 'idLivre',
    orcamentoStamp: 'orcamentoStamp',
    orcamentoNumero: 'orcamentoNumero',
    ano: 'ano'
  };

  export type OrcamentoLivreScalarFieldEnum = (typeof OrcamentoLivreScalarFieldEnum)[keyof typeof OrcamentoLivreScalarFieldEnum]


  export const OrcamentoLivreLinhasScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    idLivre: 'idLivre',
    orcamentoStamp: 'orcamentoStamp',
    orcamentoLinhasStamp: 'orcamentoLinhasStamp',
    orcamentoLinhasStampRecebido: 'orcamentoLinhasStampRecebido',
    ordem: 'ordem',
    design: 'design',
    custoPeca: 'custoPeca',
    edebito: 'edebito',
    qtt: 'qtt',
    unidade: 'unidade'
  };

  export type OrcamentoLivreLinhasScalarFieldEnum = (typeof OrcamentoLivreLinhasScalarFieldEnum)[keyof typeof OrcamentoLivreLinhasScalarFieldEnum]


  export const OrcamentoOpScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    Op: 'Op',
    orcamentoStamp: 'orcamentoStamp',
    orcamentoNumero: 'orcamentoNumero',
    ano: 'ano'
  };

  export type OrcamentoOpScalarFieldEnum = (typeof OrcamentoOpScalarFieldEnum)[keyof typeof OrcamentoOpScalarFieldEnum]


  export const OrcamentoOpLinhasScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    Op: 'Op',
    orcamentoStamp: 'orcamentoStamp',
    orcamentoLinhasStamp: 'orcamentoLinhasStamp',
    orcamentoLinhasStampRecebido: 'orcamentoLinhasStampRecebido',
    ordem: 'ordem',
    design: 'design',
    custoPeca: 'custoPeca',
    edebito: 'edebito',
    qtt: 'qtt',
    unidade: 'unidade'
  };

  export type OrcamentoOpLinhasScalarFieldEnum = (typeof OrcamentoOpLinhasScalarFieldEnum)[keyof typeof OrcamentoOpLinhasScalarFieldEnum]


  export const PapeisScalarFieldEnum: {
    idPapeis: 'idPapeis',
    descPapel: 'descPapel'
  };

  export type PapeisScalarFieldEnum = (typeof PapeisScalarFieldEnum)[keyof typeof PapeisScalarFieldEnum]


  export const PlaneamentoScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    nomeUser: 'nomeUser',
    pais: 'pais',
    idFornecedor: 'idFornecedor',
    numeroPecas: 'numeroPecas',
    modelo: 'modelo',
    obs: 'obs',
    cliente: 'cliente',
    dataPrimeiroCamiao: 'dataPrimeiroCamiao',
    dataPrimeiroEnvio: 'dataPrimeiroEnvio',
    dataCriacao: 'dataCriacao',
    dataUltimaAlteracao: 'dataUltimaAlteracao',
    envioEnviado: 'envioEnviado'
  };

  export type PlaneamentoScalarFieldEnum = (typeof PlaneamentoScalarFieldEnum)[keyof typeof PlaneamentoScalarFieldEnum]


  export const ServicosEscolhidosLivreScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    idLivre: 'idLivre',
    idServicoEscolhido: 'idServicoEscolhido',
    nome: 'nome',
    qtt: 'qtt',
    preco: 'preco',
    valor: 'valor',
    unidade: 'unidade',
    obs: 'obs'
  };

  export type ServicosEscolhidosLivreScalarFieldEnum = (typeof ServicosEscolhidosLivreScalarFieldEnum)[keyof typeof ServicosEscolhidosLivreScalarFieldEnum]


  export const ServicosEscolhidosLivreOrigemScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    idLivre: 'idLivre',
    idServicoEscolhido: 'idServicoEscolhido',
    orcamentoLinhasStamp: 'orcamentoLinhasStamp'
  };

  export type ServicosEscolhidosLivreOrigemScalarFieldEnum = (typeof ServicosEscolhidosLivreOrigemScalarFieldEnum)[keyof typeof ServicosEscolhidosLivreOrigemScalarFieldEnum]


  export const ServicosEscolhidosOpScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    Op: 'Op',
    idServicoEscolhido: 'idServicoEscolhido',
    nome: 'nome',
    qtt: 'qtt',
    preco: 'preco',
    valor: 'valor',
    unidade: 'unidade',
    obs: 'obs'
  };

  export type ServicosEscolhidosOpScalarFieldEnum = (typeof ServicosEscolhidosOpScalarFieldEnum)[keyof typeof ServicosEscolhidosOpScalarFieldEnum]


  export const ServicosEscolhidosOpOrigemScalarFieldEnum: {
    idPlaneamento: 'idPlaneamento',
    Op: 'Op',
    idServicoEscolhido: 'idServicoEscolhido',
    orcamentoLinhasStamp: 'orcamentoLinhasStamp'
  };

  export type ServicosEscolhidosOpOrigemScalarFieldEnum = (typeof ServicosEscolhidosOpOrigemScalarFieldEnum)[keyof typeof ServicosEscolhidosOpOrigemScalarFieldEnum]


  export const SysdiagramsScalarFieldEnum: {
    name: 'name',
    principal_id: 'principal_id',
    diagram_id: 'diagram_id',
    version: 'version',
    definition: 'definition'
  };

  export type SysdiagramsScalarFieldEnum = (typeof SysdiagramsScalarFieldEnum)[keyof typeof SysdiagramsScalarFieldEnum]


  export const TcScalarFieldEnum: {
    idTc: 'idTc',
    fechado: 'fechado',
    createdAt: 'createdAt'
  };

  export type TcScalarFieldEnum = (typeof TcScalarFieldEnum)[keyof typeof TcScalarFieldEnum]


  export const TcCompraConteudoScalarFieldEnum: {
    idCompra: 'idCompra',
    idConteudoCompraPhc: 'idConteudoCompraPhc',
    refTipo: 'refTipo',
    ref: 'ref',
    design: 'design',
    qtt: 'qtt',
    cor: 'cor',
    tam: 'tam',
    unidade: 'unidade',
    largura: 'largura',
    gramagem: 'gramagem',
    op: 'op'
  };

  export type TcCompraConteudoScalarFieldEnum = (typeof TcCompraConteudoScalarFieldEnum)[keyof typeof TcCompraConteudoScalarFieldEnum]


  export const TcCompraConteudoEntradaScalarFieldEnum: {
    idConteudoEntradaPhc: 'idConteudoEntradaPhc',
    idConteudoCompraPhc: 'idConteudoCompraPhc',
    nEntrada: 'nEntrada',
    Nguia: 'Nguia',
    dataEntrada: 'dataEntrada',
    dataEntradaString: 'dataEntradaString',
    qtt: 'qtt',
    cor: 'cor',
    tam: 'tam',
    unidade: 'unidade',
    largura: 'largura',
    gramagem: 'gramagem',
    lote: 'lote',
    op: 'op'
  };

  export type TcCompraConteudoEntradaScalarFieldEnum = (typeof TcCompraConteudoEntradaScalarFieldEnum)[keyof typeof TcCompraConteudoEntradaScalarFieldEnum]


  export const TcCompraConteudoEntradaFaturadaScalarFieldEnum: {
    idFaturaPhc: 'idFaturaPhc',
    idConteudoEntradaPhc: 'idConteudoEntradaPhc',
    nGuiaPhc: 'nGuiaPhc',
    nFatura: 'nFatura',
    dataFatura: 'dataFatura',
    dataFaturaString: 'dataFaturaString',
    qtt: 'qtt',
    unidade: 'unidade',
    lote: 'lote',
    op: 'op'
  };

  export type TcCompraConteudoEntradaFaturadaScalarFieldEnum = (typeof TcCompraConteudoEntradaFaturadaScalarFieldEnum)[keyof typeof TcCompraConteudoEntradaFaturadaScalarFieldEnum]


  export const TcOpScalarFieldEnum: {
    idTc: 'idTc',
    op: 'op',
    foto: 'foto',
    createdAt: 'createdAt'
  };

  export type TcOpScalarFieldEnum = (typeof TcOpScalarFieldEnum)[keyof typeof TcOpScalarFieldEnum]


  export const TcOpCompraScalarFieldEnum: {
    idCompra: 'idCompra',
    idCompraPhc: 'idCompraPhc',
    nCompra: 'nCompra',
    nome: 'nome',
    dataCompra: 'dataCompra',
    dataCompraString: 'dataCompraString',
    op: 'op'
  };

  export type TcOpCompraScalarFieldEnum = (typeof TcOpCompraScalarFieldEnum)[keyof typeof TcOpCompraScalarFieldEnum]


  export const UserScalarFieldEnum: {
    nomeUser: 'nomeUser',
    pHashed: 'pHashed',
    nome: 'nome',
    apelido: 'apelido',
    email: 'email',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserPapeisScalarFieldEnum: {
    idPapel: 'idPapel',
    nomeUser: 'nomeUser'
  };

  export type UserPapeisScalarFieldEnum = (typeof UserPapeisScalarFieldEnum)[keyof typeof UserPapeisScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    
  /**
   * Deep Input Types
   */


  export type BmWhereInput = {
    AND?: BmWhereInput | BmWhereInput[]
    OR?: BmWhereInput[]
    NOT?: BmWhereInput | BmWhereInput[]
    idBm?: StringFilter<"Bm"> | string
    composicao?: StringFilter<"Bm"> | string
    fechado?: BoolFilter<"Bm"> | boolean
    CreatedAt?: DateTimeFilter<"Bm"> | Date | string
    BmMalhas?: BmMalhasListRelationFilter
    BmOp?: BmOpListRelationFilter
    BmTc?: BmTcListRelationFilter
  }

  export type BmOrderByWithRelationInput = {
    idBm?: SortOrder
    composicao?: SortOrder
    fechado?: SortOrder
    CreatedAt?: SortOrder
    BmMalhas?: BmMalhasOrderByRelationAggregateInput
    BmOp?: BmOpOrderByRelationAggregateInput
    BmTc?: BmTcOrderByRelationAggregateInput
  }

  export type BmWhereUniqueInput = Prisma.AtLeast<{
    idBm?: string
    AND?: BmWhereInput | BmWhereInput[]
    OR?: BmWhereInput[]
    NOT?: BmWhereInput | BmWhereInput[]
    composicao?: StringFilter<"Bm"> | string
    fechado?: BoolFilter<"Bm"> | boolean
    CreatedAt?: DateTimeFilter<"Bm"> | Date | string
    BmMalhas?: BmMalhasListRelationFilter
    BmOp?: BmOpListRelationFilter
    BmTc?: BmTcListRelationFilter
  }, "idBm">

  export type BmOrderByWithAggregationInput = {
    idBm?: SortOrder
    composicao?: SortOrder
    fechado?: SortOrder
    CreatedAt?: SortOrder
    _count?: BmCountOrderByAggregateInput
    _max?: BmMaxOrderByAggregateInput
    _min?: BmMinOrderByAggregateInput
  }

  export type BmScalarWhereWithAggregatesInput = {
    AND?: BmScalarWhereWithAggregatesInput | BmScalarWhereWithAggregatesInput[]
    OR?: BmScalarWhereWithAggregatesInput[]
    NOT?: BmScalarWhereWithAggregatesInput | BmScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"Bm"> | string
    composicao?: StringWithAggregatesFilter<"Bm"> | string
    fechado?: BoolWithAggregatesFilter<"Bm"> | boolean
    CreatedAt?: DateTimeWithAggregatesFilter<"Bm"> | Date | string
  }

  export type BmFioComposicaoWhereInput = {
    AND?: BmFioComposicaoWhereInput | BmFioComposicaoWhereInput[]
    OR?: BmFioComposicaoWhereInput[]
    NOT?: BmFioComposicaoWhereInput | BmFioComposicaoWhereInput[]
    idBm?: StringFilter<"BmFioComposicao"> | string
    ref?: StringFilter<"BmFioComposicao"> | string
    refOrigem?: StringFilter<"BmFioComposicao"> | string
    idComposicao?: IntFilter<"BmFioComposicao"> | number
    qtt?: DecimalFilter<"BmFioComposicao"> | Decimal | DecimalJsLike | number | string
    BmMalhasFio?: XOR<BmMalhasFioScalarRelationFilter, BmMalhasFioWhereInput>
    BmMateriaisComposicao?: XOR<BmMateriaisComposicaoScalarRelationFilter, BmMateriaisComposicaoWhereInput>
  }

  export type BmFioComposicaoOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
    BmMalhasFio?: BmMalhasFioOrderByWithRelationInput
    BmMateriaisComposicao?: BmMateriaisComposicaoOrderByWithRelationInput
  }

  export type BmFioComposicaoWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref_refOrigem_idComposicao?: BmFioComposicaoIdBmRefRefOrigemIdComposicaoCompoundUniqueInput
    AND?: BmFioComposicaoWhereInput | BmFioComposicaoWhereInput[]
    OR?: BmFioComposicaoWhereInput[]
    NOT?: BmFioComposicaoWhereInput | BmFioComposicaoWhereInput[]
    idBm?: StringFilter<"BmFioComposicao"> | string
    ref?: StringFilter<"BmFioComposicao"> | string
    refOrigem?: StringFilter<"BmFioComposicao"> | string
    idComposicao?: IntFilter<"BmFioComposicao"> | number
    qtt?: DecimalFilter<"BmFioComposicao"> | Decimal | DecimalJsLike | number | string
    BmMalhasFio?: XOR<BmMalhasFioScalarRelationFilter, BmMalhasFioWhereInput>
    BmMateriaisComposicao?: XOR<BmMateriaisComposicaoScalarRelationFilter, BmMateriaisComposicaoWhereInput>
  }, "idBm_ref_refOrigem_idComposicao">

  export type BmFioComposicaoOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
    _count?: BmFioComposicaoCountOrderByAggregateInput
    _avg?: BmFioComposicaoAvgOrderByAggregateInput
    _max?: BmFioComposicaoMaxOrderByAggregateInput
    _min?: BmFioComposicaoMinOrderByAggregateInput
    _sum?: BmFioComposicaoSumOrderByAggregateInput
  }

  export type BmFioComposicaoScalarWhereWithAggregatesInput = {
    AND?: BmFioComposicaoScalarWhereWithAggregatesInput | BmFioComposicaoScalarWhereWithAggregatesInput[]
    OR?: BmFioComposicaoScalarWhereWithAggregatesInput[]
    NOT?: BmFioComposicaoScalarWhereWithAggregatesInput | BmFioComposicaoScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmFioComposicao"> | string
    ref?: StringWithAggregatesFilter<"BmFioComposicao"> | string
    refOrigem?: StringWithAggregatesFilter<"BmFioComposicao"> | string
    idComposicao?: IntWithAggregatesFilter<"BmFioComposicao"> | number
    qtt?: DecimalWithAggregatesFilter<"BmFioComposicao"> | Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoWhereInput = {
    AND?: BmIdBmComposicaoWhereInput | BmIdBmComposicaoWhereInput[]
    OR?: BmIdBmComposicaoWhereInput[]
    NOT?: BmIdBmComposicaoWhereInput | BmIdBmComposicaoWhereInput[]
    idBm?: StringFilter<"BmIdBmComposicao"> | string
    ref?: StringFilter<"BmIdBmComposicao"> | string
    idComposicao?: IntFilter<"BmIdBmComposicao"> | number
    qtt?: DecimalFilter<"BmIdBmComposicao"> | Decimal | DecimalJsLike | number | string
    BmMalhas?: XOR<BmMalhasScalarRelationFilter, BmMalhasWhereInput>
    BmMateriaisComposicao?: XOR<BmMateriaisComposicaoScalarRelationFilter, BmMateriaisComposicaoWhereInput>
  }

  export type BmIdBmComposicaoOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
    BmMalhas?: BmMalhasOrderByWithRelationInput
    BmMateriaisComposicao?: BmMateriaisComposicaoOrderByWithRelationInput
  }

  export type BmIdBmComposicaoWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref_idComposicao?: BmIdBmComposicaoIdBmRefIdComposicaoCompoundUniqueInput
    AND?: BmIdBmComposicaoWhereInput | BmIdBmComposicaoWhereInput[]
    OR?: BmIdBmComposicaoWhereInput[]
    NOT?: BmIdBmComposicaoWhereInput | BmIdBmComposicaoWhereInput[]
    idBm?: StringFilter<"BmIdBmComposicao"> | string
    ref?: StringFilter<"BmIdBmComposicao"> | string
    idComposicao?: IntFilter<"BmIdBmComposicao"> | number
    qtt?: DecimalFilter<"BmIdBmComposicao"> | Decimal | DecimalJsLike | number | string
    BmMalhas?: XOR<BmMalhasScalarRelationFilter, BmMalhasWhereInput>
    BmMateriaisComposicao?: XOR<BmMateriaisComposicaoScalarRelationFilter, BmMateriaisComposicaoWhereInput>
  }, "idBm_ref_idComposicao">

  export type BmIdBmComposicaoOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
    _count?: BmIdBmComposicaoCountOrderByAggregateInput
    _avg?: BmIdBmComposicaoAvgOrderByAggregateInput
    _max?: BmIdBmComposicaoMaxOrderByAggregateInput
    _min?: BmIdBmComposicaoMinOrderByAggregateInput
    _sum?: BmIdBmComposicaoSumOrderByAggregateInput
  }

  export type BmIdBmComposicaoScalarWhereWithAggregatesInput = {
    AND?: BmIdBmComposicaoScalarWhereWithAggregatesInput | BmIdBmComposicaoScalarWhereWithAggregatesInput[]
    OR?: BmIdBmComposicaoScalarWhereWithAggregatesInput[]
    NOT?: BmIdBmComposicaoScalarWhereWithAggregatesInput | BmIdBmComposicaoScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmIdBmComposicao"> | string
    ref?: StringWithAggregatesFilter<"BmIdBmComposicao"> | string
    idComposicao?: IntWithAggregatesFilter<"BmIdBmComposicao"> | number
    qtt?: DecimalWithAggregatesFilter<"BmIdBmComposicao"> | Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasWhereInput = {
    AND?: BmMalhasWhereInput | BmMalhasWhereInput[]
    OR?: BmMalhasWhereInput[]
    NOT?: BmMalhasWhereInput | BmMalhasWhereInput[]
    idBm?: StringFilter<"BmMalhas"> | string
    ref?: StringFilter<"BmMalhas"> | string
    malha?: StringFilter<"BmMalhas"> | string
    grupo?: StringFilter<"BmMalhas"> | string
    subGrupo?: StringFilter<"BmMalhas"> | string
    qtdePedida?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: DecimalNullableFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhas"> | string
    lote?: StringFilter<"BmMalhas"> | string
    BmIdBmComposicao?: BmIdBmComposicaoListRelationFilter
    Bm?: XOR<BmScalarRelationFilter, BmWhereInput>
    BmMateriais?: XOR<BmMateriaisScalarRelationFilter, BmMateriaisWhereInput>
    BmMalhasFio?: BmMalhasFioListRelationFilter
    BmOpsPorMalha?: BmOpsPorMalhaListRelationFilter
  }

  export type BmMalhasOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    malha?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    qtdeEntradaSeUnidade?: SortOrderInput | SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    BmIdBmComposicao?: BmIdBmComposicaoOrderByRelationAggregateInput
    Bm?: BmOrderByWithRelationInput
    BmMateriais?: BmMateriaisOrderByWithRelationInput
    BmMalhasFio?: BmMalhasFioOrderByRelationAggregateInput
    BmOpsPorMalha?: BmOpsPorMalhaOrderByRelationAggregateInput
  }

  export type BmMalhasWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref?: BmMalhasIdBmRefCompoundUniqueInput
    AND?: BmMalhasWhereInput | BmMalhasWhereInput[]
    OR?: BmMalhasWhereInput[]
    NOT?: BmMalhasWhereInput | BmMalhasWhereInput[]
    idBm?: StringFilter<"BmMalhas"> | string
    ref?: StringFilter<"BmMalhas"> | string
    malha?: StringFilter<"BmMalhas"> | string
    grupo?: StringFilter<"BmMalhas"> | string
    subGrupo?: StringFilter<"BmMalhas"> | string
    qtdePedida?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: DecimalNullableFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhas"> | string
    lote?: StringFilter<"BmMalhas"> | string
    BmIdBmComposicao?: BmIdBmComposicaoListRelationFilter
    Bm?: XOR<BmScalarRelationFilter, BmWhereInput>
    BmMateriais?: XOR<BmMateriaisScalarRelationFilter, BmMateriaisWhereInput>
    BmMalhasFio?: BmMalhasFioListRelationFilter
    BmOpsPorMalha?: BmOpsPorMalhaListRelationFilter
  }, "idBm_ref">

  export type BmMalhasOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    malha?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    qtdeEntradaSeUnidade?: SortOrderInput | SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    _count?: BmMalhasCountOrderByAggregateInput
    _avg?: BmMalhasAvgOrderByAggregateInput
    _max?: BmMalhasMaxOrderByAggregateInput
    _min?: BmMalhasMinOrderByAggregateInput
    _sum?: BmMalhasSumOrderByAggregateInput
  }

  export type BmMalhasScalarWhereWithAggregatesInput = {
    AND?: BmMalhasScalarWhereWithAggregatesInput | BmMalhasScalarWhereWithAggregatesInput[]
    OR?: BmMalhasScalarWhereWithAggregatesInput[]
    NOT?: BmMalhasScalarWhereWithAggregatesInput | BmMalhasScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmMalhas"> | string
    ref?: StringWithAggregatesFilter<"BmMalhas"> | string
    malha?: StringWithAggregatesFilter<"BmMalhas"> | string
    grupo?: StringWithAggregatesFilter<"BmMalhas"> | string
    subGrupo?: StringWithAggregatesFilter<"BmMalhas"> | string
    qtdePedida?: DecimalWithAggregatesFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalWithAggregatesFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: DecimalNullableWithAggregatesFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalWithAggregatesFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalWithAggregatesFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    unidade?: StringWithAggregatesFilter<"BmMalhas"> | string
    lote?: StringWithAggregatesFilter<"BmMalhas"> | string
  }

  export type BmMalhasFioWhereInput = {
    AND?: BmMalhasFioWhereInput | BmMalhasFioWhereInput[]
    OR?: BmMalhasFioWhereInput[]
    NOT?: BmMalhasFioWhereInput | BmMalhasFioWhereInput[]
    idBm?: StringFilter<"BmMalhasFio"> | string
    ref?: StringFilter<"BmMalhasFio"> | string
    refOrigem?: StringFilter<"BmMalhasFio"> | string
    fio?: StringFilter<"BmMalhasFio"> | string
    grupo?: StringFilter<"BmMalhasFio"> | string
    subGrupo?: StringFilter<"BmMalhasFio"> | string
    qtdePedida?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhasFio"> | string
    lote?: StringFilter<"BmMalhasFio"> | string
    BmFioComposicao?: BmFioComposicaoListRelationFilter
    BmMalhas?: XOR<BmMalhasScalarRelationFilter, BmMalhasWhereInput>
    BmMateriaisFio?: XOR<BmMateriaisFioScalarRelationFilter, BmMateriaisFioWhereInput>
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioListRelationFilter
  }

  export type BmMalhasFioOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    fio?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    BmFioComposicao?: BmFioComposicaoOrderByRelationAggregateInput
    BmMalhas?: BmMalhasOrderByWithRelationInput
    BmMateriaisFio?: BmMateriaisFioOrderByWithRelationInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioOrderByRelationAggregateInput
  }

  export type BmMalhasFioWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref_refOrigem?: BmMalhasFioIdBmRefRefOrigemCompoundUniqueInput
    AND?: BmMalhasFioWhereInput | BmMalhasFioWhereInput[]
    OR?: BmMalhasFioWhereInput[]
    NOT?: BmMalhasFioWhereInput | BmMalhasFioWhereInput[]
    idBm?: StringFilter<"BmMalhasFio"> | string
    ref?: StringFilter<"BmMalhasFio"> | string
    refOrigem?: StringFilter<"BmMalhasFio"> | string
    fio?: StringFilter<"BmMalhasFio"> | string
    grupo?: StringFilter<"BmMalhasFio"> | string
    subGrupo?: StringFilter<"BmMalhasFio"> | string
    qtdePedida?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhasFio"> | string
    lote?: StringFilter<"BmMalhasFio"> | string
    BmFioComposicao?: BmFioComposicaoListRelationFilter
    BmMalhas?: XOR<BmMalhasScalarRelationFilter, BmMalhasWhereInput>
    BmMateriaisFio?: XOR<BmMateriaisFioScalarRelationFilter, BmMateriaisFioWhereInput>
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioListRelationFilter
  }, "idBm_ref_refOrigem">

  export type BmMalhasFioOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    fio?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    _count?: BmMalhasFioCountOrderByAggregateInput
    _avg?: BmMalhasFioAvgOrderByAggregateInput
    _max?: BmMalhasFioMaxOrderByAggregateInput
    _min?: BmMalhasFioMinOrderByAggregateInput
    _sum?: BmMalhasFioSumOrderByAggregateInput
  }

  export type BmMalhasFioScalarWhereWithAggregatesInput = {
    AND?: BmMalhasFioScalarWhereWithAggregatesInput | BmMalhasFioScalarWhereWithAggregatesInput[]
    OR?: BmMalhasFioScalarWhereWithAggregatesInput[]
    NOT?: BmMalhasFioScalarWhereWithAggregatesInput | BmMalhasFioScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmMalhasFio"> | string
    ref?: StringWithAggregatesFilter<"BmMalhasFio"> | string
    refOrigem?: StringWithAggregatesFilter<"BmMalhasFio"> | string
    fio?: StringWithAggregatesFilter<"BmMalhasFio"> | string
    grupo?: StringWithAggregatesFilter<"BmMalhasFio"> | string
    subGrupo?: StringWithAggregatesFilter<"BmMalhasFio"> | string
    qtdePedida?: DecimalWithAggregatesFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalWithAggregatesFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalWithAggregatesFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalWithAggregatesFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    unidade?: StringWithAggregatesFilter<"BmMalhasFio"> | string
    lote?: StringWithAggregatesFilter<"BmMalhasFio"> | string
  }

  export type BmMalhasFioMovimentosWhereInput = {
    AND?: BmMalhasFioMovimentosWhereInput | BmMalhasFioMovimentosWhereInput[]
    OR?: BmMalhasFioMovimentosWhereInput[]
    NOT?: BmMalhasFioMovimentosWhereInput | BmMalhasFioMovimentosWhereInput[]
    idBm?: StringFilter<"BmMalhasFioMovimentos"> | string
    ref?: StringFilter<"BmMalhasFioMovimentos"> | string
    refOrigem?: StringFilter<"BmMalhasFioMovimentos"> | string
    op?: IntFilter<"BmMalhasFioMovimentos"> | number
    idBmMovimentosLote?: StringFilter<"BmMalhasFioMovimentos"> | string
    idMovimento?: StringFilter<"BmMalhasFioMovimentos"> | string
    nMovimento?: IntFilter<"BmMalhasFioMovimentos"> | number
    nome?: StringFilter<"BmMalhasFioMovimentos"> | string
    idTipo?: DecimalFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    tipo?: StringFilter<"BmMalhasFioMovimentos"> | string
    qtt?: DecimalFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhasFioMovimentos"> | string
    lote?: StringFilter<"BmMalhasFioMovimentos"> | string
    BmOpsPorMalhaFio?: XOR<BmOpsPorMalhaFioScalarRelationFilter, BmOpsPorMalhaFioWhereInput>
  }

  export type BmMalhasFioMovimentosOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioOrderByWithRelationInput
  }

  export type BmMalhasFioMovimentosWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref_refOrigem_op_idBmMovimentosLote?: BmMalhasFioMovimentosIdBmRefRefOrigemOpIdBmMovimentosLoteCompoundUniqueInput
    AND?: BmMalhasFioMovimentosWhereInput | BmMalhasFioMovimentosWhereInput[]
    OR?: BmMalhasFioMovimentosWhereInput[]
    NOT?: BmMalhasFioMovimentosWhereInput | BmMalhasFioMovimentosWhereInput[]
    idBm?: StringFilter<"BmMalhasFioMovimentos"> | string
    ref?: StringFilter<"BmMalhasFioMovimentos"> | string
    refOrigem?: StringFilter<"BmMalhasFioMovimentos"> | string
    op?: IntFilter<"BmMalhasFioMovimentos"> | number
    idBmMovimentosLote?: StringFilter<"BmMalhasFioMovimentos"> | string
    idMovimento?: StringFilter<"BmMalhasFioMovimentos"> | string
    nMovimento?: IntFilter<"BmMalhasFioMovimentos"> | number
    nome?: StringFilter<"BmMalhasFioMovimentos"> | string
    idTipo?: DecimalFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    tipo?: StringFilter<"BmMalhasFioMovimentos"> | string
    qtt?: DecimalFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhasFioMovimentos"> | string
    lote?: StringFilter<"BmMalhasFioMovimentos"> | string
    BmOpsPorMalhaFio?: XOR<BmOpsPorMalhaFioScalarRelationFilter, BmOpsPorMalhaFioWhereInput>
  }, "idBm_ref_refOrigem_op_idBmMovimentosLote">

  export type BmMalhasFioMovimentosOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    _count?: BmMalhasFioMovimentosCountOrderByAggregateInput
    _avg?: BmMalhasFioMovimentosAvgOrderByAggregateInput
    _max?: BmMalhasFioMovimentosMaxOrderByAggregateInput
    _min?: BmMalhasFioMovimentosMinOrderByAggregateInput
    _sum?: BmMalhasFioMovimentosSumOrderByAggregateInput
  }

  export type BmMalhasFioMovimentosScalarWhereWithAggregatesInput = {
    AND?: BmMalhasFioMovimentosScalarWhereWithAggregatesInput | BmMalhasFioMovimentosScalarWhereWithAggregatesInput[]
    OR?: BmMalhasFioMovimentosScalarWhereWithAggregatesInput[]
    NOT?: BmMalhasFioMovimentosScalarWhereWithAggregatesInput | BmMalhasFioMovimentosScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    ref?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    refOrigem?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    op?: IntWithAggregatesFilter<"BmMalhasFioMovimentos"> | number
    idBmMovimentosLote?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    idMovimento?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    nMovimento?: IntWithAggregatesFilter<"BmMalhasFioMovimentos"> | number
    nome?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    idTipo?: DecimalWithAggregatesFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    tipo?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    qtt?: DecimalWithAggregatesFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    unidade?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
    lote?: StringWithAggregatesFilter<"BmMalhasFioMovimentos"> | string
  }

  export type BmMateriaisWhereInput = {
    AND?: BmMateriaisWhereInput | BmMateriaisWhereInput[]
    OR?: BmMateriaisWhereInput[]
    NOT?: BmMateriaisWhereInput | BmMateriaisWhereInput[]
    grupo?: StringFilter<"BmMateriais"> | string
    subGrupo?: StringFilter<"BmMateriais"> | string
    BmMalhas?: BmMalhasListRelationFilter
    BmMaterialGrupo?: XOR<BmMaterialGrupoScalarRelationFilter, BmMaterialGrupoWhereInput>
    BmMaterialSubGrupo?: XOR<BmMaterialSubGrupoScalarRelationFilter, BmMaterialSubGrupoWhereInput>
  }

  export type BmMateriaisOrderByWithRelationInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
    BmMalhas?: BmMalhasOrderByRelationAggregateInput
    BmMaterialGrupo?: BmMaterialGrupoOrderByWithRelationInput
    BmMaterialSubGrupo?: BmMaterialSubGrupoOrderByWithRelationInput
  }

  export type BmMateriaisWhereUniqueInput = Prisma.AtLeast<{
    grupo_subGrupo?: BmMateriaisGrupoSubGrupoCompoundUniqueInput
    AND?: BmMateriaisWhereInput | BmMateriaisWhereInput[]
    OR?: BmMateriaisWhereInput[]
    NOT?: BmMateriaisWhereInput | BmMateriaisWhereInput[]
    grupo?: StringFilter<"BmMateriais"> | string
    subGrupo?: StringFilter<"BmMateriais"> | string
    BmMalhas?: BmMalhasListRelationFilter
    BmMaterialGrupo?: XOR<BmMaterialGrupoScalarRelationFilter, BmMaterialGrupoWhereInput>
    BmMaterialSubGrupo?: XOR<BmMaterialSubGrupoScalarRelationFilter, BmMaterialSubGrupoWhereInput>
  }, "grupo_subGrupo">

  export type BmMateriaisOrderByWithAggregationInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
    _count?: BmMateriaisCountOrderByAggregateInput
    _max?: BmMateriaisMaxOrderByAggregateInput
    _min?: BmMateriaisMinOrderByAggregateInput
  }

  export type BmMateriaisScalarWhereWithAggregatesInput = {
    AND?: BmMateriaisScalarWhereWithAggregatesInput | BmMateriaisScalarWhereWithAggregatesInput[]
    OR?: BmMateriaisScalarWhereWithAggregatesInput[]
    NOT?: BmMateriaisScalarWhereWithAggregatesInput | BmMateriaisScalarWhereWithAggregatesInput[]
    grupo?: StringWithAggregatesFilter<"BmMateriais"> | string
    subGrupo?: StringWithAggregatesFilter<"BmMateriais"> | string
  }

  export type BmMateriaisComposicaoWhereInput = {
    AND?: BmMateriaisComposicaoWhereInput | BmMateriaisComposicaoWhereInput[]
    OR?: BmMateriaisComposicaoWhereInput[]
    NOT?: BmMateriaisComposicaoWhereInput | BmMateriaisComposicaoWhereInput[]
    idComposicao?: IntFilter<"BmMateriaisComposicao"> | number
    composicao?: StringFilter<"BmMateriaisComposicao"> | string
    composicaoAbreviatura?: StringFilter<"BmMateriaisComposicao"> | string
    ordem?: IntFilter<"BmMateriaisComposicao"> | number
    inactivo?: BoolFilter<"BmMateriaisComposicao"> | boolean
    BmFioComposicao?: BmFioComposicaoListRelationFilter
    BmIdBmComposicao?: BmIdBmComposicaoListRelationFilter
  }

  export type BmMateriaisComposicaoOrderByWithRelationInput = {
    idComposicao?: SortOrder
    composicao?: SortOrder
    composicaoAbreviatura?: SortOrder
    ordem?: SortOrder
    inactivo?: SortOrder
    BmFioComposicao?: BmFioComposicaoOrderByRelationAggregateInput
    BmIdBmComposicao?: BmIdBmComposicaoOrderByRelationAggregateInput
  }

  export type BmMateriaisComposicaoWhereUniqueInput = Prisma.AtLeast<{
    idComposicao?: number
    AND?: BmMateriaisComposicaoWhereInput | BmMateriaisComposicaoWhereInput[]
    OR?: BmMateriaisComposicaoWhereInput[]
    NOT?: BmMateriaisComposicaoWhereInput | BmMateriaisComposicaoWhereInput[]
    composicao?: StringFilter<"BmMateriaisComposicao"> | string
    composicaoAbreviatura?: StringFilter<"BmMateriaisComposicao"> | string
    ordem?: IntFilter<"BmMateriaisComposicao"> | number
    inactivo?: BoolFilter<"BmMateriaisComposicao"> | boolean
    BmFioComposicao?: BmFioComposicaoListRelationFilter
    BmIdBmComposicao?: BmIdBmComposicaoListRelationFilter
  }, "idComposicao">

  export type BmMateriaisComposicaoOrderByWithAggregationInput = {
    idComposicao?: SortOrder
    composicao?: SortOrder
    composicaoAbreviatura?: SortOrder
    ordem?: SortOrder
    inactivo?: SortOrder
    _count?: BmMateriaisComposicaoCountOrderByAggregateInput
    _avg?: BmMateriaisComposicaoAvgOrderByAggregateInput
    _max?: BmMateriaisComposicaoMaxOrderByAggregateInput
    _min?: BmMateriaisComposicaoMinOrderByAggregateInput
    _sum?: BmMateriaisComposicaoSumOrderByAggregateInput
  }

  export type BmMateriaisComposicaoScalarWhereWithAggregatesInput = {
    AND?: BmMateriaisComposicaoScalarWhereWithAggregatesInput | BmMateriaisComposicaoScalarWhereWithAggregatesInput[]
    OR?: BmMateriaisComposicaoScalarWhereWithAggregatesInput[]
    NOT?: BmMateriaisComposicaoScalarWhereWithAggregatesInput | BmMateriaisComposicaoScalarWhereWithAggregatesInput[]
    idComposicao?: IntWithAggregatesFilter<"BmMateriaisComposicao"> | number
    composicao?: StringWithAggregatesFilter<"BmMateriaisComposicao"> | string
    composicaoAbreviatura?: StringWithAggregatesFilter<"BmMateriaisComposicao"> | string
    ordem?: IntWithAggregatesFilter<"BmMateriaisComposicao"> | number
    inactivo?: BoolWithAggregatesFilter<"BmMateriaisComposicao"> | boolean
  }

  export type BmMateriaisFioWhereInput = {
    AND?: BmMateriaisFioWhereInput | BmMateriaisFioWhereInput[]
    OR?: BmMateriaisFioWhereInput[]
    NOT?: BmMateriaisFioWhereInput | BmMateriaisFioWhereInput[]
    grupo?: StringFilter<"BmMateriaisFio"> | string
    subGrupo?: StringFilter<"BmMateriaisFio"> | string
    BmMalhasFio?: BmMalhasFioListRelationFilter
    BmMaterialGrupoFio?: XOR<BmMaterialGrupoFioScalarRelationFilter, BmMaterialGrupoFioWhereInput>
    BmMaterialSubGrupoFio?: XOR<BmMaterialSubGrupoFioScalarRelationFilter, BmMaterialSubGrupoFioWhereInput>
  }

  export type BmMateriaisFioOrderByWithRelationInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
    BmMalhasFio?: BmMalhasFioOrderByRelationAggregateInput
    BmMaterialGrupoFio?: BmMaterialGrupoFioOrderByWithRelationInput
    BmMaterialSubGrupoFio?: BmMaterialSubGrupoFioOrderByWithRelationInput
  }

  export type BmMateriaisFioWhereUniqueInput = Prisma.AtLeast<{
    grupo_subGrupo?: BmMateriaisFioGrupoSubGrupoCompoundUniqueInput
    AND?: BmMateriaisFioWhereInput | BmMateriaisFioWhereInput[]
    OR?: BmMateriaisFioWhereInput[]
    NOT?: BmMateriaisFioWhereInput | BmMateriaisFioWhereInput[]
    grupo?: StringFilter<"BmMateriaisFio"> | string
    subGrupo?: StringFilter<"BmMateriaisFio"> | string
    BmMalhasFio?: BmMalhasFioListRelationFilter
    BmMaterialGrupoFio?: XOR<BmMaterialGrupoFioScalarRelationFilter, BmMaterialGrupoFioWhereInput>
    BmMaterialSubGrupoFio?: XOR<BmMaterialSubGrupoFioScalarRelationFilter, BmMaterialSubGrupoFioWhereInput>
  }, "grupo_subGrupo">

  export type BmMateriaisFioOrderByWithAggregationInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
    _count?: BmMateriaisFioCountOrderByAggregateInput
    _max?: BmMateriaisFioMaxOrderByAggregateInput
    _min?: BmMateriaisFioMinOrderByAggregateInput
  }

  export type BmMateriaisFioScalarWhereWithAggregatesInput = {
    AND?: BmMateriaisFioScalarWhereWithAggregatesInput | BmMateriaisFioScalarWhereWithAggregatesInput[]
    OR?: BmMateriaisFioScalarWhereWithAggregatesInput[]
    NOT?: BmMateriaisFioScalarWhereWithAggregatesInput | BmMateriaisFioScalarWhereWithAggregatesInput[]
    grupo?: StringWithAggregatesFilter<"BmMateriaisFio"> | string
    subGrupo?: StringWithAggregatesFilter<"BmMateriaisFio"> | string
  }

  export type BmMaterialGrupoWhereInput = {
    AND?: BmMaterialGrupoWhereInput | BmMaterialGrupoWhereInput[]
    OR?: BmMaterialGrupoWhereInput[]
    NOT?: BmMaterialGrupoWhereInput | BmMaterialGrupoWhereInput[]
    grupo?: StringFilter<"BmMaterialGrupo"> | string
    grupoDescricao?: StringFilter<"BmMaterialGrupo"> | string
    BmMateriais?: BmMateriaisListRelationFilter
  }

  export type BmMaterialGrupoOrderByWithRelationInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
    BmMateriais?: BmMateriaisOrderByRelationAggregateInput
  }

  export type BmMaterialGrupoWhereUniqueInput = Prisma.AtLeast<{
    grupo?: string
    AND?: BmMaterialGrupoWhereInput | BmMaterialGrupoWhereInput[]
    OR?: BmMaterialGrupoWhereInput[]
    NOT?: BmMaterialGrupoWhereInput | BmMaterialGrupoWhereInput[]
    grupoDescricao?: StringFilter<"BmMaterialGrupo"> | string
    BmMateriais?: BmMateriaisListRelationFilter
  }, "grupo">

  export type BmMaterialGrupoOrderByWithAggregationInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
    _count?: BmMaterialGrupoCountOrderByAggregateInput
    _max?: BmMaterialGrupoMaxOrderByAggregateInput
    _min?: BmMaterialGrupoMinOrderByAggregateInput
  }

  export type BmMaterialGrupoScalarWhereWithAggregatesInput = {
    AND?: BmMaterialGrupoScalarWhereWithAggregatesInput | BmMaterialGrupoScalarWhereWithAggregatesInput[]
    OR?: BmMaterialGrupoScalarWhereWithAggregatesInput[]
    NOT?: BmMaterialGrupoScalarWhereWithAggregatesInput | BmMaterialGrupoScalarWhereWithAggregatesInput[]
    grupo?: StringWithAggregatesFilter<"BmMaterialGrupo"> | string
    grupoDescricao?: StringWithAggregatesFilter<"BmMaterialGrupo"> | string
  }

  export type BmMaterialGrupoFioWhereInput = {
    AND?: BmMaterialGrupoFioWhereInput | BmMaterialGrupoFioWhereInput[]
    OR?: BmMaterialGrupoFioWhereInput[]
    NOT?: BmMaterialGrupoFioWhereInput | BmMaterialGrupoFioWhereInput[]
    grupo?: StringFilter<"BmMaterialGrupoFio"> | string
    grupoDescricao?: StringFilter<"BmMaterialGrupoFio"> | string
    BmMateriaisFio?: BmMateriaisFioListRelationFilter
  }

  export type BmMaterialGrupoFioOrderByWithRelationInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
    BmMateriaisFio?: BmMateriaisFioOrderByRelationAggregateInput
  }

  export type BmMaterialGrupoFioWhereUniqueInput = Prisma.AtLeast<{
    grupo?: string
    AND?: BmMaterialGrupoFioWhereInput | BmMaterialGrupoFioWhereInput[]
    OR?: BmMaterialGrupoFioWhereInput[]
    NOT?: BmMaterialGrupoFioWhereInput | BmMaterialGrupoFioWhereInput[]
    grupoDescricao?: StringFilter<"BmMaterialGrupoFio"> | string
    BmMateriaisFio?: BmMateriaisFioListRelationFilter
  }, "grupo">

  export type BmMaterialGrupoFioOrderByWithAggregationInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
    _count?: BmMaterialGrupoFioCountOrderByAggregateInput
    _max?: BmMaterialGrupoFioMaxOrderByAggregateInput
    _min?: BmMaterialGrupoFioMinOrderByAggregateInput
  }

  export type BmMaterialGrupoFioScalarWhereWithAggregatesInput = {
    AND?: BmMaterialGrupoFioScalarWhereWithAggregatesInput | BmMaterialGrupoFioScalarWhereWithAggregatesInput[]
    OR?: BmMaterialGrupoFioScalarWhereWithAggregatesInput[]
    NOT?: BmMaterialGrupoFioScalarWhereWithAggregatesInput | BmMaterialGrupoFioScalarWhereWithAggregatesInput[]
    grupo?: StringWithAggregatesFilter<"BmMaterialGrupoFio"> | string
    grupoDescricao?: StringWithAggregatesFilter<"BmMaterialGrupoFio"> | string
  }

  export type BmMaterialSubGrupoWhereInput = {
    AND?: BmMaterialSubGrupoWhereInput | BmMaterialSubGrupoWhereInput[]
    OR?: BmMaterialSubGrupoWhereInput[]
    NOT?: BmMaterialSubGrupoWhereInput | BmMaterialSubGrupoWhereInput[]
    subGrupo?: StringFilter<"BmMaterialSubGrupo"> | string
    subGrupoDescricao?: StringFilter<"BmMaterialSubGrupo"> | string
    BmMateriais?: BmMateriaisListRelationFilter
  }

  export type BmMaterialSubGrupoOrderByWithRelationInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
    BmMateriais?: BmMateriaisOrderByRelationAggregateInput
  }

  export type BmMaterialSubGrupoWhereUniqueInput = Prisma.AtLeast<{
    subGrupo?: string
    AND?: BmMaterialSubGrupoWhereInput | BmMaterialSubGrupoWhereInput[]
    OR?: BmMaterialSubGrupoWhereInput[]
    NOT?: BmMaterialSubGrupoWhereInput | BmMaterialSubGrupoWhereInput[]
    subGrupoDescricao?: StringFilter<"BmMaterialSubGrupo"> | string
    BmMateriais?: BmMateriaisListRelationFilter
  }, "subGrupo">

  export type BmMaterialSubGrupoOrderByWithAggregationInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
    _count?: BmMaterialSubGrupoCountOrderByAggregateInput
    _max?: BmMaterialSubGrupoMaxOrderByAggregateInput
    _min?: BmMaterialSubGrupoMinOrderByAggregateInput
  }

  export type BmMaterialSubGrupoScalarWhereWithAggregatesInput = {
    AND?: BmMaterialSubGrupoScalarWhereWithAggregatesInput | BmMaterialSubGrupoScalarWhereWithAggregatesInput[]
    OR?: BmMaterialSubGrupoScalarWhereWithAggregatesInput[]
    NOT?: BmMaterialSubGrupoScalarWhereWithAggregatesInput | BmMaterialSubGrupoScalarWhereWithAggregatesInput[]
    subGrupo?: StringWithAggregatesFilter<"BmMaterialSubGrupo"> | string
    subGrupoDescricao?: StringWithAggregatesFilter<"BmMaterialSubGrupo"> | string
  }

  export type BmMaterialSubGrupoFioWhereInput = {
    AND?: BmMaterialSubGrupoFioWhereInput | BmMaterialSubGrupoFioWhereInput[]
    OR?: BmMaterialSubGrupoFioWhereInput[]
    NOT?: BmMaterialSubGrupoFioWhereInput | BmMaterialSubGrupoFioWhereInput[]
    subGrupo?: StringFilter<"BmMaterialSubGrupoFio"> | string
    subGrupoDescricao?: StringFilter<"BmMaterialSubGrupoFio"> | string
    BmMateriaisFio?: BmMateriaisFioListRelationFilter
  }

  export type BmMaterialSubGrupoFioOrderByWithRelationInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
    BmMateriaisFio?: BmMateriaisFioOrderByRelationAggregateInput
  }

  export type BmMaterialSubGrupoFioWhereUniqueInput = Prisma.AtLeast<{
    subGrupo?: string
    AND?: BmMaterialSubGrupoFioWhereInput | BmMaterialSubGrupoFioWhereInput[]
    OR?: BmMaterialSubGrupoFioWhereInput[]
    NOT?: BmMaterialSubGrupoFioWhereInput | BmMaterialSubGrupoFioWhereInput[]
    subGrupoDescricao?: StringFilter<"BmMaterialSubGrupoFio"> | string
    BmMateriaisFio?: BmMateriaisFioListRelationFilter
  }, "subGrupo">

  export type BmMaterialSubGrupoFioOrderByWithAggregationInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
    _count?: BmMaterialSubGrupoFioCountOrderByAggregateInput
    _max?: BmMaterialSubGrupoFioMaxOrderByAggregateInput
    _min?: BmMaterialSubGrupoFioMinOrderByAggregateInput
  }

  export type BmMaterialSubGrupoFioScalarWhereWithAggregatesInput = {
    AND?: BmMaterialSubGrupoFioScalarWhereWithAggregatesInput | BmMaterialSubGrupoFioScalarWhereWithAggregatesInput[]
    OR?: BmMaterialSubGrupoFioScalarWhereWithAggregatesInput[]
    NOT?: BmMaterialSubGrupoFioScalarWhereWithAggregatesInput | BmMaterialSubGrupoFioScalarWhereWithAggregatesInput[]
    subGrupo?: StringWithAggregatesFilter<"BmMaterialSubGrupoFio"> | string
    subGrupoDescricao?: StringWithAggregatesFilter<"BmMaterialSubGrupoFio"> | string
  }

  export type BmMovimentosLotesWhereInput = {
    AND?: BmMovimentosLotesWhereInput | BmMovimentosLotesWhereInput[]
    OR?: BmMovimentosLotesWhereInput[]
    NOT?: BmMovimentosLotesWhereInput | BmMovimentosLotesWhereInput[]
    idBm?: StringFilter<"BmMovimentosLotes"> | string
    ref?: StringFilter<"BmMovimentosLotes"> | string
    op?: IntFilter<"BmMovimentosLotes"> | number
    idBmMovimentosLote?: StringFilter<"BmMovimentosLotes"> | string
    idMovimento?: StringFilter<"BmMovimentosLotes"> | string
    nMovimento?: IntFilter<"BmMovimentosLotes"> | number
    nome?: StringFilter<"BmMovimentosLotes"> | string
    idTipo?: DecimalFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    tipo?: StringFilter<"BmMovimentosLotes"> | string
    qtt?: DecimalFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMovimentosLotes"> | string
    lote?: StringFilter<"BmMovimentosLotes"> | string
    BmOpsPorMalha?: XOR<BmOpsPorMalhaScalarRelationFilter, BmOpsPorMalhaWhereInput>
  }

  export type BmMovimentosLotesOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    BmOpsPorMalha?: BmOpsPorMalhaOrderByWithRelationInput
  }

  export type BmMovimentosLotesWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref_op_idBmMovimentosLote?: BmMovimentosLotesIdBmRefOpIdBmMovimentosLoteCompoundUniqueInput
    AND?: BmMovimentosLotesWhereInput | BmMovimentosLotesWhereInput[]
    OR?: BmMovimentosLotesWhereInput[]
    NOT?: BmMovimentosLotesWhereInput | BmMovimentosLotesWhereInput[]
    idBm?: StringFilter<"BmMovimentosLotes"> | string
    ref?: StringFilter<"BmMovimentosLotes"> | string
    op?: IntFilter<"BmMovimentosLotes"> | number
    idBmMovimentosLote?: StringFilter<"BmMovimentosLotes"> | string
    idMovimento?: StringFilter<"BmMovimentosLotes"> | string
    nMovimento?: IntFilter<"BmMovimentosLotes"> | number
    nome?: StringFilter<"BmMovimentosLotes"> | string
    idTipo?: DecimalFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    tipo?: StringFilter<"BmMovimentosLotes"> | string
    qtt?: DecimalFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMovimentosLotes"> | string
    lote?: StringFilter<"BmMovimentosLotes"> | string
    BmOpsPorMalha?: XOR<BmOpsPorMalhaScalarRelationFilter, BmOpsPorMalhaWhereInput>
  }, "idBm_ref_op_idBmMovimentosLote">

  export type BmMovimentosLotesOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    _count?: BmMovimentosLotesCountOrderByAggregateInput
    _avg?: BmMovimentosLotesAvgOrderByAggregateInput
    _max?: BmMovimentosLotesMaxOrderByAggregateInput
    _min?: BmMovimentosLotesMinOrderByAggregateInput
    _sum?: BmMovimentosLotesSumOrderByAggregateInput
  }

  export type BmMovimentosLotesScalarWhereWithAggregatesInput = {
    AND?: BmMovimentosLotesScalarWhereWithAggregatesInput | BmMovimentosLotesScalarWhereWithAggregatesInput[]
    OR?: BmMovimentosLotesScalarWhereWithAggregatesInput[]
    NOT?: BmMovimentosLotesScalarWhereWithAggregatesInput | BmMovimentosLotesScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
    ref?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
    op?: IntWithAggregatesFilter<"BmMovimentosLotes"> | number
    idBmMovimentosLote?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
    idMovimento?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
    nMovimento?: IntWithAggregatesFilter<"BmMovimentosLotes"> | number
    nome?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
    idTipo?: DecimalWithAggregatesFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    tipo?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
    qtt?: DecimalWithAggregatesFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    unidade?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
    lote?: StringWithAggregatesFilter<"BmMovimentosLotes"> | string
  }

  export type BmOpWhereInput = {
    AND?: BmOpWhereInput | BmOpWhereInput[]
    OR?: BmOpWhereInput[]
    NOT?: BmOpWhereInput | BmOpWhereInput[]
    idBm?: StringFilter<"BmOp"> | string
    op?: IntFilter<"BmOp"> | number
    CreatedAt?: DateTimeFilter<"BmOp"> | Date | string
    foto?: StringFilter<"BmOp"> | string
    Bm?: XOR<BmScalarRelationFilter, BmWhereInput>
    BmOpFaturado?: BmOpFaturadoListRelationFilter
    BmOpsPorMalha?: BmOpsPorMalhaListRelationFilter
  }

  export type BmOpOrderByWithRelationInput = {
    idBm?: SortOrder
    op?: SortOrder
    CreatedAt?: SortOrder
    foto?: SortOrder
    Bm?: BmOrderByWithRelationInput
    BmOpFaturado?: BmOpFaturadoOrderByRelationAggregateInput
    BmOpsPorMalha?: BmOpsPorMalhaOrderByRelationAggregateInput
  }

  export type BmOpWhereUniqueInput = Prisma.AtLeast<{
    op?: number
    idBm_op?: BmOpIdBmOpCompoundUniqueInput
    AND?: BmOpWhereInput | BmOpWhereInput[]
    OR?: BmOpWhereInput[]
    NOT?: BmOpWhereInput | BmOpWhereInput[]
    idBm?: StringFilter<"BmOp"> | string
    CreatedAt?: DateTimeFilter<"BmOp"> | Date | string
    foto?: StringFilter<"BmOp"> | string
    Bm?: XOR<BmScalarRelationFilter, BmWhereInput>
    BmOpFaturado?: BmOpFaturadoListRelationFilter
    BmOpsPorMalha?: BmOpsPorMalhaListRelationFilter
  }, "idBm_op" | "op">

  export type BmOpOrderByWithAggregationInput = {
    idBm?: SortOrder
    op?: SortOrder
    CreatedAt?: SortOrder
    foto?: SortOrder
    _count?: BmOpCountOrderByAggregateInput
    _avg?: BmOpAvgOrderByAggregateInput
    _max?: BmOpMaxOrderByAggregateInput
    _min?: BmOpMinOrderByAggregateInput
    _sum?: BmOpSumOrderByAggregateInput
  }

  export type BmOpScalarWhereWithAggregatesInput = {
    AND?: BmOpScalarWhereWithAggregatesInput | BmOpScalarWhereWithAggregatesInput[]
    OR?: BmOpScalarWhereWithAggregatesInput[]
    NOT?: BmOpScalarWhereWithAggregatesInput | BmOpScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmOp"> | string
    op?: IntWithAggregatesFilter<"BmOp"> | number
    CreatedAt?: DateTimeWithAggregatesFilter<"BmOp"> | Date | string
    foto?: StringWithAggregatesFilter<"BmOp"> | string
  }

  export type BmOpFaturadoWhereInput = {
    AND?: BmOpFaturadoWhereInput | BmOpFaturadoWhereInput[]
    OR?: BmOpFaturadoWhereInput[]
    NOT?: BmOpFaturadoWhereInput | BmOpFaturadoWhereInput[]
    idBm?: StringFilter<"BmOpFaturado"> | string
    op?: IntFilter<"BmOpFaturado"> | number
    nFatutura?: IntFilter<"BmOpFaturado"> | number
    fData?: DateTimeFilter<"BmOpFaturado"> | Date | string
    dataFatura?: StringFilter<"BmOpFaturado"> | string
    refModelo?: StringFilter<"BmOpFaturado"> | string
    pedido?: StringFilter<"BmOpFaturado"> | string
    qtt?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    cmr?: StringFilter<"BmOpFaturado"> | string
    local?: StringFilter<"BmOpFaturado"> | string
    obs?: StringNullableFilter<"BmOpFaturado"> | string | null
    BmOp?: XOR<BmOpScalarRelationFilter, BmOpWhereInput>
  }

  export type BmOpFaturadoOrderByWithRelationInput = {
    idBm?: SortOrder
    op?: SortOrder
    nFatutura?: SortOrder
    fData?: SortOrder
    dataFatura?: SortOrder
    refModelo?: SortOrder
    pedido?: SortOrder
    qtt?: SortOrder
    pesoLiquido?: SortOrder
    pesoBruto?: SortOrder
    cmr?: SortOrder
    local?: SortOrder
    obs?: SortOrderInput | SortOrder
    BmOp?: BmOpOrderByWithRelationInput
  }

  export type BmOpFaturadoWhereUniqueInput = Prisma.AtLeast<{
    idBm_op_nFatutura?: BmOpFaturadoIdBmOpNFatuturaCompoundUniqueInput
    AND?: BmOpFaturadoWhereInput | BmOpFaturadoWhereInput[]
    OR?: BmOpFaturadoWhereInput[]
    NOT?: BmOpFaturadoWhereInput | BmOpFaturadoWhereInput[]
    idBm?: StringFilter<"BmOpFaturado"> | string
    op?: IntFilter<"BmOpFaturado"> | number
    nFatutura?: IntFilter<"BmOpFaturado"> | number
    fData?: DateTimeFilter<"BmOpFaturado"> | Date | string
    dataFatura?: StringFilter<"BmOpFaturado"> | string
    refModelo?: StringFilter<"BmOpFaturado"> | string
    pedido?: StringFilter<"BmOpFaturado"> | string
    qtt?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    cmr?: StringFilter<"BmOpFaturado"> | string
    local?: StringFilter<"BmOpFaturado"> | string
    obs?: StringNullableFilter<"BmOpFaturado"> | string | null
    BmOp?: XOR<BmOpScalarRelationFilter, BmOpWhereInput>
  }, "idBm_op_nFatutura">

  export type BmOpFaturadoOrderByWithAggregationInput = {
    idBm?: SortOrder
    op?: SortOrder
    nFatutura?: SortOrder
    fData?: SortOrder
    dataFatura?: SortOrder
    refModelo?: SortOrder
    pedido?: SortOrder
    qtt?: SortOrder
    pesoLiquido?: SortOrder
    pesoBruto?: SortOrder
    cmr?: SortOrder
    local?: SortOrder
    obs?: SortOrderInput | SortOrder
    _count?: BmOpFaturadoCountOrderByAggregateInput
    _avg?: BmOpFaturadoAvgOrderByAggregateInput
    _max?: BmOpFaturadoMaxOrderByAggregateInput
    _min?: BmOpFaturadoMinOrderByAggregateInput
    _sum?: BmOpFaturadoSumOrderByAggregateInput
  }

  export type BmOpFaturadoScalarWhereWithAggregatesInput = {
    AND?: BmOpFaturadoScalarWhereWithAggregatesInput | BmOpFaturadoScalarWhereWithAggregatesInput[]
    OR?: BmOpFaturadoScalarWhereWithAggregatesInput[]
    NOT?: BmOpFaturadoScalarWhereWithAggregatesInput | BmOpFaturadoScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmOpFaturado"> | string
    op?: IntWithAggregatesFilter<"BmOpFaturado"> | number
    nFatutura?: IntWithAggregatesFilter<"BmOpFaturado"> | number
    fData?: DateTimeWithAggregatesFilter<"BmOpFaturado"> | Date | string
    dataFatura?: StringWithAggregatesFilter<"BmOpFaturado"> | string
    refModelo?: StringWithAggregatesFilter<"BmOpFaturado"> | string
    pedido?: StringWithAggregatesFilter<"BmOpFaturado"> | string
    qtt?: DecimalWithAggregatesFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalWithAggregatesFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalWithAggregatesFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    cmr?: StringWithAggregatesFilter<"BmOpFaturado"> | string
    local?: StringWithAggregatesFilter<"BmOpFaturado"> | string
    obs?: StringNullableWithAggregatesFilter<"BmOpFaturado"> | string | null
  }

  export type BmOpsPorMalhaWhereInput = {
    AND?: BmOpsPorMalhaWhereInput | BmOpsPorMalhaWhereInput[]
    OR?: BmOpsPorMalhaWhereInput[]
    NOT?: BmOpsPorMalhaWhereInput | BmOpsPorMalhaWhereInput[]
    idBm?: StringFilter<"BmOpsPorMalha"> | string
    ref?: StringFilter<"BmOpsPorMalha"> | string
    op?: IntFilter<"BmOpsPorMalha"> | number
    BmMovimentosLotes?: BmMovimentosLotesListRelationFilter
    BmMalhas?: XOR<BmMalhasScalarRelationFilter, BmMalhasWhereInput>
    BmOp?: XOR<BmOpScalarRelationFilter, BmOpWhereInput>
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioListRelationFilter
  }

  export type BmOpsPorMalhaOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
    BmMovimentosLotes?: BmMovimentosLotesOrderByRelationAggregateInput
    BmMalhas?: BmMalhasOrderByWithRelationInput
    BmOp?: BmOpOrderByWithRelationInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioOrderByRelationAggregateInput
  }

  export type BmOpsPorMalhaWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref_op?: BmOpsPorMalhaIdBmRefOpCompoundUniqueInput
    AND?: BmOpsPorMalhaWhereInput | BmOpsPorMalhaWhereInput[]
    OR?: BmOpsPorMalhaWhereInput[]
    NOT?: BmOpsPorMalhaWhereInput | BmOpsPorMalhaWhereInput[]
    idBm?: StringFilter<"BmOpsPorMalha"> | string
    ref?: StringFilter<"BmOpsPorMalha"> | string
    op?: IntFilter<"BmOpsPorMalha"> | number
    BmMovimentosLotes?: BmMovimentosLotesListRelationFilter
    BmMalhas?: XOR<BmMalhasScalarRelationFilter, BmMalhasWhereInput>
    BmOp?: XOR<BmOpScalarRelationFilter, BmOpWhereInput>
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioListRelationFilter
  }, "idBm_ref_op">

  export type BmOpsPorMalhaOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
    _count?: BmOpsPorMalhaCountOrderByAggregateInput
    _avg?: BmOpsPorMalhaAvgOrderByAggregateInput
    _max?: BmOpsPorMalhaMaxOrderByAggregateInput
    _min?: BmOpsPorMalhaMinOrderByAggregateInput
    _sum?: BmOpsPorMalhaSumOrderByAggregateInput
  }

  export type BmOpsPorMalhaScalarWhereWithAggregatesInput = {
    AND?: BmOpsPorMalhaScalarWhereWithAggregatesInput | BmOpsPorMalhaScalarWhereWithAggregatesInput[]
    OR?: BmOpsPorMalhaScalarWhereWithAggregatesInput[]
    NOT?: BmOpsPorMalhaScalarWhereWithAggregatesInput | BmOpsPorMalhaScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmOpsPorMalha"> | string
    ref?: StringWithAggregatesFilter<"BmOpsPorMalha"> | string
    op?: IntWithAggregatesFilter<"BmOpsPorMalha"> | number
  }

  export type BmOpsPorMalhaFioWhereInput = {
    AND?: BmOpsPorMalhaFioWhereInput | BmOpsPorMalhaFioWhereInput[]
    OR?: BmOpsPorMalhaFioWhereInput[]
    NOT?: BmOpsPorMalhaFioWhereInput | BmOpsPorMalhaFioWhereInput[]
    idBm?: StringFilter<"BmOpsPorMalhaFio"> | string
    ref?: StringFilter<"BmOpsPorMalhaFio"> | string
    refOrigem?: StringFilter<"BmOpsPorMalhaFio"> | string
    op?: IntFilter<"BmOpsPorMalhaFio"> | number
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosListRelationFilter
    BmMalhasFio?: XOR<BmMalhasFioScalarRelationFilter, BmMalhasFioWhereInput>
    BmOpsPorMalha?: XOR<BmOpsPorMalhaScalarRelationFilter, BmOpsPorMalhaWhereInput>
  }

  export type BmOpsPorMalhaFioOrderByWithRelationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosOrderByRelationAggregateInput
    BmMalhasFio?: BmMalhasFioOrderByWithRelationInput
    BmOpsPorMalha?: BmOpsPorMalhaOrderByWithRelationInput
  }

  export type BmOpsPorMalhaFioWhereUniqueInput = Prisma.AtLeast<{
    idBm_ref_refOrigem_op?: BmOpsPorMalhaFioIdBmRefRefOrigemOpCompoundUniqueInput
    AND?: BmOpsPorMalhaFioWhereInput | BmOpsPorMalhaFioWhereInput[]
    OR?: BmOpsPorMalhaFioWhereInput[]
    NOT?: BmOpsPorMalhaFioWhereInput | BmOpsPorMalhaFioWhereInput[]
    idBm?: StringFilter<"BmOpsPorMalhaFio"> | string
    ref?: StringFilter<"BmOpsPorMalhaFio"> | string
    refOrigem?: StringFilter<"BmOpsPorMalhaFio"> | string
    op?: IntFilter<"BmOpsPorMalhaFio"> | number
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosListRelationFilter
    BmMalhasFio?: XOR<BmMalhasFioScalarRelationFilter, BmMalhasFioWhereInput>
    BmOpsPorMalha?: XOR<BmOpsPorMalhaScalarRelationFilter, BmOpsPorMalhaWhereInput>
  }, "idBm_ref_refOrigem_op">

  export type BmOpsPorMalhaFioOrderByWithAggregationInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
    _count?: BmOpsPorMalhaFioCountOrderByAggregateInput
    _avg?: BmOpsPorMalhaFioAvgOrderByAggregateInput
    _max?: BmOpsPorMalhaFioMaxOrderByAggregateInput
    _min?: BmOpsPorMalhaFioMinOrderByAggregateInput
    _sum?: BmOpsPorMalhaFioSumOrderByAggregateInput
  }

  export type BmOpsPorMalhaFioScalarWhereWithAggregatesInput = {
    AND?: BmOpsPorMalhaFioScalarWhereWithAggregatesInput | BmOpsPorMalhaFioScalarWhereWithAggregatesInput[]
    OR?: BmOpsPorMalhaFioScalarWhereWithAggregatesInput[]
    NOT?: BmOpsPorMalhaFioScalarWhereWithAggregatesInput | BmOpsPorMalhaFioScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmOpsPorMalhaFio"> | string
    ref?: StringWithAggregatesFilter<"BmOpsPorMalhaFio"> | string
    refOrigem?: StringWithAggregatesFilter<"BmOpsPorMalhaFio"> | string
    op?: IntWithAggregatesFilter<"BmOpsPorMalhaFio"> | number
  }

  export type BmTcWhereInput = {
    AND?: BmTcWhereInput | BmTcWhereInput[]
    OR?: BmTcWhereInput[]
    NOT?: BmTcWhereInput | BmTcWhereInput[]
    idBm?: StringFilter<"BmTc"> | string
    nomeTc?: StringFilter<"BmTc"> | string
    Bm?: XOR<BmScalarRelationFilter, BmWhereInput>
  }

  export type BmTcOrderByWithRelationInput = {
    idBm?: SortOrder
    nomeTc?: SortOrder
    Bm?: BmOrderByWithRelationInput
  }

  export type BmTcWhereUniqueInput = Prisma.AtLeast<{
    idBm_nomeTc?: BmTcIdBmNomeTcCompoundUniqueInput
    AND?: BmTcWhereInput | BmTcWhereInput[]
    OR?: BmTcWhereInput[]
    NOT?: BmTcWhereInput | BmTcWhereInput[]
    idBm?: StringFilter<"BmTc"> | string
    nomeTc?: StringFilter<"BmTc"> | string
    Bm?: XOR<BmScalarRelationFilter, BmWhereInput>
  }, "idBm_nomeTc">

  export type BmTcOrderByWithAggregationInput = {
    idBm?: SortOrder
    nomeTc?: SortOrder
    _count?: BmTcCountOrderByAggregateInput
    _max?: BmTcMaxOrderByAggregateInput
    _min?: BmTcMinOrderByAggregateInput
  }

  export type BmTcScalarWhereWithAggregatesInput = {
    AND?: BmTcScalarWhereWithAggregatesInput | BmTcScalarWhereWithAggregatesInput[]
    OR?: BmTcScalarWhereWithAggregatesInput[]
    NOT?: BmTcScalarWhereWithAggregatesInput | BmTcScalarWhereWithAggregatesInput[]
    idBm?: StringWithAggregatesFilter<"BmTc"> | string
    nomeTc?: StringWithAggregatesFilter<"BmTc"> | string
  }

  export type DataCamiaoWhereInput = {
    AND?: DataCamiaoWhereInput | DataCamiaoWhereInput[]
    OR?: DataCamiaoWhereInput[]
    NOT?: DataCamiaoWhereInput | DataCamiaoWhereInput[]
    idPlaneamento?: StringFilter<"DataCamiao"> | string
    IdCamiao?: StringFilter<"DataCamiao"> | string
    nomeUser?: StringFilter<"DataCamiao"> | string
    dataCamiao?: DateTimeFilter<"DataCamiao"> | Date | string
    quantidade?: IntFilter<"DataCamiao"> | number
    percentagem?: FloatFilter<"DataCamiao"> | number
    obs?: StringFilter<"DataCamiao"> | string
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DataCamiaoOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    IdCamiao?: SortOrder
    nomeUser?: SortOrder
    dataCamiao?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
    Planeamento?: PlaneamentoOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type DataCamiaoWhereUniqueInput = Prisma.AtLeast<{
    IdCamiao?: string
    AND?: DataCamiaoWhereInput | DataCamiaoWhereInput[]
    OR?: DataCamiaoWhereInput[]
    NOT?: DataCamiaoWhereInput | DataCamiaoWhereInput[]
    idPlaneamento?: StringFilter<"DataCamiao"> | string
    nomeUser?: StringFilter<"DataCamiao"> | string
    dataCamiao?: DateTimeFilter<"DataCamiao"> | Date | string
    quantidade?: IntFilter<"DataCamiao"> | number
    percentagem?: FloatFilter<"DataCamiao"> | number
    obs?: StringFilter<"DataCamiao"> | string
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "IdCamiao">

  export type DataCamiaoOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    IdCamiao?: SortOrder
    nomeUser?: SortOrder
    dataCamiao?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
    _count?: DataCamiaoCountOrderByAggregateInput
    _avg?: DataCamiaoAvgOrderByAggregateInput
    _max?: DataCamiaoMaxOrderByAggregateInput
    _min?: DataCamiaoMinOrderByAggregateInput
    _sum?: DataCamiaoSumOrderByAggregateInput
  }

  export type DataCamiaoScalarWhereWithAggregatesInput = {
    AND?: DataCamiaoScalarWhereWithAggregatesInput | DataCamiaoScalarWhereWithAggregatesInput[]
    OR?: DataCamiaoScalarWhereWithAggregatesInput[]
    NOT?: DataCamiaoScalarWhereWithAggregatesInput | DataCamiaoScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"DataCamiao"> | string
    IdCamiao?: StringWithAggregatesFilter<"DataCamiao"> | string
    nomeUser?: StringWithAggregatesFilter<"DataCamiao"> | string
    dataCamiao?: DateTimeWithAggregatesFilter<"DataCamiao"> | Date | string
    quantidade?: IntWithAggregatesFilter<"DataCamiao"> | number
    percentagem?: FloatWithAggregatesFilter<"DataCamiao"> | number
    obs?: StringWithAggregatesFilter<"DataCamiao"> | string
  }

  export type DataEnvioWhereInput = {
    AND?: DataEnvioWhereInput | DataEnvioWhereInput[]
    OR?: DataEnvioWhereInput[]
    NOT?: DataEnvioWhereInput | DataEnvioWhereInput[]
    idPlaneamento?: StringFilter<"DataEnvio"> | string
    idEnvio?: StringFilter<"DataEnvio"> | string
    nomeUser?: StringFilter<"DataEnvio"> | string
    dataEnvio?: DateTimeFilter<"DataEnvio"> | Date | string
    quantidade?: IntFilter<"DataEnvio"> | number
    percentagem?: FloatFilter<"DataEnvio"> | number
    obs?: StringFilter<"DataEnvio"> | string
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DataEnvioOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    idEnvio?: SortOrder
    nomeUser?: SortOrder
    dataEnvio?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
    Planeamento?: PlaneamentoOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type DataEnvioWhereUniqueInput = Prisma.AtLeast<{
    idEnvio?: string
    AND?: DataEnvioWhereInput | DataEnvioWhereInput[]
    OR?: DataEnvioWhereInput[]
    NOT?: DataEnvioWhereInput | DataEnvioWhereInput[]
    idPlaneamento?: StringFilter<"DataEnvio"> | string
    nomeUser?: StringFilter<"DataEnvio"> | string
    dataEnvio?: DateTimeFilter<"DataEnvio"> | Date | string
    quantidade?: IntFilter<"DataEnvio"> | number
    percentagem?: FloatFilter<"DataEnvio"> | number
    obs?: StringFilter<"DataEnvio"> | string
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "idEnvio">

  export type DataEnvioOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    idEnvio?: SortOrder
    nomeUser?: SortOrder
    dataEnvio?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
    _count?: DataEnvioCountOrderByAggregateInput
    _avg?: DataEnvioAvgOrderByAggregateInput
    _max?: DataEnvioMaxOrderByAggregateInput
    _min?: DataEnvioMinOrderByAggregateInput
    _sum?: DataEnvioSumOrderByAggregateInput
  }

  export type DataEnvioScalarWhereWithAggregatesInput = {
    AND?: DataEnvioScalarWhereWithAggregatesInput | DataEnvioScalarWhereWithAggregatesInput[]
    OR?: DataEnvioScalarWhereWithAggregatesInput[]
    NOT?: DataEnvioScalarWhereWithAggregatesInput | DataEnvioScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"DataEnvio"> | string
    idEnvio?: StringWithAggregatesFilter<"DataEnvio"> | string
    nomeUser?: StringWithAggregatesFilter<"DataEnvio"> | string
    dataEnvio?: DateTimeWithAggregatesFilter<"DataEnvio"> | Date | string
    quantidade?: IntWithAggregatesFilter<"DataEnvio"> | number
    percentagem?: FloatWithAggregatesFilter<"DataEnvio"> | number
    obs?: StringWithAggregatesFilter<"DataEnvio"> | string
  }

  export type FornecedorWhereInput = {
    AND?: FornecedorWhereInput | FornecedorWhereInput[]
    OR?: FornecedorWhereInput[]
    NOT?: FornecedorWhereInput | FornecedorWhereInput[]
    idFornecedor?: StringFilter<"Fornecedor"> | string
    nomeFornecedor?: StringFilter<"Fornecedor"> | string
    Planeamento?: PlaneamentoListRelationFilter
  }

  export type FornecedorOrderByWithRelationInput = {
    idFornecedor?: SortOrder
    nomeFornecedor?: SortOrder
    Planeamento?: PlaneamentoOrderByRelationAggregateInput
  }

  export type FornecedorWhereUniqueInput = Prisma.AtLeast<{
    idFornecedor?: string
    AND?: FornecedorWhereInput | FornecedorWhereInput[]
    OR?: FornecedorWhereInput[]
    NOT?: FornecedorWhereInput | FornecedorWhereInput[]
    nomeFornecedor?: StringFilter<"Fornecedor"> | string
    Planeamento?: PlaneamentoListRelationFilter
  }, "idFornecedor">

  export type FornecedorOrderByWithAggregationInput = {
    idFornecedor?: SortOrder
    nomeFornecedor?: SortOrder
    _count?: FornecedorCountOrderByAggregateInput
    _max?: FornecedorMaxOrderByAggregateInput
    _min?: FornecedorMinOrderByAggregateInput
  }

  export type FornecedorScalarWhereWithAggregatesInput = {
    AND?: FornecedorScalarWhereWithAggregatesInput | FornecedorScalarWhereWithAggregatesInput[]
    OR?: FornecedorScalarWhereWithAggregatesInput[]
    NOT?: FornecedorScalarWhereWithAggregatesInput | FornecedorScalarWhereWithAggregatesInput[]
    idFornecedor?: StringWithAggregatesFilter<"Fornecedor"> | string
    nomeFornecedor?: StringWithAggregatesFilter<"Fornecedor"> | string
  }

  export type LivreWhereInput = {
    AND?: LivreWhereInput | LivreWhereInput[]
    OR?: LivreWhereInput[]
    NOT?: LivreWhereInput | LivreWhereInput[]
    idPlaneamento?: StringFilter<"Livre"> | string
    idLivre?: StringFilter<"Livre"> | string
    nomeUser?: StringFilter<"Livre"> | string
    Op?: StringNullableFilter<"Livre"> | string | null
    nOp?: IntNullableFilter<"Livre"> | number | null
    orcamentoStamp?: StringNullableFilter<"Livre"> | string | null
    nOrcamento?: IntNullableFilter<"Livre"> | number | null
    anoOrcamento?: IntNullableFilter<"Livre"> | number | null
    desenho?: StringNullableFilter<"Livre"> | string | null
    modelo?: StringFilter<"Livre"> | string
    cor?: StringFilter<"Livre"> | string
    pedidoCliente?: StringFilter<"Livre"> | string
    imagem?: StringFilter<"Livre"> | string
    cortaPt?: BoolFilter<"Livre"> | boolean
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    OrcamentoLivre?: XOR<OrcamentoLivreNullableScalarRelationFilter, OrcamentoLivreWhereInput> | null
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreListRelationFilter
  }

  export type LivreOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    nomeUser?: SortOrder
    Op?: SortOrderInput | SortOrder
    nOp?: SortOrderInput | SortOrder
    orcamentoStamp?: SortOrderInput | SortOrder
    nOrcamento?: SortOrderInput | SortOrder
    anoOrcamento?: SortOrderInput | SortOrder
    desenho?: SortOrderInput | SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
    Planeamento?: PlaneamentoOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    OrcamentoLivre?: OrcamentoLivreOrderByWithRelationInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreOrderByRelationAggregateInput
  }

  export type LivreWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_idLivre?: LivreIdPlaneamentoIdLivreCompoundUniqueInput
    AND?: LivreWhereInput | LivreWhereInput[]
    OR?: LivreWhereInput[]
    NOT?: LivreWhereInput | LivreWhereInput[]
    idPlaneamento?: StringFilter<"Livre"> | string
    idLivre?: StringFilter<"Livre"> | string
    nomeUser?: StringFilter<"Livre"> | string
    Op?: StringNullableFilter<"Livre"> | string | null
    nOp?: IntNullableFilter<"Livre"> | number | null
    orcamentoStamp?: StringNullableFilter<"Livre"> | string | null
    nOrcamento?: IntNullableFilter<"Livre"> | number | null
    anoOrcamento?: IntNullableFilter<"Livre"> | number | null
    desenho?: StringNullableFilter<"Livre"> | string | null
    modelo?: StringFilter<"Livre"> | string
    cor?: StringFilter<"Livre"> | string
    pedidoCliente?: StringFilter<"Livre"> | string
    imagem?: StringFilter<"Livre"> | string
    cortaPt?: BoolFilter<"Livre"> | boolean
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    OrcamentoLivre?: XOR<OrcamentoLivreNullableScalarRelationFilter, OrcamentoLivreWhereInput> | null
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreListRelationFilter
  }, "idPlaneamento_idLivre">

  export type LivreOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    nomeUser?: SortOrder
    Op?: SortOrderInput | SortOrder
    nOp?: SortOrderInput | SortOrder
    orcamentoStamp?: SortOrderInput | SortOrder
    nOrcamento?: SortOrderInput | SortOrder
    anoOrcamento?: SortOrderInput | SortOrder
    desenho?: SortOrderInput | SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
    _count?: LivreCountOrderByAggregateInput
    _avg?: LivreAvgOrderByAggregateInput
    _max?: LivreMaxOrderByAggregateInput
    _min?: LivreMinOrderByAggregateInput
    _sum?: LivreSumOrderByAggregateInput
  }

  export type LivreScalarWhereWithAggregatesInput = {
    AND?: LivreScalarWhereWithAggregatesInput | LivreScalarWhereWithAggregatesInput[]
    OR?: LivreScalarWhereWithAggregatesInput[]
    NOT?: LivreScalarWhereWithAggregatesInput | LivreScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"Livre"> | string
    idLivre?: StringWithAggregatesFilter<"Livre"> | string
    nomeUser?: StringWithAggregatesFilter<"Livre"> | string
    Op?: StringNullableWithAggregatesFilter<"Livre"> | string | null
    nOp?: IntNullableWithAggregatesFilter<"Livre"> | number | null
    orcamentoStamp?: StringNullableWithAggregatesFilter<"Livre"> | string | null
    nOrcamento?: IntNullableWithAggregatesFilter<"Livre"> | number | null
    anoOrcamento?: IntNullableWithAggregatesFilter<"Livre"> | number | null
    desenho?: StringNullableWithAggregatesFilter<"Livre"> | string | null
    modelo?: StringWithAggregatesFilter<"Livre"> | string
    cor?: StringWithAggregatesFilter<"Livre"> | string
    pedidoCliente?: StringWithAggregatesFilter<"Livre"> | string
    imagem?: StringWithAggregatesFilter<"Livre"> | string
    cortaPt?: BoolWithAggregatesFilter<"Livre"> | boolean
  }

  export type OpWhereInput = {
    AND?: OpWhereInput | OpWhereInput[]
    OR?: OpWhereInput[]
    NOT?: OpWhereInput | OpWhereInput[]
    idPlaneamento?: StringFilter<"Op"> | string
    Op?: StringFilter<"Op"> | string
    nomeUser?: StringFilter<"Op"> | string
    nOp?: IntFilter<"Op"> | number
    modelo?: StringFilter<"Op"> | string
    cor?: StringFilter<"Op"> | string
    pedidoCliente?: StringFilter<"Op"> | string
    imagem?: StringFilter<"Op"> | string
    cortaPt?: BoolFilter<"Op"> | boolean
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: XOR<OrcamentoOpNullableScalarRelationFilter, OrcamentoOpWhereInput> | null
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpListRelationFilter
  }

  export type OpOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    nomeUser?: SortOrder
    nOp?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
    Planeamento?: PlaneamentoOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpOrderByWithRelationInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpOrderByRelationAggregateInput
  }

  export type OpWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_Op?: OpIdPlaneamentoOpCompoundUniqueInput
    AND?: OpWhereInput | OpWhereInput[]
    OR?: OpWhereInput[]
    NOT?: OpWhereInput | OpWhereInput[]
    idPlaneamento?: StringFilter<"Op"> | string
    Op?: StringFilter<"Op"> | string
    nomeUser?: StringFilter<"Op"> | string
    nOp?: IntFilter<"Op"> | number
    modelo?: StringFilter<"Op"> | string
    cor?: StringFilter<"Op"> | string
    pedidoCliente?: StringFilter<"Op"> | string
    imagem?: StringFilter<"Op"> | string
    cortaPt?: BoolFilter<"Op"> | boolean
    Planeamento?: XOR<PlaneamentoScalarRelationFilter, PlaneamentoWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: XOR<OrcamentoOpNullableScalarRelationFilter, OrcamentoOpWhereInput> | null
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpListRelationFilter
  }, "idPlaneamento_Op">

  export type OpOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    nomeUser?: SortOrder
    nOp?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
    _count?: OpCountOrderByAggregateInput
    _avg?: OpAvgOrderByAggregateInput
    _max?: OpMaxOrderByAggregateInput
    _min?: OpMinOrderByAggregateInput
    _sum?: OpSumOrderByAggregateInput
  }

  export type OpScalarWhereWithAggregatesInput = {
    AND?: OpScalarWhereWithAggregatesInput | OpScalarWhereWithAggregatesInput[]
    OR?: OpScalarWhereWithAggregatesInput[]
    NOT?: OpScalarWhereWithAggregatesInput | OpScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"Op"> | string
    Op?: StringWithAggregatesFilter<"Op"> | string
    nomeUser?: StringWithAggregatesFilter<"Op"> | string
    nOp?: IntWithAggregatesFilter<"Op"> | number
    modelo?: StringWithAggregatesFilter<"Op"> | string
    cor?: StringWithAggregatesFilter<"Op"> | string
    pedidoCliente?: StringWithAggregatesFilter<"Op"> | string
    imagem?: StringWithAggregatesFilter<"Op"> | string
    cortaPt?: BoolWithAggregatesFilter<"Op"> | boolean
  }

  export type OrcamentoLivreWhereInput = {
    AND?: OrcamentoLivreWhereInput | OrcamentoLivreWhereInput[]
    OR?: OrcamentoLivreWhereInput[]
    NOT?: OrcamentoLivreWhereInput | OrcamentoLivreWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoLivre"> | string
    idLivre?: StringFilter<"OrcamentoLivre"> | string
    orcamentoStamp?: StringFilter<"OrcamentoLivre"> | string
    orcamentoNumero?: IntFilter<"OrcamentoLivre"> | number
    ano?: IntFilter<"OrcamentoLivre"> | number
    Livre?: XOR<LivreScalarRelationFilter, LivreWhereInput>
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasListRelationFilter
  }

  export type OrcamentoLivreOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
    Livre?: LivreOrderByWithRelationInput
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasOrderByRelationAggregateInput
  }

  export type OrcamentoLivreWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_idLivre_orcamentoStamp?: OrcamentoLivreIdPlaneamentoIdLivreOrcamentoStampCompoundUniqueInput
    idPlaneamento_idLivre?: OrcamentoLivreIdPlaneamentoIdLivreCompoundUniqueInput
    AND?: OrcamentoLivreWhereInput | OrcamentoLivreWhereInput[]
    OR?: OrcamentoLivreWhereInput[]
    NOT?: OrcamentoLivreWhereInput | OrcamentoLivreWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoLivre"> | string
    idLivre?: StringFilter<"OrcamentoLivre"> | string
    orcamentoStamp?: StringFilter<"OrcamentoLivre"> | string
    orcamentoNumero?: IntFilter<"OrcamentoLivre"> | number
    ano?: IntFilter<"OrcamentoLivre"> | number
    Livre?: XOR<LivreScalarRelationFilter, LivreWhereInput>
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasListRelationFilter
  }, "idPlaneamento_idLivre_orcamentoStamp" | "idPlaneamento_idLivre_orcamentoStamp" | "idPlaneamento_idLivre">

  export type OrcamentoLivreOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
    _count?: OrcamentoLivreCountOrderByAggregateInput
    _avg?: OrcamentoLivreAvgOrderByAggregateInput
    _max?: OrcamentoLivreMaxOrderByAggregateInput
    _min?: OrcamentoLivreMinOrderByAggregateInput
    _sum?: OrcamentoLivreSumOrderByAggregateInput
  }

  export type OrcamentoLivreScalarWhereWithAggregatesInput = {
    AND?: OrcamentoLivreScalarWhereWithAggregatesInput | OrcamentoLivreScalarWhereWithAggregatesInput[]
    OR?: OrcamentoLivreScalarWhereWithAggregatesInput[]
    NOT?: OrcamentoLivreScalarWhereWithAggregatesInput | OrcamentoLivreScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"OrcamentoLivre"> | string
    idLivre?: StringWithAggregatesFilter<"OrcamentoLivre"> | string
    orcamentoStamp?: StringWithAggregatesFilter<"OrcamentoLivre"> | string
    orcamentoNumero?: IntWithAggregatesFilter<"OrcamentoLivre"> | number
    ano?: IntWithAggregatesFilter<"OrcamentoLivre"> | number
  }

  export type OrcamentoLivreLinhasWhereInput = {
    AND?: OrcamentoLivreLinhasWhereInput | OrcamentoLivreLinhasWhereInput[]
    OR?: OrcamentoLivreLinhasWhereInput[]
    NOT?: OrcamentoLivreLinhasWhereInput | OrcamentoLivreLinhasWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoLivreLinhas"> | string
    idLivre?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoStamp?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoLinhasStamp?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoLinhasStampRecebido?: StringFilter<"OrcamentoLivreLinhas"> | string
    ordem?: IntFilter<"OrcamentoLivreLinhas"> | number
    design?: StringFilter<"OrcamentoLivreLinhas"> | string
    custoPeca?: FloatFilter<"OrcamentoLivreLinhas"> | number
    edebito?: FloatFilter<"OrcamentoLivreLinhas"> | number
    qtt?: FloatFilter<"OrcamentoLivreLinhas"> | number
    unidade?: StringFilter<"OrcamentoLivreLinhas"> | string
    OrcamentoLivre?: XOR<OrcamentoLivreScalarRelationFilter, OrcamentoLivreWhereInput>
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemListRelationFilter
  }

  export type OrcamentoLivreLinhasOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    OrcamentoLivre?: OrcamentoLivreOrderByWithRelationInput
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemOrderByRelationAggregateInput
  }

  export type OrcamentoLivreLinhasWhereUniqueInput = Prisma.AtLeast<{
    orcamentoLinhasStamp?: string
    idPlaneamento_idLivre_orcamentoStamp_orcamentoLinhasStamp?: OrcamentoLivreLinhasIdPlaneamentoIdLivreOrcamentoStampOrcamentoLinhasStampCompoundUniqueInput
    AND?: OrcamentoLivreLinhasWhereInput | OrcamentoLivreLinhasWhereInput[]
    OR?: OrcamentoLivreLinhasWhereInput[]
    NOT?: OrcamentoLivreLinhasWhereInput | OrcamentoLivreLinhasWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoLivreLinhas"> | string
    idLivre?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoStamp?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoLinhasStampRecebido?: StringFilter<"OrcamentoLivreLinhas"> | string
    ordem?: IntFilter<"OrcamentoLivreLinhas"> | number
    design?: StringFilter<"OrcamentoLivreLinhas"> | string
    custoPeca?: FloatFilter<"OrcamentoLivreLinhas"> | number
    edebito?: FloatFilter<"OrcamentoLivreLinhas"> | number
    qtt?: FloatFilter<"OrcamentoLivreLinhas"> | number
    unidade?: StringFilter<"OrcamentoLivreLinhas"> | string
    OrcamentoLivre?: XOR<OrcamentoLivreScalarRelationFilter, OrcamentoLivreWhereInput>
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemListRelationFilter
  }, "idPlaneamento_idLivre_orcamentoStamp_orcamentoLinhasStamp" | "orcamentoLinhasStamp">

  export type OrcamentoLivreLinhasOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    _count?: OrcamentoLivreLinhasCountOrderByAggregateInput
    _avg?: OrcamentoLivreLinhasAvgOrderByAggregateInput
    _max?: OrcamentoLivreLinhasMaxOrderByAggregateInput
    _min?: OrcamentoLivreLinhasMinOrderByAggregateInput
    _sum?: OrcamentoLivreLinhasSumOrderByAggregateInput
  }

  export type OrcamentoLivreLinhasScalarWhereWithAggregatesInput = {
    AND?: OrcamentoLivreLinhasScalarWhereWithAggregatesInput | OrcamentoLivreLinhasScalarWhereWithAggregatesInput[]
    OR?: OrcamentoLivreLinhasScalarWhereWithAggregatesInput[]
    NOT?: OrcamentoLivreLinhasScalarWhereWithAggregatesInput | OrcamentoLivreLinhasScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"OrcamentoLivreLinhas"> | string
    idLivre?: StringWithAggregatesFilter<"OrcamentoLivreLinhas"> | string
    orcamentoStamp?: StringWithAggregatesFilter<"OrcamentoLivreLinhas"> | string
    orcamentoLinhasStamp?: StringWithAggregatesFilter<"OrcamentoLivreLinhas"> | string
    orcamentoLinhasStampRecebido?: StringWithAggregatesFilter<"OrcamentoLivreLinhas"> | string
    ordem?: IntWithAggregatesFilter<"OrcamentoLivreLinhas"> | number
    design?: StringWithAggregatesFilter<"OrcamentoLivreLinhas"> | string
    custoPeca?: FloatWithAggregatesFilter<"OrcamentoLivreLinhas"> | number
    edebito?: FloatWithAggregatesFilter<"OrcamentoLivreLinhas"> | number
    qtt?: FloatWithAggregatesFilter<"OrcamentoLivreLinhas"> | number
    unidade?: StringWithAggregatesFilter<"OrcamentoLivreLinhas"> | string
  }

  export type OrcamentoOpWhereInput = {
    AND?: OrcamentoOpWhereInput | OrcamentoOpWhereInput[]
    OR?: OrcamentoOpWhereInput[]
    NOT?: OrcamentoOpWhereInput | OrcamentoOpWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoOp"> | string
    Op?: StringFilter<"OrcamentoOp"> | string
    orcamentoStamp?: StringFilter<"OrcamentoOp"> | string
    orcamentoNumero?: IntFilter<"OrcamentoOp"> | number
    ano?: IntFilter<"OrcamentoOp"> | number
    Op_OrcamentoOp_idPlaneamento_OpToOp?: XOR<OpScalarRelationFilter, OpWhereInput>
    OrcamentoOpLinhas?: OrcamentoOpLinhasListRelationFilter
  }

  export type OrcamentoOpOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
    Op_OrcamentoOp_idPlaneamento_OpToOp?: OpOrderByWithRelationInput
    OrcamentoOpLinhas?: OrcamentoOpLinhasOrderByRelationAggregateInput
  }

  export type OrcamentoOpWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_Op_orcamentoStamp?: OrcamentoOpIdPlaneamentoOpOrcamentoStampCompoundUniqueInput
    idPlaneamento_Op?: OrcamentoOpIdPlaneamentoOpCompoundUniqueInput
    AND?: OrcamentoOpWhereInput | OrcamentoOpWhereInput[]
    OR?: OrcamentoOpWhereInput[]
    NOT?: OrcamentoOpWhereInput | OrcamentoOpWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoOp"> | string
    Op?: StringFilter<"OrcamentoOp"> | string
    orcamentoStamp?: StringFilter<"OrcamentoOp"> | string
    orcamentoNumero?: IntFilter<"OrcamentoOp"> | number
    ano?: IntFilter<"OrcamentoOp"> | number
    Op_OrcamentoOp_idPlaneamento_OpToOp?: XOR<OpScalarRelationFilter, OpWhereInput>
    OrcamentoOpLinhas?: OrcamentoOpLinhasListRelationFilter
  }, "idPlaneamento_Op_orcamentoStamp" | "idPlaneamento_Op_orcamentoStamp" | "idPlaneamento_Op">

  export type OrcamentoOpOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
    _count?: OrcamentoOpCountOrderByAggregateInput
    _avg?: OrcamentoOpAvgOrderByAggregateInput
    _max?: OrcamentoOpMaxOrderByAggregateInput
    _min?: OrcamentoOpMinOrderByAggregateInput
    _sum?: OrcamentoOpSumOrderByAggregateInput
  }

  export type OrcamentoOpScalarWhereWithAggregatesInput = {
    AND?: OrcamentoOpScalarWhereWithAggregatesInput | OrcamentoOpScalarWhereWithAggregatesInput[]
    OR?: OrcamentoOpScalarWhereWithAggregatesInput[]
    NOT?: OrcamentoOpScalarWhereWithAggregatesInput | OrcamentoOpScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"OrcamentoOp"> | string
    Op?: StringWithAggregatesFilter<"OrcamentoOp"> | string
    orcamentoStamp?: StringWithAggregatesFilter<"OrcamentoOp"> | string
    orcamentoNumero?: IntWithAggregatesFilter<"OrcamentoOp"> | number
    ano?: IntWithAggregatesFilter<"OrcamentoOp"> | number
  }

  export type OrcamentoOpLinhasWhereInput = {
    AND?: OrcamentoOpLinhasWhereInput | OrcamentoOpLinhasWhereInput[]
    OR?: OrcamentoOpLinhasWhereInput[]
    NOT?: OrcamentoOpLinhasWhereInput | OrcamentoOpLinhasWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoOpLinhas"> | string
    Op?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoStamp?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoLinhasStamp?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoLinhasStampRecebido?: StringFilter<"OrcamentoOpLinhas"> | string
    ordem?: IntFilter<"OrcamentoOpLinhas"> | number
    design?: StringFilter<"OrcamentoOpLinhas"> | string
    custoPeca?: FloatFilter<"OrcamentoOpLinhas"> | number
    edebito?: FloatFilter<"OrcamentoOpLinhas"> | number
    qtt?: FloatFilter<"OrcamentoOpLinhas"> | number
    unidade?: StringFilter<"OrcamentoOpLinhas"> | string
    OrcamentoOp?: XOR<OrcamentoOpScalarRelationFilter, OrcamentoOpWhereInput>
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemListRelationFilter
  }

  export type OrcamentoOpLinhasOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    OrcamentoOp?: OrcamentoOpOrderByWithRelationInput
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemOrderByRelationAggregateInput
  }

  export type OrcamentoOpLinhasWhereUniqueInput = Prisma.AtLeast<{
    orcamentoLinhasStamp?: string
    idPlaneamento_Op_orcamentoStamp_orcamentoLinhasStamp?: OrcamentoOpLinhasIdPlaneamentoOpOrcamentoStampOrcamentoLinhasStampCompoundUniqueInput
    AND?: OrcamentoOpLinhasWhereInput | OrcamentoOpLinhasWhereInput[]
    OR?: OrcamentoOpLinhasWhereInput[]
    NOT?: OrcamentoOpLinhasWhereInput | OrcamentoOpLinhasWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoOpLinhas"> | string
    Op?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoStamp?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoLinhasStampRecebido?: StringFilter<"OrcamentoOpLinhas"> | string
    ordem?: IntFilter<"OrcamentoOpLinhas"> | number
    design?: StringFilter<"OrcamentoOpLinhas"> | string
    custoPeca?: FloatFilter<"OrcamentoOpLinhas"> | number
    edebito?: FloatFilter<"OrcamentoOpLinhas"> | number
    qtt?: FloatFilter<"OrcamentoOpLinhas"> | number
    unidade?: StringFilter<"OrcamentoOpLinhas"> | string
    OrcamentoOp?: XOR<OrcamentoOpScalarRelationFilter, OrcamentoOpWhereInput>
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemListRelationFilter
  }, "idPlaneamento_Op_orcamentoStamp_orcamentoLinhasStamp" | "orcamentoLinhasStamp">

  export type OrcamentoOpLinhasOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    _count?: OrcamentoOpLinhasCountOrderByAggregateInput
    _avg?: OrcamentoOpLinhasAvgOrderByAggregateInput
    _max?: OrcamentoOpLinhasMaxOrderByAggregateInput
    _min?: OrcamentoOpLinhasMinOrderByAggregateInput
    _sum?: OrcamentoOpLinhasSumOrderByAggregateInput
  }

  export type OrcamentoOpLinhasScalarWhereWithAggregatesInput = {
    AND?: OrcamentoOpLinhasScalarWhereWithAggregatesInput | OrcamentoOpLinhasScalarWhereWithAggregatesInput[]
    OR?: OrcamentoOpLinhasScalarWhereWithAggregatesInput[]
    NOT?: OrcamentoOpLinhasScalarWhereWithAggregatesInput | OrcamentoOpLinhasScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"OrcamentoOpLinhas"> | string
    Op?: StringWithAggregatesFilter<"OrcamentoOpLinhas"> | string
    orcamentoStamp?: StringWithAggregatesFilter<"OrcamentoOpLinhas"> | string
    orcamentoLinhasStamp?: StringWithAggregatesFilter<"OrcamentoOpLinhas"> | string
    orcamentoLinhasStampRecebido?: StringWithAggregatesFilter<"OrcamentoOpLinhas"> | string
    ordem?: IntWithAggregatesFilter<"OrcamentoOpLinhas"> | number
    design?: StringWithAggregatesFilter<"OrcamentoOpLinhas"> | string
    custoPeca?: FloatWithAggregatesFilter<"OrcamentoOpLinhas"> | number
    edebito?: FloatWithAggregatesFilter<"OrcamentoOpLinhas"> | number
    qtt?: FloatWithAggregatesFilter<"OrcamentoOpLinhas"> | number
    unidade?: StringWithAggregatesFilter<"OrcamentoOpLinhas"> | string
  }

  export type PapeisWhereInput = {
    AND?: PapeisWhereInput | PapeisWhereInput[]
    OR?: PapeisWhereInput[]
    NOT?: PapeisWhereInput | PapeisWhereInput[]
    idPapeis?: StringFilter<"Papeis"> | string
    descPapel?: StringFilter<"Papeis"> | string
    UserPapeis?: UserPapeisListRelationFilter
  }

  export type PapeisOrderByWithRelationInput = {
    idPapeis?: SortOrder
    descPapel?: SortOrder
    UserPapeis?: UserPapeisOrderByRelationAggregateInput
  }

  export type PapeisWhereUniqueInput = Prisma.AtLeast<{
    idPapeis?: string
    descPapel?: string
    AND?: PapeisWhereInput | PapeisWhereInput[]
    OR?: PapeisWhereInput[]
    NOT?: PapeisWhereInput | PapeisWhereInput[]
    UserPapeis?: UserPapeisListRelationFilter
  }, "idPapeis" | "descPapel">

  export type PapeisOrderByWithAggregationInput = {
    idPapeis?: SortOrder
    descPapel?: SortOrder
    _count?: PapeisCountOrderByAggregateInput
    _max?: PapeisMaxOrderByAggregateInput
    _min?: PapeisMinOrderByAggregateInput
  }

  export type PapeisScalarWhereWithAggregatesInput = {
    AND?: PapeisScalarWhereWithAggregatesInput | PapeisScalarWhereWithAggregatesInput[]
    OR?: PapeisScalarWhereWithAggregatesInput[]
    NOT?: PapeisScalarWhereWithAggregatesInput | PapeisScalarWhereWithAggregatesInput[]
    idPapeis?: StringWithAggregatesFilter<"Papeis"> | string
    descPapel?: StringWithAggregatesFilter<"Papeis"> | string
  }

  export type PlaneamentoWhereInput = {
    AND?: PlaneamentoWhereInput | PlaneamentoWhereInput[]
    OR?: PlaneamentoWhereInput[]
    NOT?: PlaneamentoWhereInput | PlaneamentoWhereInput[]
    idPlaneamento?: StringFilter<"Planeamento"> | string
    nomeUser?: StringFilter<"Planeamento"> | string
    pais?: StringFilter<"Planeamento"> | string
    idFornecedor?: StringFilter<"Planeamento"> | string
    numeroPecas?: IntFilter<"Planeamento"> | number
    modelo?: StringFilter<"Planeamento"> | string
    obs?: StringFilter<"Planeamento"> | string
    cliente?: StringFilter<"Planeamento"> | string
    dataPrimeiroCamiao?: DateTimeNullableFilter<"Planeamento"> | Date | string | null
    dataPrimeiroEnvio?: DateTimeNullableFilter<"Planeamento"> | Date | string | null
    dataCriacao?: DateTimeFilter<"Planeamento"> | Date | string
    dataUltimaAlteracao?: DateTimeFilter<"Planeamento"> | Date | string
    envioEnviado?: BoolFilter<"Planeamento"> | boolean
    DataCamiao?: DataCamiaoListRelationFilter
    DataEnvio?: DataEnvioListRelationFilter
    Livre?: LivreListRelationFilter
    Op?: OpListRelationFilter
    Fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PlaneamentoOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    nomeUser?: SortOrder
    pais?: SortOrder
    idFornecedor?: SortOrder
    numeroPecas?: SortOrder
    modelo?: SortOrder
    obs?: SortOrder
    cliente?: SortOrder
    dataPrimeiroCamiao?: SortOrderInput | SortOrder
    dataPrimeiroEnvio?: SortOrderInput | SortOrder
    dataCriacao?: SortOrder
    dataUltimaAlteracao?: SortOrder
    envioEnviado?: SortOrder
    DataCamiao?: DataCamiaoOrderByRelationAggregateInput
    DataEnvio?: DataEnvioOrderByRelationAggregateInput
    Livre?: LivreOrderByRelationAggregateInput
    Op?: OpOrderByRelationAggregateInput
    Fornecedor?: FornecedorOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type PlaneamentoWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento?: string
    AND?: PlaneamentoWhereInput | PlaneamentoWhereInput[]
    OR?: PlaneamentoWhereInput[]
    NOT?: PlaneamentoWhereInput | PlaneamentoWhereInput[]
    nomeUser?: StringFilter<"Planeamento"> | string
    pais?: StringFilter<"Planeamento"> | string
    idFornecedor?: StringFilter<"Planeamento"> | string
    numeroPecas?: IntFilter<"Planeamento"> | number
    modelo?: StringFilter<"Planeamento"> | string
    obs?: StringFilter<"Planeamento"> | string
    cliente?: StringFilter<"Planeamento"> | string
    dataPrimeiroCamiao?: DateTimeNullableFilter<"Planeamento"> | Date | string | null
    dataPrimeiroEnvio?: DateTimeNullableFilter<"Planeamento"> | Date | string | null
    dataCriacao?: DateTimeFilter<"Planeamento"> | Date | string
    dataUltimaAlteracao?: DateTimeFilter<"Planeamento"> | Date | string
    envioEnviado?: BoolFilter<"Planeamento"> | boolean
    DataCamiao?: DataCamiaoListRelationFilter
    DataEnvio?: DataEnvioListRelationFilter
    Livre?: LivreListRelationFilter
    Op?: OpListRelationFilter
    Fornecedor?: XOR<FornecedorScalarRelationFilter, FornecedorWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "idPlaneamento">

  export type PlaneamentoOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    nomeUser?: SortOrder
    pais?: SortOrder
    idFornecedor?: SortOrder
    numeroPecas?: SortOrder
    modelo?: SortOrder
    obs?: SortOrder
    cliente?: SortOrder
    dataPrimeiroCamiao?: SortOrderInput | SortOrder
    dataPrimeiroEnvio?: SortOrderInput | SortOrder
    dataCriacao?: SortOrder
    dataUltimaAlteracao?: SortOrder
    envioEnviado?: SortOrder
    _count?: PlaneamentoCountOrderByAggregateInput
    _avg?: PlaneamentoAvgOrderByAggregateInput
    _max?: PlaneamentoMaxOrderByAggregateInput
    _min?: PlaneamentoMinOrderByAggregateInput
    _sum?: PlaneamentoSumOrderByAggregateInput
  }

  export type PlaneamentoScalarWhereWithAggregatesInput = {
    AND?: PlaneamentoScalarWhereWithAggregatesInput | PlaneamentoScalarWhereWithAggregatesInput[]
    OR?: PlaneamentoScalarWhereWithAggregatesInput[]
    NOT?: PlaneamentoScalarWhereWithAggregatesInput | PlaneamentoScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"Planeamento"> | string
    nomeUser?: StringWithAggregatesFilter<"Planeamento"> | string
    pais?: StringWithAggregatesFilter<"Planeamento"> | string
    idFornecedor?: StringWithAggregatesFilter<"Planeamento"> | string
    numeroPecas?: IntWithAggregatesFilter<"Planeamento"> | number
    modelo?: StringWithAggregatesFilter<"Planeamento"> | string
    obs?: StringWithAggregatesFilter<"Planeamento"> | string
    cliente?: StringWithAggregatesFilter<"Planeamento"> | string
    dataPrimeiroCamiao?: DateTimeNullableWithAggregatesFilter<"Planeamento"> | Date | string | null
    dataPrimeiroEnvio?: DateTimeNullableWithAggregatesFilter<"Planeamento"> | Date | string | null
    dataCriacao?: DateTimeWithAggregatesFilter<"Planeamento"> | Date | string
    dataUltimaAlteracao?: DateTimeWithAggregatesFilter<"Planeamento"> | Date | string
    envioEnviado?: BoolWithAggregatesFilter<"Planeamento"> | boolean
  }

  export type ServicosEscolhidosLivreWhereInput = {
    AND?: ServicosEscolhidosLivreWhereInput | ServicosEscolhidosLivreWhereInput[]
    OR?: ServicosEscolhidosLivreWhereInput[]
    NOT?: ServicosEscolhidosLivreWhereInput | ServicosEscolhidosLivreWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosLivre"> | string
    idLivre?: StringFilter<"ServicosEscolhidosLivre"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosLivre"> | string
    nome?: StringFilter<"ServicosEscolhidosLivre"> | string
    qtt?: FloatFilter<"ServicosEscolhidosLivre"> | number
    preco?: FloatFilter<"ServicosEscolhidosLivre"> | number
    valor?: FloatFilter<"ServicosEscolhidosLivre"> | number
    unidade?: StringFilter<"ServicosEscolhidosLivre"> | string
    obs?: StringFilter<"ServicosEscolhidosLivre"> | string
    Livre?: XOR<LivreScalarRelationFilter, LivreWhereInput>
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemListRelationFilter
  }

  export type ServicosEscolhidosLivreOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
    Livre?: LivreOrderByWithRelationInput
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemOrderByRelationAggregateInput
  }

  export type ServicosEscolhidosLivreWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_idLivre_idServicoEscolhido?: ServicosEscolhidosLivreIdPlaneamentoIdLivreIdServicoEscolhidoCompoundUniqueInput
    AND?: ServicosEscolhidosLivreWhereInput | ServicosEscolhidosLivreWhereInput[]
    OR?: ServicosEscolhidosLivreWhereInput[]
    NOT?: ServicosEscolhidosLivreWhereInput | ServicosEscolhidosLivreWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosLivre"> | string
    idLivre?: StringFilter<"ServicosEscolhidosLivre"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosLivre"> | string
    nome?: StringFilter<"ServicosEscolhidosLivre"> | string
    qtt?: FloatFilter<"ServicosEscolhidosLivre"> | number
    preco?: FloatFilter<"ServicosEscolhidosLivre"> | number
    valor?: FloatFilter<"ServicosEscolhidosLivre"> | number
    unidade?: StringFilter<"ServicosEscolhidosLivre"> | string
    obs?: StringFilter<"ServicosEscolhidosLivre"> | string
    Livre?: XOR<LivreScalarRelationFilter, LivreWhereInput>
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemListRelationFilter
  }, "idPlaneamento_idLivre_idServicoEscolhido">

  export type ServicosEscolhidosLivreOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
    _count?: ServicosEscolhidosLivreCountOrderByAggregateInput
    _avg?: ServicosEscolhidosLivreAvgOrderByAggregateInput
    _max?: ServicosEscolhidosLivreMaxOrderByAggregateInput
    _min?: ServicosEscolhidosLivreMinOrderByAggregateInput
    _sum?: ServicosEscolhidosLivreSumOrderByAggregateInput
  }

  export type ServicosEscolhidosLivreScalarWhereWithAggregatesInput = {
    AND?: ServicosEscolhidosLivreScalarWhereWithAggregatesInput | ServicosEscolhidosLivreScalarWhereWithAggregatesInput[]
    OR?: ServicosEscolhidosLivreScalarWhereWithAggregatesInput[]
    NOT?: ServicosEscolhidosLivreScalarWhereWithAggregatesInput | ServicosEscolhidosLivreScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"ServicosEscolhidosLivre"> | string
    idLivre?: StringWithAggregatesFilter<"ServicosEscolhidosLivre"> | string
    idServicoEscolhido?: StringWithAggregatesFilter<"ServicosEscolhidosLivre"> | string
    nome?: StringWithAggregatesFilter<"ServicosEscolhidosLivre"> | string
    qtt?: FloatWithAggregatesFilter<"ServicosEscolhidosLivre"> | number
    preco?: FloatWithAggregatesFilter<"ServicosEscolhidosLivre"> | number
    valor?: FloatWithAggregatesFilter<"ServicosEscolhidosLivre"> | number
    unidade?: StringWithAggregatesFilter<"ServicosEscolhidosLivre"> | string
    obs?: StringWithAggregatesFilter<"ServicosEscolhidosLivre"> | string
  }

  export type ServicosEscolhidosLivreOrigemWhereInput = {
    AND?: ServicosEscolhidosLivreOrigemWhereInput | ServicosEscolhidosLivreOrigemWhereInput[]
    OR?: ServicosEscolhidosLivreOrigemWhereInput[]
    NOT?: ServicosEscolhidosLivreOrigemWhereInput | ServicosEscolhidosLivreOrigemWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    idLivre?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    orcamentoLinhasStamp?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    OrcamentoLivreLinhas?: XOR<OrcamentoLivreLinhasScalarRelationFilter, OrcamentoLivreLinhasWhereInput>
    ServicosEscolhidosLivre?: XOR<ServicosEscolhidosLivreScalarRelationFilter, ServicosEscolhidosLivreWhereInput>
  }

  export type ServicosEscolhidosLivreOrigemOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasOrderByWithRelationInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreOrderByWithRelationInput
  }

  export type ServicosEscolhidosLivreOrigemWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_idLivre_idServicoEscolhido_orcamentoLinhasStamp?: ServicosEscolhidosLivreOrigemIdPlaneamentoIdLivreIdServicoEscolhidoOrcamentoLinhasStampCompoundUniqueInput
    AND?: ServicosEscolhidosLivreOrigemWhereInput | ServicosEscolhidosLivreOrigemWhereInput[]
    OR?: ServicosEscolhidosLivreOrigemWhereInput[]
    NOT?: ServicosEscolhidosLivreOrigemWhereInput | ServicosEscolhidosLivreOrigemWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    idLivre?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    orcamentoLinhasStamp?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    OrcamentoLivreLinhas?: XOR<OrcamentoLivreLinhasScalarRelationFilter, OrcamentoLivreLinhasWhereInput>
    ServicosEscolhidosLivre?: XOR<ServicosEscolhidosLivreScalarRelationFilter, ServicosEscolhidosLivreWhereInput>
  }, "idPlaneamento_idLivre_idServicoEscolhido_orcamentoLinhasStamp">

  export type ServicosEscolhidosLivreOrigemOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    _count?: ServicosEscolhidosLivreOrigemCountOrderByAggregateInput
    _max?: ServicosEscolhidosLivreOrigemMaxOrderByAggregateInput
    _min?: ServicosEscolhidosLivreOrigemMinOrderByAggregateInput
  }

  export type ServicosEscolhidosLivreOrigemScalarWhereWithAggregatesInput = {
    AND?: ServicosEscolhidosLivreOrigemScalarWhereWithAggregatesInput | ServicosEscolhidosLivreOrigemScalarWhereWithAggregatesInput[]
    OR?: ServicosEscolhidosLivreOrigemScalarWhereWithAggregatesInput[]
    NOT?: ServicosEscolhidosLivreOrigemScalarWhereWithAggregatesInput | ServicosEscolhidosLivreOrigemScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"ServicosEscolhidosLivreOrigem"> | string
    idLivre?: StringWithAggregatesFilter<"ServicosEscolhidosLivreOrigem"> | string
    idServicoEscolhido?: StringWithAggregatesFilter<"ServicosEscolhidosLivreOrigem"> | string
    orcamentoLinhasStamp?: StringWithAggregatesFilter<"ServicosEscolhidosLivreOrigem"> | string
  }

  export type ServicosEscolhidosOpWhereInput = {
    AND?: ServicosEscolhidosOpWhereInput | ServicosEscolhidosOpWhereInput[]
    OR?: ServicosEscolhidosOpWhereInput[]
    NOT?: ServicosEscolhidosOpWhereInput | ServicosEscolhidosOpWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosOp"> | string
    Op?: StringFilter<"ServicosEscolhidosOp"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosOp"> | string
    nome?: StringFilter<"ServicosEscolhidosOp"> | string
    qtt?: FloatFilter<"ServicosEscolhidosOp"> | number
    preco?: FloatFilter<"ServicosEscolhidosOp"> | number
    valor?: FloatFilter<"ServicosEscolhidosOp"> | number
    unidade?: StringFilter<"ServicosEscolhidosOp"> | string
    obs?: StringFilter<"ServicosEscolhidosOp"> | string
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp?: XOR<OpScalarRelationFilter, OpWhereInput>
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemListRelationFilter
  }

  export type ServicosEscolhidosOpOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp?: OpOrderByWithRelationInput
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemOrderByRelationAggregateInput
  }

  export type ServicosEscolhidosOpWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_Op_idServicoEscolhido?: ServicosEscolhidosOpIdPlaneamentoOpIdServicoEscolhidoCompoundUniqueInput
    AND?: ServicosEscolhidosOpWhereInput | ServicosEscolhidosOpWhereInput[]
    OR?: ServicosEscolhidosOpWhereInput[]
    NOT?: ServicosEscolhidosOpWhereInput | ServicosEscolhidosOpWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosOp"> | string
    Op?: StringFilter<"ServicosEscolhidosOp"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosOp"> | string
    nome?: StringFilter<"ServicosEscolhidosOp"> | string
    qtt?: FloatFilter<"ServicosEscolhidosOp"> | number
    preco?: FloatFilter<"ServicosEscolhidosOp"> | number
    valor?: FloatFilter<"ServicosEscolhidosOp"> | number
    unidade?: StringFilter<"ServicosEscolhidosOp"> | string
    obs?: StringFilter<"ServicosEscolhidosOp"> | string
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp?: XOR<OpScalarRelationFilter, OpWhereInput>
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemListRelationFilter
  }, "idPlaneamento_Op_idServicoEscolhido">

  export type ServicosEscolhidosOpOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
    _count?: ServicosEscolhidosOpCountOrderByAggregateInput
    _avg?: ServicosEscolhidosOpAvgOrderByAggregateInput
    _max?: ServicosEscolhidosOpMaxOrderByAggregateInput
    _min?: ServicosEscolhidosOpMinOrderByAggregateInput
    _sum?: ServicosEscolhidosOpSumOrderByAggregateInput
  }

  export type ServicosEscolhidosOpScalarWhereWithAggregatesInput = {
    AND?: ServicosEscolhidosOpScalarWhereWithAggregatesInput | ServicosEscolhidosOpScalarWhereWithAggregatesInput[]
    OR?: ServicosEscolhidosOpScalarWhereWithAggregatesInput[]
    NOT?: ServicosEscolhidosOpScalarWhereWithAggregatesInput | ServicosEscolhidosOpScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"ServicosEscolhidosOp"> | string
    Op?: StringWithAggregatesFilter<"ServicosEscolhidosOp"> | string
    idServicoEscolhido?: StringWithAggregatesFilter<"ServicosEscolhidosOp"> | string
    nome?: StringWithAggregatesFilter<"ServicosEscolhidosOp"> | string
    qtt?: FloatWithAggregatesFilter<"ServicosEscolhidosOp"> | number
    preco?: FloatWithAggregatesFilter<"ServicosEscolhidosOp"> | number
    valor?: FloatWithAggregatesFilter<"ServicosEscolhidosOp"> | number
    unidade?: StringWithAggregatesFilter<"ServicosEscolhidosOp"> | string
    obs?: StringWithAggregatesFilter<"ServicosEscolhidosOp"> | string
  }

  export type ServicosEscolhidosOpOrigemWhereInput = {
    AND?: ServicosEscolhidosOpOrigemWhereInput | ServicosEscolhidosOpOrigemWhereInput[]
    OR?: ServicosEscolhidosOpOrigemWhereInput[]
    NOT?: ServicosEscolhidosOpOrigemWhereInput | ServicosEscolhidosOpOrigemWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    Op?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    orcamentoLinhasStamp?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    OrcamentoOpLinhas?: XOR<OrcamentoOpLinhasScalarRelationFilter, OrcamentoOpLinhasWhereInput>
    ServicosEscolhidosOp?: XOR<ServicosEscolhidosOpScalarRelationFilter, ServicosEscolhidosOpWhereInput>
  }

  export type ServicosEscolhidosOpOrigemOrderByWithRelationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    OrcamentoOpLinhas?: OrcamentoOpLinhasOrderByWithRelationInput
    ServicosEscolhidosOp?: ServicosEscolhidosOpOrderByWithRelationInput
  }

  export type ServicosEscolhidosOpOrigemWhereUniqueInput = Prisma.AtLeast<{
    idPlaneamento_Op_idServicoEscolhido_orcamentoLinhasStamp?: ServicosEscolhidosOpOrigemIdPlaneamentoOpIdServicoEscolhidoOrcamentoLinhasStampCompoundUniqueInput
    AND?: ServicosEscolhidosOpOrigemWhereInput | ServicosEscolhidosOpOrigemWhereInput[]
    OR?: ServicosEscolhidosOpOrigemWhereInput[]
    NOT?: ServicosEscolhidosOpOrigemWhereInput | ServicosEscolhidosOpOrigemWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    Op?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    orcamentoLinhasStamp?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    OrcamentoOpLinhas?: XOR<OrcamentoOpLinhasScalarRelationFilter, OrcamentoOpLinhasWhereInput>
    ServicosEscolhidosOp?: XOR<ServicosEscolhidosOpScalarRelationFilter, ServicosEscolhidosOpWhereInput>
  }, "idPlaneamento_Op_idServicoEscolhido_orcamentoLinhasStamp">

  export type ServicosEscolhidosOpOrigemOrderByWithAggregationInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    _count?: ServicosEscolhidosOpOrigemCountOrderByAggregateInput
    _max?: ServicosEscolhidosOpOrigemMaxOrderByAggregateInput
    _min?: ServicosEscolhidosOpOrigemMinOrderByAggregateInput
  }

  export type ServicosEscolhidosOpOrigemScalarWhereWithAggregatesInput = {
    AND?: ServicosEscolhidosOpOrigemScalarWhereWithAggregatesInput | ServicosEscolhidosOpOrigemScalarWhereWithAggregatesInput[]
    OR?: ServicosEscolhidosOpOrigemScalarWhereWithAggregatesInput[]
    NOT?: ServicosEscolhidosOpOrigemScalarWhereWithAggregatesInput | ServicosEscolhidosOpOrigemScalarWhereWithAggregatesInput[]
    idPlaneamento?: StringWithAggregatesFilter<"ServicosEscolhidosOpOrigem"> | string
    Op?: StringWithAggregatesFilter<"ServicosEscolhidosOpOrigem"> | string
    idServicoEscolhido?: StringWithAggregatesFilter<"ServicosEscolhidosOpOrigem"> | string
    orcamentoLinhasStamp?: StringWithAggregatesFilter<"ServicosEscolhidosOpOrigem"> | string
  }

  export type sysdiagramsWhereInput = {
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    diagram_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type sysdiagramsOrderByWithRelationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
  }

  export type sysdiagramsWhereUniqueInput = Prisma.AtLeast<{
    diagram_id?: number
    principal_id_name?: sysdiagramsPrincipal_idNameCompoundUniqueInput
    AND?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    OR?: sysdiagramsWhereInput[]
    NOT?: sysdiagramsWhereInput | sysdiagramsWhereInput[]
    name?: StringFilter<"sysdiagrams"> | string
    principal_id?: IntFilter<"sysdiagrams"> | number
    version?: IntNullableFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableFilter<"sysdiagrams"> | Uint8Array | null
  }, "diagram_id" | "principal_id_name">

  export type sysdiagramsOrderByWithAggregationInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrderInput | SortOrder
    definition?: SortOrderInput | SortOrder
    _count?: sysdiagramsCountOrderByAggregateInput
    _avg?: sysdiagramsAvgOrderByAggregateInput
    _max?: sysdiagramsMaxOrderByAggregateInput
    _min?: sysdiagramsMinOrderByAggregateInput
    _sum?: sysdiagramsSumOrderByAggregateInput
  }

  export type sysdiagramsScalarWhereWithAggregatesInput = {
    AND?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    OR?: sysdiagramsScalarWhereWithAggregatesInput[]
    NOT?: sysdiagramsScalarWhereWithAggregatesInput | sysdiagramsScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"sysdiagrams"> | string
    principal_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    diagram_id?: IntWithAggregatesFilter<"sysdiagrams"> | number
    version?: IntNullableWithAggregatesFilter<"sysdiagrams"> | number | null
    definition?: BytesNullableWithAggregatesFilter<"sysdiagrams"> | Uint8Array | null
  }

  export type TcWhereInput = {
    AND?: TcWhereInput | TcWhereInput[]
    OR?: TcWhereInput[]
    NOT?: TcWhereInput | TcWhereInput[]
    idTc?: StringFilter<"Tc"> | string
    fechado?: BoolFilter<"Tc"> | boolean
    createdAt?: DateTimeFilter<"Tc"> | Date | string
    TcOp?: TcOpListRelationFilter
  }

  export type TcOrderByWithRelationInput = {
    idTc?: SortOrder
    fechado?: SortOrder
    createdAt?: SortOrder
    TcOp?: TcOpOrderByRelationAggregateInput
  }

  export type TcWhereUniqueInput = Prisma.AtLeast<{
    idTc?: string
    AND?: TcWhereInput | TcWhereInput[]
    OR?: TcWhereInput[]
    NOT?: TcWhereInput | TcWhereInput[]
    fechado?: BoolFilter<"Tc"> | boolean
    createdAt?: DateTimeFilter<"Tc"> | Date | string
    TcOp?: TcOpListRelationFilter
  }, "idTc">

  export type TcOrderByWithAggregationInput = {
    idTc?: SortOrder
    fechado?: SortOrder
    createdAt?: SortOrder
    _count?: TcCountOrderByAggregateInput
    _max?: TcMaxOrderByAggregateInput
    _min?: TcMinOrderByAggregateInput
  }

  export type TcScalarWhereWithAggregatesInput = {
    AND?: TcScalarWhereWithAggregatesInput | TcScalarWhereWithAggregatesInput[]
    OR?: TcScalarWhereWithAggregatesInput[]
    NOT?: TcScalarWhereWithAggregatesInput | TcScalarWhereWithAggregatesInput[]
    idTc?: StringWithAggregatesFilter<"Tc"> | string
    fechado?: BoolWithAggregatesFilter<"Tc"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Tc"> | Date | string
  }

  export type TcCompraConteudoWhereInput = {
    AND?: TcCompraConteudoWhereInput | TcCompraConteudoWhereInput[]
    OR?: TcCompraConteudoWhereInput[]
    NOT?: TcCompraConteudoWhereInput | TcCompraConteudoWhereInput[]
    idCompra?: StringFilter<"TcCompraConteudo"> | string
    idConteudoCompraPhc?: StringFilter<"TcCompraConteudo"> | string
    refTipo?: StringFilter<"TcCompraConteudo"> | string
    ref?: StringFilter<"TcCompraConteudo"> | string
    design?: StringFilter<"TcCompraConteudo"> | string
    qtt?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    cor?: StringFilter<"TcCompraConteudo"> | string
    tam?: StringFilter<"TcCompraConteudo"> | string
    unidade?: StringFilter<"TcCompraConteudo"> | string
    largura?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    op?: IntFilter<"TcCompraConteudo"> | number
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
    TcOpCompra?: XOR<TcOpCompraScalarRelationFilter, TcOpCompraWhereInput>
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaListRelationFilter
  }

  export type TcCompraConteudoOrderByWithRelationInput = {
    idCompra?: SortOrder
    idConteudoCompraPhc?: SortOrder
    refTipo?: SortOrder
    ref?: SortOrder
    design?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
    TcOp?: TcOpOrderByWithRelationInput
    TcOpCompra?: TcOpCompraOrderByWithRelationInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaOrderByRelationAggregateInput
  }

  export type TcCompraConteudoWhereUniqueInput = Prisma.AtLeast<{
    idConteudoCompraPhc?: string
    idCompra_idConteudoCompraPhc_op?: TcCompraConteudoIdCompraIdConteudoCompraPhcOpCompoundUniqueInput
    AND?: TcCompraConteudoWhereInput | TcCompraConteudoWhereInput[]
    OR?: TcCompraConteudoWhereInput[]
    NOT?: TcCompraConteudoWhereInput | TcCompraConteudoWhereInput[]
    idCompra?: StringFilter<"TcCompraConteudo"> | string
    refTipo?: StringFilter<"TcCompraConteudo"> | string
    ref?: StringFilter<"TcCompraConteudo"> | string
    design?: StringFilter<"TcCompraConteudo"> | string
    qtt?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    cor?: StringFilter<"TcCompraConteudo"> | string
    tam?: StringFilter<"TcCompraConteudo"> | string
    unidade?: StringFilter<"TcCompraConteudo"> | string
    largura?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    op?: IntFilter<"TcCompraConteudo"> | number
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
    TcOpCompra?: XOR<TcOpCompraScalarRelationFilter, TcOpCompraWhereInput>
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaListRelationFilter
  }, "idCompra_idConteudoCompraPhc_op" | "idConteudoCompraPhc">

  export type TcCompraConteudoOrderByWithAggregationInput = {
    idCompra?: SortOrder
    idConteudoCompraPhc?: SortOrder
    refTipo?: SortOrder
    ref?: SortOrder
    design?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
    _count?: TcCompraConteudoCountOrderByAggregateInput
    _avg?: TcCompraConteudoAvgOrderByAggregateInput
    _max?: TcCompraConteudoMaxOrderByAggregateInput
    _min?: TcCompraConteudoMinOrderByAggregateInput
    _sum?: TcCompraConteudoSumOrderByAggregateInput
  }

  export type TcCompraConteudoScalarWhereWithAggregatesInput = {
    AND?: TcCompraConteudoScalarWhereWithAggregatesInput | TcCompraConteudoScalarWhereWithAggregatesInput[]
    OR?: TcCompraConteudoScalarWhereWithAggregatesInput[]
    NOT?: TcCompraConteudoScalarWhereWithAggregatesInput | TcCompraConteudoScalarWhereWithAggregatesInput[]
    idCompra?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    idConteudoCompraPhc?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    refTipo?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    ref?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    design?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    qtt?: DecimalWithAggregatesFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    cor?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    tam?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    unidade?: StringWithAggregatesFilter<"TcCompraConteudo"> | string
    largura?: DecimalWithAggregatesFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalWithAggregatesFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    op?: IntWithAggregatesFilter<"TcCompraConteudo"> | number
  }

  export type TcCompraConteudoEntradaWhereInput = {
    AND?: TcCompraConteudoEntradaWhereInput | TcCompraConteudoEntradaWhereInput[]
    OR?: TcCompraConteudoEntradaWhereInput[]
    NOT?: TcCompraConteudoEntradaWhereInput | TcCompraConteudoEntradaWhereInput[]
    idConteudoEntradaPhc?: StringFilter<"TcCompraConteudoEntrada"> | string
    idConteudoCompraPhc?: StringFilter<"TcCompraConteudoEntrada"> | string
    nEntrada?: IntFilter<"TcCompraConteudoEntrada"> | number
    Nguia?: StringFilter<"TcCompraConteudoEntrada"> | string
    dataEntrada?: DateTimeFilter<"TcCompraConteudoEntrada"> | Date | string
    dataEntradaString?: StringFilter<"TcCompraConteudoEntrada"> | string
    qtt?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    cor?: StringFilter<"TcCompraConteudoEntrada"> | string
    tam?: StringFilter<"TcCompraConteudoEntrada"> | string
    unidade?: StringFilter<"TcCompraConteudoEntrada"> | string
    largura?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    lote?: StringFilter<"TcCompraConteudoEntrada"> | string
    op?: IntFilter<"TcCompraConteudoEntrada"> | number
    TcCompraConteudo?: XOR<TcCompraConteudoScalarRelationFilter, TcCompraConteudoWhereInput>
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaListRelationFilter
  }

  export type TcCompraConteudoEntradaOrderByWithRelationInput = {
    idConteudoEntradaPhc?: SortOrder
    idConteudoCompraPhc?: SortOrder
    nEntrada?: SortOrder
    Nguia?: SortOrder
    dataEntrada?: SortOrder
    dataEntradaString?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    lote?: SortOrder
    op?: SortOrder
    TcCompraConteudo?: TcCompraConteudoOrderByWithRelationInput
    TcOp?: TcOpOrderByWithRelationInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaOrderByRelationAggregateInput
  }

  export type TcCompraConteudoEntradaWhereUniqueInput = Prisma.AtLeast<{
    idConteudoEntradaPhc?: string
    idConteudoEntradaPhc_idConteudoCompraPhc_op?: TcCompraConteudoEntradaIdConteudoEntradaPhcIdConteudoCompraPhcOpCompoundUniqueInput
    AND?: TcCompraConteudoEntradaWhereInput | TcCompraConteudoEntradaWhereInput[]
    OR?: TcCompraConteudoEntradaWhereInput[]
    NOT?: TcCompraConteudoEntradaWhereInput | TcCompraConteudoEntradaWhereInput[]
    idConteudoCompraPhc?: StringFilter<"TcCompraConteudoEntrada"> | string
    nEntrada?: IntFilter<"TcCompraConteudoEntrada"> | number
    Nguia?: StringFilter<"TcCompraConteudoEntrada"> | string
    dataEntrada?: DateTimeFilter<"TcCompraConteudoEntrada"> | Date | string
    dataEntradaString?: StringFilter<"TcCompraConteudoEntrada"> | string
    qtt?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    cor?: StringFilter<"TcCompraConteudoEntrada"> | string
    tam?: StringFilter<"TcCompraConteudoEntrada"> | string
    unidade?: StringFilter<"TcCompraConteudoEntrada"> | string
    largura?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    lote?: StringFilter<"TcCompraConteudoEntrada"> | string
    op?: IntFilter<"TcCompraConteudoEntrada"> | number
    TcCompraConteudo?: XOR<TcCompraConteudoScalarRelationFilter, TcCompraConteudoWhereInput>
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaListRelationFilter
  }, "idConteudoEntradaPhc_idConteudoCompraPhc_op" | "idConteudoEntradaPhc">

  export type TcCompraConteudoEntradaOrderByWithAggregationInput = {
    idConteudoEntradaPhc?: SortOrder
    idConteudoCompraPhc?: SortOrder
    nEntrada?: SortOrder
    Nguia?: SortOrder
    dataEntrada?: SortOrder
    dataEntradaString?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    lote?: SortOrder
    op?: SortOrder
    _count?: TcCompraConteudoEntradaCountOrderByAggregateInput
    _avg?: TcCompraConteudoEntradaAvgOrderByAggregateInput
    _max?: TcCompraConteudoEntradaMaxOrderByAggregateInput
    _min?: TcCompraConteudoEntradaMinOrderByAggregateInput
    _sum?: TcCompraConteudoEntradaSumOrderByAggregateInput
  }

  export type TcCompraConteudoEntradaScalarWhereWithAggregatesInput = {
    AND?: TcCompraConteudoEntradaScalarWhereWithAggregatesInput | TcCompraConteudoEntradaScalarWhereWithAggregatesInput[]
    OR?: TcCompraConteudoEntradaScalarWhereWithAggregatesInput[]
    NOT?: TcCompraConteudoEntradaScalarWhereWithAggregatesInput | TcCompraConteudoEntradaScalarWhereWithAggregatesInput[]
    idConteudoEntradaPhc?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    idConteudoCompraPhc?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    nEntrada?: IntWithAggregatesFilter<"TcCompraConteudoEntrada"> | number
    Nguia?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    dataEntrada?: DateTimeWithAggregatesFilter<"TcCompraConteudoEntrada"> | Date | string
    dataEntradaString?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    qtt?: DecimalWithAggregatesFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    cor?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    tam?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    unidade?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    largura?: DecimalWithAggregatesFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalWithAggregatesFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    lote?: StringWithAggregatesFilter<"TcCompraConteudoEntrada"> | string
    op?: IntWithAggregatesFilter<"TcCompraConteudoEntrada"> | number
  }

  export type TcCompraConteudoEntradaFaturadaWhereInput = {
    AND?: TcCompraConteudoEntradaFaturadaWhereInput | TcCompraConteudoEntradaFaturadaWhereInput[]
    OR?: TcCompraConteudoEntradaFaturadaWhereInput[]
    NOT?: TcCompraConteudoEntradaFaturadaWhereInput | TcCompraConteudoEntradaFaturadaWhereInput[]
    idFaturaPhc?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    idConteudoEntradaPhc?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    nGuiaPhc?: IntFilter<"TcCompraConteudoEntradaFaturada"> | number
    nFatura?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    dataFatura?: DateTimeFilter<"TcCompraConteudoEntradaFaturada"> | Date | string
    dataFaturaString?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    qtt?: DecimalFilter<"TcCompraConteudoEntradaFaturada"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    lote?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    op?: IntFilter<"TcCompraConteudoEntradaFaturada"> | number
    TcCompraConteudoEntrada?: XOR<TcCompraConteudoEntradaScalarRelationFilter, TcCompraConteudoEntradaWhereInput>
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
  }

  export type TcCompraConteudoEntradaFaturadaOrderByWithRelationInput = {
    idFaturaPhc?: SortOrder
    idConteudoEntradaPhc?: SortOrder
    nGuiaPhc?: SortOrder
    nFatura?: SortOrder
    dataFatura?: SortOrder
    dataFaturaString?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    op?: SortOrder
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaOrderByWithRelationInput
    TcOp?: TcOpOrderByWithRelationInput
  }

  export type TcCompraConteudoEntradaFaturadaWhereUniqueInput = Prisma.AtLeast<{
    idFaturaPhc?: string
    idFaturaPhc_idConteudoEntradaPhc_op?: TcCompraConteudoEntradaFaturadaIdFaturaPhcIdConteudoEntradaPhcOpCompoundUniqueInput
    AND?: TcCompraConteudoEntradaFaturadaWhereInput | TcCompraConteudoEntradaFaturadaWhereInput[]
    OR?: TcCompraConteudoEntradaFaturadaWhereInput[]
    NOT?: TcCompraConteudoEntradaFaturadaWhereInput | TcCompraConteudoEntradaFaturadaWhereInput[]
    idConteudoEntradaPhc?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    nGuiaPhc?: IntFilter<"TcCompraConteudoEntradaFaturada"> | number
    nFatura?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    dataFatura?: DateTimeFilter<"TcCompraConteudoEntradaFaturada"> | Date | string
    dataFaturaString?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    qtt?: DecimalFilter<"TcCompraConteudoEntradaFaturada"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    lote?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    op?: IntFilter<"TcCompraConteudoEntradaFaturada"> | number
    TcCompraConteudoEntrada?: XOR<TcCompraConteudoEntradaScalarRelationFilter, TcCompraConteudoEntradaWhereInput>
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
  }, "idFaturaPhc_idConteudoEntradaPhc_op" | "idFaturaPhc">

  export type TcCompraConteudoEntradaFaturadaOrderByWithAggregationInput = {
    idFaturaPhc?: SortOrder
    idConteudoEntradaPhc?: SortOrder
    nGuiaPhc?: SortOrder
    nFatura?: SortOrder
    dataFatura?: SortOrder
    dataFaturaString?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    op?: SortOrder
    _count?: TcCompraConteudoEntradaFaturadaCountOrderByAggregateInput
    _avg?: TcCompraConteudoEntradaFaturadaAvgOrderByAggregateInput
    _max?: TcCompraConteudoEntradaFaturadaMaxOrderByAggregateInput
    _min?: TcCompraConteudoEntradaFaturadaMinOrderByAggregateInput
    _sum?: TcCompraConteudoEntradaFaturadaSumOrderByAggregateInput
  }

  export type TcCompraConteudoEntradaFaturadaScalarWhereWithAggregatesInput = {
    AND?: TcCompraConteudoEntradaFaturadaScalarWhereWithAggregatesInput | TcCompraConteudoEntradaFaturadaScalarWhereWithAggregatesInput[]
    OR?: TcCompraConteudoEntradaFaturadaScalarWhereWithAggregatesInput[]
    NOT?: TcCompraConteudoEntradaFaturadaScalarWhereWithAggregatesInput | TcCompraConteudoEntradaFaturadaScalarWhereWithAggregatesInput[]
    idFaturaPhc?: StringWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | string
    idConteudoEntradaPhc?: StringWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | string
    nGuiaPhc?: IntWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | number
    nFatura?: StringWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | string
    dataFatura?: DateTimeWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | Date | string
    dataFaturaString?: StringWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | string
    qtt?: DecimalWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | Decimal | DecimalJsLike | number | string
    unidade?: StringWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | string
    lote?: StringWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | string
    op?: IntWithAggregatesFilter<"TcCompraConteudoEntradaFaturada"> | number
  }

  export type TcOpWhereInput = {
    AND?: TcOpWhereInput | TcOpWhereInput[]
    OR?: TcOpWhereInput[]
    NOT?: TcOpWhereInput | TcOpWhereInput[]
    idTc?: StringFilter<"TcOp"> | string
    op?: IntFilter<"TcOp"> | number
    foto?: StringFilter<"TcOp"> | string
    createdAt?: DateTimeFilter<"TcOp"> | Date | string
    TcCompraConteudo?: TcCompraConteudoListRelationFilter
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaListRelationFilter
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaListRelationFilter
    Tc?: XOR<TcScalarRelationFilter, TcWhereInput>
    TcOpCompra?: TcOpCompraListRelationFilter
  }

  export type TcOpOrderByWithRelationInput = {
    idTc?: SortOrder
    op?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
    TcCompraConteudo?: TcCompraConteudoOrderByRelationAggregateInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaOrderByRelationAggregateInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaOrderByRelationAggregateInput
    Tc?: TcOrderByWithRelationInput
    TcOpCompra?: TcOpCompraOrderByRelationAggregateInput
  }

  export type TcOpWhereUniqueInput = Prisma.AtLeast<{
    op?: number
    idTc_op?: TcOpIdTcOpCompoundUniqueInput
    AND?: TcOpWhereInput | TcOpWhereInput[]
    OR?: TcOpWhereInput[]
    NOT?: TcOpWhereInput | TcOpWhereInput[]
    idTc?: StringFilter<"TcOp"> | string
    foto?: StringFilter<"TcOp"> | string
    createdAt?: DateTimeFilter<"TcOp"> | Date | string
    TcCompraConteudo?: TcCompraConteudoListRelationFilter
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaListRelationFilter
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaListRelationFilter
    Tc?: XOR<TcScalarRelationFilter, TcWhereInput>
    TcOpCompra?: TcOpCompraListRelationFilter
  }, "idTc_op" | "op">

  export type TcOpOrderByWithAggregationInput = {
    idTc?: SortOrder
    op?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
    _count?: TcOpCountOrderByAggregateInput
    _avg?: TcOpAvgOrderByAggregateInput
    _max?: TcOpMaxOrderByAggregateInput
    _min?: TcOpMinOrderByAggregateInput
    _sum?: TcOpSumOrderByAggregateInput
  }

  export type TcOpScalarWhereWithAggregatesInput = {
    AND?: TcOpScalarWhereWithAggregatesInput | TcOpScalarWhereWithAggregatesInput[]
    OR?: TcOpScalarWhereWithAggregatesInput[]
    NOT?: TcOpScalarWhereWithAggregatesInput | TcOpScalarWhereWithAggregatesInput[]
    idTc?: StringWithAggregatesFilter<"TcOp"> | string
    op?: IntWithAggregatesFilter<"TcOp"> | number
    foto?: StringWithAggregatesFilter<"TcOp"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TcOp"> | Date | string
  }

  export type TcOpCompraWhereInput = {
    AND?: TcOpCompraWhereInput | TcOpCompraWhereInput[]
    OR?: TcOpCompraWhereInput[]
    NOT?: TcOpCompraWhereInput | TcOpCompraWhereInput[]
    idCompra?: StringFilter<"TcOpCompra"> | string
    idCompraPhc?: StringFilter<"TcOpCompra"> | string
    nCompra?: IntFilter<"TcOpCompra"> | number
    nome?: StringFilter<"TcOpCompra"> | string
    dataCompra?: DateTimeFilter<"TcOpCompra"> | Date | string
    dataCompraString?: StringFilter<"TcOpCompra"> | string
    op?: IntFilter<"TcOpCompra"> | number
    TcCompraConteudo?: TcCompraConteudoListRelationFilter
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
  }

  export type TcOpCompraOrderByWithRelationInput = {
    idCompra?: SortOrder
    idCompraPhc?: SortOrder
    nCompra?: SortOrder
    nome?: SortOrder
    dataCompra?: SortOrder
    dataCompraString?: SortOrder
    op?: SortOrder
    TcCompraConteudo?: TcCompraConteudoOrderByRelationAggregateInput
    TcOp?: TcOpOrderByWithRelationInput
  }

  export type TcOpCompraWhereUniqueInput = Prisma.AtLeast<{
    idCompra?: string
    idCompra_idCompraPhc_op?: TcOpCompraIdCompraIdCompraPhcOpCompoundUniqueInput
    AND?: TcOpCompraWhereInput | TcOpCompraWhereInput[]
    OR?: TcOpCompraWhereInput[]
    NOT?: TcOpCompraWhereInput | TcOpCompraWhereInput[]
    idCompraPhc?: StringFilter<"TcOpCompra"> | string
    nCompra?: IntFilter<"TcOpCompra"> | number
    nome?: StringFilter<"TcOpCompra"> | string
    dataCompra?: DateTimeFilter<"TcOpCompra"> | Date | string
    dataCompraString?: StringFilter<"TcOpCompra"> | string
    op?: IntFilter<"TcOpCompra"> | number
    TcCompraConteudo?: TcCompraConteudoListRelationFilter
    TcOp?: XOR<TcOpScalarRelationFilter, TcOpWhereInput>
  }, "idCompra_idCompraPhc_op" | "idCompra">

  export type TcOpCompraOrderByWithAggregationInput = {
    idCompra?: SortOrder
    idCompraPhc?: SortOrder
    nCompra?: SortOrder
    nome?: SortOrder
    dataCompra?: SortOrder
    dataCompraString?: SortOrder
    op?: SortOrder
    _count?: TcOpCompraCountOrderByAggregateInput
    _avg?: TcOpCompraAvgOrderByAggregateInput
    _max?: TcOpCompraMaxOrderByAggregateInput
    _min?: TcOpCompraMinOrderByAggregateInput
    _sum?: TcOpCompraSumOrderByAggregateInput
  }

  export type TcOpCompraScalarWhereWithAggregatesInput = {
    AND?: TcOpCompraScalarWhereWithAggregatesInput | TcOpCompraScalarWhereWithAggregatesInput[]
    OR?: TcOpCompraScalarWhereWithAggregatesInput[]
    NOT?: TcOpCompraScalarWhereWithAggregatesInput | TcOpCompraScalarWhereWithAggregatesInput[]
    idCompra?: StringWithAggregatesFilter<"TcOpCompra"> | string
    idCompraPhc?: StringWithAggregatesFilter<"TcOpCompra"> | string
    nCompra?: IntWithAggregatesFilter<"TcOpCompra"> | number
    nome?: StringWithAggregatesFilter<"TcOpCompra"> | string
    dataCompra?: DateTimeWithAggregatesFilter<"TcOpCompra"> | Date | string
    dataCompraString?: StringWithAggregatesFilter<"TcOpCompra"> | string
    op?: IntWithAggregatesFilter<"TcOpCompra"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    nomeUser?: StringFilter<"User"> | string
    pHashed?: StringFilter<"User"> | string
    nome?: StringFilter<"User"> | string
    apelido?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    DataCamiao?: DataCamiaoListRelationFilter
    DataEnvio?: DataEnvioListRelationFilter
    Livre?: LivreListRelationFilter
    Op?: OpListRelationFilter
    Planeamento?: PlaneamentoListRelationFilter
    UserPapeis?: UserPapeisListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    nomeUser?: SortOrder
    pHashed?: SortOrder
    nome?: SortOrder
    apelido?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    DataCamiao?: DataCamiaoOrderByRelationAggregateInput
    DataEnvio?: DataEnvioOrderByRelationAggregateInput
    Livre?: LivreOrderByRelationAggregateInput
    Op?: OpOrderByRelationAggregateInput
    Planeamento?: PlaneamentoOrderByRelationAggregateInput
    UserPapeis?: UserPapeisOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    nomeUser?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    pHashed?: StringFilter<"User"> | string
    nome?: StringFilter<"User"> | string
    apelido?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    DataCamiao?: DataCamiaoListRelationFilter
    DataEnvio?: DataEnvioListRelationFilter
    Livre?: LivreListRelationFilter
    Op?: OpListRelationFilter
    Planeamento?: PlaneamentoListRelationFilter
    UserPapeis?: UserPapeisListRelationFilter
  }, "nomeUser" | "nomeUser" | "email">

  export type UserOrderByWithAggregationInput = {
    nomeUser?: SortOrder
    pHashed?: SortOrder
    nome?: SortOrder
    apelido?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    nomeUser?: StringWithAggregatesFilter<"User"> | string
    pHashed?: StringWithAggregatesFilter<"User"> | string
    nome?: StringWithAggregatesFilter<"User"> | string
    apelido?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserPapeisWhereInput = {
    AND?: UserPapeisWhereInput | UserPapeisWhereInput[]
    OR?: UserPapeisWhereInput[]
    NOT?: UserPapeisWhereInput | UserPapeisWhereInput[]
    idPapel?: StringFilter<"UserPapeis"> | string
    nomeUser?: StringFilter<"UserPapeis"> | string
    Papeis?: XOR<PapeisScalarRelationFilter, PapeisWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPapeisOrderByWithRelationInput = {
    idPapel?: SortOrder
    nomeUser?: SortOrder
    Papeis?: PapeisOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
  }

  export type UserPapeisWhereUniqueInput = Prisma.AtLeast<{
    idPapel_nomeUser?: UserPapeisIdPapelNomeUserCompoundUniqueInput
    AND?: UserPapeisWhereInput | UserPapeisWhereInput[]
    OR?: UserPapeisWhereInput[]
    NOT?: UserPapeisWhereInput | UserPapeisWhereInput[]
    idPapel?: StringFilter<"UserPapeis"> | string
    nomeUser?: StringFilter<"UserPapeis"> | string
    Papeis?: XOR<PapeisScalarRelationFilter, PapeisWhereInput>
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "idPapel_nomeUser">

  export type UserPapeisOrderByWithAggregationInput = {
    idPapel?: SortOrder
    nomeUser?: SortOrder
    _count?: UserPapeisCountOrderByAggregateInput
    _max?: UserPapeisMaxOrderByAggregateInput
    _min?: UserPapeisMinOrderByAggregateInput
  }

  export type UserPapeisScalarWhereWithAggregatesInput = {
    AND?: UserPapeisScalarWhereWithAggregatesInput | UserPapeisScalarWhereWithAggregatesInput[]
    OR?: UserPapeisScalarWhereWithAggregatesInput[]
    NOT?: UserPapeisScalarWhereWithAggregatesInput | UserPapeisScalarWhereWithAggregatesInput[]
    idPapel?: StringWithAggregatesFilter<"UserPapeis"> | string
    nomeUser?: StringWithAggregatesFilter<"UserPapeis"> | string
  }

  export type BmCreateInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmMalhas?: BmMalhasCreateNestedManyWithoutBmInput
    BmOp?: BmOpCreateNestedManyWithoutBmInput
    BmTc?: BmTcCreateNestedManyWithoutBmInput
  }

  export type BmUncheckedCreateInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmMalhas?: BmMalhasUncheckedCreateNestedManyWithoutBmInput
    BmOp?: BmOpUncheckedCreateNestedManyWithoutBmInput
    BmTc?: BmTcUncheckedCreateNestedManyWithoutBmInput
  }

  export type BmUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmMalhas?: BmMalhasUpdateManyWithoutBmNestedInput
    BmOp?: BmOpUpdateManyWithoutBmNestedInput
    BmTc?: BmTcUpdateManyWithoutBmNestedInput
  }

  export type BmUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmMalhas?: BmMalhasUncheckedUpdateManyWithoutBmNestedInput
    BmOp?: BmOpUncheckedUpdateManyWithoutBmNestedInput
    BmTc?: BmTcUncheckedUpdateManyWithoutBmNestedInput
  }

  export type BmCreateManyInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
  }

  export type BmUpdateManyMutationInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BmUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BmFioComposicaoCreateInput = {
    qtt: Decimal | DecimalJsLike | number | string
    BmMalhasFio: BmMalhasFioCreateNestedOneWithoutBmFioComposicaoInput
    BmMateriaisComposicao: BmMateriaisComposicaoCreateNestedOneWithoutBmFioComposicaoInput
  }

  export type BmFioComposicaoUncheckedCreateInput = {
    idBm: string
    ref: string
    refOrigem: string
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoUpdateInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BmMalhasFio?: BmMalhasFioUpdateOneRequiredWithoutBmFioComposicaoNestedInput
    BmMateriaisComposicao?: BmMateriaisComposicaoUpdateOneRequiredWithoutBmFioComposicaoNestedInput
  }

  export type BmFioComposicaoUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoCreateManyInput = {
    idBm: string
    ref: string
    refOrigem: string
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoUpdateManyMutationInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoCreateInput = {
    qtt: Decimal | DecimalJsLike | number | string
    BmMalhas: BmMalhasCreateNestedOneWithoutBmIdBmComposicaoInput
    BmMateriaisComposicao: BmMateriaisComposicaoCreateNestedOneWithoutBmIdBmComposicaoInput
  }

  export type BmIdBmComposicaoUncheckedCreateInput = {
    idBm: string
    ref: string
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoUpdateInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmIdBmComposicaoNestedInput
    BmMateriaisComposicao?: BmMateriaisComposicaoUpdateOneRequiredWithoutBmIdBmComposicaoNestedInput
  }

  export type BmIdBmComposicaoUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoCreateManyInput = {
    idBm: string
    ref: string
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoUpdateManyMutationInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasCreateInput = {
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoCreateNestedManyWithoutBmMalhasInput
    Bm: BmCreateNestedOneWithoutBmMalhasInput
    BmMateriais: BmMateriaisCreateNestedOneWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasUncheckedCreateInput = {
    idBm: string
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasUpdateInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUpdateManyWithoutBmMalhasNestedInput
    Bm?: BmUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMateriais?: BmMateriaisUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasCreateManyInput = {
    idBm: string
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasUpdateManyMutationInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioCreateInput = {
    refOrigem: string
    fio: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoCreateNestedManyWithoutBmMalhasFioInput
    BmMalhas: BmMalhasCreateNestedOneWithoutBmMalhasFioInput
    BmMateriaisFio: BmMateriaisFioCreateNestedOneWithoutBmMalhasFioInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioUncheckedCreateInput = {
    idBm: string
    ref: string
    refOrigem: string
    fio: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoUncheckedCreateNestedManyWithoutBmMalhasFioInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioUpdateInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUpdateManyWithoutBmMalhasFioNestedInput
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmMalhasFioNestedInput
    BmMateriaisFio?: BmMateriaisFioUpdateOneRequiredWithoutBmMalhasFioNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUncheckedUpdateManyWithoutBmMalhasFioNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioCreateManyInput = {
    idBm: string
    ref: string
    refOrigem: string
    fio: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasFioUpdateManyMutationInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioMovimentosCreateInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmOpsPorMalhaFio: BmOpsPorMalhaFioCreateNestedOneWithoutBmMalhasFioMovimentosInput
  }

  export type BmMalhasFioMovimentosUncheckedCreateInput = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasFioMovimentosUpdateInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateOneRequiredWithoutBmMalhasFioMovimentosNestedInput
  }

  export type BmMalhasFioMovimentosUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioMovimentosCreateManyInput = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasFioMovimentosUpdateManyMutationInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioMovimentosUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMateriaisCreateInput = {
    BmMalhas?: BmMalhasCreateNestedManyWithoutBmMateriaisInput
    BmMaterialGrupo: BmMaterialGrupoCreateNestedOneWithoutBmMateriaisInput
    BmMaterialSubGrupo: BmMaterialSubGrupoCreateNestedOneWithoutBmMateriaisInput
  }

  export type BmMateriaisUncheckedCreateInput = {
    grupo: string
    subGrupo: string
    BmMalhas?: BmMalhasUncheckedCreateNestedManyWithoutBmMateriaisInput
  }

  export type BmMateriaisUpdateInput = {
    BmMalhas?: BmMalhasUpdateManyWithoutBmMateriaisNestedInput
    BmMaterialGrupo?: BmMaterialGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput
    BmMaterialSubGrupo?: BmMaterialSubGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput
  }

  export type BmMateriaisUncheckedUpdateInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    BmMalhas?: BmMalhasUncheckedUpdateManyWithoutBmMateriaisNestedInput
  }

  export type BmMateriaisCreateManyInput = {
    grupo: string
    subGrupo: string
  }

  export type BmMateriaisUpdateManyMutationInput = {

  }

  export type BmMateriaisUncheckedUpdateManyInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmMateriaisComposicaoCreateInput = {
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
    BmFioComposicao?: BmFioComposicaoCreateNestedManyWithoutBmMateriaisComposicaoInput
    BmIdBmComposicao?: BmIdBmComposicaoCreateNestedManyWithoutBmMateriaisComposicaoInput
  }

  export type BmMateriaisComposicaoUncheckedCreateInput = {
    idComposicao?: number
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
    BmFioComposicao?: BmFioComposicaoUncheckedCreateNestedManyWithoutBmMateriaisComposicaoInput
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMateriaisComposicaoInput
  }

  export type BmMateriaisComposicaoUpdateInput = {
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
    BmFioComposicao?: BmFioComposicaoUpdateManyWithoutBmMateriaisComposicaoNestedInput
    BmIdBmComposicao?: BmIdBmComposicaoUpdateManyWithoutBmMateriaisComposicaoNestedInput
  }

  export type BmMateriaisComposicaoUncheckedUpdateInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
    BmFioComposicao?: BmFioComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoNestedInput
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoNestedInput
  }

  export type BmMateriaisComposicaoCreateManyInput = {
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
  }

  export type BmMateriaisComposicaoUpdateManyMutationInput = {
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BmMateriaisComposicaoUncheckedUpdateManyInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
  }

  export type BmMateriaisFioCreateInput = {
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMateriaisFioInput
    BmMaterialGrupoFio: BmMaterialGrupoFioCreateNestedOneWithoutBmMateriaisFioInput
    BmMaterialSubGrupoFio: BmMaterialSubGrupoFioCreateNestedOneWithoutBmMateriaisFioInput
  }

  export type BmMateriaisFioUncheckedCreateInput = {
    grupo: string
    subGrupo: string
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMateriaisFioInput
  }

  export type BmMateriaisFioUpdateInput = {
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMateriaisFioNestedInput
    BmMaterialGrupoFio?: BmMaterialGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput
    BmMaterialSubGrupoFio?: BmMaterialSubGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput
  }

  export type BmMateriaisFioUncheckedUpdateInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMateriaisFioNestedInput
  }

  export type BmMateriaisFioCreateManyInput = {
    grupo: string
    subGrupo: string
  }

  export type BmMateriaisFioUpdateManyMutationInput = {

  }

  export type BmMateriaisFioUncheckedUpdateManyInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialGrupoCreateInput = {
    grupo: string
    grupoDescricao: string
    BmMateriais?: BmMateriaisCreateNestedManyWithoutBmMaterialGrupoInput
  }

  export type BmMaterialGrupoUncheckedCreateInput = {
    grupo: string
    grupoDescricao: string
    BmMateriais?: BmMateriaisUncheckedCreateNestedManyWithoutBmMaterialGrupoInput
  }

  export type BmMaterialGrupoUpdateInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriais?: BmMateriaisUpdateManyWithoutBmMaterialGrupoNestedInput
  }

  export type BmMaterialGrupoUncheckedUpdateInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriais?: BmMateriaisUncheckedUpdateManyWithoutBmMaterialGrupoNestedInput
  }

  export type BmMaterialGrupoCreateManyInput = {
    grupo: string
    grupoDescricao: string
  }

  export type BmMaterialGrupoUpdateManyMutationInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialGrupoUncheckedUpdateManyInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialGrupoFioCreateInput = {
    grupo: string
    grupoDescricao: string
    BmMateriaisFio?: BmMateriaisFioCreateNestedManyWithoutBmMaterialGrupoFioInput
  }

  export type BmMaterialGrupoFioUncheckedCreateInput = {
    grupo: string
    grupoDescricao: string
    BmMateriaisFio?: BmMateriaisFioUncheckedCreateNestedManyWithoutBmMaterialGrupoFioInput
  }

  export type BmMaterialGrupoFioUpdateInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriaisFio?: BmMateriaisFioUpdateManyWithoutBmMaterialGrupoFioNestedInput
  }

  export type BmMaterialGrupoFioUncheckedUpdateInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriaisFio?: BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialGrupoFioNestedInput
  }

  export type BmMaterialGrupoFioCreateManyInput = {
    grupo: string
    grupoDescricao: string
  }

  export type BmMaterialGrupoFioUpdateManyMutationInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialGrupoFioUncheckedUpdateManyInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoCreateInput = {
    subGrupo: string
    subGrupoDescricao: string
    BmMateriais?: BmMateriaisCreateNestedManyWithoutBmMaterialSubGrupoInput
  }

  export type BmMaterialSubGrupoUncheckedCreateInput = {
    subGrupo: string
    subGrupoDescricao: string
    BmMateriais?: BmMateriaisUncheckedCreateNestedManyWithoutBmMaterialSubGrupoInput
  }

  export type BmMaterialSubGrupoUpdateInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriais?: BmMateriaisUpdateManyWithoutBmMaterialSubGrupoNestedInput
  }

  export type BmMaterialSubGrupoUncheckedUpdateInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriais?: BmMateriaisUncheckedUpdateManyWithoutBmMaterialSubGrupoNestedInput
  }

  export type BmMaterialSubGrupoCreateManyInput = {
    subGrupo: string
    subGrupoDescricao: string
  }

  export type BmMaterialSubGrupoUpdateManyMutationInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoUncheckedUpdateManyInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoFioCreateInput = {
    subGrupo: string
    subGrupoDescricao: string
    BmMateriaisFio?: BmMateriaisFioCreateNestedManyWithoutBmMaterialSubGrupoFioInput
  }

  export type BmMaterialSubGrupoFioUncheckedCreateInput = {
    subGrupo: string
    subGrupoDescricao: string
    BmMateriaisFio?: BmMateriaisFioUncheckedCreateNestedManyWithoutBmMaterialSubGrupoFioInput
  }

  export type BmMaterialSubGrupoFioUpdateInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriaisFio?: BmMateriaisFioUpdateManyWithoutBmMaterialSubGrupoFioNestedInput
  }

  export type BmMaterialSubGrupoFioUncheckedUpdateInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
    BmMateriaisFio?: BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialSubGrupoFioNestedInput
  }

  export type BmMaterialSubGrupoFioCreateManyInput = {
    subGrupo: string
    subGrupoDescricao: string
  }

  export type BmMaterialSubGrupoFioUpdateManyMutationInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoFioUncheckedUpdateManyInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMovimentosLotesCreateInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmOpsPorMalha: BmOpsPorMalhaCreateNestedOneWithoutBmMovimentosLotesInput
  }

  export type BmMovimentosLotesUncheckedCreateInput = {
    idBm: string
    ref: string
    op: number
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMovimentosLotesUpdateInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmOpsPorMalha?: BmOpsPorMalhaUpdateOneRequiredWithoutBmMovimentosLotesNestedInput
  }

  export type BmMovimentosLotesUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMovimentosLotesCreateManyInput = {
    idBm: string
    ref: string
    op: number
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMovimentosLotesUpdateManyMutationInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMovimentosLotesUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpCreateInput = {
    op: number
    CreatedAt?: Date | string
    foto?: string
    Bm: BmCreateNestedOneWithoutBmOpInput
    BmOpFaturado?: BmOpFaturadoCreateNestedManyWithoutBmOpInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmOpInput
  }

  export type BmOpUncheckedCreateInput = {
    idBm: string
    op: number
    CreatedAt?: Date | string
    foto?: string
    BmOpFaturado?: BmOpFaturadoUncheckedCreateNestedManyWithoutBmOpInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmOpInput
  }

  export type BmOpUpdateInput = {
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    Bm?: BmUpdateOneRequiredWithoutBmOpNestedInput
    BmOpFaturado?: BmOpFaturadoUpdateManyWithoutBmOpNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmOpNestedInput
  }

  export type BmOpUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    BmOpFaturado?: BmOpFaturadoUncheckedUpdateManyWithoutBmOpNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmOpNestedInput
  }

  export type BmOpCreateManyInput = {
    idBm: string
    op: number
    CreatedAt?: Date | string
    foto?: string
  }

  export type BmOpUpdateManyMutationInput = {
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpFaturadoCreateInput = {
    nFatutura: number
    fData: Date | string
    dataFatura: string
    refModelo: string
    pedido: string
    qtt: Decimal | DecimalJsLike | number | string
    pesoLiquido: Decimal | DecimalJsLike | number | string
    pesoBruto: Decimal | DecimalJsLike | number | string
    cmr: string
    local: string
    obs?: string | null
    BmOp: BmOpCreateNestedOneWithoutBmOpFaturadoInput
  }

  export type BmOpFaturadoUncheckedCreateInput = {
    idBm: string
    op: number
    nFatutura: number
    fData: Date | string
    dataFatura: string
    refModelo: string
    pedido: string
    qtt: Decimal | DecimalJsLike | number | string
    pesoLiquido: Decimal | DecimalJsLike | number | string
    pesoBruto: Decimal | DecimalJsLike | number | string
    cmr: string
    local: string
    obs?: string | null
  }

  export type BmOpFaturadoUpdateInput = {
    nFatutura?: IntFieldUpdateOperationsInput | number
    fData?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFatura?: StringFieldUpdateOperationsInput | string
    refModelo?: StringFieldUpdateOperationsInput | string
    pedido?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmr?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
    BmOp?: BmOpUpdateOneRequiredWithoutBmOpFaturadoNestedInput
  }

  export type BmOpFaturadoUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    nFatutura?: IntFieldUpdateOperationsInput | number
    fData?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFatura?: StringFieldUpdateOperationsInput | string
    refModelo?: StringFieldUpdateOperationsInput | string
    pedido?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmr?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmOpFaturadoCreateManyInput = {
    idBm: string
    op: number
    nFatutura: number
    fData: Date | string
    dataFatura: string
    refModelo: string
    pedido: string
    qtt: Decimal | DecimalJsLike | number | string
    pesoLiquido: Decimal | DecimalJsLike | number | string
    pesoBruto: Decimal | DecimalJsLike | number | string
    cmr: string
    local: string
    obs?: string | null
  }

  export type BmOpFaturadoUpdateManyMutationInput = {
    nFatutura?: IntFieldUpdateOperationsInput | number
    fData?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFatura?: StringFieldUpdateOperationsInput | string
    refModelo?: StringFieldUpdateOperationsInput | string
    pedido?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmr?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmOpFaturadoUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    nFatutura?: IntFieldUpdateOperationsInput | number
    fData?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFatura?: StringFieldUpdateOperationsInput | string
    refModelo?: StringFieldUpdateOperationsInput | string
    pedido?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmr?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmOpsPorMalhaCreateInput = {
    BmMovimentosLotes?: BmMovimentosLotesCreateNestedManyWithoutBmOpsPorMalhaInput
    BmMalhas: BmMalhasCreateNestedOneWithoutBmOpsPorMalhaInput
    BmOp: BmOpCreateNestedOneWithoutBmOpsPorMalhaInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaUncheckedCreateInput = {
    idBm: string
    ref: string
    op: number
    BmMovimentosLotes?: BmMovimentosLotesUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaUpdateInput = {
    BmMovimentosLotes?: BmMovimentosLotesUpdateManyWithoutBmOpsPorMalhaNestedInput
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
    BmOp?: BmOpUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    BmMovimentosLotes?: BmMovimentosLotesUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaCreateManyInput = {
    idBm: string
    ref: string
    op: number
  }

  export type BmOpsPorMalhaUpdateManyMutationInput = {

  }

  export type BmOpsPorMalhaUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type BmOpsPorMalhaFioCreateInput = {
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosCreateNestedManyWithoutBmOpsPorMalhaFioInput
    BmMalhasFio: BmMalhasFioCreateNestedOneWithoutBmOpsPorMalhaFioInput
    BmOpsPorMalha: BmOpsPorMalhaCreateNestedOneWithoutBmOpsPorMalhaFioInput
  }

  export type BmOpsPorMalhaFioUncheckedCreateInput = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUncheckedCreateNestedManyWithoutBmOpsPorMalhaFioInput
  }

  export type BmOpsPorMalhaFioUpdateInput = {
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUpdateManyWithoutBmOpsPorMalhaFioNestedInput
    BmMalhasFio?: BmMalhasFioUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput
  }

  export type BmOpsPorMalhaFioUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUncheckedUpdateManyWithoutBmOpsPorMalhaFioNestedInput
  }

  export type BmOpsPorMalhaFioCreateManyInput = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
  }

  export type BmOpsPorMalhaFioUpdateManyMutationInput = {

  }

  export type BmOpsPorMalhaFioUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type BmTcCreateInput = {
    nomeTc: string
    Bm: BmCreateNestedOneWithoutBmTcInput
  }

  export type BmTcUncheckedCreateInput = {
    idBm: string
    nomeTc: string
  }

  export type BmTcUpdateInput = {
    nomeTc?: StringFieldUpdateOperationsInput | string
    Bm?: BmUpdateOneRequiredWithoutBmTcNestedInput
  }

  export type BmTcUncheckedUpdateInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    nomeTc?: StringFieldUpdateOperationsInput | string
  }

  export type BmTcCreateManyInput = {
    idBm: string
    nomeTc: string
  }

  export type BmTcUpdateManyMutationInput = {
    nomeTc?: StringFieldUpdateOperationsInput | string
  }

  export type BmTcUncheckedUpdateManyInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    nomeTc?: StringFieldUpdateOperationsInput | string
  }

  export type DataCamiaoCreateInput = {
    IdCamiao?: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
    Planeamento: PlaneamentoCreateNestedOneWithoutDataCamiaoInput
    User: UserCreateNestedOneWithoutDataCamiaoInput
  }

  export type DataCamiaoUncheckedCreateInput = {
    idPlaneamento: string
    IdCamiao?: string
    nomeUser: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataCamiaoUpdateInput = {
    IdCamiao?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutDataCamiaoNestedInput
    User?: UserUpdateOneRequiredWithoutDataCamiaoNestedInput
  }

  export type DataCamiaoUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    IdCamiao?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataCamiaoCreateManyInput = {
    idPlaneamento: string
    IdCamiao?: string
    nomeUser: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataCamiaoUpdateManyMutationInput = {
    IdCamiao?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataCamiaoUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    IdCamiao?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataEnvioCreateInput = {
    idEnvio?: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
    Planeamento: PlaneamentoCreateNestedOneWithoutDataEnvioInput
    User: UserCreateNestedOneWithoutDataEnvioInput
  }

  export type DataEnvioUncheckedCreateInput = {
    idPlaneamento: string
    idEnvio?: string
    nomeUser: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataEnvioUpdateInput = {
    idEnvio?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutDataEnvioNestedInput
    User?: UserUpdateOneRequiredWithoutDataEnvioNestedInput
  }

  export type DataEnvioUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idEnvio?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataEnvioCreateManyInput = {
    idPlaneamento: string
    idEnvio?: string
    nomeUser: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataEnvioUpdateManyMutationInput = {
    idEnvio?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataEnvioUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idEnvio?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type FornecedorCreateInput = {
    idFornecedor: string
    nomeFornecedor: string
    Planeamento?: PlaneamentoCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUncheckedCreateInput = {
    idFornecedor: string
    nomeFornecedor: string
    Planeamento?: PlaneamentoUncheckedCreateNestedManyWithoutFornecedorInput
  }

  export type FornecedorUpdateInput = {
    idFornecedor?: StringFieldUpdateOperationsInput | string
    nomeFornecedor?: StringFieldUpdateOperationsInput | string
    Planeamento?: PlaneamentoUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorUncheckedUpdateInput = {
    idFornecedor?: StringFieldUpdateOperationsInput | string
    nomeFornecedor?: StringFieldUpdateOperationsInput | string
    Planeamento?: PlaneamentoUncheckedUpdateManyWithoutFornecedorNestedInput
  }

  export type FornecedorCreateManyInput = {
    idFornecedor: string
    nomeFornecedor: string
  }

  export type FornecedorUpdateManyMutationInput = {
    idFornecedor?: StringFieldUpdateOperationsInput | string
    nomeFornecedor?: StringFieldUpdateOperationsInput | string
  }

  export type FornecedorUncheckedUpdateManyInput = {
    idFornecedor?: StringFieldUpdateOperationsInput | string
    nomeFornecedor?: StringFieldUpdateOperationsInput | string
  }

  export type LivreCreateInput = {
    idLivre?: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutLivreInput
    User: UserCreateNestedOneWithoutLivreInput
    OrcamentoLivre?: OrcamentoLivreCreateNestedOneWithoutLivreInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreCreateNestedManyWithoutLivreInput
  }

  export type LivreUncheckedCreateInput = {
    idPlaneamento: string
    idLivre?: string
    nomeUser: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedCreateNestedOneWithoutLivreInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedCreateNestedManyWithoutLivreInput
  }

  export type LivreUpdateInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutLivreNestedInput
    User?: UserUpdateOneRequiredWithoutLivreNestedInput
    OrcamentoLivre?: OrcamentoLivreUpdateOneWithoutLivreNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUpdateManyWithoutLivreNestedInput
  }

  export type LivreUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedUpdateOneWithoutLivreNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedUpdateManyWithoutLivreNestedInput
  }

  export type LivreCreateManyInput = {
    idPlaneamento: string
    idLivre?: string
    nomeUser: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
  }

  export type LivreUpdateManyMutationInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type LivreUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpCreateInput = {
    Op: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutOpInput
    User: UserCreateNestedOneWithoutOpInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpUncheckedCreateInput = {
    idPlaneamento: string
    Op: string
    nomeUser: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpUpdateInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutOpNestedInput
    User?: UserUpdateOneRequiredWithoutOpNestedInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpCreateManyInput = {
    idPlaneamento: string
    Op: string
    nomeUser: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
  }

  export type OpUpdateManyMutationInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrcamentoLivreCreateInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    Livre: LivreCreateNestedOneWithoutOrcamentoLivreInput
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasCreateNestedManyWithoutOrcamentoLivreInput
  }

  export type OrcamentoLivreUncheckedCreateInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUncheckedCreateNestedManyWithoutOrcamentoLivreInput
  }

  export type OrcamentoLivreUpdateInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    Livre?: LivreUpdateOneRequiredWithoutOrcamentoLivreNestedInput
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUpdateManyWithoutOrcamentoLivreNestedInput
  }

  export type OrcamentoLivreUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUncheckedUpdateManyWithoutOrcamentoLivreNestedInput
  }

  export type OrcamentoLivreCreateManyInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
  }

  export type OrcamentoLivreUpdateManyMutationInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type OrcamentoLivreUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type OrcamentoLivreLinhasCreateInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    OrcamentoLivre: OrcamentoLivreCreateNestedOneWithoutOrcamentoLivreLinhasInput
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemCreateNestedManyWithoutOrcamentoLivreLinhasInput
  }

  export type OrcamentoLivreLinhasUncheckedCreateInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedCreateNestedManyWithoutOrcamentoLivreLinhasInput
  }

  export type OrcamentoLivreLinhasUpdateInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    OrcamentoLivre?: OrcamentoLivreUpdateOneRequiredWithoutOrcamentoLivreLinhasNestedInput
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUpdateManyWithoutOrcamentoLivreLinhasNestedInput
  }

  export type OrcamentoLivreLinhasUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutOrcamentoLivreLinhasNestedInput
  }

  export type OrcamentoLivreLinhasCreateManyInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
  }

  export type OrcamentoLivreLinhasUpdateManyMutationInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type OrcamentoLivreLinhasUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type OrcamentoOpCreateInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    Op_OrcamentoOp_idPlaneamento_OpToOp: OpCreateNestedOneWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput
    OrcamentoOpLinhas?: OrcamentoOpLinhasCreateNestedManyWithoutOrcamentoOpInput
  }

  export type OrcamentoOpUncheckedCreateInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    OrcamentoOpLinhas?: OrcamentoOpLinhasUncheckedCreateNestedManyWithoutOrcamentoOpInput
  }

  export type OrcamentoOpUpdateInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    Op_OrcamentoOp_idPlaneamento_OpToOp?: OpUpdateOneRequiredWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
    OrcamentoOpLinhas?: OrcamentoOpLinhasUpdateManyWithoutOrcamentoOpNestedInput
  }

  export type OrcamentoOpUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    OrcamentoOpLinhas?: OrcamentoOpLinhasUncheckedUpdateManyWithoutOrcamentoOpNestedInput
  }

  export type OrcamentoOpCreateManyInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
  }

  export type OrcamentoOpUpdateManyMutationInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type OrcamentoOpUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type OrcamentoOpLinhasCreateInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    OrcamentoOp: OrcamentoOpCreateNestedOneWithoutOrcamentoOpLinhasInput
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemCreateNestedManyWithoutOrcamentoOpLinhasInput
  }

  export type OrcamentoOpLinhasUncheckedCreateInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedCreateNestedManyWithoutOrcamentoOpLinhasInput
  }

  export type OrcamentoOpLinhasUpdateInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    OrcamentoOp?: OrcamentoOpUpdateOneRequiredWithoutOrcamentoOpLinhasNestedInput
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUpdateManyWithoutOrcamentoOpLinhasNestedInput
  }

  export type OrcamentoOpLinhasUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutOrcamentoOpLinhasNestedInput
  }

  export type OrcamentoOpLinhasCreateManyInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
  }

  export type OrcamentoOpLinhasUpdateManyMutationInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type OrcamentoOpLinhasUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type PapeisCreateInput = {
    idPapeis?: string
    descPapel: string
    UserPapeis?: UserPapeisCreateNestedManyWithoutPapeisInput
  }

  export type PapeisUncheckedCreateInput = {
    idPapeis?: string
    descPapel: string
    UserPapeis?: UserPapeisUncheckedCreateNestedManyWithoutPapeisInput
  }

  export type PapeisUpdateInput = {
    idPapeis?: StringFieldUpdateOperationsInput | string
    descPapel?: StringFieldUpdateOperationsInput | string
    UserPapeis?: UserPapeisUpdateManyWithoutPapeisNestedInput
  }

  export type PapeisUncheckedUpdateInput = {
    idPapeis?: StringFieldUpdateOperationsInput | string
    descPapel?: StringFieldUpdateOperationsInput | string
    UserPapeis?: UserPapeisUncheckedUpdateManyWithoutPapeisNestedInput
  }

  export type PapeisCreateManyInput = {
    idPapeis?: string
    descPapel: string
  }

  export type PapeisUpdateManyMutationInput = {
    idPapeis?: StringFieldUpdateOperationsInput | string
    descPapel?: StringFieldUpdateOperationsInput | string
  }

  export type PapeisUncheckedUpdateManyInput = {
    idPapeis?: StringFieldUpdateOperationsInput | string
    descPapel?: StringFieldUpdateOperationsInput | string
  }

  export type PlaneamentoCreateInput = {
    idPlaneamento?: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreCreateNestedManyWithoutPlaneamentoInput
    Op?: OpCreateNestedManyWithoutPlaneamentoInput
    Fornecedor: FornecedorCreateNestedOneWithoutPlaneamentoInput
    User: UserCreateNestedOneWithoutPlaneamentoInput
  }

  export type PlaneamentoUncheckedCreateInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreUncheckedCreateNestedManyWithoutPlaneamentoInput
    Op?: OpUncheckedCreateNestedManyWithoutPlaneamentoInput
  }

  export type PlaneamentoUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUpdateManyWithoutPlaneamentoNestedInput
    Fornecedor?: FornecedorUpdateOneRequiredWithoutPlaneamentoNestedInput
    User?: UserUpdateOneRequiredWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUncheckedUpdateManyWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoCreateManyInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
  }

  export type PlaneamentoUpdateManyMutationInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlaneamentoUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicosEscolhidosLivreCreateInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    Livre: LivreCreateNestedOneWithoutServicosEscolhidosLivreInput
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemCreateNestedManyWithoutServicosEscolhidosLivreInput
  }

  export type ServicosEscolhidosLivreUncheckedCreateInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedCreateNestedManyWithoutServicosEscolhidosLivreInput
  }

  export type ServicosEscolhidosLivreUpdateInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    Livre?: LivreUpdateOneRequiredWithoutServicosEscolhidosLivreNestedInput
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUpdateManyWithoutServicosEscolhidosLivreNestedInput
  }

  export type ServicosEscolhidosLivreUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutServicosEscolhidosLivreNestedInput
  }

  export type ServicosEscolhidosLivreCreateManyInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
  }

  export type ServicosEscolhidosLivreUpdateManyMutationInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosLivreUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosLivreOrigemCreateInput = {
    OrcamentoLivreLinhas: OrcamentoLivreLinhasCreateNestedOneWithoutServicosEscolhidosLivreOrigemInput
    ServicosEscolhidosLivre: ServicosEscolhidosLivreCreateNestedOneWithoutServicosEscolhidosLivreOrigemInput
  }

  export type ServicosEscolhidosLivreOrigemUncheckedCreateInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosLivreOrigemUpdateInput = {
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUpdateOneRequiredWithoutServicosEscolhidosLivreOrigemNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUpdateOneRequiredWithoutServicosEscolhidosLivreOrigemNestedInput
  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosLivreOrigemCreateManyInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosLivreOrigemUpdateManyMutationInput = {

  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpCreateInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp: OpCreateNestedOneWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemCreateNestedManyWithoutServicosEscolhidosOpInput
  }

  export type ServicosEscolhidosOpUncheckedCreateInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedCreateNestedManyWithoutServicosEscolhidosOpInput
  }

  export type ServicosEscolhidosOpUpdateInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp?: OpUpdateOneRequiredWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUpdateManyWithoutServicosEscolhidosOpNestedInput
  }

  export type ServicosEscolhidosOpUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutServicosEscolhidosOpNestedInput
  }

  export type ServicosEscolhidosOpCreateManyInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
  }

  export type ServicosEscolhidosOpUpdateManyMutationInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpOrigemCreateInput = {
    OrcamentoOpLinhas: OrcamentoOpLinhasCreateNestedOneWithoutServicosEscolhidosOpOrigemInput
    ServicosEscolhidosOp: ServicosEscolhidosOpCreateNestedOneWithoutServicosEscolhidosOpOrigemInput
  }

  export type ServicosEscolhidosOpOrigemUncheckedCreateInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosOpOrigemUpdateInput = {
    OrcamentoOpLinhas?: OrcamentoOpLinhasUpdateOneRequiredWithoutServicosEscolhidosOpOrigemNestedInput
    ServicosEscolhidosOp?: ServicosEscolhidosOpUpdateOneRequiredWithoutServicosEscolhidosOpOrigemNestedInput
  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpOrigemCreateManyInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosOpOrigemUpdateManyMutationInput = {

  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateManyInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type sysdiagramsCreateInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUncheckedCreateInput = {
    name: string
    principal_id: number
    diagram_id?: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsCreateManyInput = {
    name: string
    principal_id: number
    version?: number | null
    definition?: Uint8Array | null
  }

  export type sysdiagramsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type sysdiagramsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    principal_id?: IntFieldUpdateOperationsInput | number
    diagram_id?: IntFieldUpdateOperationsInput | number
    version?: NullableIntFieldUpdateOperationsInput | number | null
    definition?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type TcCreateInput = {
    idTc?: string
    fechado?: boolean
    createdAt?: Date | string
    TcOp?: TcOpCreateNestedManyWithoutTcInput
  }

  export type TcUncheckedCreateInput = {
    idTc?: string
    fechado?: boolean
    createdAt?: Date | string
    TcOp?: TcOpUncheckedCreateNestedManyWithoutTcInput
  }

  export type TcUpdateInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcOp?: TcOpUpdateManyWithoutTcNestedInput
  }

  export type TcUncheckedUpdateInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcOp?: TcOpUncheckedUpdateManyWithoutTcNestedInput
  }

  export type TcCreateManyInput = {
    idTc?: string
    fechado?: boolean
    createdAt?: Date | string
  }

  export type TcUpdateManyMutationInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TcUncheckedUpdateManyInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TcCompraConteudoCreateInput = {
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoInput
    TcOpCompra: TcOpCompraCreateNestedOneWithoutTcCompraConteudoInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcCompraConteudoInput
  }

  export type TcCompraConteudoUncheckedCreateInput = {
    idCompra: string
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    op: number
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcCompraConteudoInput
  }

  export type TcCompraConteudoUpdateInput = {
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoNestedInput
    TcOpCompra?: TcOpCompraUpdateOneRequiredWithoutTcCompraConteudoNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcCompraConteudoNestedInput
  }

  export type TcCompraConteudoUncheckedUpdateInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    op?: IntFieldUpdateOperationsInput | number
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcCompraConteudoNestedInput
  }

  export type TcCompraConteudoCreateManyInput = {
    idCompra: string
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    op: number
  }

  export type TcCompraConteudoUpdateManyMutationInput = {
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TcCompraConteudoUncheckedUpdateManyInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcCompraConteudoEntradaCreateInput = {
    idConteudoEntradaPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    TcCompraConteudo: TcCompraConteudoCreateNestedOneWithoutTcCompraConteudoEntradaInput
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoEntradaInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcCompraConteudoEntradaInput
  }

  export type TcCompraConteudoEntradaUncheckedCreateInput = {
    idConteudoEntradaPhc: string
    idConteudoCompraPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    op: number
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcCompraConteudoEntradaInput
  }

  export type TcCompraConteudoEntradaUpdateInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    TcCompraConteudo?: TcCompraConteudoUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcCompraConteudoEntradaNestedInput
  }

  export type TcCompraConteudoEntradaUncheckedUpdateInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcCompraConteudoEntradaNestedInput
  }

  export type TcCompraConteudoEntradaCreateManyInput = {
    idConteudoEntradaPhc: string
    idConteudoCompraPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    op: number
  }

  export type TcCompraConteudoEntradaUpdateManyMutationInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type TcCompraConteudoEntradaUncheckedUpdateManyInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcCompraConteudoEntradaFaturadaCreateInput = {
    idFaturaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    TcCompraConteudoEntrada: TcCompraConteudoEntradaCreateNestedOneWithoutTcCompraConteudoEntradaFaturadaInput
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoEntradaFaturadaInput
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedCreateInput = {
    idFaturaPhc: string
    idConteudoEntradaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    op: number
  }

  export type TcCompraConteudoEntradaFaturadaUpdateInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateOneRequiredWithoutTcCompraConteudoEntradaFaturadaNestedInput
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoEntradaFaturadaNestedInput
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcCompraConteudoEntradaFaturadaCreateManyInput = {
    idFaturaPhc: string
    idConteudoEntradaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    op: number
  }

  export type TcCompraConteudoEntradaFaturadaUpdateManyMutationInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateManyInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcOpCreateInput = {
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcOpInput
    Tc: TcCreateNestedOneWithoutTcOpInput
    TcOpCompra?: TcOpCompraCreateNestedManyWithoutTcOpInput
  }

  export type TcOpUncheckedCreateInput = {
    idTc: string
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcOpInput
    TcOpCompra?: TcOpCompraUncheckedCreateNestedManyWithoutTcOpInput
  }

  export type TcOpUpdateInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcOpNestedInput
    Tc?: TcUpdateOneRequiredWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpUncheckedUpdateInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUncheckedUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpCreateManyInput = {
    idTc: string
    op: number
    foto: string
    createdAt?: Date | string
  }

  export type TcOpUpdateManyMutationInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TcOpUncheckedUpdateManyInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TcOpCompraCreateInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
    TcCompraConteudo?: TcCompraConteudoCreateNestedManyWithoutTcOpCompraInput
    TcOp: TcOpCreateNestedOneWithoutTcOpCompraInput
  }

  export type TcOpCompraUncheckedCreateInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
    op: number
    TcCompraConteudo?: TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpCompraInput
  }

  export type TcOpCompraUpdateInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
    TcCompraConteudo?: TcCompraConteudoUpdateManyWithoutTcOpCompraNestedInput
    TcOp?: TcOpUpdateOneRequiredWithoutTcOpCompraNestedInput
  }

  export type TcOpCompraUncheckedUpdateInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    TcCompraConteudo?: TcCompraConteudoUncheckedUpdateManyWithoutTcOpCompraNestedInput
  }

  export type TcOpCompraCreateManyInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
    op: number
  }

  export type TcOpCompraUpdateManyMutationInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
  }

  export type TcOpCompraUncheckedUpdateManyInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutUserInput
    Livre?: LivreCreateNestedManyWithoutUserInput
    Op?: OpCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutUserInput
    Livre?: LivreUncheckedCreateNestedManyWithoutUserInput
    Op?: OpUncheckedCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoUncheckedCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutUserNestedInput
    Livre?: LivreUpdateManyWithoutUserNestedInput
    Op?: OpUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutUserNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutUserNestedInput
    Op?: OpUncheckedUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUncheckedUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type UserUpdateManyMutationInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPapeisCreateInput = {
    Papeis: PapeisCreateNestedOneWithoutUserPapeisInput
    User: UserCreateNestedOneWithoutUserPapeisInput
  }

  export type UserPapeisUncheckedCreateInput = {
    idPapel: string
    nomeUser: string
  }

  export type UserPapeisUpdateInput = {
    Papeis?: PapeisUpdateOneRequiredWithoutUserPapeisNestedInput
    User?: UserUpdateOneRequiredWithoutUserPapeisNestedInput
  }

  export type UserPapeisUncheckedUpdateInput = {
    idPapel?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
  }

  export type UserPapeisCreateManyInput = {
    idPapel: string
    nomeUser: string
  }

  export type UserPapeisUpdateManyMutationInput = {

  }

  export type UserPapeisUncheckedUpdateManyInput = {
    idPapel?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BmMalhasListRelationFilter = {
    every?: BmMalhasWhereInput
    some?: BmMalhasWhereInput
    none?: BmMalhasWhereInput
  }

  export type BmOpListRelationFilter = {
    every?: BmOpWhereInput
    some?: BmOpWhereInput
    none?: BmOpWhereInput
  }

  export type BmTcListRelationFilter = {
    every?: BmTcWhereInput
    some?: BmTcWhereInput
    none?: BmTcWhereInput
  }

  export type BmMalhasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmOpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmTcOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmCountOrderByAggregateInput = {
    idBm?: SortOrder
    composicao?: SortOrder
    fechado?: SortOrder
    CreatedAt?: SortOrder
  }

  export type BmMaxOrderByAggregateInput = {
    idBm?: SortOrder
    composicao?: SortOrder
    fechado?: SortOrder
    CreatedAt?: SortOrder
  }

  export type BmMinOrderByAggregateInput = {
    idBm?: SortOrder
    composicao?: SortOrder
    fechado?: SortOrder
    CreatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasFioScalarRelationFilter = {
    is?: BmMalhasFioWhereInput
    isNot?: BmMalhasFioWhereInput
  }

  export type BmMateriaisComposicaoScalarRelationFilter = {
    is?: BmMateriaisComposicaoWhereInput
    isNot?: BmMateriaisComposicaoWhereInput
  }

  export type BmFioComposicaoIdBmRefRefOrigemIdComposicaoCompoundUniqueInput = {
    idBm: string
    ref: string
    refOrigem: string
    idComposicao: number
  }

  export type BmFioComposicaoCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmFioComposicaoAvgOrderByAggregateInput = {
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmFioComposicaoMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmFioComposicaoMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmFioComposicaoSumOrderByAggregateInput = {
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type BmMalhasScalarRelationFilter = {
    is?: BmMalhasWhereInput
    isNot?: BmMalhasWhereInput
  }

  export type BmIdBmComposicaoIdBmRefIdComposicaoCompoundUniqueInput = {
    idBm: string
    ref: string
    idComposicao: number
  }

  export type BmIdBmComposicaoCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmIdBmComposicaoAvgOrderByAggregateInput = {
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmIdBmComposicaoMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmIdBmComposicaoMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type BmIdBmComposicaoSumOrderByAggregateInput = {
    idComposicao?: SortOrder
    qtt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BmIdBmComposicaoListRelationFilter = {
    every?: BmIdBmComposicaoWhereInput
    some?: BmIdBmComposicaoWhereInput
    none?: BmIdBmComposicaoWhereInput
  }

  export type BmScalarRelationFilter = {
    is?: BmWhereInput
    isNot?: BmWhereInput
  }

  export type BmMateriaisScalarRelationFilter = {
    is?: BmMateriaisWhereInput
    isNot?: BmMateriaisWhereInput
  }

  export type BmMalhasFioListRelationFilter = {
    every?: BmMalhasFioWhereInput
    some?: BmMalhasFioWhereInput
    none?: BmMalhasFioWhereInput
  }

  export type BmOpsPorMalhaListRelationFilter = {
    every?: BmOpsPorMalhaWhereInput
    some?: BmOpsPorMalhaWhereInput
    none?: BmOpsPorMalhaWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BmIdBmComposicaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmMalhasFioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmOpsPorMalhaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmMalhasIdBmRefCompoundUniqueInput = {
    idBm: string
    ref: string
  }

  export type BmMalhasCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    malha?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    qtdeEntradaSeUnidade?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasAvgOrderByAggregateInput = {
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    qtdeEntradaSeUnidade?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
  }

  export type BmMalhasMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    malha?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    qtdeEntradaSeUnidade?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    malha?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    qtdeEntradaSeUnidade?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasSumOrderByAggregateInput = {
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    qtdeEntradaSeUnidade?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BmFioComposicaoListRelationFilter = {
    every?: BmFioComposicaoWhereInput
    some?: BmFioComposicaoWhereInput
    none?: BmFioComposicaoWhereInput
  }

  export type BmMateriaisFioScalarRelationFilter = {
    is?: BmMateriaisFioWhereInput
    isNot?: BmMateriaisFioWhereInput
  }

  export type BmOpsPorMalhaFioListRelationFilter = {
    every?: BmOpsPorMalhaFioWhereInput
    some?: BmOpsPorMalhaFioWhereInput
    none?: BmOpsPorMalhaFioWhereInput
  }

  export type BmFioComposicaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmOpsPorMalhaFioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmMalhasFioIdBmRefRefOrigemCompoundUniqueInput = {
    idBm: string
    ref: string
    refOrigem: string
  }

  export type BmMalhasFioCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    fio?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasFioAvgOrderByAggregateInput = {
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
  }

  export type BmMalhasFioMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    fio?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasFioMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    fio?: SortOrder
    grupo?: SortOrder
    subGrupo?: SortOrder
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasFioSumOrderByAggregateInput = {
    qtdePedida?: SortOrder
    qtdeEntrada?: SortOrder
    defeitosStock?: SortOrder
    sobras?: SortOrder
  }

  export type BmOpsPorMalhaFioScalarRelationFilter = {
    is?: BmOpsPorMalhaFioWhereInput
    isNot?: BmOpsPorMalhaFioWhereInput
  }

  export type BmMalhasFioMovimentosIdBmRefRefOrigemOpIdBmMovimentosLoteCompoundUniqueInput = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
    idBmMovimentosLote: string
  }

  export type BmMalhasFioMovimentosCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasFioMovimentosAvgOrderByAggregateInput = {
    op?: SortOrder
    nMovimento?: SortOrder
    idTipo?: SortOrder
    qtt?: SortOrder
  }

  export type BmMalhasFioMovimentosMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasFioMovimentosMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMalhasFioMovimentosSumOrderByAggregateInput = {
    op?: SortOrder
    nMovimento?: SortOrder
    idTipo?: SortOrder
    qtt?: SortOrder
  }

  export type BmMaterialGrupoScalarRelationFilter = {
    is?: BmMaterialGrupoWhereInput
    isNot?: BmMaterialGrupoWhereInput
  }

  export type BmMaterialSubGrupoScalarRelationFilter = {
    is?: BmMaterialSubGrupoWhereInput
    isNot?: BmMaterialSubGrupoWhereInput
  }

  export type BmMateriaisGrupoSubGrupoCompoundUniqueInput = {
    grupo: string
    subGrupo: string
  }

  export type BmMateriaisCountOrderByAggregateInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
  }

  export type BmMateriaisMaxOrderByAggregateInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
  }

  export type BmMateriaisMinOrderByAggregateInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
  }

  export type BmMateriaisComposicaoCountOrderByAggregateInput = {
    idComposicao?: SortOrder
    composicao?: SortOrder
    composicaoAbreviatura?: SortOrder
    ordem?: SortOrder
    inactivo?: SortOrder
  }

  export type BmMateriaisComposicaoAvgOrderByAggregateInput = {
    idComposicao?: SortOrder
    ordem?: SortOrder
  }

  export type BmMateriaisComposicaoMaxOrderByAggregateInput = {
    idComposicao?: SortOrder
    composicao?: SortOrder
    composicaoAbreviatura?: SortOrder
    ordem?: SortOrder
    inactivo?: SortOrder
  }

  export type BmMateriaisComposicaoMinOrderByAggregateInput = {
    idComposicao?: SortOrder
    composicao?: SortOrder
    composicaoAbreviatura?: SortOrder
    ordem?: SortOrder
    inactivo?: SortOrder
  }

  export type BmMateriaisComposicaoSumOrderByAggregateInput = {
    idComposicao?: SortOrder
    ordem?: SortOrder
  }

  export type BmMaterialGrupoFioScalarRelationFilter = {
    is?: BmMaterialGrupoFioWhereInput
    isNot?: BmMaterialGrupoFioWhereInput
  }

  export type BmMaterialSubGrupoFioScalarRelationFilter = {
    is?: BmMaterialSubGrupoFioWhereInput
    isNot?: BmMaterialSubGrupoFioWhereInput
  }

  export type BmMateriaisFioGrupoSubGrupoCompoundUniqueInput = {
    grupo: string
    subGrupo: string
  }

  export type BmMateriaisFioCountOrderByAggregateInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
  }

  export type BmMateriaisFioMaxOrderByAggregateInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
  }

  export type BmMateriaisFioMinOrderByAggregateInput = {
    grupo?: SortOrder
    subGrupo?: SortOrder
  }

  export type BmMateriaisListRelationFilter = {
    every?: BmMateriaisWhereInput
    some?: BmMateriaisWhereInput
    none?: BmMateriaisWhereInput
  }

  export type BmMateriaisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmMaterialGrupoCountOrderByAggregateInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
  }

  export type BmMaterialGrupoMaxOrderByAggregateInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
  }

  export type BmMaterialGrupoMinOrderByAggregateInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
  }

  export type BmMateriaisFioListRelationFilter = {
    every?: BmMateriaisFioWhereInput
    some?: BmMateriaisFioWhereInput
    none?: BmMateriaisFioWhereInput
  }

  export type BmMateriaisFioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmMaterialGrupoFioCountOrderByAggregateInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
  }

  export type BmMaterialGrupoFioMaxOrderByAggregateInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
  }

  export type BmMaterialGrupoFioMinOrderByAggregateInput = {
    grupo?: SortOrder
    grupoDescricao?: SortOrder
  }

  export type BmMaterialSubGrupoCountOrderByAggregateInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
  }

  export type BmMaterialSubGrupoMaxOrderByAggregateInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
  }

  export type BmMaterialSubGrupoMinOrderByAggregateInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
  }

  export type BmMaterialSubGrupoFioCountOrderByAggregateInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
  }

  export type BmMaterialSubGrupoFioMaxOrderByAggregateInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
  }

  export type BmMaterialSubGrupoFioMinOrderByAggregateInput = {
    subGrupo?: SortOrder
    subGrupoDescricao?: SortOrder
  }

  export type BmOpsPorMalhaScalarRelationFilter = {
    is?: BmOpsPorMalhaWhereInput
    isNot?: BmOpsPorMalhaWhereInput
  }

  export type BmMovimentosLotesIdBmRefOpIdBmMovimentosLoteCompoundUniqueInput = {
    idBm: string
    ref: string
    op: number
    idBmMovimentosLote: string
  }

  export type BmMovimentosLotesCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMovimentosLotesAvgOrderByAggregateInput = {
    op?: SortOrder
    nMovimento?: SortOrder
    idTipo?: SortOrder
    qtt?: SortOrder
  }

  export type BmMovimentosLotesMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMovimentosLotesMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
    idBmMovimentosLote?: SortOrder
    idMovimento?: SortOrder
    nMovimento?: SortOrder
    nome?: SortOrder
    idTipo?: SortOrder
    tipo?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
  }

  export type BmMovimentosLotesSumOrderByAggregateInput = {
    op?: SortOrder
    nMovimento?: SortOrder
    idTipo?: SortOrder
    qtt?: SortOrder
  }

  export type BmOpFaturadoListRelationFilter = {
    every?: BmOpFaturadoWhereInput
    some?: BmOpFaturadoWhereInput
    none?: BmOpFaturadoWhereInput
  }

  export type BmOpFaturadoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmOpIdBmOpCompoundUniqueInput = {
    idBm: string
    op: number
  }

  export type BmOpCountOrderByAggregateInput = {
    idBm?: SortOrder
    op?: SortOrder
    CreatedAt?: SortOrder
    foto?: SortOrder
  }

  export type BmOpAvgOrderByAggregateInput = {
    op?: SortOrder
  }

  export type BmOpMaxOrderByAggregateInput = {
    idBm?: SortOrder
    op?: SortOrder
    CreatedAt?: SortOrder
    foto?: SortOrder
  }

  export type BmOpMinOrderByAggregateInput = {
    idBm?: SortOrder
    op?: SortOrder
    CreatedAt?: SortOrder
    foto?: SortOrder
  }

  export type BmOpSumOrderByAggregateInput = {
    op?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BmOpScalarRelationFilter = {
    is?: BmOpWhereInput
    isNot?: BmOpWhereInput
  }

  export type BmOpFaturadoIdBmOpNFatuturaCompoundUniqueInput = {
    idBm: string
    op: number
    nFatutura: number
  }

  export type BmOpFaturadoCountOrderByAggregateInput = {
    idBm?: SortOrder
    op?: SortOrder
    nFatutura?: SortOrder
    fData?: SortOrder
    dataFatura?: SortOrder
    refModelo?: SortOrder
    pedido?: SortOrder
    qtt?: SortOrder
    pesoLiquido?: SortOrder
    pesoBruto?: SortOrder
    cmr?: SortOrder
    local?: SortOrder
    obs?: SortOrder
  }

  export type BmOpFaturadoAvgOrderByAggregateInput = {
    op?: SortOrder
    nFatutura?: SortOrder
    qtt?: SortOrder
    pesoLiquido?: SortOrder
    pesoBruto?: SortOrder
  }

  export type BmOpFaturadoMaxOrderByAggregateInput = {
    idBm?: SortOrder
    op?: SortOrder
    nFatutura?: SortOrder
    fData?: SortOrder
    dataFatura?: SortOrder
    refModelo?: SortOrder
    pedido?: SortOrder
    qtt?: SortOrder
    pesoLiquido?: SortOrder
    pesoBruto?: SortOrder
    cmr?: SortOrder
    local?: SortOrder
    obs?: SortOrder
  }

  export type BmOpFaturadoMinOrderByAggregateInput = {
    idBm?: SortOrder
    op?: SortOrder
    nFatutura?: SortOrder
    fData?: SortOrder
    dataFatura?: SortOrder
    refModelo?: SortOrder
    pedido?: SortOrder
    qtt?: SortOrder
    pesoLiquido?: SortOrder
    pesoBruto?: SortOrder
    cmr?: SortOrder
    local?: SortOrder
    obs?: SortOrder
  }

  export type BmOpFaturadoSumOrderByAggregateInput = {
    op?: SortOrder
    nFatutura?: SortOrder
    qtt?: SortOrder
    pesoLiquido?: SortOrder
    pesoBruto?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BmMovimentosLotesListRelationFilter = {
    every?: BmMovimentosLotesWhereInput
    some?: BmMovimentosLotesWhereInput
    none?: BmMovimentosLotesWhereInput
  }

  export type BmMovimentosLotesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmOpsPorMalhaIdBmRefOpCompoundUniqueInput = {
    idBm: string
    ref: string
    op: number
  }

  export type BmOpsPorMalhaCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
  }

  export type BmOpsPorMalhaAvgOrderByAggregateInput = {
    op?: SortOrder
  }

  export type BmOpsPorMalhaMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
  }

  export type BmOpsPorMalhaMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    op?: SortOrder
  }

  export type BmOpsPorMalhaSumOrderByAggregateInput = {
    op?: SortOrder
  }

  export type BmMalhasFioMovimentosListRelationFilter = {
    every?: BmMalhasFioMovimentosWhereInput
    some?: BmMalhasFioMovimentosWhereInput
    none?: BmMalhasFioMovimentosWhereInput
  }

  export type BmMalhasFioMovimentosOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BmOpsPorMalhaFioIdBmRefRefOrigemOpCompoundUniqueInput = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
  }

  export type BmOpsPorMalhaFioCountOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
  }

  export type BmOpsPorMalhaFioAvgOrderByAggregateInput = {
    op?: SortOrder
  }

  export type BmOpsPorMalhaFioMaxOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
  }

  export type BmOpsPorMalhaFioMinOrderByAggregateInput = {
    idBm?: SortOrder
    ref?: SortOrder
    refOrigem?: SortOrder
    op?: SortOrder
  }

  export type BmOpsPorMalhaFioSumOrderByAggregateInput = {
    op?: SortOrder
  }

  export type BmTcIdBmNomeTcCompoundUniqueInput = {
    idBm: string
    nomeTc: string
  }

  export type BmTcCountOrderByAggregateInput = {
    idBm?: SortOrder
    nomeTc?: SortOrder
  }

  export type BmTcMaxOrderByAggregateInput = {
    idBm?: SortOrder
    nomeTc?: SortOrder
  }

  export type BmTcMinOrderByAggregateInput = {
    idBm?: SortOrder
    nomeTc?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type PlaneamentoScalarRelationFilter = {
    is?: PlaneamentoWhereInput
    isNot?: PlaneamentoWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DataCamiaoCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    IdCamiao?: SortOrder
    nomeUser?: SortOrder
    dataCamiao?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
  }

  export type DataCamiaoAvgOrderByAggregateInput = {
    quantidade?: SortOrder
    percentagem?: SortOrder
  }

  export type DataCamiaoMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    IdCamiao?: SortOrder
    nomeUser?: SortOrder
    dataCamiao?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
  }

  export type DataCamiaoMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    IdCamiao?: SortOrder
    nomeUser?: SortOrder
    dataCamiao?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
  }

  export type DataCamiaoSumOrderByAggregateInput = {
    quantidade?: SortOrder
    percentagem?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DataEnvioCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idEnvio?: SortOrder
    nomeUser?: SortOrder
    dataEnvio?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
  }

  export type DataEnvioAvgOrderByAggregateInput = {
    quantidade?: SortOrder
    percentagem?: SortOrder
  }

  export type DataEnvioMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idEnvio?: SortOrder
    nomeUser?: SortOrder
    dataEnvio?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
  }

  export type DataEnvioMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idEnvio?: SortOrder
    nomeUser?: SortOrder
    dataEnvio?: SortOrder
    quantidade?: SortOrder
    percentagem?: SortOrder
    obs?: SortOrder
  }

  export type DataEnvioSumOrderByAggregateInput = {
    quantidade?: SortOrder
    percentagem?: SortOrder
  }

  export type PlaneamentoListRelationFilter = {
    every?: PlaneamentoWhereInput
    some?: PlaneamentoWhereInput
    none?: PlaneamentoWhereInput
  }

  export type PlaneamentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FornecedorCountOrderByAggregateInput = {
    idFornecedor?: SortOrder
    nomeFornecedor?: SortOrder
  }

  export type FornecedorMaxOrderByAggregateInput = {
    idFornecedor?: SortOrder
    nomeFornecedor?: SortOrder
  }

  export type FornecedorMinOrderByAggregateInput = {
    idFornecedor?: SortOrder
    nomeFornecedor?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type OrcamentoLivreNullableScalarRelationFilter = {
    is?: OrcamentoLivreWhereInput | null
    isNot?: OrcamentoLivreWhereInput | null
  }

  export type ServicosEscolhidosLivreListRelationFilter = {
    every?: ServicosEscolhidosLivreWhereInput
    some?: ServicosEscolhidosLivreWhereInput
    none?: ServicosEscolhidosLivreWhereInput
  }

  export type ServicosEscolhidosLivreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivreIdPlaneamentoIdLivreCompoundUniqueInput = {
    idPlaneamento: string
    idLivre: string
  }

  export type LivreCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    nomeUser?: SortOrder
    Op?: SortOrder
    nOp?: SortOrder
    orcamentoStamp?: SortOrder
    nOrcamento?: SortOrder
    anoOrcamento?: SortOrder
    desenho?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
  }

  export type LivreAvgOrderByAggregateInput = {
    nOp?: SortOrder
    nOrcamento?: SortOrder
    anoOrcamento?: SortOrder
  }

  export type LivreMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    nomeUser?: SortOrder
    Op?: SortOrder
    nOp?: SortOrder
    orcamentoStamp?: SortOrder
    nOrcamento?: SortOrder
    anoOrcamento?: SortOrder
    desenho?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
  }

  export type LivreMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    nomeUser?: SortOrder
    Op?: SortOrder
    nOp?: SortOrder
    orcamentoStamp?: SortOrder
    nOrcamento?: SortOrder
    anoOrcamento?: SortOrder
    desenho?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
  }

  export type LivreSumOrderByAggregateInput = {
    nOp?: SortOrder
    nOrcamento?: SortOrder
    anoOrcamento?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type OrcamentoOpNullableScalarRelationFilter = {
    is?: OrcamentoOpWhereInput | null
    isNot?: OrcamentoOpWhereInput | null
  }

  export type ServicosEscolhidosOpListRelationFilter = {
    every?: ServicosEscolhidosOpWhereInput
    some?: ServicosEscolhidosOpWhereInput
    none?: ServicosEscolhidosOpWhereInput
  }

  export type ServicosEscolhidosOpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpIdPlaneamentoOpCompoundUniqueInput = {
    idPlaneamento: string
    Op: string
  }

  export type OpCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    nomeUser?: SortOrder
    nOp?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
  }

  export type OpAvgOrderByAggregateInput = {
    nOp?: SortOrder
  }

  export type OpMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    nomeUser?: SortOrder
    nOp?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
  }

  export type OpMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    nomeUser?: SortOrder
    nOp?: SortOrder
    modelo?: SortOrder
    cor?: SortOrder
    pedidoCliente?: SortOrder
    imagem?: SortOrder
    cortaPt?: SortOrder
  }

  export type OpSumOrderByAggregateInput = {
    nOp?: SortOrder
  }

  export type LivreScalarRelationFilter = {
    is?: LivreWhereInput
    isNot?: LivreWhereInput
  }

  export type OrcamentoLivreLinhasListRelationFilter = {
    every?: OrcamentoLivreLinhasWhereInput
    some?: OrcamentoLivreLinhasWhereInput
    none?: OrcamentoLivreLinhasWhereInput
  }

  export type OrcamentoLivreLinhasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrcamentoLivreIdPlaneamentoIdLivreOrcamentoStampCompoundUniqueInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
  }

  export type OrcamentoLivreIdPlaneamentoIdLivreCompoundUniqueInput = {
    idPlaneamento: string
    idLivre: string
  }

  export type OrcamentoLivreCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoLivreAvgOrderByAggregateInput = {
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoLivreMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoLivreMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoLivreSumOrderByAggregateInput = {
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoLivreScalarRelationFilter = {
    is?: OrcamentoLivreWhereInput
    isNot?: OrcamentoLivreWhereInput
  }

  export type ServicosEscolhidosLivreOrigemListRelationFilter = {
    every?: ServicosEscolhidosLivreOrigemWhereInput
    some?: ServicosEscolhidosLivreOrigemWhereInput
    none?: ServicosEscolhidosLivreOrigemWhereInput
  }

  export type ServicosEscolhidosLivreOrigemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrcamentoLivreLinhasIdPlaneamentoIdLivreOrcamentoStampOrcamentoLinhasStampCompoundUniqueInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoLinhasStamp: string
  }

  export type OrcamentoLivreLinhasCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
  }

  export type OrcamentoLivreLinhasAvgOrderByAggregateInput = {
    ordem?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
  }

  export type OrcamentoLivreLinhasMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
  }

  export type OrcamentoLivreLinhasMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
  }

  export type OrcamentoLivreLinhasSumOrderByAggregateInput = {
    ordem?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
  }

  export type OpScalarRelationFilter = {
    is?: OpWhereInput
    isNot?: OpWhereInput
  }

  export type OrcamentoOpLinhasListRelationFilter = {
    every?: OrcamentoOpLinhasWhereInput
    some?: OrcamentoOpLinhasWhereInput
    none?: OrcamentoOpLinhasWhereInput
  }

  export type OrcamentoOpLinhasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrcamentoOpIdPlaneamentoOpOrcamentoStampCompoundUniqueInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
  }

  export type OrcamentoOpIdPlaneamentoOpCompoundUniqueInput = {
    idPlaneamento: string
    Op: string
  }

  export type OrcamentoOpCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoOpAvgOrderByAggregateInput = {
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoOpMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoOpMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoOpSumOrderByAggregateInput = {
    orcamentoNumero?: SortOrder
    ano?: SortOrder
  }

  export type OrcamentoOpScalarRelationFilter = {
    is?: OrcamentoOpWhereInput
    isNot?: OrcamentoOpWhereInput
  }

  export type ServicosEscolhidosOpOrigemListRelationFilter = {
    every?: ServicosEscolhidosOpOrigemWhereInput
    some?: ServicosEscolhidosOpOrigemWhereInput
    none?: ServicosEscolhidosOpOrigemWhereInput
  }

  export type ServicosEscolhidosOpOrigemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrcamentoOpLinhasIdPlaneamentoOpOrcamentoStampOrcamentoLinhasStampCompoundUniqueInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoLinhasStamp: string
  }

  export type OrcamentoOpLinhasCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
  }

  export type OrcamentoOpLinhasAvgOrderByAggregateInput = {
    ordem?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
  }

  export type OrcamentoOpLinhasMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
  }

  export type OrcamentoOpLinhasMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    orcamentoStamp?: SortOrder
    orcamentoLinhasStamp?: SortOrder
    orcamentoLinhasStampRecebido?: SortOrder
    ordem?: SortOrder
    design?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
  }

  export type OrcamentoOpLinhasSumOrderByAggregateInput = {
    ordem?: SortOrder
    custoPeca?: SortOrder
    edebito?: SortOrder
    qtt?: SortOrder
  }

  export type UserPapeisListRelationFilter = {
    every?: UserPapeisWhereInput
    some?: UserPapeisWhereInput
    none?: UserPapeisWhereInput
  }

  export type UserPapeisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PapeisCountOrderByAggregateInput = {
    idPapeis?: SortOrder
    descPapel?: SortOrder
  }

  export type PapeisMaxOrderByAggregateInput = {
    idPapeis?: SortOrder
    descPapel?: SortOrder
  }

  export type PapeisMinOrderByAggregateInput = {
    idPapeis?: SortOrder
    descPapel?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DataCamiaoListRelationFilter = {
    every?: DataCamiaoWhereInput
    some?: DataCamiaoWhereInput
    none?: DataCamiaoWhereInput
  }

  export type DataEnvioListRelationFilter = {
    every?: DataEnvioWhereInput
    some?: DataEnvioWhereInput
    none?: DataEnvioWhereInput
  }

  export type LivreListRelationFilter = {
    every?: LivreWhereInput
    some?: LivreWhereInput
    none?: LivreWhereInput
  }

  export type OpListRelationFilter = {
    every?: OpWhereInput
    some?: OpWhereInput
    none?: OpWhereInput
  }

  export type FornecedorScalarRelationFilter = {
    is?: FornecedorWhereInput
    isNot?: FornecedorWhereInput
  }

  export type DataCamiaoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataEnvioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LivreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlaneamentoCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    nomeUser?: SortOrder
    pais?: SortOrder
    idFornecedor?: SortOrder
    numeroPecas?: SortOrder
    modelo?: SortOrder
    obs?: SortOrder
    cliente?: SortOrder
    dataPrimeiroCamiao?: SortOrder
    dataPrimeiroEnvio?: SortOrder
    dataCriacao?: SortOrder
    dataUltimaAlteracao?: SortOrder
    envioEnviado?: SortOrder
  }

  export type PlaneamentoAvgOrderByAggregateInput = {
    numeroPecas?: SortOrder
  }

  export type PlaneamentoMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    nomeUser?: SortOrder
    pais?: SortOrder
    idFornecedor?: SortOrder
    numeroPecas?: SortOrder
    modelo?: SortOrder
    obs?: SortOrder
    cliente?: SortOrder
    dataPrimeiroCamiao?: SortOrder
    dataPrimeiroEnvio?: SortOrder
    dataCriacao?: SortOrder
    dataUltimaAlteracao?: SortOrder
    envioEnviado?: SortOrder
  }

  export type PlaneamentoMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    nomeUser?: SortOrder
    pais?: SortOrder
    idFornecedor?: SortOrder
    numeroPecas?: SortOrder
    modelo?: SortOrder
    obs?: SortOrder
    cliente?: SortOrder
    dataPrimeiroCamiao?: SortOrder
    dataPrimeiroEnvio?: SortOrder
    dataCriacao?: SortOrder
    dataUltimaAlteracao?: SortOrder
    envioEnviado?: SortOrder
  }

  export type PlaneamentoSumOrderByAggregateInput = {
    numeroPecas?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ServicosEscolhidosLivreIdPlaneamentoIdLivreIdServicoEscolhidoCompoundUniqueInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
  }

  export type ServicosEscolhidosLivreCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
  }

  export type ServicosEscolhidosLivreAvgOrderByAggregateInput = {
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
  }

  export type ServicosEscolhidosLivreMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
  }

  export type ServicosEscolhidosLivreMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
  }

  export type ServicosEscolhidosLivreSumOrderByAggregateInput = {
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
  }

  export type OrcamentoLivreLinhasScalarRelationFilter = {
    is?: OrcamentoLivreLinhasWhereInput
    isNot?: OrcamentoLivreLinhasWhereInput
  }

  export type ServicosEscolhidosLivreScalarRelationFilter = {
    is?: ServicosEscolhidosLivreWhereInput
    isNot?: ServicosEscolhidosLivreWhereInput
  }

  export type ServicosEscolhidosLivreOrigemIdPlaneamentoIdLivreIdServicoEscolhidoOrcamentoLinhasStampCompoundUniqueInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosLivreOrigemCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
  }

  export type ServicosEscolhidosLivreOrigemMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
  }

  export type ServicosEscolhidosLivreOrigemMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    idLivre?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
  }

  export type ServicosEscolhidosOpIdPlaneamentoOpIdServicoEscolhidoCompoundUniqueInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
  }

  export type ServicosEscolhidosOpCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
  }

  export type ServicosEscolhidosOpAvgOrderByAggregateInput = {
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
  }

  export type ServicosEscolhidosOpMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
  }

  export type ServicosEscolhidosOpMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    nome?: SortOrder
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
    unidade?: SortOrder
    obs?: SortOrder
  }

  export type ServicosEscolhidosOpSumOrderByAggregateInput = {
    qtt?: SortOrder
    preco?: SortOrder
    valor?: SortOrder
  }

  export type OrcamentoOpLinhasScalarRelationFilter = {
    is?: OrcamentoOpLinhasWhereInput
    isNot?: OrcamentoOpLinhasWhereInput
  }

  export type ServicosEscolhidosOpScalarRelationFilter = {
    is?: ServicosEscolhidosOpWhereInput
    isNot?: ServicosEscolhidosOpWhereInput
  }

  export type ServicosEscolhidosOpOrigemIdPlaneamentoOpIdServicoEscolhidoOrcamentoLinhasStampCompoundUniqueInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosOpOrigemCountOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
  }

  export type ServicosEscolhidosOpOrigemMaxOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
  }

  export type ServicosEscolhidosOpOrigemMinOrderByAggregateInput = {
    idPlaneamento?: SortOrder
    Op?: SortOrder
    idServicoEscolhido?: SortOrder
    orcamentoLinhasStamp?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type sysdiagramsPrincipal_idNameCompoundUniqueInput = {
    principal_id: number
    name: string
  }

  export type sysdiagramsCountOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsAvgOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type sysdiagramsMaxOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsMinOrderByAggregateInput = {
    name?: SortOrder
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
    definition?: SortOrder
  }

  export type sysdiagramsSumOrderByAggregateInput = {
    principal_id?: SortOrder
    diagram_id?: SortOrder
    version?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type TcOpListRelationFilter = {
    every?: TcOpWhereInput
    some?: TcOpWhereInput
    none?: TcOpWhereInput
  }

  export type TcOpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TcCountOrderByAggregateInput = {
    idTc?: SortOrder
    fechado?: SortOrder
    createdAt?: SortOrder
  }

  export type TcMaxOrderByAggregateInput = {
    idTc?: SortOrder
    fechado?: SortOrder
    createdAt?: SortOrder
  }

  export type TcMinOrderByAggregateInput = {
    idTc?: SortOrder
    fechado?: SortOrder
    createdAt?: SortOrder
  }

  export type TcOpScalarRelationFilter = {
    is?: TcOpWhereInput
    isNot?: TcOpWhereInput
  }

  export type TcOpCompraScalarRelationFilter = {
    is?: TcOpCompraWhereInput
    isNot?: TcOpCompraWhereInput
  }

  export type TcCompraConteudoEntradaListRelationFilter = {
    every?: TcCompraConteudoEntradaWhereInput
    some?: TcCompraConteudoEntradaWhereInput
    none?: TcCompraConteudoEntradaWhereInput
  }

  export type TcCompraConteudoEntradaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TcCompraConteudoIdCompraIdConteudoCompraPhcOpCompoundUniqueInput = {
    idCompra: string
    idConteudoCompraPhc: string
    op: number
  }

  export type TcCompraConteudoCountOrderByAggregateInput = {
    idCompra?: SortOrder
    idConteudoCompraPhc?: SortOrder
    refTipo?: SortOrder
    ref?: SortOrder
    design?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoAvgOrderByAggregateInput = {
    qtt?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoMaxOrderByAggregateInput = {
    idCompra?: SortOrder
    idConteudoCompraPhc?: SortOrder
    refTipo?: SortOrder
    ref?: SortOrder
    design?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoMinOrderByAggregateInput = {
    idCompra?: SortOrder
    idConteudoCompraPhc?: SortOrder
    refTipo?: SortOrder
    ref?: SortOrder
    design?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoSumOrderByAggregateInput = {
    qtt?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoScalarRelationFilter = {
    is?: TcCompraConteudoWhereInput
    isNot?: TcCompraConteudoWhereInput
  }

  export type TcCompraConteudoEntradaFaturadaListRelationFilter = {
    every?: TcCompraConteudoEntradaFaturadaWhereInput
    some?: TcCompraConteudoEntradaFaturadaWhereInput
    none?: TcCompraConteudoEntradaFaturadaWhereInput
  }

  export type TcCompraConteudoEntradaFaturadaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TcCompraConteudoEntradaIdConteudoEntradaPhcIdConteudoCompraPhcOpCompoundUniqueInput = {
    idConteudoEntradaPhc: string
    idConteudoCompraPhc: string
    op: number
  }

  export type TcCompraConteudoEntradaCountOrderByAggregateInput = {
    idConteudoEntradaPhc?: SortOrder
    idConteudoCompraPhc?: SortOrder
    nEntrada?: SortOrder
    Nguia?: SortOrder
    dataEntrada?: SortOrder
    dataEntradaString?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    lote?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaAvgOrderByAggregateInput = {
    nEntrada?: SortOrder
    qtt?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaMaxOrderByAggregateInput = {
    idConteudoEntradaPhc?: SortOrder
    idConteudoCompraPhc?: SortOrder
    nEntrada?: SortOrder
    Nguia?: SortOrder
    dataEntrada?: SortOrder
    dataEntradaString?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    lote?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaMinOrderByAggregateInput = {
    idConteudoEntradaPhc?: SortOrder
    idConteudoCompraPhc?: SortOrder
    nEntrada?: SortOrder
    Nguia?: SortOrder
    dataEntrada?: SortOrder
    dataEntradaString?: SortOrder
    qtt?: SortOrder
    cor?: SortOrder
    tam?: SortOrder
    unidade?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    lote?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaSumOrderByAggregateInput = {
    nEntrada?: SortOrder
    qtt?: SortOrder
    largura?: SortOrder
    gramagem?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaScalarRelationFilter = {
    is?: TcCompraConteudoEntradaWhereInput
    isNot?: TcCompraConteudoEntradaWhereInput
  }

  export type TcCompraConteudoEntradaFaturadaIdFaturaPhcIdConteudoEntradaPhcOpCompoundUniqueInput = {
    idFaturaPhc: string
    idConteudoEntradaPhc: string
    op: number
  }

  export type TcCompraConteudoEntradaFaturadaCountOrderByAggregateInput = {
    idFaturaPhc?: SortOrder
    idConteudoEntradaPhc?: SortOrder
    nGuiaPhc?: SortOrder
    nFatura?: SortOrder
    dataFatura?: SortOrder
    dataFaturaString?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaFaturadaAvgOrderByAggregateInput = {
    nGuiaPhc?: SortOrder
    qtt?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaFaturadaMaxOrderByAggregateInput = {
    idFaturaPhc?: SortOrder
    idConteudoEntradaPhc?: SortOrder
    nGuiaPhc?: SortOrder
    nFatura?: SortOrder
    dataFatura?: SortOrder
    dataFaturaString?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaFaturadaMinOrderByAggregateInput = {
    idFaturaPhc?: SortOrder
    idConteudoEntradaPhc?: SortOrder
    nGuiaPhc?: SortOrder
    nFatura?: SortOrder
    dataFatura?: SortOrder
    dataFaturaString?: SortOrder
    qtt?: SortOrder
    unidade?: SortOrder
    lote?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoEntradaFaturadaSumOrderByAggregateInput = {
    nGuiaPhc?: SortOrder
    qtt?: SortOrder
    op?: SortOrder
  }

  export type TcCompraConteudoListRelationFilter = {
    every?: TcCompraConteudoWhereInput
    some?: TcCompraConteudoWhereInput
    none?: TcCompraConteudoWhereInput
  }

  export type TcScalarRelationFilter = {
    is?: TcWhereInput
    isNot?: TcWhereInput
  }

  export type TcOpCompraListRelationFilter = {
    every?: TcOpCompraWhereInput
    some?: TcOpCompraWhereInput
    none?: TcOpCompraWhereInput
  }

  export type TcCompraConteudoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TcOpCompraOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TcOpIdTcOpCompoundUniqueInput = {
    idTc: string
    op: number
  }

  export type TcOpCountOrderByAggregateInput = {
    idTc?: SortOrder
    op?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
  }

  export type TcOpAvgOrderByAggregateInput = {
    op?: SortOrder
  }

  export type TcOpMaxOrderByAggregateInput = {
    idTc?: SortOrder
    op?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
  }

  export type TcOpMinOrderByAggregateInput = {
    idTc?: SortOrder
    op?: SortOrder
    foto?: SortOrder
    createdAt?: SortOrder
  }

  export type TcOpSumOrderByAggregateInput = {
    op?: SortOrder
  }

  export type TcOpCompraIdCompraIdCompraPhcOpCompoundUniqueInput = {
    idCompra: string
    idCompraPhc: string
    op: number
  }

  export type TcOpCompraCountOrderByAggregateInput = {
    idCompra?: SortOrder
    idCompraPhc?: SortOrder
    nCompra?: SortOrder
    nome?: SortOrder
    dataCompra?: SortOrder
    dataCompraString?: SortOrder
    op?: SortOrder
  }

  export type TcOpCompraAvgOrderByAggregateInput = {
    nCompra?: SortOrder
    op?: SortOrder
  }

  export type TcOpCompraMaxOrderByAggregateInput = {
    idCompra?: SortOrder
    idCompraPhc?: SortOrder
    nCompra?: SortOrder
    nome?: SortOrder
    dataCompra?: SortOrder
    dataCompraString?: SortOrder
    op?: SortOrder
  }

  export type TcOpCompraMinOrderByAggregateInput = {
    idCompra?: SortOrder
    idCompraPhc?: SortOrder
    nCompra?: SortOrder
    nome?: SortOrder
    dataCompra?: SortOrder
    dataCompraString?: SortOrder
    op?: SortOrder
  }

  export type TcOpCompraSumOrderByAggregateInput = {
    nCompra?: SortOrder
    op?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    nomeUser?: SortOrder
    pHashed?: SortOrder
    nome?: SortOrder
    apelido?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    nomeUser?: SortOrder
    pHashed?: SortOrder
    nome?: SortOrder
    apelido?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    nomeUser?: SortOrder
    pHashed?: SortOrder
    nome?: SortOrder
    apelido?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PapeisScalarRelationFilter = {
    is?: PapeisWhereInput
    isNot?: PapeisWhereInput
  }

  export type UserPapeisIdPapelNomeUserCompoundUniqueInput = {
    idPapel: string
    nomeUser: string
  }

  export type UserPapeisCountOrderByAggregateInput = {
    idPapel?: SortOrder
    nomeUser?: SortOrder
  }

  export type UserPapeisMaxOrderByAggregateInput = {
    idPapel?: SortOrder
    nomeUser?: SortOrder
  }

  export type UserPapeisMinOrderByAggregateInput = {
    idPapel?: SortOrder
    nomeUser?: SortOrder
  }

  export type BmMalhasCreateNestedManyWithoutBmInput = {
    create?: XOR<BmMalhasCreateWithoutBmInput, BmMalhasUncheckedCreateWithoutBmInput> | BmMalhasCreateWithoutBmInput[] | BmMalhasUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmInput | BmMalhasCreateOrConnectWithoutBmInput[]
    createMany?: BmMalhasCreateManyBmInputEnvelope
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
  }

  export type BmOpCreateNestedManyWithoutBmInput = {
    create?: XOR<BmOpCreateWithoutBmInput, BmOpUncheckedCreateWithoutBmInput> | BmOpCreateWithoutBmInput[] | BmOpUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmOpCreateOrConnectWithoutBmInput | BmOpCreateOrConnectWithoutBmInput[]
    createMany?: BmOpCreateManyBmInputEnvelope
    connect?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
  }

  export type BmTcCreateNestedManyWithoutBmInput = {
    create?: XOR<BmTcCreateWithoutBmInput, BmTcUncheckedCreateWithoutBmInput> | BmTcCreateWithoutBmInput[] | BmTcUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmTcCreateOrConnectWithoutBmInput | BmTcCreateOrConnectWithoutBmInput[]
    createMany?: BmTcCreateManyBmInputEnvelope
    connect?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
  }

  export type BmMalhasUncheckedCreateNestedManyWithoutBmInput = {
    create?: XOR<BmMalhasCreateWithoutBmInput, BmMalhasUncheckedCreateWithoutBmInput> | BmMalhasCreateWithoutBmInput[] | BmMalhasUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmInput | BmMalhasCreateOrConnectWithoutBmInput[]
    createMany?: BmMalhasCreateManyBmInputEnvelope
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
  }

  export type BmOpUncheckedCreateNestedManyWithoutBmInput = {
    create?: XOR<BmOpCreateWithoutBmInput, BmOpUncheckedCreateWithoutBmInput> | BmOpCreateWithoutBmInput[] | BmOpUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmOpCreateOrConnectWithoutBmInput | BmOpCreateOrConnectWithoutBmInput[]
    createMany?: BmOpCreateManyBmInputEnvelope
    connect?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
  }

  export type BmTcUncheckedCreateNestedManyWithoutBmInput = {
    create?: XOR<BmTcCreateWithoutBmInput, BmTcUncheckedCreateWithoutBmInput> | BmTcCreateWithoutBmInput[] | BmTcUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmTcCreateOrConnectWithoutBmInput | BmTcCreateOrConnectWithoutBmInput[]
    createMany?: BmTcCreateManyBmInputEnvelope
    connect?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BmMalhasUpdateManyWithoutBmNestedInput = {
    create?: XOR<BmMalhasCreateWithoutBmInput, BmMalhasUncheckedCreateWithoutBmInput> | BmMalhasCreateWithoutBmInput[] | BmMalhasUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmInput | BmMalhasCreateOrConnectWithoutBmInput[]
    upsert?: BmMalhasUpsertWithWhereUniqueWithoutBmInput | BmMalhasUpsertWithWhereUniqueWithoutBmInput[]
    createMany?: BmMalhasCreateManyBmInputEnvelope
    set?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    disconnect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    delete?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    update?: BmMalhasUpdateWithWhereUniqueWithoutBmInput | BmMalhasUpdateWithWhereUniqueWithoutBmInput[]
    updateMany?: BmMalhasUpdateManyWithWhereWithoutBmInput | BmMalhasUpdateManyWithWhereWithoutBmInput[]
    deleteMany?: BmMalhasScalarWhereInput | BmMalhasScalarWhereInput[]
  }

  export type BmOpUpdateManyWithoutBmNestedInput = {
    create?: XOR<BmOpCreateWithoutBmInput, BmOpUncheckedCreateWithoutBmInput> | BmOpCreateWithoutBmInput[] | BmOpUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmOpCreateOrConnectWithoutBmInput | BmOpCreateOrConnectWithoutBmInput[]
    upsert?: BmOpUpsertWithWhereUniqueWithoutBmInput | BmOpUpsertWithWhereUniqueWithoutBmInput[]
    createMany?: BmOpCreateManyBmInputEnvelope
    set?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    disconnect?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    delete?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    connect?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    update?: BmOpUpdateWithWhereUniqueWithoutBmInput | BmOpUpdateWithWhereUniqueWithoutBmInput[]
    updateMany?: BmOpUpdateManyWithWhereWithoutBmInput | BmOpUpdateManyWithWhereWithoutBmInput[]
    deleteMany?: BmOpScalarWhereInput | BmOpScalarWhereInput[]
  }

  export type BmTcUpdateManyWithoutBmNestedInput = {
    create?: XOR<BmTcCreateWithoutBmInput, BmTcUncheckedCreateWithoutBmInput> | BmTcCreateWithoutBmInput[] | BmTcUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmTcCreateOrConnectWithoutBmInput | BmTcCreateOrConnectWithoutBmInput[]
    upsert?: BmTcUpsertWithWhereUniqueWithoutBmInput | BmTcUpsertWithWhereUniqueWithoutBmInput[]
    createMany?: BmTcCreateManyBmInputEnvelope
    set?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    disconnect?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    delete?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    connect?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    update?: BmTcUpdateWithWhereUniqueWithoutBmInput | BmTcUpdateWithWhereUniqueWithoutBmInput[]
    updateMany?: BmTcUpdateManyWithWhereWithoutBmInput | BmTcUpdateManyWithWhereWithoutBmInput[]
    deleteMany?: BmTcScalarWhereInput | BmTcScalarWhereInput[]
  }

  export type BmMalhasUncheckedUpdateManyWithoutBmNestedInput = {
    create?: XOR<BmMalhasCreateWithoutBmInput, BmMalhasUncheckedCreateWithoutBmInput> | BmMalhasCreateWithoutBmInput[] | BmMalhasUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmInput | BmMalhasCreateOrConnectWithoutBmInput[]
    upsert?: BmMalhasUpsertWithWhereUniqueWithoutBmInput | BmMalhasUpsertWithWhereUniqueWithoutBmInput[]
    createMany?: BmMalhasCreateManyBmInputEnvelope
    set?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    disconnect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    delete?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    update?: BmMalhasUpdateWithWhereUniqueWithoutBmInput | BmMalhasUpdateWithWhereUniqueWithoutBmInput[]
    updateMany?: BmMalhasUpdateManyWithWhereWithoutBmInput | BmMalhasUpdateManyWithWhereWithoutBmInput[]
    deleteMany?: BmMalhasScalarWhereInput | BmMalhasScalarWhereInput[]
  }

  export type BmOpUncheckedUpdateManyWithoutBmNestedInput = {
    create?: XOR<BmOpCreateWithoutBmInput, BmOpUncheckedCreateWithoutBmInput> | BmOpCreateWithoutBmInput[] | BmOpUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmOpCreateOrConnectWithoutBmInput | BmOpCreateOrConnectWithoutBmInput[]
    upsert?: BmOpUpsertWithWhereUniqueWithoutBmInput | BmOpUpsertWithWhereUniqueWithoutBmInput[]
    createMany?: BmOpCreateManyBmInputEnvelope
    set?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    disconnect?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    delete?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    connect?: BmOpWhereUniqueInput | BmOpWhereUniqueInput[]
    update?: BmOpUpdateWithWhereUniqueWithoutBmInput | BmOpUpdateWithWhereUniqueWithoutBmInput[]
    updateMany?: BmOpUpdateManyWithWhereWithoutBmInput | BmOpUpdateManyWithWhereWithoutBmInput[]
    deleteMany?: BmOpScalarWhereInput | BmOpScalarWhereInput[]
  }

  export type BmTcUncheckedUpdateManyWithoutBmNestedInput = {
    create?: XOR<BmTcCreateWithoutBmInput, BmTcUncheckedCreateWithoutBmInput> | BmTcCreateWithoutBmInput[] | BmTcUncheckedCreateWithoutBmInput[]
    connectOrCreate?: BmTcCreateOrConnectWithoutBmInput | BmTcCreateOrConnectWithoutBmInput[]
    upsert?: BmTcUpsertWithWhereUniqueWithoutBmInput | BmTcUpsertWithWhereUniqueWithoutBmInput[]
    createMany?: BmTcCreateManyBmInputEnvelope
    set?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    disconnect?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    delete?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    connect?: BmTcWhereUniqueInput | BmTcWhereUniqueInput[]
    update?: BmTcUpdateWithWhereUniqueWithoutBmInput | BmTcUpdateWithWhereUniqueWithoutBmInput[]
    updateMany?: BmTcUpdateManyWithWhereWithoutBmInput | BmTcUpdateManyWithWhereWithoutBmInput[]
    deleteMany?: BmTcScalarWhereInput | BmTcScalarWhereInput[]
  }

  export type BmMalhasFioCreateNestedOneWithoutBmFioComposicaoInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmFioComposicaoInput, BmMalhasFioUncheckedCreateWithoutBmFioComposicaoInput>
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmFioComposicaoInput
    connect?: BmMalhasFioWhereUniqueInput
  }

  export type BmMateriaisComposicaoCreateNestedOneWithoutBmFioComposicaoInput = {
    create?: XOR<BmMateriaisComposicaoCreateWithoutBmFioComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmFioComposicaoInput>
    connectOrCreate?: BmMateriaisComposicaoCreateOrConnectWithoutBmFioComposicaoInput
    connect?: BmMateriaisComposicaoWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasFioUpdateOneRequiredWithoutBmFioComposicaoNestedInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmFioComposicaoInput, BmMalhasFioUncheckedCreateWithoutBmFioComposicaoInput>
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmFioComposicaoInput
    upsert?: BmMalhasFioUpsertWithoutBmFioComposicaoInput
    connect?: BmMalhasFioWhereUniqueInput
    update?: XOR<XOR<BmMalhasFioUpdateToOneWithWhereWithoutBmFioComposicaoInput, BmMalhasFioUpdateWithoutBmFioComposicaoInput>, BmMalhasFioUncheckedUpdateWithoutBmFioComposicaoInput>
  }

  export type BmMateriaisComposicaoUpdateOneRequiredWithoutBmFioComposicaoNestedInput = {
    create?: XOR<BmMateriaisComposicaoCreateWithoutBmFioComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmFioComposicaoInput>
    connectOrCreate?: BmMateriaisComposicaoCreateOrConnectWithoutBmFioComposicaoInput
    upsert?: BmMateriaisComposicaoUpsertWithoutBmFioComposicaoInput
    connect?: BmMateriaisComposicaoWhereUniqueInput
    update?: XOR<XOR<BmMateriaisComposicaoUpdateToOneWithWhereWithoutBmFioComposicaoInput, BmMateriaisComposicaoUpdateWithoutBmFioComposicaoInput>, BmMateriaisComposicaoUncheckedUpdateWithoutBmFioComposicaoInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BmMalhasCreateNestedOneWithoutBmIdBmComposicaoInput = {
    create?: XOR<BmMalhasCreateWithoutBmIdBmComposicaoInput, BmMalhasUncheckedCreateWithoutBmIdBmComposicaoInput>
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmIdBmComposicaoInput
    connect?: BmMalhasWhereUniqueInput
  }

  export type BmMateriaisComposicaoCreateNestedOneWithoutBmIdBmComposicaoInput = {
    create?: XOR<BmMateriaisComposicaoCreateWithoutBmIdBmComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmIdBmComposicaoInput>
    connectOrCreate?: BmMateriaisComposicaoCreateOrConnectWithoutBmIdBmComposicaoInput
    connect?: BmMateriaisComposicaoWhereUniqueInput
  }

  export type BmMalhasUpdateOneRequiredWithoutBmIdBmComposicaoNestedInput = {
    create?: XOR<BmMalhasCreateWithoutBmIdBmComposicaoInput, BmMalhasUncheckedCreateWithoutBmIdBmComposicaoInput>
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmIdBmComposicaoInput
    upsert?: BmMalhasUpsertWithoutBmIdBmComposicaoInput
    connect?: BmMalhasWhereUniqueInput
    update?: XOR<XOR<BmMalhasUpdateToOneWithWhereWithoutBmIdBmComposicaoInput, BmMalhasUpdateWithoutBmIdBmComposicaoInput>, BmMalhasUncheckedUpdateWithoutBmIdBmComposicaoInput>
  }

  export type BmMateriaisComposicaoUpdateOneRequiredWithoutBmIdBmComposicaoNestedInput = {
    create?: XOR<BmMateriaisComposicaoCreateWithoutBmIdBmComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmIdBmComposicaoInput>
    connectOrCreate?: BmMateriaisComposicaoCreateOrConnectWithoutBmIdBmComposicaoInput
    upsert?: BmMateriaisComposicaoUpsertWithoutBmIdBmComposicaoInput
    connect?: BmMateriaisComposicaoWhereUniqueInput
    update?: XOR<XOR<BmMateriaisComposicaoUpdateToOneWithWhereWithoutBmIdBmComposicaoInput, BmMateriaisComposicaoUpdateWithoutBmIdBmComposicaoInput>, BmMateriaisComposicaoUncheckedUpdateWithoutBmIdBmComposicaoInput>
  }

  export type BmIdBmComposicaoCreateNestedManyWithoutBmMalhasInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput> | BmIdBmComposicaoCreateWithoutBmMalhasInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput | BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMalhasInputEnvelope
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
  }

  export type BmCreateNestedOneWithoutBmMalhasInput = {
    create?: XOR<BmCreateWithoutBmMalhasInput, BmUncheckedCreateWithoutBmMalhasInput>
    connectOrCreate?: BmCreateOrConnectWithoutBmMalhasInput
    connect?: BmWhereUniqueInput
  }

  export type BmMateriaisCreateNestedOneWithoutBmMalhasInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMalhasInput, BmMateriaisUncheckedCreateWithoutBmMalhasInput>
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMalhasInput
    connect?: BmMateriaisWhereUniqueInput
  }

  export type BmMalhasFioCreateNestedManyWithoutBmMalhasInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMalhasInput, BmMalhasFioUncheckedCreateWithoutBmMalhasInput> | BmMalhasFioCreateWithoutBmMalhasInput[] | BmMalhasFioUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMalhasInput | BmMalhasFioCreateOrConnectWithoutBmMalhasInput[]
    createMany?: BmMalhasFioCreateManyBmMalhasInputEnvelope
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
  }

  export type BmOpsPorMalhaCreateNestedManyWithoutBmMalhasInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput> | BmOpsPorMalhaCreateWithoutBmMalhasInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput | BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput[]
    createMany?: BmOpsPorMalhaCreateManyBmMalhasInputEnvelope
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
  }

  export type BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMalhasInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput> | BmIdBmComposicaoCreateWithoutBmMalhasInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput | BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMalhasInputEnvelope
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
  }

  export type BmMalhasFioUncheckedCreateNestedManyWithoutBmMalhasInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMalhasInput, BmMalhasFioUncheckedCreateWithoutBmMalhasInput> | BmMalhasFioCreateWithoutBmMalhasInput[] | BmMalhasFioUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMalhasInput | BmMalhasFioCreateOrConnectWithoutBmMalhasInput[]
    createMany?: BmMalhasFioCreateManyBmMalhasInputEnvelope
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
  }

  export type BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmMalhasInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput> | BmOpsPorMalhaCreateWithoutBmMalhasInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput | BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput[]
    createMany?: BmOpsPorMalhaCreateManyBmMalhasInputEnvelope
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoUpdateManyWithoutBmMalhasNestedInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput> | BmIdBmComposicaoCreateWithoutBmMalhasInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput | BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput[]
    upsert?: BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMalhasInput | BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMalhasInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMalhasInputEnvelope
    set?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    disconnect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    delete?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    update?: BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMalhasInput | BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMalhasInput[]
    updateMany?: BmIdBmComposicaoUpdateManyWithWhereWithoutBmMalhasInput | BmIdBmComposicaoUpdateManyWithWhereWithoutBmMalhasInput[]
    deleteMany?: BmIdBmComposicaoScalarWhereInput | BmIdBmComposicaoScalarWhereInput[]
  }

  export type BmUpdateOneRequiredWithoutBmMalhasNestedInput = {
    create?: XOR<BmCreateWithoutBmMalhasInput, BmUncheckedCreateWithoutBmMalhasInput>
    connectOrCreate?: BmCreateOrConnectWithoutBmMalhasInput
    upsert?: BmUpsertWithoutBmMalhasInput
    connect?: BmWhereUniqueInput
    update?: XOR<XOR<BmUpdateToOneWithWhereWithoutBmMalhasInput, BmUpdateWithoutBmMalhasInput>, BmUncheckedUpdateWithoutBmMalhasInput>
  }

  export type BmMateriaisUpdateOneRequiredWithoutBmMalhasNestedInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMalhasInput, BmMateriaisUncheckedCreateWithoutBmMalhasInput>
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMalhasInput
    upsert?: BmMateriaisUpsertWithoutBmMalhasInput
    connect?: BmMateriaisWhereUniqueInput
    update?: XOR<XOR<BmMateriaisUpdateToOneWithWhereWithoutBmMalhasInput, BmMateriaisUpdateWithoutBmMalhasInput>, BmMateriaisUncheckedUpdateWithoutBmMalhasInput>
  }

  export type BmMalhasFioUpdateManyWithoutBmMalhasNestedInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMalhasInput, BmMalhasFioUncheckedCreateWithoutBmMalhasInput> | BmMalhasFioCreateWithoutBmMalhasInput[] | BmMalhasFioUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMalhasInput | BmMalhasFioCreateOrConnectWithoutBmMalhasInput[]
    upsert?: BmMalhasFioUpsertWithWhereUniqueWithoutBmMalhasInput | BmMalhasFioUpsertWithWhereUniqueWithoutBmMalhasInput[]
    createMany?: BmMalhasFioCreateManyBmMalhasInputEnvelope
    set?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    disconnect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    delete?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    update?: BmMalhasFioUpdateWithWhereUniqueWithoutBmMalhasInput | BmMalhasFioUpdateWithWhereUniqueWithoutBmMalhasInput[]
    updateMany?: BmMalhasFioUpdateManyWithWhereWithoutBmMalhasInput | BmMalhasFioUpdateManyWithWhereWithoutBmMalhasInput[]
    deleteMany?: BmMalhasFioScalarWhereInput | BmMalhasFioScalarWhereInput[]
  }

  export type BmOpsPorMalhaUpdateManyWithoutBmMalhasNestedInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput> | BmOpsPorMalhaCreateWithoutBmMalhasInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput | BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput[]
    upsert?: BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmMalhasInput | BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmMalhasInput[]
    createMany?: BmOpsPorMalhaCreateManyBmMalhasInputEnvelope
    set?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    delete?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    update?: BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmMalhasInput | BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmMalhasInput[]
    updateMany?: BmOpsPorMalhaUpdateManyWithWhereWithoutBmMalhasInput | BmOpsPorMalhaUpdateManyWithWhereWithoutBmMalhasInput[]
    deleteMany?: BmOpsPorMalhaScalarWhereInput | BmOpsPorMalhaScalarWhereInput[]
  }

  export type BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasNestedInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput> | BmIdBmComposicaoCreateWithoutBmMalhasInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput | BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput[]
    upsert?: BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMalhasInput | BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMalhasInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMalhasInputEnvelope
    set?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    disconnect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    delete?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    update?: BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMalhasInput | BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMalhasInput[]
    updateMany?: BmIdBmComposicaoUpdateManyWithWhereWithoutBmMalhasInput | BmIdBmComposicaoUpdateManyWithWhereWithoutBmMalhasInput[]
    deleteMany?: BmIdBmComposicaoScalarWhereInput | BmIdBmComposicaoScalarWhereInput[]
  }

  export type BmMalhasFioUncheckedUpdateManyWithoutBmMalhasNestedInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMalhasInput, BmMalhasFioUncheckedCreateWithoutBmMalhasInput> | BmMalhasFioCreateWithoutBmMalhasInput[] | BmMalhasFioUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMalhasInput | BmMalhasFioCreateOrConnectWithoutBmMalhasInput[]
    upsert?: BmMalhasFioUpsertWithWhereUniqueWithoutBmMalhasInput | BmMalhasFioUpsertWithWhereUniqueWithoutBmMalhasInput[]
    createMany?: BmMalhasFioCreateManyBmMalhasInputEnvelope
    set?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    disconnect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    delete?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    update?: BmMalhasFioUpdateWithWhereUniqueWithoutBmMalhasInput | BmMalhasFioUpdateWithWhereUniqueWithoutBmMalhasInput[]
    updateMany?: BmMalhasFioUpdateManyWithWhereWithoutBmMalhasInput | BmMalhasFioUpdateManyWithWhereWithoutBmMalhasInput[]
    deleteMany?: BmMalhasFioScalarWhereInput | BmMalhasFioScalarWhereInput[]
  }

  export type BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasNestedInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput> | BmOpsPorMalhaCreateWithoutBmMalhasInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput | BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput[]
    upsert?: BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmMalhasInput | BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmMalhasInput[]
    createMany?: BmOpsPorMalhaCreateManyBmMalhasInputEnvelope
    set?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    delete?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    update?: BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmMalhasInput | BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmMalhasInput[]
    updateMany?: BmOpsPorMalhaUpdateManyWithWhereWithoutBmMalhasInput | BmOpsPorMalhaUpdateManyWithWhereWithoutBmMalhasInput[]
    deleteMany?: BmOpsPorMalhaScalarWhereInput | BmOpsPorMalhaScalarWhereInput[]
  }

  export type BmFioComposicaoCreateNestedManyWithoutBmMalhasFioInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput> | BmFioComposicaoCreateWithoutBmMalhasFioInput[] | BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput | BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput[]
    createMany?: BmFioComposicaoCreateManyBmMalhasFioInputEnvelope
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
  }

  export type BmMalhasCreateNestedOneWithoutBmMalhasFioInput = {
    create?: XOR<BmMalhasCreateWithoutBmMalhasFioInput, BmMalhasUncheckedCreateWithoutBmMalhasFioInput>
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmMalhasFioInput
    connect?: BmMalhasWhereUniqueInput
  }

  export type BmMateriaisFioCreateNestedOneWithoutBmMalhasFioInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMalhasFioInput, BmMateriaisFioUncheckedCreateWithoutBmMalhasFioInput>
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMalhasFioInput
    connect?: BmMateriaisFioWhereUniqueInput
  }

  export type BmOpsPorMalhaFioCreateNestedManyWithoutBmMalhasFioInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput> | BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmMalhasFioInputEnvelope
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
  }

  export type BmFioComposicaoUncheckedCreateNestedManyWithoutBmMalhasFioInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput> | BmFioComposicaoCreateWithoutBmMalhasFioInput[] | BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput | BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput[]
    createMany?: BmFioComposicaoCreateManyBmMalhasFioInputEnvelope
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
  }

  export type BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmMalhasFioInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput> | BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmMalhasFioInputEnvelope
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
  }

  export type BmFioComposicaoUpdateManyWithoutBmMalhasFioNestedInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput> | BmFioComposicaoCreateWithoutBmMalhasFioInput[] | BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput | BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput[]
    upsert?: BmFioComposicaoUpsertWithWhereUniqueWithoutBmMalhasFioInput | BmFioComposicaoUpsertWithWhereUniqueWithoutBmMalhasFioInput[]
    createMany?: BmFioComposicaoCreateManyBmMalhasFioInputEnvelope
    set?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    disconnect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    delete?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    update?: BmFioComposicaoUpdateWithWhereUniqueWithoutBmMalhasFioInput | BmFioComposicaoUpdateWithWhereUniqueWithoutBmMalhasFioInput[]
    updateMany?: BmFioComposicaoUpdateManyWithWhereWithoutBmMalhasFioInput | BmFioComposicaoUpdateManyWithWhereWithoutBmMalhasFioInput[]
    deleteMany?: BmFioComposicaoScalarWhereInput | BmFioComposicaoScalarWhereInput[]
  }

  export type BmMalhasUpdateOneRequiredWithoutBmMalhasFioNestedInput = {
    create?: XOR<BmMalhasCreateWithoutBmMalhasFioInput, BmMalhasUncheckedCreateWithoutBmMalhasFioInput>
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmMalhasFioInput
    upsert?: BmMalhasUpsertWithoutBmMalhasFioInput
    connect?: BmMalhasWhereUniqueInput
    update?: XOR<XOR<BmMalhasUpdateToOneWithWhereWithoutBmMalhasFioInput, BmMalhasUpdateWithoutBmMalhasFioInput>, BmMalhasUncheckedUpdateWithoutBmMalhasFioInput>
  }

  export type BmMateriaisFioUpdateOneRequiredWithoutBmMalhasFioNestedInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMalhasFioInput, BmMateriaisFioUncheckedCreateWithoutBmMalhasFioInput>
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMalhasFioInput
    upsert?: BmMateriaisFioUpsertWithoutBmMalhasFioInput
    connect?: BmMateriaisFioWhereUniqueInput
    update?: XOR<XOR<BmMateriaisFioUpdateToOneWithWhereWithoutBmMalhasFioInput, BmMateriaisFioUpdateWithoutBmMalhasFioInput>, BmMateriaisFioUncheckedUpdateWithoutBmMalhasFioInput>
  }

  export type BmOpsPorMalhaFioUpdateManyWithoutBmMalhasFioNestedInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput> | BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput[]
    upsert?: BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmMalhasFioInput | BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmMalhasFioInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmMalhasFioInputEnvelope
    set?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    delete?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    update?: BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmMalhasFioInput | BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmMalhasFioInput[]
    updateMany?: BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmMalhasFioInput | BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmMalhasFioInput[]
    deleteMany?: BmOpsPorMalhaFioScalarWhereInput | BmOpsPorMalhaFioScalarWhereInput[]
  }

  export type BmFioComposicaoUncheckedUpdateManyWithoutBmMalhasFioNestedInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput> | BmFioComposicaoCreateWithoutBmMalhasFioInput[] | BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput | BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput[]
    upsert?: BmFioComposicaoUpsertWithWhereUniqueWithoutBmMalhasFioInput | BmFioComposicaoUpsertWithWhereUniqueWithoutBmMalhasFioInput[]
    createMany?: BmFioComposicaoCreateManyBmMalhasFioInputEnvelope
    set?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    disconnect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    delete?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    update?: BmFioComposicaoUpdateWithWhereUniqueWithoutBmMalhasFioInput | BmFioComposicaoUpdateWithWhereUniqueWithoutBmMalhasFioInput[]
    updateMany?: BmFioComposicaoUpdateManyWithWhereWithoutBmMalhasFioInput | BmFioComposicaoUpdateManyWithWhereWithoutBmMalhasFioInput[]
    deleteMany?: BmFioComposicaoScalarWhereInput | BmFioComposicaoScalarWhereInput[]
  }

  export type BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmMalhasFioNestedInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput> | BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput[]
    upsert?: BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmMalhasFioInput | BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmMalhasFioInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmMalhasFioInputEnvelope
    set?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    delete?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    update?: BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmMalhasFioInput | BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmMalhasFioInput[]
    updateMany?: BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmMalhasFioInput | BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmMalhasFioInput[]
    deleteMany?: BmOpsPorMalhaFioScalarWhereInput | BmOpsPorMalhaFioScalarWhereInput[]
  }

  export type BmOpsPorMalhaFioCreateNestedOneWithoutBmMalhasFioMovimentosInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioMovimentosInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioMovimentosInput>
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioMovimentosInput
    connect?: BmOpsPorMalhaFioWhereUniqueInput
  }

  export type BmOpsPorMalhaFioUpdateOneRequiredWithoutBmMalhasFioMovimentosNestedInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioMovimentosInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioMovimentosInput>
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioMovimentosInput
    upsert?: BmOpsPorMalhaFioUpsertWithoutBmMalhasFioMovimentosInput
    connect?: BmOpsPorMalhaFioWhereUniqueInput
    update?: XOR<XOR<BmOpsPorMalhaFioUpdateToOneWithWhereWithoutBmMalhasFioMovimentosInput, BmOpsPorMalhaFioUpdateWithoutBmMalhasFioMovimentosInput>, BmOpsPorMalhaFioUncheckedUpdateWithoutBmMalhasFioMovimentosInput>
  }

  export type BmMalhasCreateNestedManyWithoutBmMateriaisInput = {
    create?: XOR<BmMalhasCreateWithoutBmMateriaisInput, BmMalhasUncheckedCreateWithoutBmMateriaisInput> | BmMalhasCreateWithoutBmMateriaisInput[] | BmMalhasUncheckedCreateWithoutBmMateriaisInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmMateriaisInput | BmMalhasCreateOrConnectWithoutBmMateriaisInput[]
    createMany?: BmMalhasCreateManyBmMateriaisInputEnvelope
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
  }

  export type BmMaterialGrupoCreateNestedOneWithoutBmMateriaisInput = {
    create?: XOR<BmMaterialGrupoCreateWithoutBmMateriaisInput, BmMaterialGrupoUncheckedCreateWithoutBmMateriaisInput>
    connectOrCreate?: BmMaterialGrupoCreateOrConnectWithoutBmMateriaisInput
    connect?: BmMaterialGrupoWhereUniqueInput
  }

  export type BmMaterialSubGrupoCreateNestedOneWithoutBmMateriaisInput = {
    create?: XOR<BmMaterialSubGrupoCreateWithoutBmMateriaisInput, BmMaterialSubGrupoUncheckedCreateWithoutBmMateriaisInput>
    connectOrCreate?: BmMaterialSubGrupoCreateOrConnectWithoutBmMateriaisInput
    connect?: BmMaterialSubGrupoWhereUniqueInput
  }

  export type BmMalhasUncheckedCreateNestedManyWithoutBmMateriaisInput = {
    create?: XOR<BmMalhasCreateWithoutBmMateriaisInput, BmMalhasUncheckedCreateWithoutBmMateriaisInput> | BmMalhasCreateWithoutBmMateriaisInput[] | BmMalhasUncheckedCreateWithoutBmMateriaisInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmMateriaisInput | BmMalhasCreateOrConnectWithoutBmMateriaisInput[]
    createMany?: BmMalhasCreateManyBmMateriaisInputEnvelope
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
  }

  export type BmMalhasUpdateManyWithoutBmMateriaisNestedInput = {
    create?: XOR<BmMalhasCreateWithoutBmMateriaisInput, BmMalhasUncheckedCreateWithoutBmMateriaisInput> | BmMalhasCreateWithoutBmMateriaisInput[] | BmMalhasUncheckedCreateWithoutBmMateriaisInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmMateriaisInput | BmMalhasCreateOrConnectWithoutBmMateriaisInput[]
    upsert?: BmMalhasUpsertWithWhereUniqueWithoutBmMateriaisInput | BmMalhasUpsertWithWhereUniqueWithoutBmMateriaisInput[]
    createMany?: BmMalhasCreateManyBmMateriaisInputEnvelope
    set?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    disconnect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    delete?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    update?: BmMalhasUpdateWithWhereUniqueWithoutBmMateriaisInput | BmMalhasUpdateWithWhereUniqueWithoutBmMateriaisInput[]
    updateMany?: BmMalhasUpdateManyWithWhereWithoutBmMateriaisInput | BmMalhasUpdateManyWithWhereWithoutBmMateriaisInput[]
    deleteMany?: BmMalhasScalarWhereInput | BmMalhasScalarWhereInput[]
  }

  export type BmMaterialGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput = {
    create?: XOR<BmMaterialGrupoCreateWithoutBmMateriaisInput, BmMaterialGrupoUncheckedCreateWithoutBmMateriaisInput>
    connectOrCreate?: BmMaterialGrupoCreateOrConnectWithoutBmMateriaisInput
    upsert?: BmMaterialGrupoUpsertWithoutBmMateriaisInput
    connect?: BmMaterialGrupoWhereUniqueInput
    update?: XOR<XOR<BmMaterialGrupoUpdateToOneWithWhereWithoutBmMateriaisInput, BmMaterialGrupoUpdateWithoutBmMateriaisInput>, BmMaterialGrupoUncheckedUpdateWithoutBmMateriaisInput>
  }

  export type BmMaterialSubGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput = {
    create?: XOR<BmMaterialSubGrupoCreateWithoutBmMateriaisInput, BmMaterialSubGrupoUncheckedCreateWithoutBmMateriaisInput>
    connectOrCreate?: BmMaterialSubGrupoCreateOrConnectWithoutBmMateriaisInput
    upsert?: BmMaterialSubGrupoUpsertWithoutBmMateriaisInput
    connect?: BmMaterialSubGrupoWhereUniqueInput
    update?: XOR<XOR<BmMaterialSubGrupoUpdateToOneWithWhereWithoutBmMateriaisInput, BmMaterialSubGrupoUpdateWithoutBmMateriaisInput>, BmMaterialSubGrupoUncheckedUpdateWithoutBmMateriaisInput>
  }

  export type BmMalhasUncheckedUpdateManyWithoutBmMateriaisNestedInput = {
    create?: XOR<BmMalhasCreateWithoutBmMateriaisInput, BmMalhasUncheckedCreateWithoutBmMateriaisInput> | BmMalhasCreateWithoutBmMateriaisInput[] | BmMalhasUncheckedCreateWithoutBmMateriaisInput[]
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmMateriaisInput | BmMalhasCreateOrConnectWithoutBmMateriaisInput[]
    upsert?: BmMalhasUpsertWithWhereUniqueWithoutBmMateriaisInput | BmMalhasUpsertWithWhereUniqueWithoutBmMateriaisInput[]
    createMany?: BmMalhasCreateManyBmMateriaisInputEnvelope
    set?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    disconnect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    delete?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    connect?: BmMalhasWhereUniqueInput | BmMalhasWhereUniqueInput[]
    update?: BmMalhasUpdateWithWhereUniqueWithoutBmMateriaisInput | BmMalhasUpdateWithWhereUniqueWithoutBmMateriaisInput[]
    updateMany?: BmMalhasUpdateManyWithWhereWithoutBmMateriaisInput | BmMalhasUpdateManyWithWhereWithoutBmMateriaisInput[]
    deleteMany?: BmMalhasScalarWhereInput | BmMalhasScalarWhereInput[]
  }

  export type BmFioComposicaoCreateNestedManyWithoutBmMateriaisComposicaoInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    createMany?: BmFioComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
  }

  export type BmIdBmComposicaoCreateNestedManyWithoutBmMateriaisComposicaoInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
  }

  export type BmFioComposicaoUncheckedCreateNestedManyWithoutBmMateriaisComposicaoInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    createMany?: BmFioComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
  }

  export type BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMateriaisComposicaoInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
  }

  export type BmFioComposicaoUpdateManyWithoutBmMateriaisComposicaoNestedInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    upsert?: BmFioComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmFioComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    createMany?: BmFioComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    set?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    disconnect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    delete?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    update?: BmFioComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmFioComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    updateMany?: BmFioComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput | BmFioComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput[]
    deleteMany?: BmFioComposicaoScalarWhereInput | BmFioComposicaoScalarWhereInput[]
  }

  export type BmIdBmComposicaoUpdateManyWithoutBmMateriaisComposicaoNestedInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    upsert?: BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    set?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    disconnect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    delete?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    update?: BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    updateMany?: BmIdBmComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput[]
    deleteMany?: BmIdBmComposicaoScalarWhereInput | BmIdBmComposicaoScalarWhereInput[]
  }

  export type BmFioComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoNestedInput = {
    create?: XOR<BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    upsert?: BmFioComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmFioComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    createMany?: BmFioComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    set?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    disconnect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    delete?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    connect?: BmFioComposicaoWhereUniqueInput | BmFioComposicaoWhereUniqueInput[]
    update?: BmFioComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmFioComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    updateMany?: BmFioComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput | BmFioComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput[]
    deleteMany?: BmFioComposicaoScalarWhereInput | BmFioComposicaoScalarWhereInput[]
  }

  export type BmIdBmComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoNestedInput = {
    create?: XOR<BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput> | BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput[] | BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput[]
    connectOrCreate?: BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput[]
    upsert?: BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    createMany?: BmIdBmComposicaoCreateManyBmMateriaisComposicaoInputEnvelope
    set?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    disconnect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    delete?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    connect?: BmIdBmComposicaoWhereUniqueInput | BmIdBmComposicaoWhereUniqueInput[]
    update?: BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput[]
    updateMany?: BmIdBmComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput | BmIdBmComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput[]
    deleteMany?: BmIdBmComposicaoScalarWhereInput | BmIdBmComposicaoScalarWhereInput[]
  }

  export type BmMalhasFioCreateNestedManyWithoutBmMateriaisFioInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput> | BmMalhasFioCreateWithoutBmMateriaisFioInput[] | BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput | BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput[]
    createMany?: BmMalhasFioCreateManyBmMateriaisFioInputEnvelope
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
  }

  export type BmMaterialGrupoFioCreateNestedOneWithoutBmMateriaisFioInput = {
    create?: XOR<BmMaterialGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
    connectOrCreate?: BmMaterialGrupoFioCreateOrConnectWithoutBmMateriaisFioInput
    connect?: BmMaterialGrupoFioWhereUniqueInput
  }

  export type BmMaterialSubGrupoFioCreateNestedOneWithoutBmMateriaisFioInput = {
    create?: XOR<BmMaterialSubGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialSubGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
    connectOrCreate?: BmMaterialSubGrupoFioCreateOrConnectWithoutBmMateriaisFioInput
    connect?: BmMaterialSubGrupoFioWhereUniqueInput
  }

  export type BmMalhasFioUncheckedCreateNestedManyWithoutBmMateriaisFioInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput> | BmMalhasFioCreateWithoutBmMateriaisFioInput[] | BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput | BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput[]
    createMany?: BmMalhasFioCreateManyBmMateriaisFioInputEnvelope
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
  }

  export type BmMalhasFioUpdateManyWithoutBmMateriaisFioNestedInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput> | BmMalhasFioCreateWithoutBmMateriaisFioInput[] | BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput | BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput[]
    upsert?: BmMalhasFioUpsertWithWhereUniqueWithoutBmMateriaisFioInput | BmMalhasFioUpsertWithWhereUniqueWithoutBmMateriaisFioInput[]
    createMany?: BmMalhasFioCreateManyBmMateriaisFioInputEnvelope
    set?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    disconnect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    delete?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    update?: BmMalhasFioUpdateWithWhereUniqueWithoutBmMateriaisFioInput | BmMalhasFioUpdateWithWhereUniqueWithoutBmMateriaisFioInput[]
    updateMany?: BmMalhasFioUpdateManyWithWhereWithoutBmMateriaisFioInput | BmMalhasFioUpdateManyWithWhereWithoutBmMateriaisFioInput[]
    deleteMany?: BmMalhasFioScalarWhereInput | BmMalhasFioScalarWhereInput[]
  }

  export type BmMaterialGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput = {
    create?: XOR<BmMaterialGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
    connectOrCreate?: BmMaterialGrupoFioCreateOrConnectWithoutBmMateriaisFioInput
    upsert?: BmMaterialGrupoFioUpsertWithoutBmMateriaisFioInput
    connect?: BmMaterialGrupoFioWhereUniqueInput
    update?: XOR<XOR<BmMaterialGrupoFioUpdateToOneWithWhereWithoutBmMateriaisFioInput, BmMaterialGrupoFioUpdateWithoutBmMateriaisFioInput>, BmMaterialGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput>
  }

  export type BmMaterialSubGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput = {
    create?: XOR<BmMaterialSubGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialSubGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
    connectOrCreate?: BmMaterialSubGrupoFioCreateOrConnectWithoutBmMateriaisFioInput
    upsert?: BmMaterialSubGrupoFioUpsertWithoutBmMateriaisFioInput
    connect?: BmMaterialSubGrupoFioWhereUniqueInput
    update?: XOR<XOR<BmMaterialSubGrupoFioUpdateToOneWithWhereWithoutBmMateriaisFioInput, BmMaterialSubGrupoFioUpdateWithoutBmMateriaisFioInput>, BmMaterialSubGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput>
  }

  export type BmMalhasFioUncheckedUpdateManyWithoutBmMateriaisFioNestedInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput> | BmMalhasFioCreateWithoutBmMateriaisFioInput[] | BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput[]
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput | BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput[]
    upsert?: BmMalhasFioUpsertWithWhereUniqueWithoutBmMateriaisFioInput | BmMalhasFioUpsertWithWhereUniqueWithoutBmMateriaisFioInput[]
    createMany?: BmMalhasFioCreateManyBmMateriaisFioInputEnvelope
    set?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    disconnect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    delete?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    connect?: BmMalhasFioWhereUniqueInput | BmMalhasFioWhereUniqueInput[]
    update?: BmMalhasFioUpdateWithWhereUniqueWithoutBmMateriaisFioInput | BmMalhasFioUpdateWithWhereUniqueWithoutBmMateriaisFioInput[]
    updateMany?: BmMalhasFioUpdateManyWithWhereWithoutBmMateriaisFioInput | BmMalhasFioUpdateManyWithWhereWithoutBmMateriaisFioInput[]
    deleteMany?: BmMalhasFioScalarWhereInput | BmMalhasFioScalarWhereInput[]
  }

  export type BmMateriaisCreateNestedManyWithoutBmMaterialGrupoInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput> | BmMateriaisCreateWithoutBmMaterialGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialGrupoInputEnvelope
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
  }

  export type BmMateriaisUncheckedCreateNestedManyWithoutBmMaterialGrupoInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput> | BmMateriaisCreateWithoutBmMaterialGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialGrupoInputEnvelope
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
  }

  export type BmMateriaisUpdateManyWithoutBmMaterialGrupoNestedInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput> | BmMateriaisCreateWithoutBmMaterialGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput[]
    upsert?: BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialGrupoInput | BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialGrupoInputEnvelope
    set?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    disconnect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    delete?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    update?: BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialGrupoInput | BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialGrupoInput[]
    updateMany?: BmMateriaisUpdateManyWithWhereWithoutBmMaterialGrupoInput | BmMateriaisUpdateManyWithWhereWithoutBmMaterialGrupoInput[]
    deleteMany?: BmMateriaisScalarWhereInput | BmMateriaisScalarWhereInput[]
  }

  export type BmMateriaisUncheckedUpdateManyWithoutBmMaterialGrupoNestedInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput> | BmMateriaisCreateWithoutBmMaterialGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput[]
    upsert?: BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialGrupoInput | BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialGrupoInputEnvelope
    set?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    disconnect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    delete?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    update?: BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialGrupoInput | BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialGrupoInput[]
    updateMany?: BmMateriaisUpdateManyWithWhereWithoutBmMaterialGrupoInput | BmMateriaisUpdateManyWithWhereWithoutBmMaterialGrupoInput[]
    deleteMany?: BmMateriaisScalarWhereInput | BmMateriaisScalarWhereInput[]
  }

  export type BmMateriaisFioCreateNestedManyWithoutBmMaterialGrupoFioInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialGrupoFioInputEnvelope
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
  }

  export type BmMateriaisFioUncheckedCreateNestedManyWithoutBmMaterialGrupoFioInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialGrupoFioInputEnvelope
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
  }

  export type BmMateriaisFioUpdateManyWithoutBmMaterialGrupoFioNestedInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput[]
    upsert?: BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialGrupoFioInput | BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialGrupoFioInputEnvelope
    set?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    disconnect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    delete?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    update?: BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialGrupoFioInput | BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialGrupoFioInput[]
    updateMany?: BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialGrupoFioInput | BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialGrupoFioInput[]
    deleteMany?: BmMateriaisFioScalarWhereInput | BmMateriaisFioScalarWhereInput[]
  }

  export type BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialGrupoFioNestedInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput[]
    upsert?: BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialGrupoFioInput | BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialGrupoFioInputEnvelope
    set?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    disconnect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    delete?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    update?: BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialGrupoFioInput | BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialGrupoFioInput[]
    updateMany?: BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialGrupoFioInput | BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialGrupoFioInput[]
    deleteMany?: BmMateriaisFioScalarWhereInput | BmMateriaisFioScalarWhereInput[]
  }

  export type BmMateriaisCreateNestedManyWithoutBmMaterialSubGrupoInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput> | BmMateriaisCreateWithoutBmMaterialSubGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialSubGrupoInputEnvelope
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
  }

  export type BmMateriaisUncheckedCreateNestedManyWithoutBmMaterialSubGrupoInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput> | BmMateriaisCreateWithoutBmMaterialSubGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialSubGrupoInputEnvelope
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
  }

  export type BmMateriaisUpdateManyWithoutBmMaterialSubGrupoNestedInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput> | BmMateriaisCreateWithoutBmMaterialSubGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput[]
    upsert?: BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialSubGrupoInput | BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialSubGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialSubGrupoInputEnvelope
    set?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    disconnect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    delete?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    update?: BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialSubGrupoInput | BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialSubGrupoInput[]
    updateMany?: BmMateriaisUpdateManyWithWhereWithoutBmMaterialSubGrupoInput | BmMateriaisUpdateManyWithWhereWithoutBmMaterialSubGrupoInput[]
    deleteMany?: BmMateriaisScalarWhereInput | BmMateriaisScalarWhereInput[]
  }

  export type BmMateriaisUncheckedUpdateManyWithoutBmMaterialSubGrupoNestedInput = {
    create?: XOR<BmMateriaisCreateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput> | BmMateriaisCreateWithoutBmMaterialSubGrupoInput[] | BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput[]
    connectOrCreate?: BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput | BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput[]
    upsert?: BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialSubGrupoInput | BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialSubGrupoInput[]
    createMany?: BmMateriaisCreateManyBmMaterialSubGrupoInputEnvelope
    set?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    disconnect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    delete?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    connect?: BmMateriaisWhereUniqueInput | BmMateriaisWhereUniqueInput[]
    update?: BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialSubGrupoInput | BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialSubGrupoInput[]
    updateMany?: BmMateriaisUpdateManyWithWhereWithoutBmMaterialSubGrupoInput | BmMateriaisUpdateManyWithWhereWithoutBmMaterialSubGrupoInput[]
    deleteMany?: BmMateriaisScalarWhereInput | BmMateriaisScalarWhereInput[]
  }

  export type BmMateriaisFioCreateNestedManyWithoutBmMaterialSubGrupoFioInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialSubGrupoFioInputEnvelope
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
  }

  export type BmMateriaisFioUncheckedCreateNestedManyWithoutBmMaterialSubGrupoFioInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialSubGrupoFioInputEnvelope
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
  }

  export type BmMateriaisFioUpdateManyWithoutBmMaterialSubGrupoFioNestedInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput[]
    upsert?: BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialSubGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialSubGrupoFioInputEnvelope
    set?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    disconnect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    delete?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    update?: BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialSubGrupoFioInput[]
    updateMany?: BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialSubGrupoFioInput[]
    deleteMany?: BmMateriaisFioScalarWhereInput | BmMateriaisFioScalarWhereInput[]
  }

  export type BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialSubGrupoFioNestedInput = {
    create?: XOR<BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput> | BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput[] | BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput[]
    connectOrCreate?: BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput[]
    upsert?: BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialSubGrupoFioInput[]
    createMany?: BmMateriaisFioCreateManyBmMaterialSubGrupoFioInputEnvelope
    set?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    disconnect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    delete?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    connect?: BmMateriaisFioWhereUniqueInput | BmMateriaisFioWhereUniqueInput[]
    update?: BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialSubGrupoFioInput[]
    updateMany?: BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialSubGrupoFioInput | BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialSubGrupoFioInput[]
    deleteMany?: BmMateriaisFioScalarWhereInput | BmMateriaisFioScalarWhereInput[]
  }

  export type BmOpsPorMalhaCreateNestedOneWithoutBmMovimentosLotesInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmMovimentosLotesInput, BmOpsPorMalhaUncheckedCreateWithoutBmMovimentosLotesInput>
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmMovimentosLotesInput
    connect?: BmOpsPorMalhaWhereUniqueInput
  }

  export type BmOpsPorMalhaUpdateOneRequiredWithoutBmMovimentosLotesNestedInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmMovimentosLotesInput, BmOpsPorMalhaUncheckedCreateWithoutBmMovimentosLotesInput>
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmMovimentosLotesInput
    upsert?: BmOpsPorMalhaUpsertWithoutBmMovimentosLotesInput
    connect?: BmOpsPorMalhaWhereUniqueInput
    update?: XOR<XOR<BmOpsPorMalhaUpdateToOneWithWhereWithoutBmMovimentosLotesInput, BmOpsPorMalhaUpdateWithoutBmMovimentosLotesInput>, BmOpsPorMalhaUncheckedUpdateWithoutBmMovimentosLotesInput>
  }

  export type BmCreateNestedOneWithoutBmOpInput = {
    create?: XOR<BmCreateWithoutBmOpInput, BmUncheckedCreateWithoutBmOpInput>
    connectOrCreate?: BmCreateOrConnectWithoutBmOpInput
    connect?: BmWhereUniqueInput
  }

  export type BmOpFaturadoCreateNestedManyWithoutBmOpInput = {
    create?: XOR<BmOpFaturadoCreateWithoutBmOpInput, BmOpFaturadoUncheckedCreateWithoutBmOpInput> | BmOpFaturadoCreateWithoutBmOpInput[] | BmOpFaturadoUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpFaturadoCreateOrConnectWithoutBmOpInput | BmOpFaturadoCreateOrConnectWithoutBmOpInput[]
    createMany?: BmOpFaturadoCreateManyBmOpInputEnvelope
    connect?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
  }

  export type BmOpsPorMalhaCreateNestedManyWithoutBmOpInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmOpInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpInput> | BmOpsPorMalhaCreateWithoutBmOpInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmOpInput | BmOpsPorMalhaCreateOrConnectWithoutBmOpInput[]
    createMany?: BmOpsPorMalhaCreateManyBmOpInputEnvelope
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
  }

  export type BmOpFaturadoUncheckedCreateNestedManyWithoutBmOpInput = {
    create?: XOR<BmOpFaturadoCreateWithoutBmOpInput, BmOpFaturadoUncheckedCreateWithoutBmOpInput> | BmOpFaturadoCreateWithoutBmOpInput[] | BmOpFaturadoUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpFaturadoCreateOrConnectWithoutBmOpInput | BmOpFaturadoCreateOrConnectWithoutBmOpInput[]
    createMany?: BmOpFaturadoCreateManyBmOpInputEnvelope
    connect?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
  }

  export type BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmOpInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmOpInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpInput> | BmOpsPorMalhaCreateWithoutBmOpInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmOpInput | BmOpsPorMalhaCreateOrConnectWithoutBmOpInput[]
    createMany?: BmOpsPorMalhaCreateManyBmOpInputEnvelope
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
  }

  export type BmUpdateOneRequiredWithoutBmOpNestedInput = {
    create?: XOR<BmCreateWithoutBmOpInput, BmUncheckedCreateWithoutBmOpInput>
    connectOrCreate?: BmCreateOrConnectWithoutBmOpInput
    upsert?: BmUpsertWithoutBmOpInput
    connect?: BmWhereUniqueInput
    update?: XOR<XOR<BmUpdateToOneWithWhereWithoutBmOpInput, BmUpdateWithoutBmOpInput>, BmUncheckedUpdateWithoutBmOpInput>
  }

  export type BmOpFaturadoUpdateManyWithoutBmOpNestedInput = {
    create?: XOR<BmOpFaturadoCreateWithoutBmOpInput, BmOpFaturadoUncheckedCreateWithoutBmOpInput> | BmOpFaturadoCreateWithoutBmOpInput[] | BmOpFaturadoUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpFaturadoCreateOrConnectWithoutBmOpInput | BmOpFaturadoCreateOrConnectWithoutBmOpInput[]
    upsert?: BmOpFaturadoUpsertWithWhereUniqueWithoutBmOpInput | BmOpFaturadoUpsertWithWhereUniqueWithoutBmOpInput[]
    createMany?: BmOpFaturadoCreateManyBmOpInputEnvelope
    set?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    disconnect?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    delete?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    connect?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    update?: BmOpFaturadoUpdateWithWhereUniqueWithoutBmOpInput | BmOpFaturadoUpdateWithWhereUniqueWithoutBmOpInput[]
    updateMany?: BmOpFaturadoUpdateManyWithWhereWithoutBmOpInput | BmOpFaturadoUpdateManyWithWhereWithoutBmOpInput[]
    deleteMany?: BmOpFaturadoScalarWhereInput | BmOpFaturadoScalarWhereInput[]
  }

  export type BmOpsPorMalhaUpdateManyWithoutBmOpNestedInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmOpInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpInput> | BmOpsPorMalhaCreateWithoutBmOpInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmOpInput | BmOpsPorMalhaCreateOrConnectWithoutBmOpInput[]
    upsert?: BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmOpInput | BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmOpInput[]
    createMany?: BmOpsPorMalhaCreateManyBmOpInputEnvelope
    set?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    delete?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    update?: BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmOpInput | BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmOpInput[]
    updateMany?: BmOpsPorMalhaUpdateManyWithWhereWithoutBmOpInput | BmOpsPorMalhaUpdateManyWithWhereWithoutBmOpInput[]
    deleteMany?: BmOpsPorMalhaScalarWhereInput | BmOpsPorMalhaScalarWhereInput[]
  }

  export type BmOpFaturadoUncheckedUpdateManyWithoutBmOpNestedInput = {
    create?: XOR<BmOpFaturadoCreateWithoutBmOpInput, BmOpFaturadoUncheckedCreateWithoutBmOpInput> | BmOpFaturadoCreateWithoutBmOpInput[] | BmOpFaturadoUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpFaturadoCreateOrConnectWithoutBmOpInput | BmOpFaturadoCreateOrConnectWithoutBmOpInput[]
    upsert?: BmOpFaturadoUpsertWithWhereUniqueWithoutBmOpInput | BmOpFaturadoUpsertWithWhereUniqueWithoutBmOpInput[]
    createMany?: BmOpFaturadoCreateManyBmOpInputEnvelope
    set?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    disconnect?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    delete?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    connect?: BmOpFaturadoWhereUniqueInput | BmOpFaturadoWhereUniqueInput[]
    update?: BmOpFaturadoUpdateWithWhereUniqueWithoutBmOpInput | BmOpFaturadoUpdateWithWhereUniqueWithoutBmOpInput[]
    updateMany?: BmOpFaturadoUpdateManyWithWhereWithoutBmOpInput | BmOpFaturadoUpdateManyWithWhereWithoutBmOpInput[]
    deleteMany?: BmOpFaturadoScalarWhereInput | BmOpFaturadoScalarWhereInput[]
  }

  export type BmOpsPorMalhaUncheckedUpdateManyWithoutBmOpNestedInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmOpInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpInput> | BmOpsPorMalhaCreateWithoutBmOpInput[] | BmOpsPorMalhaUncheckedCreateWithoutBmOpInput[]
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmOpInput | BmOpsPorMalhaCreateOrConnectWithoutBmOpInput[]
    upsert?: BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmOpInput | BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmOpInput[]
    createMany?: BmOpsPorMalhaCreateManyBmOpInputEnvelope
    set?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    delete?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    connect?: BmOpsPorMalhaWhereUniqueInput | BmOpsPorMalhaWhereUniqueInput[]
    update?: BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmOpInput | BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmOpInput[]
    updateMany?: BmOpsPorMalhaUpdateManyWithWhereWithoutBmOpInput | BmOpsPorMalhaUpdateManyWithWhereWithoutBmOpInput[]
    deleteMany?: BmOpsPorMalhaScalarWhereInput | BmOpsPorMalhaScalarWhereInput[]
  }

  export type BmOpCreateNestedOneWithoutBmOpFaturadoInput = {
    create?: XOR<BmOpCreateWithoutBmOpFaturadoInput, BmOpUncheckedCreateWithoutBmOpFaturadoInput>
    connectOrCreate?: BmOpCreateOrConnectWithoutBmOpFaturadoInput
    connect?: BmOpWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BmOpUpdateOneRequiredWithoutBmOpFaturadoNestedInput = {
    create?: XOR<BmOpCreateWithoutBmOpFaturadoInput, BmOpUncheckedCreateWithoutBmOpFaturadoInput>
    connectOrCreate?: BmOpCreateOrConnectWithoutBmOpFaturadoInput
    upsert?: BmOpUpsertWithoutBmOpFaturadoInput
    connect?: BmOpWhereUniqueInput
    update?: XOR<XOR<BmOpUpdateToOneWithWhereWithoutBmOpFaturadoInput, BmOpUpdateWithoutBmOpFaturadoInput>, BmOpUncheckedUpdateWithoutBmOpFaturadoInput>
  }

  export type BmMovimentosLotesCreateNestedManyWithoutBmOpsPorMalhaInput = {
    create?: XOR<BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput> | BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput[] | BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput | BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput[]
    createMany?: BmMovimentosLotesCreateManyBmOpsPorMalhaInputEnvelope
    connect?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
  }

  export type BmMalhasCreateNestedOneWithoutBmOpsPorMalhaInput = {
    create?: XOR<BmMalhasCreateWithoutBmOpsPorMalhaInput, BmMalhasUncheckedCreateWithoutBmOpsPorMalhaInput>
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmOpsPorMalhaInput
    connect?: BmMalhasWhereUniqueInput
  }

  export type BmOpCreateNestedOneWithoutBmOpsPorMalhaInput = {
    create?: XOR<BmOpCreateWithoutBmOpsPorMalhaInput, BmOpUncheckedCreateWithoutBmOpsPorMalhaInput>
    connectOrCreate?: BmOpCreateOrConnectWithoutBmOpsPorMalhaInput
    connect?: BmOpWhereUniqueInput
  }

  export type BmOpsPorMalhaFioCreateNestedManyWithoutBmOpsPorMalhaInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput> | BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInputEnvelope
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
  }

  export type BmMovimentosLotesUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput = {
    create?: XOR<BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput> | BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput[] | BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput | BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput[]
    createMany?: BmMovimentosLotesCreateManyBmOpsPorMalhaInputEnvelope
    connect?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
  }

  export type BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput> | BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInputEnvelope
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
  }

  export type BmMovimentosLotesUpdateManyWithoutBmOpsPorMalhaNestedInput = {
    create?: XOR<BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput> | BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput[] | BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput | BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput[]
    upsert?: BmMovimentosLotesUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput | BmMovimentosLotesUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    createMany?: BmMovimentosLotesCreateManyBmOpsPorMalhaInputEnvelope
    set?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    disconnect?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    delete?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    connect?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    update?: BmMovimentosLotesUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput | BmMovimentosLotesUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    updateMany?: BmMovimentosLotesUpdateManyWithWhereWithoutBmOpsPorMalhaInput | BmMovimentosLotesUpdateManyWithWhereWithoutBmOpsPorMalhaInput[]
    deleteMany?: BmMovimentosLotesScalarWhereInput | BmMovimentosLotesScalarWhereInput[]
  }

  export type BmMalhasUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput = {
    create?: XOR<BmMalhasCreateWithoutBmOpsPorMalhaInput, BmMalhasUncheckedCreateWithoutBmOpsPorMalhaInput>
    connectOrCreate?: BmMalhasCreateOrConnectWithoutBmOpsPorMalhaInput
    upsert?: BmMalhasUpsertWithoutBmOpsPorMalhaInput
    connect?: BmMalhasWhereUniqueInput
    update?: XOR<XOR<BmMalhasUpdateToOneWithWhereWithoutBmOpsPorMalhaInput, BmMalhasUpdateWithoutBmOpsPorMalhaInput>, BmMalhasUncheckedUpdateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput = {
    create?: XOR<BmOpCreateWithoutBmOpsPorMalhaInput, BmOpUncheckedCreateWithoutBmOpsPorMalhaInput>
    connectOrCreate?: BmOpCreateOrConnectWithoutBmOpsPorMalhaInput
    upsert?: BmOpUpsertWithoutBmOpsPorMalhaInput
    connect?: BmOpWhereUniqueInput
    update?: XOR<XOR<BmOpUpdateToOneWithWhereWithoutBmOpsPorMalhaInput, BmOpUpdateWithoutBmOpsPorMalhaInput>, BmOpUncheckedUpdateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpsPorMalhaFioUpdateManyWithoutBmOpsPorMalhaNestedInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput> | BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput[]
    upsert?: BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInputEnvelope
    set?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    delete?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    update?: BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    updateMany?: BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmOpsPorMalhaInput[]
    deleteMany?: BmOpsPorMalhaFioScalarWhereInput | BmOpsPorMalhaFioScalarWhereInput[]
  }

  export type BmMovimentosLotesUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput = {
    create?: XOR<BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput> | BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput[] | BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput | BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput[]
    upsert?: BmMovimentosLotesUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput | BmMovimentosLotesUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    createMany?: BmMovimentosLotesCreateManyBmOpsPorMalhaInputEnvelope
    set?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    disconnect?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    delete?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    connect?: BmMovimentosLotesWhereUniqueInput | BmMovimentosLotesWhereUniqueInput[]
    update?: BmMovimentosLotesUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput | BmMovimentosLotesUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    updateMany?: BmMovimentosLotesUpdateManyWithWhereWithoutBmOpsPorMalhaInput | BmMovimentosLotesUpdateManyWithWhereWithoutBmOpsPorMalhaInput[]
    deleteMany?: BmMovimentosLotesScalarWhereInput | BmMovimentosLotesScalarWhereInput[]
  }

  export type BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput = {
    create?: XOR<BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput> | BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput[] | BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput[]
    connectOrCreate?: BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput[]
    upsert?: BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    createMany?: BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInputEnvelope
    set?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    disconnect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    delete?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    connect?: BmOpsPorMalhaFioWhereUniqueInput | BmOpsPorMalhaFioWhereUniqueInput[]
    update?: BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput[]
    updateMany?: BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmOpsPorMalhaInput | BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmOpsPorMalhaInput[]
    deleteMany?: BmOpsPorMalhaFioScalarWhereInput | BmOpsPorMalhaFioScalarWhereInput[]
  }

  export type BmMalhasFioMovimentosCreateNestedManyWithoutBmOpsPorMalhaFioInput = {
    create?: XOR<BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput> | BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput[] | BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput[]
    connectOrCreate?: BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput[]
    createMany?: BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInputEnvelope
    connect?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
  }

  export type BmMalhasFioCreateNestedOneWithoutBmOpsPorMalhaFioInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioUncheckedCreateWithoutBmOpsPorMalhaFioInput>
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmOpsPorMalhaFioInput
    connect?: BmMalhasFioWhereUniqueInput
  }

  export type BmOpsPorMalhaCreateNestedOneWithoutBmOpsPorMalhaFioInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmOpsPorMalhaFioInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpsPorMalhaFioInput>
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmOpsPorMalhaFioInput
    connect?: BmOpsPorMalhaWhereUniqueInput
  }

  export type BmMalhasFioMovimentosUncheckedCreateNestedManyWithoutBmOpsPorMalhaFioInput = {
    create?: XOR<BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput> | BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput[] | BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput[]
    connectOrCreate?: BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput[]
    createMany?: BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInputEnvelope
    connect?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
  }

  export type BmMalhasFioMovimentosUpdateManyWithoutBmOpsPorMalhaFioNestedInput = {
    create?: XOR<BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput> | BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput[] | BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput[]
    connectOrCreate?: BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput[]
    upsert?: BmMalhasFioMovimentosUpsertWithWhereUniqueWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosUpsertWithWhereUniqueWithoutBmOpsPorMalhaFioInput[]
    createMany?: BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInputEnvelope
    set?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    disconnect?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    delete?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    connect?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    update?: BmMalhasFioMovimentosUpdateWithWhereUniqueWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosUpdateWithWhereUniqueWithoutBmOpsPorMalhaFioInput[]
    updateMany?: BmMalhasFioMovimentosUpdateManyWithWhereWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosUpdateManyWithWhereWithoutBmOpsPorMalhaFioInput[]
    deleteMany?: BmMalhasFioMovimentosScalarWhereInput | BmMalhasFioMovimentosScalarWhereInput[]
  }

  export type BmMalhasFioUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput = {
    create?: XOR<BmMalhasFioCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioUncheckedCreateWithoutBmOpsPorMalhaFioInput>
    connectOrCreate?: BmMalhasFioCreateOrConnectWithoutBmOpsPorMalhaFioInput
    upsert?: BmMalhasFioUpsertWithoutBmOpsPorMalhaFioInput
    connect?: BmMalhasFioWhereUniqueInput
    update?: XOR<XOR<BmMalhasFioUpdateToOneWithWhereWithoutBmOpsPorMalhaFioInput, BmMalhasFioUpdateWithoutBmOpsPorMalhaFioInput>, BmMalhasFioUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmOpsPorMalhaUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput = {
    create?: XOR<BmOpsPorMalhaCreateWithoutBmOpsPorMalhaFioInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpsPorMalhaFioInput>
    connectOrCreate?: BmOpsPorMalhaCreateOrConnectWithoutBmOpsPorMalhaFioInput
    upsert?: BmOpsPorMalhaUpsertWithoutBmOpsPorMalhaFioInput
    connect?: BmOpsPorMalhaWhereUniqueInput
    update?: XOR<XOR<BmOpsPorMalhaUpdateToOneWithWhereWithoutBmOpsPorMalhaFioInput, BmOpsPorMalhaUpdateWithoutBmOpsPorMalhaFioInput>, BmOpsPorMalhaUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmMalhasFioMovimentosUncheckedUpdateManyWithoutBmOpsPorMalhaFioNestedInput = {
    create?: XOR<BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput> | BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput[] | BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput[]
    connectOrCreate?: BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput[]
    upsert?: BmMalhasFioMovimentosUpsertWithWhereUniqueWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosUpsertWithWhereUniqueWithoutBmOpsPorMalhaFioInput[]
    createMany?: BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInputEnvelope
    set?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    disconnect?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    delete?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    connect?: BmMalhasFioMovimentosWhereUniqueInput | BmMalhasFioMovimentosWhereUniqueInput[]
    update?: BmMalhasFioMovimentosUpdateWithWhereUniqueWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosUpdateWithWhereUniqueWithoutBmOpsPorMalhaFioInput[]
    updateMany?: BmMalhasFioMovimentosUpdateManyWithWhereWithoutBmOpsPorMalhaFioInput | BmMalhasFioMovimentosUpdateManyWithWhereWithoutBmOpsPorMalhaFioInput[]
    deleteMany?: BmMalhasFioMovimentosScalarWhereInput | BmMalhasFioMovimentosScalarWhereInput[]
  }

  export type BmCreateNestedOneWithoutBmTcInput = {
    create?: XOR<BmCreateWithoutBmTcInput, BmUncheckedCreateWithoutBmTcInput>
    connectOrCreate?: BmCreateOrConnectWithoutBmTcInput
    connect?: BmWhereUniqueInput
  }

  export type BmUpdateOneRequiredWithoutBmTcNestedInput = {
    create?: XOR<BmCreateWithoutBmTcInput, BmUncheckedCreateWithoutBmTcInput>
    connectOrCreate?: BmCreateOrConnectWithoutBmTcInput
    upsert?: BmUpsertWithoutBmTcInput
    connect?: BmWhereUniqueInput
    update?: XOR<XOR<BmUpdateToOneWithWhereWithoutBmTcInput, BmUpdateWithoutBmTcInput>, BmUncheckedUpdateWithoutBmTcInput>
  }

  export type PlaneamentoCreateNestedOneWithoutDataCamiaoInput = {
    create?: XOR<PlaneamentoCreateWithoutDataCamiaoInput, PlaneamentoUncheckedCreateWithoutDataCamiaoInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutDataCamiaoInput
    connect?: PlaneamentoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDataCamiaoInput = {
    create?: XOR<UserCreateWithoutDataCamiaoInput, UserUncheckedCreateWithoutDataCamiaoInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataCamiaoInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlaneamentoUpdateOneRequiredWithoutDataCamiaoNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutDataCamiaoInput, PlaneamentoUncheckedCreateWithoutDataCamiaoInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutDataCamiaoInput
    upsert?: PlaneamentoUpsertWithoutDataCamiaoInput
    connect?: PlaneamentoWhereUniqueInput
    update?: XOR<XOR<PlaneamentoUpdateToOneWithWhereWithoutDataCamiaoInput, PlaneamentoUpdateWithoutDataCamiaoInput>, PlaneamentoUncheckedUpdateWithoutDataCamiaoInput>
  }

  export type UserUpdateOneRequiredWithoutDataCamiaoNestedInput = {
    create?: XOR<UserCreateWithoutDataCamiaoInput, UserUncheckedCreateWithoutDataCamiaoInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataCamiaoInput
    upsert?: UserUpsertWithoutDataCamiaoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataCamiaoInput, UserUpdateWithoutDataCamiaoInput>, UserUncheckedUpdateWithoutDataCamiaoInput>
  }

  export type PlaneamentoCreateNestedOneWithoutDataEnvioInput = {
    create?: XOR<PlaneamentoCreateWithoutDataEnvioInput, PlaneamentoUncheckedCreateWithoutDataEnvioInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutDataEnvioInput
    connect?: PlaneamentoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDataEnvioInput = {
    create?: XOR<UserCreateWithoutDataEnvioInput, UserUncheckedCreateWithoutDataEnvioInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataEnvioInput
    connect?: UserWhereUniqueInput
  }

  export type PlaneamentoUpdateOneRequiredWithoutDataEnvioNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutDataEnvioInput, PlaneamentoUncheckedCreateWithoutDataEnvioInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutDataEnvioInput
    upsert?: PlaneamentoUpsertWithoutDataEnvioInput
    connect?: PlaneamentoWhereUniqueInput
    update?: XOR<XOR<PlaneamentoUpdateToOneWithWhereWithoutDataEnvioInput, PlaneamentoUpdateWithoutDataEnvioInput>, PlaneamentoUncheckedUpdateWithoutDataEnvioInput>
  }

  export type UserUpdateOneRequiredWithoutDataEnvioNestedInput = {
    create?: XOR<UserCreateWithoutDataEnvioInput, UserUncheckedCreateWithoutDataEnvioInput>
    connectOrCreate?: UserCreateOrConnectWithoutDataEnvioInput
    upsert?: UserUpsertWithoutDataEnvioInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDataEnvioInput, UserUpdateWithoutDataEnvioInput>, UserUncheckedUpdateWithoutDataEnvioInput>
  }

  export type PlaneamentoCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<PlaneamentoCreateWithoutFornecedorInput, PlaneamentoUncheckedCreateWithoutFornecedorInput> | PlaneamentoCreateWithoutFornecedorInput[] | PlaneamentoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutFornecedorInput | PlaneamentoCreateOrConnectWithoutFornecedorInput[]
    createMany?: PlaneamentoCreateManyFornecedorInputEnvelope
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
  }

  export type PlaneamentoUncheckedCreateNestedManyWithoutFornecedorInput = {
    create?: XOR<PlaneamentoCreateWithoutFornecedorInput, PlaneamentoUncheckedCreateWithoutFornecedorInput> | PlaneamentoCreateWithoutFornecedorInput[] | PlaneamentoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutFornecedorInput | PlaneamentoCreateOrConnectWithoutFornecedorInput[]
    createMany?: PlaneamentoCreateManyFornecedorInputEnvelope
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
  }

  export type PlaneamentoUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutFornecedorInput, PlaneamentoUncheckedCreateWithoutFornecedorInput> | PlaneamentoCreateWithoutFornecedorInput[] | PlaneamentoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutFornecedorInput | PlaneamentoCreateOrConnectWithoutFornecedorInput[]
    upsert?: PlaneamentoUpsertWithWhereUniqueWithoutFornecedorInput | PlaneamentoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: PlaneamentoCreateManyFornecedorInputEnvelope
    set?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    disconnect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    delete?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    update?: PlaneamentoUpdateWithWhereUniqueWithoutFornecedorInput | PlaneamentoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: PlaneamentoUpdateManyWithWhereWithoutFornecedorInput | PlaneamentoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: PlaneamentoScalarWhereInput | PlaneamentoScalarWhereInput[]
  }

  export type PlaneamentoUncheckedUpdateManyWithoutFornecedorNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutFornecedorInput, PlaneamentoUncheckedCreateWithoutFornecedorInput> | PlaneamentoCreateWithoutFornecedorInput[] | PlaneamentoUncheckedCreateWithoutFornecedorInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutFornecedorInput | PlaneamentoCreateOrConnectWithoutFornecedorInput[]
    upsert?: PlaneamentoUpsertWithWhereUniqueWithoutFornecedorInput | PlaneamentoUpsertWithWhereUniqueWithoutFornecedorInput[]
    createMany?: PlaneamentoCreateManyFornecedorInputEnvelope
    set?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    disconnect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    delete?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    update?: PlaneamentoUpdateWithWhereUniqueWithoutFornecedorInput | PlaneamentoUpdateWithWhereUniqueWithoutFornecedorInput[]
    updateMany?: PlaneamentoUpdateManyWithWhereWithoutFornecedorInput | PlaneamentoUpdateManyWithWhereWithoutFornecedorInput[]
    deleteMany?: PlaneamentoScalarWhereInput | PlaneamentoScalarWhereInput[]
  }

  export type PlaneamentoCreateNestedOneWithoutLivreInput = {
    create?: XOR<PlaneamentoCreateWithoutLivreInput, PlaneamentoUncheckedCreateWithoutLivreInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutLivreInput
    connect?: PlaneamentoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLivreInput = {
    create?: XOR<UserCreateWithoutLivreInput, UserUncheckedCreateWithoutLivreInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivreInput
    connect?: UserWhereUniqueInput
  }

  export type OrcamentoLivreCreateNestedOneWithoutLivreInput = {
    create?: XOR<OrcamentoLivreCreateWithoutLivreInput, OrcamentoLivreUncheckedCreateWithoutLivreInput>
    connectOrCreate?: OrcamentoLivreCreateOrConnectWithoutLivreInput
    connect?: OrcamentoLivreWhereUniqueInput
  }

  export type ServicosEscolhidosLivreCreateNestedManyWithoutLivreInput = {
    create?: XOR<ServicosEscolhidosLivreCreateWithoutLivreInput, ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput> | ServicosEscolhidosLivreCreateWithoutLivreInput[] | ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput | ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput[]
    createMany?: ServicosEscolhidosLivreCreateManyLivreInputEnvelope
    connect?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
  }

  export type OrcamentoLivreUncheckedCreateNestedOneWithoutLivreInput = {
    create?: XOR<OrcamentoLivreCreateWithoutLivreInput, OrcamentoLivreUncheckedCreateWithoutLivreInput>
    connectOrCreate?: OrcamentoLivreCreateOrConnectWithoutLivreInput
    connect?: OrcamentoLivreWhereUniqueInput
  }

  export type ServicosEscolhidosLivreUncheckedCreateNestedManyWithoutLivreInput = {
    create?: XOR<ServicosEscolhidosLivreCreateWithoutLivreInput, ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput> | ServicosEscolhidosLivreCreateWithoutLivreInput[] | ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput | ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput[]
    createMany?: ServicosEscolhidosLivreCreateManyLivreInputEnvelope
    connect?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PlaneamentoUpdateOneRequiredWithoutLivreNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutLivreInput, PlaneamentoUncheckedCreateWithoutLivreInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutLivreInput
    upsert?: PlaneamentoUpsertWithoutLivreInput
    connect?: PlaneamentoWhereUniqueInput
    update?: XOR<XOR<PlaneamentoUpdateToOneWithWhereWithoutLivreInput, PlaneamentoUpdateWithoutLivreInput>, PlaneamentoUncheckedUpdateWithoutLivreInput>
  }

  export type UserUpdateOneRequiredWithoutLivreNestedInput = {
    create?: XOR<UserCreateWithoutLivreInput, UserUncheckedCreateWithoutLivreInput>
    connectOrCreate?: UserCreateOrConnectWithoutLivreInput
    upsert?: UserUpsertWithoutLivreInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLivreInput, UserUpdateWithoutLivreInput>, UserUncheckedUpdateWithoutLivreInput>
  }

  export type OrcamentoLivreUpdateOneWithoutLivreNestedInput = {
    create?: XOR<OrcamentoLivreCreateWithoutLivreInput, OrcamentoLivreUncheckedCreateWithoutLivreInput>
    connectOrCreate?: OrcamentoLivreCreateOrConnectWithoutLivreInput
    upsert?: OrcamentoLivreUpsertWithoutLivreInput
    disconnect?: OrcamentoLivreWhereInput | boolean
    delete?: OrcamentoLivreWhereInput | boolean
    connect?: OrcamentoLivreWhereUniqueInput
    update?: XOR<XOR<OrcamentoLivreUpdateToOneWithWhereWithoutLivreInput, OrcamentoLivreUpdateWithoutLivreInput>, OrcamentoLivreUncheckedUpdateWithoutLivreInput>
  }

  export type ServicosEscolhidosLivreUpdateManyWithoutLivreNestedInput = {
    create?: XOR<ServicosEscolhidosLivreCreateWithoutLivreInput, ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput> | ServicosEscolhidosLivreCreateWithoutLivreInput[] | ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput | ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput[]
    upsert?: ServicosEscolhidosLivreUpsertWithWhereUniqueWithoutLivreInput | ServicosEscolhidosLivreUpsertWithWhereUniqueWithoutLivreInput[]
    createMany?: ServicosEscolhidosLivreCreateManyLivreInputEnvelope
    set?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    disconnect?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    delete?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    connect?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    update?: ServicosEscolhidosLivreUpdateWithWhereUniqueWithoutLivreInput | ServicosEscolhidosLivreUpdateWithWhereUniqueWithoutLivreInput[]
    updateMany?: ServicosEscolhidosLivreUpdateManyWithWhereWithoutLivreInput | ServicosEscolhidosLivreUpdateManyWithWhereWithoutLivreInput[]
    deleteMany?: ServicosEscolhidosLivreScalarWhereInput | ServicosEscolhidosLivreScalarWhereInput[]
  }

  export type OrcamentoLivreUncheckedUpdateOneWithoutLivreNestedInput = {
    create?: XOR<OrcamentoLivreCreateWithoutLivreInput, OrcamentoLivreUncheckedCreateWithoutLivreInput>
    connectOrCreate?: OrcamentoLivreCreateOrConnectWithoutLivreInput
    upsert?: OrcamentoLivreUpsertWithoutLivreInput
    disconnect?: OrcamentoLivreWhereInput | boolean
    delete?: OrcamentoLivreWhereInput | boolean
    connect?: OrcamentoLivreWhereUniqueInput
    update?: XOR<XOR<OrcamentoLivreUpdateToOneWithWhereWithoutLivreInput, OrcamentoLivreUpdateWithoutLivreInput>, OrcamentoLivreUncheckedUpdateWithoutLivreInput>
  }

  export type ServicosEscolhidosLivreUncheckedUpdateManyWithoutLivreNestedInput = {
    create?: XOR<ServicosEscolhidosLivreCreateWithoutLivreInput, ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput> | ServicosEscolhidosLivreCreateWithoutLivreInput[] | ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput | ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput[]
    upsert?: ServicosEscolhidosLivreUpsertWithWhereUniqueWithoutLivreInput | ServicosEscolhidosLivreUpsertWithWhereUniqueWithoutLivreInput[]
    createMany?: ServicosEscolhidosLivreCreateManyLivreInputEnvelope
    set?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    disconnect?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    delete?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    connect?: ServicosEscolhidosLivreWhereUniqueInput | ServicosEscolhidosLivreWhereUniqueInput[]
    update?: ServicosEscolhidosLivreUpdateWithWhereUniqueWithoutLivreInput | ServicosEscolhidosLivreUpdateWithWhereUniqueWithoutLivreInput[]
    updateMany?: ServicosEscolhidosLivreUpdateManyWithWhereWithoutLivreInput | ServicosEscolhidosLivreUpdateManyWithWhereWithoutLivreInput[]
    deleteMany?: ServicosEscolhidosLivreScalarWhereInput | ServicosEscolhidosLivreScalarWhereInput[]
  }

  export type PlaneamentoCreateNestedOneWithoutOpInput = {
    create?: XOR<PlaneamentoCreateWithoutOpInput, PlaneamentoUncheckedCreateWithoutOpInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutOpInput
    connect?: PlaneamentoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOpInput = {
    create?: XOR<UserCreateWithoutOpInput, UserUncheckedCreateWithoutOpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpInput
    connect?: UserWhereUniqueInput
  }

  export type OrcamentoOpCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    create?: XOR<OrcamentoOpCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OrcamentoOpCreateOrConnectWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    connect?: OrcamentoOpWhereUniqueInput
  }

  export type ServicosEscolhidosOpCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    create?: XOR<ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput> | ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[] | ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    connectOrCreate?: ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    createMany?: ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInputEnvelope
    connect?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
  }

  export type OrcamentoOpUncheckedCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    create?: XOR<OrcamentoOpCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OrcamentoOpCreateOrConnectWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    connect?: OrcamentoOpWhereUniqueInput
  }

  export type ServicosEscolhidosOpUncheckedCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    create?: XOR<ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput> | ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[] | ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    connectOrCreate?: ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    createMany?: ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInputEnvelope
    connect?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
  }

  export type PlaneamentoUpdateOneRequiredWithoutOpNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutOpInput, PlaneamentoUncheckedCreateWithoutOpInput>
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutOpInput
    upsert?: PlaneamentoUpsertWithoutOpInput
    connect?: PlaneamentoWhereUniqueInput
    update?: XOR<XOR<PlaneamentoUpdateToOneWithWhereWithoutOpInput, PlaneamentoUpdateWithoutOpInput>, PlaneamentoUncheckedUpdateWithoutOpInput>
  }

  export type UserUpdateOneRequiredWithoutOpNestedInput = {
    create?: XOR<UserCreateWithoutOpInput, UserUncheckedCreateWithoutOpInput>
    connectOrCreate?: UserCreateOrConnectWithoutOpInput
    upsert?: UserUpsertWithoutOpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOpInput, UserUpdateWithoutOpInput>, UserUncheckedUpdateWithoutOpInput>
  }

  export type OrcamentoOpUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput = {
    create?: XOR<OrcamentoOpCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OrcamentoOpCreateOrConnectWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    upsert?: OrcamentoOpUpsertWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    disconnect?: OrcamentoOpWhereInput | boolean
    delete?: OrcamentoOpWhereInput | boolean
    connect?: OrcamentoOpWhereUniqueInput
    update?: XOR<XOR<OrcamentoOpUpdateToOneWithWhereWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>, OrcamentoOpUncheckedUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput = {
    create?: XOR<ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput> | ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[] | ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    connectOrCreate?: ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    upsert?: ServicosEscolhidosOpUpsertWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpUpsertWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    createMany?: ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInputEnvelope
    set?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    disconnect?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    delete?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    connect?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    update?: ServicosEscolhidosOpUpdateWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpUpdateWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    updateMany?: ServicosEscolhidosOpUpdateManyWithWhereWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpUpdateManyWithWhereWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    deleteMany?: ServicosEscolhidosOpScalarWhereInput | ServicosEscolhidosOpScalarWhereInput[]
  }

  export type OrcamentoOpUncheckedUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput = {
    create?: XOR<OrcamentoOpCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OrcamentoOpCreateOrConnectWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    upsert?: OrcamentoOpUpsertWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    disconnect?: OrcamentoOpWhereInput | boolean
    delete?: OrcamentoOpWhereInput | boolean
    connect?: OrcamentoOpWhereUniqueInput
    update?: XOR<XOR<OrcamentoOpUpdateToOneWithWhereWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>, OrcamentoOpUncheckedUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpUncheckedUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput = {
    create?: XOR<ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput> | ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[] | ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    connectOrCreate?: ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    upsert?: ServicosEscolhidosOpUpsertWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpUpsertWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    createMany?: ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInputEnvelope
    set?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    disconnect?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    delete?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    connect?: ServicosEscolhidosOpWhereUniqueInput | ServicosEscolhidosOpWhereUniqueInput[]
    update?: ServicosEscolhidosOpUpdateWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpUpdateWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    updateMany?: ServicosEscolhidosOpUpdateManyWithWhereWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpUpdateManyWithWhereWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
    deleteMany?: ServicosEscolhidosOpScalarWhereInput | ServicosEscolhidosOpScalarWhereInput[]
  }

  export type LivreCreateNestedOneWithoutOrcamentoLivreInput = {
    create?: XOR<LivreCreateWithoutOrcamentoLivreInput, LivreUncheckedCreateWithoutOrcamentoLivreInput>
    connectOrCreate?: LivreCreateOrConnectWithoutOrcamentoLivreInput
    connect?: LivreWhereUniqueInput
  }

  export type OrcamentoLivreLinhasCreateNestedManyWithoutOrcamentoLivreInput = {
    create?: XOR<OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput> | OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput[] | OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput[]
    connectOrCreate?: OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput | OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput[]
    createMany?: OrcamentoLivreLinhasCreateManyOrcamentoLivreInputEnvelope
    connect?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
  }

  export type OrcamentoLivreLinhasUncheckedCreateNestedManyWithoutOrcamentoLivreInput = {
    create?: XOR<OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput> | OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput[] | OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput[]
    connectOrCreate?: OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput | OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput[]
    createMany?: OrcamentoLivreLinhasCreateManyOrcamentoLivreInputEnvelope
    connect?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
  }

  export type LivreUpdateOneRequiredWithoutOrcamentoLivreNestedInput = {
    create?: XOR<LivreCreateWithoutOrcamentoLivreInput, LivreUncheckedCreateWithoutOrcamentoLivreInput>
    connectOrCreate?: LivreCreateOrConnectWithoutOrcamentoLivreInput
    upsert?: LivreUpsertWithoutOrcamentoLivreInput
    connect?: LivreWhereUniqueInput
    update?: XOR<XOR<LivreUpdateToOneWithWhereWithoutOrcamentoLivreInput, LivreUpdateWithoutOrcamentoLivreInput>, LivreUncheckedUpdateWithoutOrcamentoLivreInput>
  }

  export type OrcamentoLivreLinhasUpdateManyWithoutOrcamentoLivreNestedInput = {
    create?: XOR<OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput> | OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput[] | OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput[]
    connectOrCreate?: OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput | OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput[]
    upsert?: OrcamentoLivreLinhasUpsertWithWhereUniqueWithoutOrcamentoLivreInput | OrcamentoLivreLinhasUpsertWithWhereUniqueWithoutOrcamentoLivreInput[]
    createMany?: OrcamentoLivreLinhasCreateManyOrcamentoLivreInputEnvelope
    set?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    disconnect?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    delete?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    connect?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    update?: OrcamentoLivreLinhasUpdateWithWhereUniqueWithoutOrcamentoLivreInput | OrcamentoLivreLinhasUpdateWithWhereUniqueWithoutOrcamentoLivreInput[]
    updateMany?: OrcamentoLivreLinhasUpdateManyWithWhereWithoutOrcamentoLivreInput | OrcamentoLivreLinhasUpdateManyWithWhereWithoutOrcamentoLivreInput[]
    deleteMany?: OrcamentoLivreLinhasScalarWhereInput | OrcamentoLivreLinhasScalarWhereInput[]
  }

  export type OrcamentoLivreLinhasUncheckedUpdateManyWithoutOrcamentoLivreNestedInput = {
    create?: XOR<OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput> | OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput[] | OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput[]
    connectOrCreate?: OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput | OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput[]
    upsert?: OrcamentoLivreLinhasUpsertWithWhereUniqueWithoutOrcamentoLivreInput | OrcamentoLivreLinhasUpsertWithWhereUniqueWithoutOrcamentoLivreInput[]
    createMany?: OrcamentoLivreLinhasCreateManyOrcamentoLivreInputEnvelope
    set?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    disconnect?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    delete?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    connect?: OrcamentoLivreLinhasWhereUniqueInput | OrcamentoLivreLinhasWhereUniqueInput[]
    update?: OrcamentoLivreLinhasUpdateWithWhereUniqueWithoutOrcamentoLivreInput | OrcamentoLivreLinhasUpdateWithWhereUniqueWithoutOrcamentoLivreInput[]
    updateMany?: OrcamentoLivreLinhasUpdateManyWithWhereWithoutOrcamentoLivreInput | OrcamentoLivreLinhasUpdateManyWithWhereWithoutOrcamentoLivreInput[]
    deleteMany?: OrcamentoLivreLinhasScalarWhereInput | OrcamentoLivreLinhasScalarWhereInput[]
  }

  export type OrcamentoLivreCreateNestedOneWithoutOrcamentoLivreLinhasInput = {
    create?: XOR<OrcamentoLivreCreateWithoutOrcamentoLivreLinhasInput, OrcamentoLivreUncheckedCreateWithoutOrcamentoLivreLinhasInput>
    connectOrCreate?: OrcamentoLivreCreateOrConnectWithoutOrcamentoLivreLinhasInput
    connect?: OrcamentoLivreWhereUniqueInput
  }

  export type ServicosEscolhidosLivreOrigemCreateNestedManyWithoutOrcamentoLivreLinhasInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput> | ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInputEnvelope
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
  }

  export type ServicosEscolhidosLivreOrigemUncheckedCreateNestedManyWithoutOrcamentoLivreLinhasInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput> | ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInputEnvelope
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
  }

  export type OrcamentoLivreUpdateOneRequiredWithoutOrcamentoLivreLinhasNestedInput = {
    create?: XOR<OrcamentoLivreCreateWithoutOrcamentoLivreLinhasInput, OrcamentoLivreUncheckedCreateWithoutOrcamentoLivreLinhasInput>
    connectOrCreate?: OrcamentoLivreCreateOrConnectWithoutOrcamentoLivreLinhasInput
    upsert?: OrcamentoLivreUpsertWithoutOrcamentoLivreLinhasInput
    connect?: OrcamentoLivreWhereUniqueInput
    update?: XOR<XOR<OrcamentoLivreUpdateToOneWithWhereWithoutOrcamentoLivreLinhasInput, OrcamentoLivreUpdateWithoutOrcamentoLivreLinhasInput>, OrcamentoLivreUncheckedUpdateWithoutOrcamentoLivreLinhasInput>
  }

  export type ServicosEscolhidosLivreOrigemUpdateManyWithoutOrcamentoLivreLinhasNestedInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput> | ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput[]
    upsert?: ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutOrcamentoLivreLinhasInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInputEnvelope
    set?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutOrcamentoLivreLinhasInput[]
    updateMany?: ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutOrcamentoLivreLinhasInput[]
    deleteMany?: ServicosEscolhidosLivreOrigemScalarWhereInput | ServicosEscolhidosLivreOrigemScalarWhereInput[]
  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutOrcamentoLivreLinhasNestedInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput> | ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput[]
    upsert?: ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutOrcamentoLivreLinhasInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInputEnvelope
    set?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutOrcamentoLivreLinhasInput[]
    updateMany?: ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutOrcamentoLivreLinhasInput[]
    deleteMany?: ServicosEscolhidosLivreOrigemScalarWhereInput | ServicosEscolhidosLivreOrigemScalarWhereInput[]
  }

  export type OpCreateNestedOneWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    create?: XOR<OpCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OpCreateOrConnectWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput
    connect?: OpWhereUniqueInput
  }

  export type OrcamentoOpLinhasCreateNestedManyWithoutOrcamentoOpInput = {
    create?: XOR<OrcamentoOpLinhasCreateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput> | OrcamentoOpLinhasCreateWithoutOrcamentoOpInput[] | OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput[]
    connectOrCreate?: OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput | OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput[]
    createMany?: OrcamentoOpLinhasCreateManyOrcamentoOpInputEnvelope
    connect?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
  }

  export type OrcamentoOpLinhasUncheckedCreateNestedManyWithoutOrcamentoOpInput = {
    create?: XOR<OrcamentoOpLinhasCreateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput> | OrcamentoOpLinhasCreateWithoutOrcamentoOpInput[] | OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput[]
    connectOrCreate?: OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput | OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput[]
    createMany?: OrcamentoOpLinhasCreateManyOrcamentoOpInputEnvelope
    connect?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
  }

  export type OpUpdateOneRequiredWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput = {
    create?: XOR<OpCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OpCreateOrConnectWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput
    upsert?: OpUpsertWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput
    connect?: OpWhereUniqueInput
    update?: XOR<XOR<OpUpdateToOneWithWhereWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput, OpUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>, OpUncheckedUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>
  }

  export type OrcamentoOpLinhasUpdateManyWithoutOrcamentoOpNestedInput = {
    create?: XOR<OrcamentoOpLinhasCreateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput> | OrcamentoOpLinhasCreateWithoutOrcamentoOpInput[] | OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput[]
    connectOrCreate?: OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput | OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput[]
    upsert?: OrcamentoOpLinhasUpsertWithWhereUniqueWithoutOrcamentoOpInput | OrcamentoOpLinhasUpsertWithWhereUniqueWithoutOrcamentoOpInput[]
    createMany?: OrcamentoOpLinhasCreateManyOrcamentoOpInputEnvelope
    set?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    disconnect?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    delete?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    connect?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    update?: OrcamentoOpLinhasUpdateWithWhereUniqueWithoutOrcamentoOpInput | OrcamentoOpLinhasUpdateWithWhereUniqueWithoutOrcamentoOpInput[]
    updateMany?: OrcamentoOpLinhasUpdateManyWithWhereWithoutOrcamentoOpInput | OrcamentoOpLinhasUpdateManyWithWhereWithoutOrcamentoOpInput[]
    deleteMany?: OrcamentoOpLinhasScalarWhereInput | OrcamentoOpLinhasScalarWhereInput[]
  }

  export type OrcamentoOpLinhasUncheckedUpdateManyWithoutOrcamentoOpNestedInput = {
    create?: XOR<OrcamentoOpLinhasCreateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput> | OrcamentoOpLinhasCreateWithoutOrcamentoOpInput[] | OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput[]
    connectOrCreate?: OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput | OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput[]
    upsert?: OrcamentoOpLinhasUpsertWithWhereUniqueWithoutOrcamentoOpInput | OrcamentoOpLinhasUpsertWithWhereUniqueWithoutOrcamentoOpInput[]
    createMany?: OrcamentoOpLinhasCreateManyOrcamentoOpInputEnvelope
    set?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    disconnect?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    delete?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    connect?: OrcamentoOpLinhasWhereUniqueInput | OrcamentoOpLinhasWhereUniqueInput[]
    update?: OrcamentoOpLinhasUpdateWithWhereUniqueWithoutOrcamentoOpInput | OrcamentoOpLinhasUpdateWithWhereUniqueWithoutOrcamentoOpInput[]
    updateMany?: OrcamentoOpLinhasUpdateManyWithWhereWithoutOrcamentoOpInput | OrcamentoOpLinhasUpdateManyWithWhereWithoutOrcamentoOpInput[]
    deleteMany?: OrcamentoOpLinhasScalarWhereInput | OrcamentoOpLinhasScalarWhereInput[]
  }

  export type OrcamentoOpCreateNestedOneWithoutOrcamentoOpLinhasInput = {
    create?: XOR<OrcamentoOpCreateWithoutOrcamentoOpLinhasInput, OrcamentoOpUncheckedCreateWithoutOrcamentoOpLinhasInput>
    connectOrCreate?: OrcamentoOpCreateOrConnectWithoutOrcamentoOpLinhasInput
    connect?: OrcamentoOpWhereUniqueInput
  }

  export type ServicosEscolhidosOpOrigemCreateNestedManyWithoutOrcamentoOpLinhasInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput> | ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInputEnvelope
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
  }

  export type ServicosEscolhidosOpOrigemUncheckedCreateNestedManyWithoutOrcamentoOpLinhasInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput> | ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInputEnvelope
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
  }

  export type OrcamentoOpUpdateOneRequiredWithoutOrcamentoOpLinhasNestedInput = {
    create?: XOR<OrcamentoOpCreateWithoutOrcamentoOpLinhasInput, OrcamentoOpUncheckedCreateWithoutOrcamentoOpLinhasInput>
    connectOrCreate?: OrcamentoOpCreateOrConnectWithoutOrcamentoOpLinhasInput
    upsert?: OrcamentoOpUpsertWithoutOrcamentoOpLinhasInput
    connect?: OrcamentoOpWhereUniqueInput
    update?: XOR<XOR<OrcamentoOpUpdateToOneWithWhereWithoutOrcamentoOpLinhasInput, OrcamentoOpUpdateWithoutOrcamentoOpLinhasInput>, OrcamentoOpUncheckedUpdateWithoutOrcamentoOpLinhasInput>
  }

  export type ServicosEscolhidosOpOrigemUpdateManyWithoutOrcamentoOpLinhasNestedInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput> | ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput[]
    upsert?: ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutOrcamentoOpLinhasInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInputEnvelope
    set?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutOrcamentoOpLinhasInput[]
    updateMany?: ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutOrcamentoOpLinhasInput[]
    deleteMany?: ServicosEscolhidosOpOrigemScalarWhereInput | ServicosEscolhidosOpOrigemScalarWhereInput[]
  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutOrcamentoOpLinhasNestedInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput> | ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput[]
    upsert?: ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutOrcamentoOpLinhasInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInputEnvelope
    set?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutOrcamentoOpLinhasInput[]
    updateMany?: ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutOrcamentoOpLinhasInput[]
    deleteMany?: ServicosEscolhidosOpOrigemScalarWhereInput | ServicosEscolhidosOpOrigemScalarWhereInput[]
  }

  export type UserPapeisCreateNestedManyWithoutPapeisInput = {
    create?: XOR<UserPapeisCreateWithoutPapeisInput, UserPapeisUncheckedCreateWithoutPapeisInput> | UserPapeisCreateWithoutPapeisInput[] | UserPapeisUncheckedCreateWithoutPapeisInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutPapeisInput | UserPapeisCreateOrConnectWithoutPapeisInput[]
    createMany?: UserPapeisCreateManyPapeisInputEnvelope
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
  }

  export type UserPapeisUncheckedCreateNestedManyWithoutPapeisInput = {
    create?: XOR<UserPapeisCreateWithoutPapeisInput, UserPapeisUncheckedCreateWithoutPapeisInput> | UserPapeisCreateWithoutPapeisInput[] | UserPapeisUncheckedCreateWithoutPapeisInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutPapeisInput | UserPapeisCreateOrConnectWithoutPapeisInput[]
    createMany?: UserPapeisCreateManyPapeisInputEnvelope
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
  }

  export type UserPapeisUpdateManyWithoutPapeisNestedInput = {
    create?: XOR<UserPapeisCreateWithoutPapeisInput, UserPapeisUncheckedCreateWithoutPapeisInput> | UserPapeisCreateWithoutPapeisInput[] | UserPapeisUncheckedCreateWithoutPapeisInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutPapeisInput | UserPapeisCreateOrConnectWithoutPapeisInput[]
    upsert?: UserPapeisUpsertWithWhereUniqueWithoutPapeisInput | UserPapeisUpsertWithWhereUniqueWithoutPapeisInput[]
    createMany?: UserPapeisCreateManyPapeisInputEnvelope
    set?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    disconnect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    delete?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    update?: UserPapeisUpdateWithWhereUniqueWithoutPapeisInput | UserPapeisUpdateWithWhereUniqueWithoutPapeisInput[]
    updateMany?: UserPapeisUpdateManyWithWhereWithoutPapeisInput | UserPapeisUpdateManyWithWhereWithoutPapeisInput[]
    deleteMany?: UserPapeisScalarWhereInput | UserPapeisScalarWhereInput[]
  }

  export type UserPapeisUncheckedUpdateManyWithoutPapeisNestedInput = {
    create?: XOR<UserPapeisCreateWithoutPapeisInput, UserPapeisUncheckedCreateWithoutPapeisInput> | UserPapeisCreateWithoutPapeisInput[] | UserPapeisUncheckedCreateWithoutPapeisInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutPapeisInput | UserPapeisCreateOrConnectWithoutPapeisInput[]
    upsert?: UserPapeisUpsertWithWhereUniqueWithoutPapeisInput | UserPapeisUpsertWithWhereUniqueWithoutPapeisInput[]
    createMany?: UserPapeisCreateManyPapeisInputEnvelope
    set?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    disconnect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    delete?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    update?: UserPapeisUpdateWithWhereUniqueWithoutPapeisInput | UserPapeisUpdateWithWhereUniqueWithoutPapeisInput[]
    updateMany?: UserPapeisUpdateManyWithWhereWithoutPapeisInput | UserPapeisUpdateManyWithWhereWithoutPapeisInput[]
    deleteMany?: UserPapeisScalarWhereInput | UserPapeisScalarWhereInput[]
  }

  export type DataCamiaoCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<DataCamiaoCreateWithoutPlaneamentoInput, DataCamiaoUncheckedCreateWithoutPlaneamentoInput> | DataCamiaoCreateWithoutPlaneamentoInput[] | DataCamiaoUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutPlaneamentoInput | DataCamiaoCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: DataCamiaoCreateManyPlaneamentoInputEnvelope
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
  }

  export type DataEnvioCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<DataEnvioCreateWithoutPlaneamentoInput, DataEnvioUncheckedCreateWithoutPlaneamentoInput> | DataEnvioCreateWithoutPlaneamentoInput[] | DataEnvioUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutPlaneamentoInput | DataEnvioCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: DataEnvioCreateManyPlaneamentoInputEnvelope
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
  }

  export type LivreCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<LivreCreateWithoutPlaneamentoInput, LivreUncheckedCreateWithoutPlaneamentoInput> | LivreCreateWithoutPlaneamentoInput[] | LivreUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutPlaneamentoInput | LivreCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: LivreCreateManyPlaneamentoInputEnvelope
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
  }

  export type OpCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<OpCreateWithoutPlaneamentoInput, OpUncheckedCreateWithoutPlaneamentoInput> | OpCreateWithoutPlaneamentoInput[] | OpUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: OpCreateOrConnectWithoutPlaneamentoInput | OpCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: OpCreateManyPlaneamentoInputEnvelope
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
  }

  export type FornecedorCreateNestedOneWithoutPlaneamentoInput = {
    create?: XOR<FornecedorCreateWithoutPlaneamentoInput, FornecedorUncheckedCreateWithoutPlaneamentoInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutPlaneamentoInput
    connect?: FornecedorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPlaneamentoInput = {
    create?: XOR<UserCreateWithoutPlaneamentoInput, UserUncheckedCreateWithoutPlaneamentoInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaneamentoInput
    connect?: UserWhereUniqueInput
  }

  export type DataCamiaoUncheckedCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<DataCamiaoCreateWithoutPlaneamentoInput, DataCamiaoUncheckedCreateWithoutPlaneamentoInput> | DataCamiaoCreateWithoutPlaneamentoInput[] | DataCamiaoUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutPlaneamentoInput | DataCamiaoCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: DataCamiaoCreateManyPlaneamentoInputEnvelope
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
  }

  export type DataEnvioUncheckedCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<DataEnvioCreateWithoutPlaneamentoInput, DataEnvioUncheckedCreateWithoutPlaneamentoInput> | DataEnvioCreateWithoutPlaneamentoInput[] | DataEnvioUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutPlaneamentoInput | DataEnvioCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: DataEnvioCreateManyPlaneamentoInputEnvelope
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
  }

  export type LivreUncheckedCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<LivreCreateWithoutPlaneamentoInput, LivreUncheckedCreateWithoutPlaneamentoInput> | LivreCreateWithoutPlaneamentoInput[] | LivreUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutPlaneamentoInput | LivreCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: LivreCreateManyPlaneamentoInputEnvelope
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
  }

  export type OpUncheckedCreateNestedManyWithoutPlaneamentoInput = {
    create?: XOR<OpCreateWithoutPlaneamentoInput, OpUncheckedCreateWithoutPlaneamentoInput> | OpCreateWithoutPlaneamentoInput[] | OpUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: OpCreateOrConnectWithoutPlaneamentoInput | OpCreateOrConnectWithoutPlaneamentoInput[]
    createMany?: OpCreateManyPlaneamentoInputEnvelope
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DataCamiaoUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<DataCamiaoCreateWithoutPlaneamentoInput, DataCamiaoUncheckedCreateWithoutPlaneamentoInput> | DataCamiaoCreateWithoutPlaneamentoInput[] | DataCamiaoUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutPlaneamentoInput | DataCamiaoCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: DataCamiaoUpsertWithWhereUniqueWithoutPlaneamentoInput | DataCamiaoUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: DataCamiaoCreateManyPlaneamentoInputEnvelope
    set?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    disconnect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    delete?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    update?: DataCamiaoUpdateWithWhereUniqueWithoutPlaneamentoInput | DataCamiaoUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: DataCamiaoUpdateManyWithWhereWithoutPlaneamentoInput | DataCamiaoUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: DataCamiaoScalarWhereInput | DataCamiaoScalarWhereInput[]
  }

  export type DataEnvioUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<DataEnvioCreateWithoutPlaneamentoInput, DataEnvioUncheckedCreateWithoutPlaneamentoInput> | DataEnvioCreateWithoutPlaneamentoInput[] | DataEnvioUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutPlaneamentoInput | DataEnvioCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: DataEnvioUpsertWithWhereUniqueWithoutPlaneamentoInput | DataEnvioUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: DataEnvioCreateManyPlaneamentoInputEnvelope
    set?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    disconnect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    delete?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    update?: DataEnvioUpdateWithWhereUniqueWithoutPlaneamentoInput | DataEnvioUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: DataEnvioUpdateManyWithWhereWithoutPlaneamentoInput | DataEnvioUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: DataEnvioScalarWhereInput | DataEnvioScalarWhereInput[]
  }

  export type LivreUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<LivreCreateWithoutPlaneamentoInput, LivreUncheckedCreateWithoutPlaneamentoInput> | LivreCreateWithoutPlaneamentoInput[] | LivreUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutPlaneamentoInput | LivreCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: LivreUpsertWithWhereUniqueWithoutPlaneamentoInput | LivreUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: LivreCreateManyPlaneamentoInputEnvelope
    set?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    disconnect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    delete?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    update?: LivreUpdateWithWhereUniqueWithoutPlaneamentoInput | LivreUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: LivreUpdateManyWithWhereWithoutPlaneamentoInput | LivreUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: LivreScalarWhereInput | LivreScalarWhereInput[]
  }

  export type OpUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<OpCreateWithoutPlaneamentoInput, OpUncheckedCreateWithoutPlaneamentoInput> | OpCreateWithoutPlaneamentoInput[] | OpUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: OpCreateOrConnectWithoutPlaneamentoInput | OpCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: OpUpsertWithWhereUniqueWithoutPlaneamentoInput | OpUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: OpCreateManyPlaneamentoInputEnvelope
    set?: OpWhereUniqueInput | OpWhereUniqueInput[]
    disconnect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    delete?: OpWhereUniqueInput | OpWhereUniqueInput[]
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    update?: OpUpdateWithWhereUniqueWithoutPlaneamentoInput | OpUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: OpUpdateManyWithWhereWithoutPlaneamentoInput | OpUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: OpScalarWhereInput | OpScalarWhereInput[]
  }

  export type FornecedorUpdateOneRequiredWithoutPlaneamentoNestedInput = {
    create?: XOR<FornecedorCreateWithoutPlaneamentoInput, FornecedorUncheckedCreateWithoutPlaneamentoInput>
    connectOrCreate?: FornecedorCreateOrConnectWithoutPlaneamentoInput
    upsert?: FornecedorUpsertWithoutPlaneamentoInput
    connect?: FornecedorWhereUniqueInput
    update?: XOR<XOR<FornecedorUpdateToOneWithWhereWithoutPlaneamentoInput, FornecedorUpdateWithoutPlaneamentoInput>, FornecedorUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type UserUpdateOneRequiredWithoutPlaneamentoNestedInput = {
    create?: XOR<UserCreateWithoutPlaneamentoInput, UserUncheckedCreateWithoutPlaneamentoInput>
    connectOrCreate?: UserCreateOrConnectWithoutPlaneamentoInput
    upsert?: UserUpsertWithoutPlaneamentoInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPlaneamentoInput, UserUpdateWithoutPlaneamentoInput>, UserUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type DataCamiaoUncheckedUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<DataCamiaoCreateWithoutPlaneamentoInput, DataCamiaoUncheckedCreateWithoutPlaneamentoInput> | DataCamiaoCreateWithoutPlaneamentoInput[] | DataCamiaoUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutPlaneamentoInput | DataCamiaoCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: DataCamiaoUpsertWithWhereUniqueWithoutPlaneamentoInput | DataCamiaoUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: DataCamiaoCreateManyPlaneamentoInputEnvelope
    set?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    disconnect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    delete?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    update?: DataCamiaoUpdateWithWhereUniqueWithoutPlaneamentoInput | DataCamiaoUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: DataCamiaoUpdateManyWithWhereWithoutPlaneamentoInput | DataCamiaoUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: DataCamiaoScalarWhereInput | DataCamiaoScalarWhereInput[]
  }

  export type DataEnvioUncheckedUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<DataEnvioCreateWithoutPlaneamentoInput, DataEnvioUncheckedCreateWithoutPlaneamentoInput> | DataEnvioCreateWithoutPlaneamentoInput[] | DataEnvioUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutPlaneamentoInput | DataEnvioCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: DataEnvioUpsertWithWhereUniqueWithoutPlaneamentoInput | DataEnvioUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: DataEnvioCreateManyPlaneamentoInputEnvelope
    set?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    disconnect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    delete?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    update?: DataEnvioUpdateWithWhereUniqueWithoutPlaneamentoInput | DataEnvioUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: DataEnvioUpdateManyWithWhereWithoutPlaneamentoInput | DataEnvioUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: DataEnvioScalarWhereInput | DataEnvioScalarWhereInput[]
  }

  export type LivreUncheckedUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<LivreCreateWithoutPlaneamentoInput, LivreUncheckedCreateWithoutPlaneamentoInput> | LivreCreateWithoutPlaneamentoInput[] | LivreUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutPlaneamentoInput | LivreCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: LivreUpsertWithWhereUniqueWithoutPlaneamentoInput | LivreUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: LivreCreateManyPlaneamentoInputEnvelope
    set?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    disconnect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    delete?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    update?: LivreUpdateWithWhereUniqueWithoutPlaneamentoInput | LivreUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: LivreUpdateManyWithWhereWithoutPlaneamentoInput | LivreUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: LivreScalarWhereInput | LivreScalarWhereInput[]
  }

  export type OpUncheckedUpdateManyWithoutPlaneamentoNestedInput = {
    create?: XOR<OpCreateWithoutPlaneamentoInput, OpUncheckedCreateWithoutPlaneamentoInput> | OpCreateWithoutPlaneamentoInput[] | OpUncheckedCreateWithoutPlaneamentoInput[]
    connectOrCreate?: OpCreateOrConnectWithoutPlaneamentoInput | OpCreateOrConnectWithoutPlaneamentoInput[]
    upsert?: OpUpsertWithWhereUniqueWithoutPlaneamentoInput | OpUpsertWithWhereUniqueWithoutPlaneamentoInput[]
    createMany?: OpCreateManyPlaneamentoInputEnvelope
    set?: OpWhereUniqueInput | OpWhereUniqueInput[]
    disconnect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    delete?: OpWhereUniqueInput | OpWhereUniqueInput[]
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    update?: OpUpdateWithWhereUniqueWithoutPlaneamentoInput | OpUpdateWithWhereUniqueWithoutPlaneamentoInput[]
    updateMany?: OpUpdateManyWithWhereWithoutPlaneamentoInput | OpUpdateManyWithWhereWithoutPlaneamentoInput[]
    deleteMany?: OpScalarWhereInput | OpScalarWhereInput[]
  }

  export type LivreCreateNestedOneWithoutServicosEscolhidosLivreInput = {
    create?: XOR<LivreCreateWithoutServicosEscolhidosLivreInput, LivreUncheckedCreateWithoutServicosEscolhidosLivreInput>
    connectOrCreate?: LivreCreateOrConnectWithoutServicosEscolhidosLivreInput
    connect?: LivreWhereUniqueInput
  }

  export type ServicosEscolhidosLivreOrigemCreateNestedManyWithoutServicosEscolhidosLivreInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput> | ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInputEnvelope
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
  }

  export type ServicosEscolhidosLivreOrigemUncheckedCreateNestedManyWithoutServicosEscolhidosLivreInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput> | ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInputEnvelope
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
  }

  export type LivreUpdateOneRequiredWithoutServicosEscolhidosLivreNestedInput = {
    create?: XOR<LivreCreateWithoutServicosEscolhidosLivreInput, LivreUncheckedCreateWithoutServicosEscolhidosLivreInput>
    connectOrCreate?: LivreCreateOrConnectWithoutServicosEscolhidosLivreInput
    upsert?: LivreUpsertWithoutServicosEscolhidosLivreInput
    connect?: LivreWhereUniqueInput
    update?: XOR<XOR<LivreUpdateToOneWithWhereWithoutServicosEscolhidosLivreInput, LivreUpdateWithoutServicosEscolhidosLivreInput>, LivreUncheckedUpdateWithoutServicosEscolhidosLivreInput>
  }

  export type ServicosEscolhidosLivreOrigemUpdateManyWithoutServicosEscolhidosLivreNestedInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput> | ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput[]
    upsert?: ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosLivreInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInputEnvelope
    set?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosLivreInput[]
    updateMany?: ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutServicosEscolhidosLivreInput[]
    deleteMany?: ServicosEscolhidosLivreOrigemScalarWhereInput | ServicosEscolhidosLivreOrigemScalarWhereInput[]
  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutServicosEscolhidosLivreNestedInput = {
    create?: XOR<ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput> | ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput[] | ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput[]
    connectOrCreate?: ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput[]
    upsert?: ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosLivreInput[]
    createMany?: ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInputEnvelope
    set?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosLivreOrigemWhereUniqueInput | ServicosEscolhidosLivreOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosLivreInput[]
    updateMany?: ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutServicosEscolhidosLivreInput[]
    deleteMany?: ServicosEscolhidosLivreOrigemScalarWhereInput | ServicosEscolhidosLivreOrigemScalarWhereInput[]
  }

  export type OrcamentoLivreLinhasCreateNestedOneWithoutServicosEscolhidosLivreOrigemInput = {
    create?: XOR<OrcamentoLivreLinhasCreateWithoutServicosEscolhidosLivreOrigemInput, OrcamentoLivreLinhasUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
    connectOrCreate?: OrcamentoLivreLinhasCreateOrConnectWithoutServicosEscolhidosLivreOrigemInput
    connect?: OrcamentoLivreLinhasWhereUniqueInput
  }

  export type ServicosEscolhidosLivreCreateNestedOneWithoutServicosEscolhidosLivreOrigemInput = {
    create?: XOR<ServicosEscolhidosLivreCreateWithoutServicosEscolhidosLivreOrigemInput, ServicosEscolhidosLivreUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
    connectOrCreate?: ServicosEscolhidosLivreCreateOrConnectWithoutServicosEscolhidosLivreOrigemInput
    connect?: ServicosEscolhidosLivreWhereUniqueInput
  }

  export type OrcamentoLivreLinhasUpdateOneRequiredWithoutServicosEscolhidosLivreOrigemNestedInput = {
    create?: XOR<OrcamentoLivreLinhasCreateWithoutServicosEscolhidosLivreOrigemInput, OrcamentoLivreLinhasUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
    connectOrCreate?: OrcamentoLivreLinhasCreateOrConnectWithoutServicosEscolhidosLivreOrigemInput
    upsert?: OrcamentoLivreLinhasUpsertWithoutServicosEscolhidosLivreOrigemInput
    connect?: OrcamentoLivreLinhasWhereUniqueInput
    update?: XOR<XOR<OrcamentoLivreLinhasUpdateToOneWithWhereWithoutServicosEscolhidosLivreOrigemInput, OrcamentoLivreLinhasUpdateWithoutServicosEscolhidosLivreOrigemInput>, OrcamentoLivreLinhasUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput>
  }

  export type ServicosEscolhidosLivreUpdateOneRequiredWithoutServicosEscolhidosLivreOrigemNestedInput = {
    create?: XOR<ServicosEscolhidosLivreCreateWithoutServicosEscolhidosLivreOrigemInput, ServicosEscolhidosLivreUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
    connectOrCreate?: ServicosEscolhidosLivreCreateOrConnectWithoutServicosEscolhidosLivreOrigemInput
    upsert?: ServicosEscolhidosLivreUpsertWithoutServicosEscolhidosLivreOrigemInput
    connect?: ServicosEscolhidosLivreWhereUniqueInput
    update?: XOR<XOR<ServicosEscolhidosLivreUpdateToOneWithWhereWithoutServicosEscolhidosLivreOrigemInput, ServicosEscolhidosLivreUpdateWithoutServicosEscolhidosLivreOrigemInput>, ServicosEscolhidosLivreUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput>
  }

  export type OpCreateNestedOneWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    create?: XOR<OpCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OpCreateOrConnectWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
    connect?: OpWhereUniqueInput
  }

  export type ServicosEscolhidosOpOrigemCreateNestedManyWithoutServicosEscolhidosOpInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput> | ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInputEnvelope
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
  }

  export type ServicosEscolhidosOpOrigemUncheckedCreateNestedManyWithoutServicosEscolhidosOpInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput> | ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInputEnvelope
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
  }

  export type OpUpdateOneRequiredWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput = {
    create?: XOR<OpCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
    connectOrCreate?: OpCreateOrConnectWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
    upsert?: OpUpsertWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
    connect?: OpWhereUniqueInput
    update?: XOR<XOR<OpUpdateToOneWithWhereWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, OpUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>, OpUncheckedUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpOrigemUpdateManyWithoutServicosEscolhidosOpNestedInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput> | ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput[]
    upsert?: ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosOpInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInputEnvelope
    set?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosOpInput[]
    updateMany?: ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutServicosEscolhidosOpInput[]
    deleteMany?: ServicosEscolhidosOpOrigemScalarWhereInput | ServicosEscolhidosOpOrigemScalarWhereInput[]
  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutServicosEscolhidosOpNestedInput = {
    create?: XOR<ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput> | ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput[] | ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput[]
    connectOrCreate?: ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput[]
    upsert?: ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosOpInput[]
    createMany?: ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInputEnvelope
    set?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    disconnect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    delete?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    connect?: ServicosEscolhidosOpOrigemWhereUniqueInput | ServicosEscolhidosOpOrigemWhereUniqueInput[]
    update?: ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosOpInput[]
    updateMany?: ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutServicosEscolhidosOpInput[]
    deleteMany?: ServicosEscolhidosOpOrigemScalarWhereInput | ServicosEscolhidosOpOrigemScalarWhereInput[]
  }

  export type OrcamentoOpLinhasCreateNestedOneWithoutServicosEscolhidosOpOrigemInput = {
    create?: XOR<OrcamentoOpLinhasCreateWithoutServicosEscolhidosOpOrigemInput, OrcamentoOpLinhasUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
    connectOrCreate?: OrcamentoOpLinhasCreateOrConnectWithoutServicosEscolhidosOpOrigemInput
    connect?: OrcamentoOpLinhasWhereUniqueInput
  }

  export type ServicosEscolhidosOpCreateNestedOneWithoutServicosEscolhidosOpOrigemInput = {
    create?: XOR<ServicosEscolhidosOpCreateWithoutServicosEscolhidosOpOrigemInput, ServicosEscolhidosOpUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
    connectOrCreate?: ServicosEscolhidosOpCreateOrConnectWithoutServicosEscolhidosOpOrigemInput
    connect?: ServicosEscolhidosOpWhereUniqueInput
  }

  export type OrcamentoOpLinhasUpdateOneRequiredWithoutServicosEscolhidosOpOrigemNestedInput = {
    create?: XOR<OrcamentoOpLinhasCreateWithoutServicosEscolhidosOpOrigemInput, OrcamentoOpLinhasUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
    connectOrCreate?: OrcamentoOpLinhasCreateOrConnectWithoutServicosEscolhidosOpOrigemInput
    upsert?: OrcamentoOpLinhasUpsertWithoutServicosEscolhidosOpOrigemInput
    connect?: OrcamentoOpLinhasWhereUniqueInput
    update?: XOR<XOR<OrcamentoOpLinhasUpdateToOneWithWhereWithoutServicosEscolhidosOpOrigemInput, OrcamentoOpLinhasUpdateWithoutServicosEscolhidosOpOrigemInput>, OrcamentoOpLinhasUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput>
  }

  export type ServicosEscolhidosOpUpdateOneRequiredWithoutServicosEscolhidosOpOrigemNestedInput = {
    create?: XOR<ServicosEscolhidosOpCreateWithoutServicosEscolhidosOpOrigemInput, ServicosEscolhidosOpUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
    connectOrCreate?: ServicosEscolhidosOpCreateOrConnectWithoutServicosEscolhidosOpOrigemInput
    upsert?: ServicosEscolhidosOpUpsertWithoutServicosEscolhidosOpOrigemInput
    connect?: ServicosEscolhidosOpWhereUniqueInput
    update?: XOR<XOR<ServicosEscolhidosOpUpdateToOneWithWhereWithoutServicosEscolhidosOpOrigemInput, ServicosEscolhidosOpUpdateWithoutServicosEscolhidosOpOrigemInput>, ServicosEscolhidosOpUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput>
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type TcOpCreateNestedManyWithoutTcInput = {
    create?: XOR<TcOpCreateWithoutTcInput, TcOpUncheckedCreateWithoutTcInput> | TcOpCreateWithoutTcInput[] | TcOpUncheckedCreateWithoutTcInput[]
    connectOrCreate?: TcOpCreateOrConnectWithoutTcInput | TcOpCreateOrConnectWithoutTcInput[]
    createMany?: TcOpCreateManyTcInputEnvelope
    connect?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
  }

  export type TcOpUncheckedCreateNestedManyWithoutTcInput = {
    create?: XOR<TcOpCreateWithoutTcInput, TcOpUncheckedCreateWithoutTcInput> | TcOpCreateWithoutTcInput[] | TcOpUncheckedCreateWithoutTcInput[]
    connectOrCreate?: TcOpCreateOrConnectWithoutTcInput | TcOpCreateOrConnectWithoutTcInput[]
    createMany?: TcOpCreateManyTcInputEnvelope
    connect?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
  }

  export type TcOpUpdateManyWithoutTcNestedInput = {
    create?: XOR<TcOpCreateWithoutTcInput, TcOpUncheckedCreateWithoutTcInput> | TcOpCreateWithoutTcInput[] | TcOpUncheckedCreateWithoutTcInput[]
    connectOrCreate?: TcOpCreateOrConnectWithoutTcInput | TcOpCreateOrConnectWithoutTcInput[]
    upsert?: TcOpUpsertWithWhereUniqueWithoutTcInput | TcOpUpsertWithWhereUniqueWithoutTcInput[]
    createMany?: TcOpCreateManyTcInputEnvelope
    set?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    disconnect?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    delete?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    connect?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    update?: TcOpUpdateWithWhereUniqueWithoutTcInput | TcOpUpdateWithWhereUniqueWithoutTcInput[]
    updateMany?: TcOpUpdateManyWithWhereWithoutTcInput | TcOpUpdateManyWithWhereWithoutTcInput[]
    deleteMany?: TcOpScalarWhereInput | TcOpScalarWhereInput[]
  }

  export type TcOpUncheckedUpdateManyWithoutTcNestedInput = {
    create?: XOR<TcOpCreateWithoutTcInput, TcOpUncheckedCreateWithoutTcInput> | TcOpCreateWithoutTcInput[] | TcOpUncheckedCreateWithoutTcInput[]
    connectOrCreate?: TcOpCreateOrConnectWithoutTcInput | TcOpCreateOrConnectWithoutTcInput[]
    upsert?: TcOpUpsertWithWhereUniqueWithoutTcInput | TcOpUpsertWithWhereUniqueWithoutTcInput[]
    createMany?: TcOpCreateManyTcInputEnvelope
    set?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    disconnect?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    delete?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    connect?: TcOpWhereUniqueInput | TcOpWhereUniqueInput[]
    update?: TcOpUpdateWithWhereUniqueWithoutTcInput | TcOpUpdateWithWhereUniqueWithoutTcInput[]
    updateMany?: TcOpUpdateManyWithWhereWithoutTcInput | TcOpUpdateManyWithWhereWithoutTcInput[]
    deleteMany?: TcOpScalarWhereInput | TcOpScalarWhereInput[]
  }

  export type TcOpCreateNestedOneWithoutTcCompraConteudoInput = {
    create?: XOR<TcOpCreateWithoutTcCompraConteudoInput, TcOpUncheckedCreateWithoutTcCompraConteudoInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcCompraConteudoInput
    connect?: TcOpWhereUniqueInput
  }

  export type TcOpCompraCreateNestedOneWithoutTcCompraConteudoInput = {
    create?: XOR<TcOpCompraCreateWithoutTcCompraConteudoInput, TcOpCompraUncheckedCreateWithoutTcCompraConteudoInput>
    connectOrCreate?: TcOpCompraCreateOrConnectWithoutTcCompraConteudoInput
    connect?: TcOpCompraWhereUniqueInput
  }

  export type TcCompraConteudoEntradaCreateNestedManyWithoutTcCompraConteudoInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput> | TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcCompraConteudoInputEnvelope
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
  }

  export type TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcCompraConteudoInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput> | TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcCompraConteudoInputEnvelope
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
  }

  export type TcOpUpdateOneRequiredWithoutTcCompraConteudoNestedInput = {
    create?: XOR<TcOpCreateWithoutTcCompraConteudoInput, TcOpUncheckedCreateWithoutTcCompraConteudoInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcCompraConteudoInput
    upsert?: TcOpUpsertWithoutTcCompraConteudoInput
    connect?: TcOpWhereUniqueInput
    update?: XOR<XOR<TcOpUpdateToOneWithWhereWithoutTcCompraConteudoInput, TcOpUpdateWithoutTcCompraConteudoInput>, TcOpUncheckedUpdateWithoutTcCompraConteudoInput>
  }

  export type TcOpCompraUpdateOneRequiredWithoutTcCompraConteudoNestedInput = {
    create?: XOR<TcOpCompraCreateWithoutTcCompraConteudoInput, TcOpCompraUncheckedCreateWithoutTcCompraConteudoInput>
    connectOrCreate?: TcOpCompraCreateOrConnectWithoutTcCompraConteudoInput
    upsert?: TcOpCompraUpsertWithoutTcCompraConteudoInput
    connect?: TcOpCompraWhereUniqueInput
    update?: XOR<XOR<TcOpCompraUpdateToOneWithWhereWithoutTcCompraConteudoInput, TcOpCompraUpdateWithoutTcCompraConteudoInput>, TcOpCompraUncheckedUpdateWithoutTcCompraConteudoInput>
  }

  export type TcCompraConteudoEntradaUpdateManyWithoutTcCompraConteudoNestedInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput> | TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput[]
    upsert?: TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcCompraConteudoInput | TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcCompraConteudoInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcCompraConteudoInputEnvelope
    set?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcCompraConteudoInput | TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcCompraConteudoInput[]
    updateMany?: TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcCompraConteudoInput | TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcCompraConteudoInput[]
    deleteMany?: TcCompraConteudoEntradaScalarWhereInput | TcCompraConteudoEntradaScalarWhereInput[]
  }

  export type TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcCompraConteudoNestedInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput> | TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput[]
    upsert?: TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcCompraConteudoInput | TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcCompraConteudoInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcCompraConteudoInputEnvelope
    set?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcCompraConteudoInput | TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcCompraConteudoInput[]
    updateMany?: TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcCompraConteudoInput | TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcCompraConteudoInput[]
    deleteMany?: TcCompraConteudoEntradaScalarWhereInput | TcCompraConteudoEntradaScalarWhereInput[]
  }

  export type TcCompraConteudoCreateNestedOneWithoutTcCompraConteudoEntradaInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoUncheckedCreateWithoutTcCompraConteudoEntradaInput>
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcCompraConteudoEntradaInput
    connect?: TcCompraConteudoWhereUniqueInput
  }

  export type TcOpCreateNestedOneWithoutTcCompraConteudoEntradaInput = {
    create?: XOR<TcOpCreateWithoutTcCompraConteudoEntradaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcCompraConteudoEntradaInput
    connect?: TcOpWhereUniqueInput
  }

  export type TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcCompraConteudoEntradaInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInputEnvelope
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcCompraConteudoEntradaInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInputEnvelope
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
  }

  export type TcCompraConteudoUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoUncheckedCreateWithoutTcCompraConteudoEntradaInput>
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcCompraConteudoEntradaInput
    upsert?: TcCompraConteudoUpsertWithoutTcCompraConteudoEntradaInput
    connect?: TcCompraConteudoWhereUniqueInput
    update?: XOR<XOR<TcCompraConteudoUpdateToOneWithWhereWithoutTcCompraConteudoEntradaInput, TcCompraConteudoUpdateWithoutTcCompraConteudoEntradaInput>, TcCompraConteudoUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcOpUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput = {
    create?: XOR<TcOpCreateWithoutTcCompraConteudoEntradaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcCompraConteudoEntradaInput
    upsert?: TcOpUpsertWithoutTcCompraConteudoEntradaInput
    connect?: TcOpWhereUniqueInput
    update?: XOR<XOR<TcOpUpdateToOneWithWhereWithoutTcCompraConteudoEntradaInput, TcOpUpdateWithoutTcCompraConteudoEntradaInput>, TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcCompraConteudoEntradaNestedInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput[]
    upsert?: TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcCompraConteudoEntradaInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInputEnvelope
    set?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcCompraConteudoEntradaInput[]
    updateMany?: TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcCompraConteudoEntradaInput[]
    deleteMany?: TcCompraConteudoEntradaFaturadaScalarWhereInput | TcCompraConteudoEntradaFaturadaScalarWhereInput[]
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcCompraConteudoEntradaNestedInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput[]
    upsert?: TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcCompraConteudoEntradaInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInputEnvelope
    set?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcCompraConteudoEntradaInput[]
    updateMany?: TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcCompraConteudoEntradaInput[]
    deleteMany?: TcCompraConteudoEntradaFaturadaScalarWhereInput | TcCompraConteudoEntradaFaturadaScalarWhereInput[]
  }

  export type TcCompraConteudoEntradaCreateNestedOneWithoutTcCompraConteudoEntradaFaturadaInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoEntradaFaturadaInput
    connect?: TcCompraConteudoEntradaWhereUniqueInput
  }

  export type TcOpCreateNestedOneWithoutTcCompraConteudoEntradaFaturadaInput = {
    create?: XOR<TcOpCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcCompraConteudoEntradaFaturadaInput
    connect?: TcOpWhereUniqueInput
  }

  export type TcCompraConteudoEntradaUpdateOneRequiredWithoutTcCompraConteudoEntradaFaturadaNestedInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoEntradaFaturadaInput
    upsert?: TcCompraConteudoEntradaUpsertWithoutTcCompraConteudoEntradaFaturadaInput
    connect?: TcCompraConteudoEntradaWhereUniqueInput
    update?: XOR<XOR<TcCompraConteudoEntradaUpdateToOneWithWhereWithoutTcCompraConteudoEntradaFaturadaInput, TcCompraConteudoEntradaUpdateWithoutTcCompraConteudoEntradaFaturadaInput>, TcCompraConteudoEntradaUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput>
  }

  export type TcOpUpdateOneRequiredWithoutTcCompraConteudoEntradaFaturadaNestedInput = {
    create?: XOR<TcOpCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcCompraConteudoEntradaFaturadaInput
    upsert?: TcOpUpsertWithoutTcCompraConteudoEntradaFaturadaInput
    connect?: TcOpWhereUniqueInput
    update?: XOR<XOR<TcOpUpdateToOneWithWhereWithoutTcCompraConteudoEntradaFaturadaInput, TcOpUpdateWithoutTcCompraConteudoEntradaFaturadaInput>, TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput>
  }

  export type TcCompraConteudoCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpInput, TcCompraConteudoUncheckedCreateWithoutTcOpInput> | TcCompraConteudoCreateWithoutTcOpInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpInput | TcCompraConteudoCreateOrConnectWithoutTcOpInput[]
    createMany?: TcCompraConteudoCreateManyTcOpInputEnvelope
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
  }

  export type TcCompraConteudoEntradaCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcOpInputEnvelope
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
  }

  export type TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcOpInputEnvelope
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
  }

  export type TcCreateNestedOneWithoutTcOpInput = {
    create?: XOR<TcCreateWithoutTcOpInput, TcUncheckedCreateWithoutTcOpInput>
    connectOrCreate?: TcCreateOrConnectWithoutTcOpInput
    connect?: TcWhereUniqueInput
  }

  export type TcOpCompraCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcOpCompraCreateWithoutTcOpInput, TcOpCompraUncheckedCreateWithoutTcOpInput> | TcOpCompraCreateWithoutTcOpInput[] | TcOpCompraUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcOpCompraCreateOrConnectWithoutTcOpInput | TcOpCompraCreateOrConnectWithoutTcOpInput[]
    createMany?: TcOpCompraCreateManyTcOpInputEnvelope
    connect?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
  }

  export type TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpInput, TcCompraConteudoUncheckedCreateWithoutTcOpInput> | TcCompraConteudoCreateWithoutTcOpInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpInput | TcCompraConteudoCreateOrConnectWithoutTcOpInput[]
    createMany?: TcCompraConteudoCreateManyTcOpInputEnvelope
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
  }

  export type TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcOpInputEnvelope
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcOpInputEnvelope
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
  }

  export type TcOpCompraUncheckedCreateNestedManyWithoutTcOpInput = {
    create?: XOR<TcOpCompraCreateWithoutTcOpInput, TcOpCompraUncheckedCreateWithoutTcOpInput> | TcOpCompraCreateWithoutTcOpInput[] | TcOpCompraUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcOpCompraCreateOrConnectWithoutTcOpInput | TcOpCompraCreateOrConnectWithoutTcOpInput[]
    createMany?: TcOpCompraCreateManyTcOpInputEnvelope
    connect?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
  }

  export type TcCompraConteudoUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpInput, TcCompraConteudoUncheckedCreateWithoutTcOpInput> | TcCompraConteudoCreateWithoutTcOpInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpInput | TcCompraConteudoCreateOrConnectWithoutTcOpInput[]
    upsert?: TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpInput | TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcCompraConteudoCreateManyTcOpInputEnvelope
    set?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    disconnect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    delete?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    update?: TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpInput | TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcCompraConteudoUpdateManyWithWhereWithoutTcOpInput | TcCompraConteudoUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcCompraConteudoScalarWhereInput | TcCompraConteudoScalarWhereInput[]
  }

  export type TcCompraConteudoEntradaUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput[]
    upsert?: TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcOpInputEnvelope
    set?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcOpInput | TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcCompraConteudoEntradaScalarWhereInput | TcCompraConteudoEntradaScalarWhereInput[]
  }

  export type TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput[]
    upsert?: TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcOpInputEnvelope
    set?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcOpInput | TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcCompraConteudoEntradaFaturadaScalarWhereInput | TcCompraConteudoEntradaFaturadaScalarWhereInput[]
  }

  export type TcUpdateOneRequiredWithoutTcOpNestedInput = {
    create?: XOR<TcCreateWithoutTcOpInput, TcUncheckedCreateWithoutTcOpInput>
    connectOrCreate?: TcCreateOrConnectWithoutTcOpInput
    upsert?: TcUpsertWithoutTcOpInput
    connect?: TcWhereUniqueInput
    update?: XOR<XOR<TcUpdateToOneWithWhereWithoutTcOpInput, TcUpdateWithoutTcOpInput>, TcUncheckedUpdateWithoutTcOpInput>
  }

  export type TcOpCompraUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcOpCompraCreateWithoutTcOpInput, TcOpCompraUncheckedCreateWithoutTcOpInput> | TcOpCompraCreateWithoutTcOpInput[] | TcOpCompraUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcOpCompraCreateOrConnectWithoutTcOpInput | TcOpCompraCreateOrConnectWithoutTcOpInput[]
    upsert?: TcOpCompraUpsertWithWhereUniqueWithoutTcOpInput | TcOpCompraUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcOpCompraCreateManyTcOpInputEnvelope
    set?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    disconnect?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    delete?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    connect?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    update?: TcOpCompraUpdateWithWhereUniqueWithoutTcOpInput | TcOpCompraUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcOpCompraUpdateManyWithWhereWithoutTcOpInput | TcOpCompraUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcOpCompraScalarWhereInput | TcOpCompraScalarWhereInput[]
  }

  export type TcCompraConteudoUncheckedUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpInput, TcCompraConteudoUncheckedCreateWithoutTcOpInput> | TcCompraConteudoCreateWithoutTcOpInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpInput | TcCompraConteudoCreateOrConnectWithoutTcOpInput[]
    upsert?: TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpInput | TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcCompraConteudoCreateManyTcOpInputEnvelope
    set?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    disconnect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    delete?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    update?: TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpInput | TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcCompraConteudoUpdateManyWithWhereWithoutTcOpInput | TcCompraConteudoUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcCompraConteudoScalarWhereInput | TcCompraConteudoScalarWhereInput[]
  }

  export type TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcCompraConteudoEntradaCreateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput[]
    upsert?: TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaCreateManyTcOpInputEnvelope
    set?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaWhereUniqueInput | TcCompraConteudoEntradaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcOpInput | TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcCompraConteudoEntradaScalarWhereInput | TcCompraConteudoEntradaScalarWhereInput[]
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput> | TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput[] | TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput | TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput[]
    upsert?: TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcCompraConteudoEntradaFaturadaCreateManyTcOpInputEnvelope
    set?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    disconnect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    delete?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    connect?: TcCompraConteudoEntradaFaturadaWhereUniqueInput | TcCompraConteudoEntradaFaturadaWhereUniqueInput[]
    update?: TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcOpInput | TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcOpInput | TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcCompraConteudoEntradaFaturadaScalarWhereInput | TcCompraConteudoEntradaFaturadaScalarWhereInput[]
  }

  export type TcOpCompraUncheckedUpdateManyWithoutTcOpNestedInput = {
    create?: XOR<TcOpCompraCreateWithoutTcOpInput, TcOpCompraUncheckedCreateWithoutTcOpInput> | TcOpCompraCreateWithoutTcOpInput[] | TcOpCompraUncheckedCreateWithoutTcOpInput[]
    connectOrCreate?: TcOpCompraCreateOrConnectWithoutTcOpInput | TcOpCompraCreateOrConnectWithoutTcOpInput[]
    upsert?: TcOpCompraUpsertWithWhereUniqueWithoutTcOpInput | TcOpCompraUpsertWithWhereUniqueWithoutTcOpInput[]
    createMany?: TcOpCompraCreateManyTcOpInputEnvelope
    set?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    disconnect?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    delete?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    connect?: TcOpCompraWhereUniqueInput | TcOpCompraWhereUniqueInput[]
    update?: TcOpCompraUpdateWithWhereUniqueWithoutTcOpInput | TcOpCompraUpdateWithWhereUniqueWithoutTcOpInput[]
    updateMany?: TcOpCompraUpdateManyWithWhereWithoutTcOpInput | TcOpCompraUpdateManyWithWhereWithoutTcOpInput[]
    deleteMany?: TcOpCompraScalarWhereInput | TcOpCompraScalarWhereInput[]
  }

  export type TcCompraConteudoCreateNestedManyWithoutTcOpCompraInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpCompraInput, TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput> | TcCompraConteudoCreateWithoutTcOpCompraInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput | TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput[]
    createMany?: TcCompraConteudoCreateManyTcOpCompraInputEnvelope
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
  }

  export type TcOpCreateNestedOneWithoutTcOpCompraInput = {
    create?: XOR<TcOpCreateWithoutTcOpCompraInput, TcOpUncheckedCreateWithoutTcOpCompraInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcOpCompraInput
    connect?: TcOpWhereUniqueInput
  }

  export type TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpCompraInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpCompraInput, TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput> | TcCompraConteudoCreateWithoutTcOpCompraInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput | TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput[]
    createMany?: TcCompraConteudoCreateManyTcOpCompraInputEnvelope
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
  }

  export type TcCompraConteudoUpdateManyWithoutTcOpCompraNestedInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpCompraInput, TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput> | TcCompraConteudoCreateWithoutTcOpCompraInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput | TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput[]
    upsert?: TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpCompraInput | TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpCompraInput[]
    createMany?: TcCompraConteudoCreateManyTcOpCompraInputEnvelope
    set?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    disconnect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    delete?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    update?: TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpCompraInput | TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpCompraInput[]
    updateMany?: TcCompraConteudoUpdateManyWithWhereWithoutTcOpCompraInput | TcCompraConteudoUpdateManyWithWhereWithoutTcOpCompraInput[]
    deleteMany?: TcCompraConteudoScalarWhereInput | TcCompraConteudoScalarWhereInput[]
  }

  export type TcOpUpdateOneRequiredWithoutTcOpCompraNestedInput = {
    create?: XOR<TcOpCreateWithoutTcOpCompraInput, TcOpUncheckedCreateWithoutTcOpCompraInput>
    connectOrCreate?: TcOpCreateOrConnectWithoutTcOpCompraInput
    upsert?: TcOpUpsertWithoutTcOpCompraInput
    connect?: TcOpWhereUniqueInput
    update?: XOR<XOR<TcOpUpdateToOneWithWhereWithoutTcOpCompraInput, TcOpUpdateWithoutTcOpCompraInput>, TcOpUncheckedUpdateWithoutTcOpCompraInput>
  }

  export type TcCompraConteudoUncheckedUpdateManyWithoutTcOpCompraNestedInput = {
    create?: XOR<TcCompraConteudoCreateWithoutTcOpCompraInput, TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput> | TcCompraConteudoCreateWithoutTcOpCompraInput[] | TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput[]
    connectOrCreate?: TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput | TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput[]
    upsert?: TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpCompraInput | TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpCompraInput[]
    createMany?: TcCompraConteudoCreateManyTcOpCompraInputEnvelope
    set?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    disconnect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    delete?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    connect?: TcCompraConteudoWhereUniqueInput | TcCompraConteudoWhereUniqueInput[]
    update?: TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpCompraInput | TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpCompraInput[]
    updateMany?: TcCompraConteudoUpdateManyWithWhereWithoutTcOpCompraInput | TcCompraConteudoUpdateManyWithWhereWithoutTcOpCompraInput[]
    deleteMany?: TcCompraConteudoScalarWhereInput | TcCompraConteudoScalarWhereInput[]
  }

  export type DataCamiaoCreateNestedManyWithoutUserInput = {
    create?: XOR<DataCamiaoCreateWithoutUserInput, DataCamiaoUncheckedCreateWithoutUserInput> | DataCamiaoCreateWithoutUserInput[] | DataCamiaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutUserInput | DataCamiaoCreateOrConnectWithoutUserInput[]
    createMany?: DataCamiaoCreateManyUserInputEnvelope
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
  }

  export type DataEnvioCreateNestedManyWithoutUserInput = {
    create?: XOR<DataEnvioCreateWithoutUserInput, DataEnvioUncheckedCreateWithoutUserInput> | DataEnvioCreateWithoutUserInput[] | DataEnvioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutUserInput | DataEnvioCreateOrConnectWithoutUserInput[]
    createMany?: DataEnvioCreateManyUserInputEnvelope
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
  }

  export type LivreCreateNestedManyWithoutUserInput = {
    create?: XOR<LivreCreateWithoutUserInput, LivreUncheckedCreateWithoutUserInput> | LivreCreateWithoutUserInput[] | LivreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutUserInput | LivreCreateOrConnectWithoutUserInput[]
    createMany?: LivreCreateManyUserInputEnvelope
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
  }

  export type OpCreateNestedManyWithoutUserInput = {
    create?: XOR<OpCreateWithoutUserInput, OpUncheckedCreateWithoutUserInput> | OpCreateWithoutUserInput[] | OpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpCreateOrConnectWithoutUserInput | OpCreateOrConnectWithoutUserInput[]
    createMany?: OpCreateManyUserInputEnvelope
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
  }

  export type PlaneamentoCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaneamentoCreateWithoutUserInput, PlaneamentoUncheckedCreateWithoutUserInput> | PlaneamentoCreateWithoutUserInput[] | PlaneamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutUserInput | PlaneamentoCreateOrConnectWithoutUserInput[]
    createMany?: PlaneamentoCreateManyUserInputEnvelope
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
  }

  export type UserPapeisCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPapeisCreateWithoutUserInput, UserPapeisUncheckedCreateWithoutUserInput> | UserPapeisCreateWithoutUserInput[] | UserPapeisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutUserInput | UserPapeisCreateOrConnectWithoutUserInput[]
    createMany?: UserPapeisCreateManyUserInputEnvelope
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
  }

  export type DataCamiaoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataCamiaoCreateWithoutUserInput, DataCamiaoUncheckedCreateWithoutUserInput> | DataCamiaoCreateWithoutUserInput[] | DataCamiaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutUserInput | DataCamiaoCreateOrConnectWithoutUserInput[]
    createMany?: DataCamiaoCreateManyUserInputEnvelope
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
  }

  export type DataEnvioUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DataEnvioCreateWithoutUserInput, DataEnvioUncheckedCreateWithoutUserInput> | DataEnvioCreateWithoutUserInput[] | DataEnvioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutUserInput | DataEnvioCreateOrConnectWithoutUserInput[]
    createMany?: DataEnvioCreateManyUserInputEnvelope
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
  }

  export type LivreUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LivreCreateWithoutUserInput, LivreUncheckedCreateWithoutUserInput> | LivreCreateWithoutUserInput[] | LivreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutUserInput | LivreCreateOrConnectWithoutUserInput[]
    createMany?: LivreCreateManyUserInputEnvelope
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
  }

  export type OpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OpCreateWithoutUserInput, OpUncheckedCreateWithoutUserInput> | OpCreateWithoutUserInput[] | OpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpCreateOrConnectWithoutUserInput | OpCreateOrConnectWithoutUserInput[]
    createMany?: OpCreateManyUserInputEnvelope
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
  }

  export type PlaneamentoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PlaneamentoCreateWithoutUserInput, PlaneamentoUncheckedCreateWithoutUserInput> | PlaneamentoCreateWithoutUserInput[] | PlaneamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutUserInput | PlaneamentoCreateOrConnectWithoutUserInput[]
    createMany?: PlaneamentoCreateManyUserInputEnvelope
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
  }

  export type UserPapeisUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserPapeisCreateWithoutUserInput, UserPapeisUncheckedCreateWithoutUserInput> | UserPapeisCreateWithoutUserInput[] | UserPapeisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutUserInput | UserPapeisCreateOrConnectWithoutUserInput[]
    createMany?: UserPapeisCreateManyUserInputEnvelope
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
  }

  export type DataCamiaoUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataCamiaoCreateWithoutUserInput, DataCamiaoUncheckedCreateWithoutUserInput> | DataCamiaoCreateWithoutUserInput[] | DataCamiaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutUserInput | DataCamiaoCreateOrConnectWithoutUserInput[]
    upsert?: DataCamiaoUpsertWithWhereUniqueWithoutUserInput | DataCamiaoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataCamiaoCreateManyUserInputEnvelope
    set?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    disconnect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    delete?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    update?: DataCamiaoUpdateWithWhereUniqueWithoutUserInput | DataCamiaoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataCamiaoUpdateManyWithWhereWithoutUserInput | DataCamiaoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataCamiaoScalarWhereInput | DataCamiaoScalarWhereInput[]
  }

  export type DataEnvioUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataEnvioCreateWithoutUserInput, DataEnvioUncheckedCreateWithoutUserInput> | DataEnvioCreateWithoutUserInput[] | DataEnvioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutUserInput | DataEnvioCreateOrConnectWithoutUserInput[]
    upsert?: DataEnvioUpsertWithWhereUniqueWithoutUserInput | DataEnvioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataEnvioCreateManyUserInputEnvelope
    set?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    disconnect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    delete?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    update?: DataEnvioUpdateWithWhereUniqueWithoutUserInput | DataEnvioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataEnvioUpdateManyWithWhereWithoutUserInput | DataEnvioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataEnvioScalarWhereInput | DataEnvioScalarWhereInput[]
  }

  export type LivreUpdateManyWithoutUserNestedInput = {
    create?: XOR<LivreCreateWithoutUserInput, LivreUncheckedCreateWithoutUserInput> | LivreCreateWithoutUserInput[] | LivreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutUserInput | LivreCreateOrConnectWithoutUserInput[]
    upsert?: LivreUpsertWithWhereUniqueWithoutUserInput | LivreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LivreCreateManyUserInputEnvelope
    set?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    disconnect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    delete?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    update?: LivreUpdateWithWhereUniqueWithoutUserInput | LivreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LivreUpdateManyWithWhereWithoutUserInput | LivreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LivreScalarWhereInput | LivreScalarWhereInput[]
  }

  export type OpUpdateManyWithoutUserNestedInput = {
    create?: XOR<OpCreateWithoutUserInput, OpUncheckedCreateWithoutUserInput> | OpCreateWithoutUserInput[] | OpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpCreateOrConnectWithoutUserInput | OpCreateOrConnectWithoutUserInput[]
    upsert?: OpUpsertWithWhereUniqueWithoutUserInput | OpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OpCreateManyUserInputEnvelope
    set?: OpWhereUniqueInput | OpWhereUniqueInput[]
    disconnect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    delete?: OpWhereUniqueInput | OpWhereUniqueInput[]
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    update?: OpUpdateWithWhereUniqueWithoutUserInput | OpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OpUpdateManyWithWhereWithoutUserInput | OpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OpScalarWhereInput | OpScalarWhereInput[]
  }

  export type PlaneamentoUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutUserInput, PlaneamentoUncheckedCreateWithoutUserInput> | PlaneamentoCreateWithoutUserInput[] | PlaneamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutUserInput | PlaneamentoCreateOrConnectWithoutUserInput[]
    upsert?: PlaneamentoUpsertWithWhereUniqueWithoutUserInput | PlaneamentoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaneamentoCreateManyUserInputEnvelope
    set?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    disconnect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    delete?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    update?: PlaneamentoUpdateWithWhereUniqueWithoutUserInput | PlaneamentoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaneamentoUpdateManyWithWhereWithoutUserInput | PlaneamentoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaneamentoScalarWhereInput | PlaneamentoScalarWhereInput[]
  }

  export type UserPapeisUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPapeisCreateWithoutUserInput, UserPapeisUncheckedCreateWithoutUserInput> | UserPapeisCreateWithoutUserInput[] | UserPapeisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutUserInput | UserPapeisCreateOrConnectWithoutUserInput[]
    upsert?: UserPapeisUpsertWithWhereUniqueWithoutUserInput | UserPapeisUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPapeisCreateManyUserInputEnvelope
    set?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    disconnect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    delete?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    update?: UserPapeisUpdateWithWhereUniqueWithoutUserInput | UserPapeisUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPapeisUpdateManyWithWhereWithoutUserInput | UserPapeisUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPapeisScalarWhereInput | UserPapeisScalarWhereInput[]
  }

  export type DataCamiaoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataCamiaoCreateWithoutUserInput, DataCamiaoUncheckedCreateWithoutUserInput> | DataCamiaoCreateWithoutUserInput[] | DataCamiaoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataCamiaoCreateOrConnectWithoutUserInput | DataCamiaoCreateOrConnectWithoutUserInput[]
    upsert?: DataCamiaoUpsertWithWhereUniqueWithoutUserInput | DataCamiaoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataCamiaoCreateManyUserInputEnvelope
    set?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    disconnect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    delete?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    connect?: DataCamiaoWhereUniqueInput | DataCamiaoWhereUniqueInput[]
    update?: DataCamiaoUpdateWithWhereUniqueWithoutUserInput | DataCamiaoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataCamiaoUpdateManyWithWhereWithoutUserInput | DataCamiaoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataCamiaoScalarWhereInput | DataCamiaoScalarWhereInput[]
  }

  export type DataEnvioUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DataEnvioCreateWithoutUserInput, DataEnvioUncheckedCreateWithoutUserInput> | DataEnvioCreateWithoutUserInput[] | DataEnvioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DataEnvioCreateOrConnectWithoutUserInput | DataEnvioCreateOrConnectWithoutUserInput[]
    upsert?: DataEnvioUpsertWithWhereUniqueWithoutUserInput | DataEnvioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DataEnvioCreateManyUserInputEnvelope
    set?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    disconnect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    delete?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    connect?: DataEnvioWhereUniqueInput | DataEnvioWhereUniqueInput[]
    update?: DataEnvioUpdateWithWhereUniqueWithoutUserInput | DataEnvioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DataEnvioUpdateManyWithWhereWithoutUserInput | DataEnvioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DataEnvioScalarWhereInput | DataEnvioScalarWhereInput[]
  }

  export type LivreUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LivreCreateWithoutUserInput, LivreUncheckedCreateWithoutUserInput> | LivreCreateWithoutUserInput[] | LivreUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LivreCreateOrConnectWithoutUserInput | LivreCreateOrConnectWithoutUserInput[]
    upsert?: LivreUpsertWithWhereUniqueWithoutUserInput | LivreUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LivreCreateManyUserInputEnvelope
    set?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    disconnect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    delete?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    connect?: LivreWhereUniqueInput | LivreWhereUniqueInput[]
    update?: LivreUpdateWithWhereUniqueWithoutUserInput | LivreUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LivreUpdateManyWithWhereWithoutUserInput | LivreUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LivreScalarWhereInput | LivreScalarWhereInput[]
  }

  export type OpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OpCreateWithoutUserInput, OpUncheckedCreateWithoutUserInput> | OpCreateWithoutUserInput[] | OpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OpCreateOrConnectWithoutUserInput | OpCreateOrConnectWithoutUserInput[]
    upsert?: OpUpsertWithWhereUniqueWithoutUserInput | OpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OpCreateManyUserInputEnvelope
    set?: OpWhereUniqueInput | OpWhereUniqueInput[]
    disconnect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    delete?: OpWhereUniqueInput | OpWhereUniqueInput[]
    connect?: OpWhereUniqueInput | OpWhereUniqueInput[]
    update?: OpUpdateWithWhereUniqueWithoutUserInput | OpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OpUpdateManyWithWhereWithoutUserInput | OpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OpScalarWhereInput | OpScalarWhereInput[]
  }

  export type PlaneamentoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PlaneamentoCreateWithoutUserInput, PlaneamentoUncheckedCreateWithoutUserInput> | PlaneamentoCreateWithoutUserInput[] | PlaneamentoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PlaneamentoCreateOrConnectWithoutUserInput | PlaneamentoCreateOrConnectWithoutUserInput[]
    upsert?: PlaneamentoUpsertWithWhereUniqueWithoutUserInput | PlaneamentoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PlaneamentoCreateManyUserInputEnvelope
    set?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    disconnect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    delete?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    connect?: PlaneamentoWhereUniqueInput | PlaneamentoWhereUniqueInput[]
    update?: PlaneamentoUpdateWithWhereUniqueWithoutUserInput | PlaneamentoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PlaneamentoUpdateManyWithWhereWithoutUserInput | PlaneamentoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PlaneamentoScalarWhereInput | PlaneamentoScalarWhereInput[]
  }

  export type UserPapeisUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserPapeisCreateWithoutUserInput, UserPapeisUncheckedCreateWithoutUserInput> | UserPapeisCreateWithoutUserInput[] | UserPapeisUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserPapeisCreateOrConnectWithoutUserInput | UserPapeisCreateOrConnectWithoutUserInput[]
    upsert?: UserPapeisUpsertWithWhereUniqueWithoutUserInput | UserPapeisUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserPapeisCreateManyUserInputEnvelope
    set?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    disconnect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    delete?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    connect?: UserPapeisWhereUniqueInput | UserPapeisWhereUniqueInput[]
    update?: UserPapeisUpdateWithWhereUniqueWithoutUserInput | UserPapeisUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserPapeisUpdateManyWithWhereWithoutUserInput | UserPapeisUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserPapeisScalarWhereInput | UserPapeisScalarWhereInput[]
  }

  export type PapeisCreateNestedOneWithoutUserPapeisInput = {
    create?: XOR<PapeisCreateWithoutUserPapeisInput, PapeisUncheckedCreateWithoutUserPapeisInput>
    connectOrCreate?: PapeisCreateOrConnectWithoutUserPapeisInput
    connect?: PapeisWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutUserPapeisInput = {
    create?: XOR<UserCreateWithoutUserPapeisInput, UserUncheckedCreateWithoutUserPapeisInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPapeisInput
    connect?: UserWhereUniqueInput
  }

  export type PapeisUpdateOneRequiredWithoutUserPapeisNestedInput = {
    create?: XOR<PapeisCreateWithoutUserPapeisInput, PapeisUncheckedCreateWithoutUserPapeisInput>
    connectOrCreate?: PapeisCreateOrConnectWithoutUserPapeisInput
    upsert?: PapeisUpsertWithoutUserPapeisInput
    connect?: PapeisWhereUniqueInput
    update?: XOR<XOR<PapeisUpdateToOneWithWhereWithoutUserPapeisInput, PapeisUpdateWithoutUserPapeisInput>, PapeisUncheckedUpdateWithoutUserPapeisInput>
  }

  export type UserUpdateOneRequiredWithoutUserPapeisNestedInput = {
    create?: XOR<UserCreateWithoutUserPapeisInput, UserUncheckedCreateWithoutUserPapeisInput>
    connectOrCreate?: UserCreateOrConnectWithoutUserPapeisInput
    upsert?: UserUpsertWithoutUserPapeisInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUserPapeisInput, UserUpdateWithoutUserPapeisInput>, UserUncheckedUpdateWithoutUserPapeisInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | null
    notIn?: Uint8Array[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BmMalhasCreateWithoutBmInput = {
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoCreateNestedManyWithoutBmMalhasInput
    BmMateriais: BmMateriaisCreateNestedOneWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasUncheckedCreateWithoutBmInput = {
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasCreateOrConnectWithoutBmInput = {
    where: BmMalhasWhereUniqueInput
    create: XOR<BmMalhasCreateWithoutBmInput, BmMalhasUncheckedCreateWithoutBmInput>
  }

  export type BmMalhasCreateManyBmInputEnvelope = {
    data: BmMalhasCreateManyBmInput | BmMalhasCreateManyBmInput[]
  }

  export type BmOpCreateWithoutBmInput = {
    op: number
    CreatedAt?: Date | string
    foto?: string
    BmOpFaturado?: BmOpFaturadoCreateNestedManyWithoutBmOpInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmOpInput
  }

  export type BmOpUncheckedCreateWithoutBmInput = {
    op: number
    CreatedAt?: Date | string
    foto?: string
    BmOpFaturado?: BmOpFaturadoUncheckedCreateNestedManyWithoutBmOpInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmOpInput
  }

  export type BmOpCreateOrConnectWithoutBmInput = {
    where: BmOpWhereUniqueInput
    create: XOR<BmOpCreateWithoutBmInput, BmOpUncheckedCreateWithoutBmInput>
  }

  export type BmOpCreateManyBmInputEnvelope = {
    data: BmOpCreateManyBmInput | BmOpCreateManyBmInput[]
  }

  export type BmTcCreateWithoutBmInput = {
    nomeTc: string
  }

  export type BmTcUncheckedCreateWithoutBmInput = {
    nomeTc: string
  }

  export type BmTcCreateOrConnectWithoutBmInput = {
    where: BmTcWhereUniqueInput
    create: XOR<BmTcCreateWithoutBmInput, BmTcUncheckedCreateWithoutBmInput>
  }

  export type BmTcCreateManyBmInputEnvelope = {
    data: BmTcCreateManyBmInput | BmTcCreateManyBmInput[]
  }

  export type BmMalhasUpsertWithWhereUniqueWithoutBmInput = {
    where: BmMalhasWhereUniqueInput
    update: XOR<BmMalhasUpdateWithoutBmInput, BmMalhasUncheckedUpdateWithoutBmInput>
    create: XOR<BmMalhasCreateWithoutBmInput, BmMalhasUncheckedCreateWithoutBmInput>
  }

  export type BmMalhasUpdateWithWhereUniqueWithoutBmInput = {
    where: BmMalhasWhereUniqueInput
    data: XOR<BmMalhasUpdateWithoutBmInput, BmMalhasUncheckedUpdateWithoutBmInput>
  }

  export type BmMalhasUpdateManyWithWhereWithoutBmInput = {
    where: BmMalhasScalarWhereInput
    data: XOR<BmMalhasUpdateManyMutationInput, BmMalhasUncheckedUpdateManyWithoutBmInput>
  }

  export type BmMalhasScalarWhereInput = {
    AND?: BmMalhasScalarWhereInput | BmMalhasScalarWhereInput[]
    OR?: BmMalhasScalarWhereInput[]
    NOT?: BmMalhasScalarWhereInput | BmMalhasScalarWhereInput[]
    idBm?: StringFilter<"BmMalhas"> | string
    ref?: StringFilter<"BmMalhas"> | string
    malha?: StringFilter<"BmMalhas"> | string
    grupo?: StringFilter<"BmMalhas"> | string
    subGrupo?: StringFilter<"BmMalhas"> | string
    qtdePedida?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: DecimalNullableFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFilter<"BmMalhas"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhas"> | string
    lote?: StringFilter<"BmMalhas"> | string
  }

  export type BmOpUpsertWithWhereUniqueWithoutBmInput = {
    where: BmOpWhereUniqueInput
    update: XOR<BmOpUpdateWithoutBmInput, BmOpUncheckedUpdateWithoutBmInput>
    create: XOR<BmOpCreateWithoutBmInput, BmOpUncheckedCreateWithoutBmInput>
  }

  export type BmOpUpdateWithWhereUniqueWithoutBmInput = {
    where: BmOpWhereUniqueInput
    data: XOR<BmOpUpdateWithoutBmInput, BmOpUncheckedUpdateWithoutBmInput>
  }

  export type BmOpUpdateManyWithWhereWithoutBmInput = {
    where: BmOpScalarWhereInput
    data: XOR<BmOpUpdateManyMutationInput, BmOpUncheckedUpdateManyWithoutBmInput>
  }

  export type BmOpScalarWhereInput = {
    AND?: BmOpScalarWhereInput | BmOpScalarWhereInput[]
    OR?: BmOpScalarWhereInput[]
    NOT?: BmOpScalarWhereInput | BmOpScalarWhereInput[]
    idBm?: StringFilter<"BmOp"> | string
    op?: IntFilter<"BmOp"> | number
    CreatedAt?: DateTimeFilter<"BmOp"> | Date | string
    foto?: StringFilter<"BmOp"> | string
  }

  export type BmTcUpsertWithWhereUniqueWithoutBmInput = {
    where: BmTcWhereUniqueInput
    update: XOR<BmTcUpdateWithoutBmInput, BmTcUncheckedUpdateWithoutBmInput>
    create: XOR<BmTcCreateWithoutBmInput, BmTcUncheckedCreateWithoutBmInput>
  }

  export type BmTcUpdateWithWhereUniqueWithoutBmInput = {
    where: BmTcWhereUniqueInput
    data: XOR<BmTcUpdateWithoutBmInput, BmTcUncheckedUpdateWithoutBmInput>
  }

  export type BmTcUpdateManyWithWhereWithoutBmInput = {
    where: BmTcScalarWhereInput
    data: XOR<BmTcUpdateManyMutationInput, BmTcUncheckedUpdateManyWithoutBmInput>
  }

  export type BmTcScalarWhereInput = {
    AND?: BmTcScalarWhereInput | BmTcScalarWhereInput[]
    OR?: BmTcScalarWhereInput[]
    NOT?: BmTcScalarWhereInput | BmTcScalarWhereInput[]
    idBm?: StringFilter<"BmTc"> | string
    nomeTc?: StringFilter<"BmTc"> | string
  }

  export type BmMalhasFioCreateWithoutBmFioComposicaoInput = {
    refOrigem: string
    fio: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmMalhas: BmMalhasCreateNestedOneWithoutBmMalhasFioInput
    BmMateriaisFio: BmMateriaisFioCreateNestedOneWithoutBmMalhasFioInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioUncheckedCreateWithoutBmFioComposicaoInput = {
    idBm: string
    ref: string
    refOrigem: string
    fio: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioCreateOrConnectWithoutBmFioComposicaoInput = {
    where: BmMalhasFioWhereUniqueInput
    create: XOR<BmMalhasFioCreateWithoutBmFioComposicaoInput, BmMalhasFioUncheckedCreateWithoutBmFioComposicaoInput>
  }

  export type BmMateriaisComposicaoCreateWithoutBmFioComposicaoInput = {
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
    BmIdBmComposicao?: BmIdBmComposicaoCreateNestedManyWithoutBmMateriaisComposicaoInput
  }

  export type BmMateriaisComposicaoUncheckedCreateWithoutBmFioComposicaoInput = {
    idComposicao?: number
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMateriaisComposicaoInput
  }

  export type BmMateriaisComposicaoCreateOrConnectWithoutBmFioComposicaoInput = {
    where: BmMateriaisComposicaoWhereUniqueInput
    create: XOR<BmMateriaisComposicaoCreateWithoutBmFioComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmFioComposicaoInput>
  }

  export type BmMalhasFioUpsertWithoutBmFioComposicaoInput = {
    update: XOR<BmMalhasFioUpdateWithoutBmFioComposicaoInput, BmMalhasFioUncheckedUpdateWithoutBmFioComposicaoInput>
    create: XOR<BmMalhasFioCreateWithoutBmFioComposicaoInput, BmMalhasFioUncheckedCreateWithoutBmFioComposicaoInput>
    where?: BmMalhasFioWhereInput
  }

  export type BmMalhasFioUpdateToOneWithWhereWithoutBmFioComposicaoInput = {
    where?: BmMalhasFioWhereInput
    data: XOR<BmMalhasFioUpdateWithoutBmFioComposicaoInput, BmMalhasFioUncheckedUpdateWithoutBmFioComposicaoInput>
  }

  export type BmMalhasFioUpdateWithoutBmFioComposicaoInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmMalhasFioNestedInput
    BmMateriaisFio?: BmMateriaisFioUpdateOneRequiredWithoutBmMalhasFioNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioUncheckedUpdateWithoutBmFioComposicaoInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMateriaisComposicaoUpsertWithoutBmFioComposicaoInput = {
    update: XOR<BmMateriaisComposicaoUpdateWithoutBmFioComposicaoInput, BmMateriaisComposicaoUncheckedUpdateWithoutBmFioComposicaoInput>
    create: XOR<BmMateriaisComposicaoCreateWithoutBmFioComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmFioComposicaoInput>
    where?: BmMateriaisComposicaoWhereInput
  }

  export type BmMateriaisComposicaoUpdateToOneWithWhereWithoutBmFioComposicaoInput = {
    where?: BmMateriaisComposicaoWhereInput
    data: XOR<BmMateriaisComposicaoUpdateWithoutBmFioComposicaoInput, BmMateriaisComposicaoUncheckedUpdateWithoutBmFioComposicaoInput>
  }

  export type BmMateriaisComposicaoUpdateWithoutBmFioComposicaoInput = {
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
    BmIdBmComposicao?: BmIdBmComposicaoUpdateManyWithoutBmMateriaisComposicaoNestedInput
  }

  export type BmMateriaisComposicaoUncheckedUpdateWithoutBmFioComposicaoInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoNestedInput
  }

  export type BmMalhasCreateWithoutBmIdBmComposicaoInput = {
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    Bm: BmCreateNestedOneWithoutBmMalhasInput
    BmMateriais: BmMateriaisCreateNestedOneWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasUncheckedCreateWithoutBmIdBmComposicaoInput = {
    idBm: string
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasCreateOrConnectWithoutBmIdBmComposicaoInput = {
    where: BmMalhasWhereUniqueInput
    create: XOR<BmMalhasCreateWithoutBmIdBmComposicaoInput, BmMalhasUncheckedCreateWithoutBmIdBmComposicaoInput>
  }

  export type BmMateriaisComposicaoCreateWithoutBmIdBmComposicaoInput = {
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
    BmFioComposicao?: BmFioComposicaoCreateNestedManyWithoutBmMateriaisComposicaoInput
  }

  export type BmMateriaisComposicaoUncheckedCreateWithoutBmIdBmComposicaoInput = {
    idComposicao?: number
    composicao: string
    composicaoAbreviatura: string
    ordem: number
    inactivo: boolean
    BmFioComposicao?: BmFioComposicaoUncheckedCreateNestedManyWithoutBmMateriaisComposicaoInput
  }

  export type BmMateriaisComposicaoCreateOrConnectWithoutBmIdBmComposicaoInput = {
    where: BmMateriaisComposicaoWhereUniqueInput
    create: XOR<BmMateriaisComposicaoCreateWithoutBmIdBmComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmIdBmComposicaoInput>
  }

  export type BmMalhasUpsertWithoutBmIdBmComposicaoInput = {
    update: XOR<BmMalhasUpdateWithoutBmIdBmComposicaoInput, BmMalhasUncheckedUpdateWithoutBmIdBmComposicaoInput>
    create: XOR<BmMalhasCreateWithoutBmIdBmComposicaoInput, BmMalhasUncheckedCreateWithoutBmIdBmComposicaoInput>
    where?: BmMalhasWhereInput
  }

  export type BmMalhasUpdateToOneWithWhereWithoutBmIdBmComposicaoInput = {
    where?: BmMalhasWhereInput
    data: XOR<BmMalhasUpdateWithoutBmIdBmComposicaoInput, BmMalhasUncheckedUpdateWithoutBmIdBmComposicaoInput>
  }

  export type BmMalhasUpdateWithoutBmIdBmComposicaoInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    Bm?: BmUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMateriais?: BmMateriaisUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateWithoutBmIdBmComposicaoInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMateriaisComposicaoUpsertWithoutBmIdBmComposicaoInput = {
    update: XOR<BmMateriaisComposicaoUpdateWithoutBmIdBmComposicaoInput, BmMateriaisComposicaoUncheckedUpdateWithoutBmIdBmComposicaoInput>
    create: XOR<BmMateriaisComposicaoCreateWithoutBmIdBmComposicaoInput, BmMateriaisComposicaoUncheckedCreateWithoutBmIdBmComposicaoInput>
    where?: BmMateriaisComposicaoWhereInput
  }

  export type BmMateriaisComposicaoUpdateToOneWithWhereWithoutBmIdBmComposicaoInput = {
    where?: BmMateriaisComposicaoWhereInput
    data: XOR<BmMateriaisComposicaoUpdateWithoutBmIdBmComposicaoInput, BmMateriaisComposicaoUncheckedUpdateWithoutBmIdBmComposicaoInput>
  }

  export type BmMateriaisComposicaoUpdateWithoutBmIdBmComposicaoInput = {
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
    BmFioComposicao?: BmFioComposicaoUpdateManyWithoutBmMateriaisComposicaoNestedInput
  }

  export type BmMateriaisComposicaoUncheckedUpdateWithoutBmIdBmComposicaoInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    composicao?: StringFieldUpdateOperationsInput | string
    composicaoAbreviatura?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    inactivo?: BoolFieldUpdateOperationsInput | boolean
    BmFioComposicao?: BmFioComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoNestedInput
  }

  export type BmIdBmComposicaoCreateWithoutBmMalhasInput = {
    qtt: Decimal | DecimalJsLike | number | string
    BmMateriaisComposicao: BmMateriaisComposicaoCreateNestedOneWithoutBmIdBmComposicaoInput
  }

  export type BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput = {
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoCreateOrConnectWithoutBmMalhasInput = {
    where: BmIdBmComposicaoWhereUniqueInput
    create: XOR<BmIdBmComposicaoCreateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmIdBmComposicaoCreateManyBmMalhasInputEnvelope = {
    data: BmIdBmComposicaoCreateManyBmMalhasInput | BmIdBmComposicaoCreateManyBmMalhasInput[]
  }

  export type BmCreateWithoutBmMalhasInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmOp?: BmOpCreateNestedManyWithoutBmInput
    BmTc?: BmTcCreateNestedManyWithoutBmInput
  }

  export type BmUncheckedCreateWithoutBmMalhasInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmOp?: BmOpUncheckedCreateNestedManyWithoutBmInput
    BmTc?: BmTcUncheckedCreateNestedManyWithoutBmInput
  }

  export type BmCreateOrConnectWithoutBmMalhasInput = {
    where: BmWhereUniqueInput
    create: XOR<BmCreateWithoutBmMalhasInput, BmUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmMateriaisCreateWithoutBmMalhasInput = {
    BmMaterialGrupo: BmMaterialGrupoCreateNestedOneWithoutBmMateriaisInput
    BmMaterialSubGrupo: BmMaterialSubGrupoCreateNestedOneWithoutBmMateriaisInput
  }

  export type BmMateriaisUncheckedCreateWithoutBmMalhasInput = {
    grupo: string
    subGrupo: string
  }

  export type BmMateriaisCreateOrConnectWithoutBmMalhasInput = {
    where: BmMateriaisWhereUniqueInput
    create: XOR<BmMateriaisCreateWithoutBmMalhasInput, BmMateriaisUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmMalhasFioCreateWithoutBmMalhasInput = {
    refOrigem: string
    fio: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoCreateNestedManyWithoutBmMalhasFioInput
    BmMateriaisFio: BmMateriaisFioCreateNestedOneWithoutBmMalhasFioInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioUncheckedCreateWithoutBmMalhasInput = {
    refOrigem: string
    fio: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoUncheckedCreateNestedManyWithoutBmMalhasFioInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioCreateOrConnectWithoutBmMalhasInput = {
    where: BmMalhasFioWhereUniqueInput
    create: XOR<BmMalhasFioCreateWithoutBmMalhasInput, BmMalhasFioUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmMalhasFioCreateManyBmMalhasInputEnvelope = {
    data: BmMalhasFioCreateManyBmMalhasInput | BmMalhasFioCreateManyBmMalhasInput[]
  }

  export type BmOpsPorMalhaCreateWithoutBmMalhasInput = {
    BmMovimentosLotes?: BmMovimentosLotesCreateNestedManyWithoutBmOpsPorMalhaInput
    BmOp: BmOpCreateNestedOneWithoutBmOpsPorMalhaInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput = {
    op: number
    BmMovimentosLotes?: BmMovimentosLotesUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaCreateOrConnectWithoutBmMalhasInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    create: XOR<BmOpsPorMalhaCreateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmOpsPorMalhaCreateManyBmMalhasInputEnvelope = {
    data: BmOpsPorMalhaCreateManyBmMalhasInput | BmOpsPorMalhaCreateManyBmMalhasInput[]
  }

  export type BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMalhasInput = {
    where: BmIdBmComposicaoWhereUniqueInput
    update: XOR<BmIdBmComposicaoUpdateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedUpdateWithoutBmMalhasInput>
    create: XOR<BmIdBmComposicaoCreateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMalhasInput = {
    where: BmIdBmComposicaoWhereUniqueInput
    data: XOR<BmIdBmComposicaoUpdateWithoutBmMalhasInput, BmIdBmComposicaoUncheckedUpdateWithoutBmMalhasInput>
  }

  export type BmIdBmComposicaoUpdateManyWithWhereWithoutBmMalhasInput = {
    where: BmIdBmComposicaoScalarWhereInput
    data: XOR<BmIdBmComposicaoUpdateManyMutationInput, BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasInput>
  }

  export type BmIdBmComposicaoScalarWhereInput = {
    AND?: BmIdBmComposicaoScalarWhereInput | BmIdBmComposicaoScalarWhereInput[]
    OR?: BmIdBmComposicaoScalarWhereInput[]
    NOT?: BmIdBmComposicaoScalarWhereInput | BmIdBmComposicaoScalarWhereInput[]
    idBm?: StringFilter<"BmIdBmComposicao"> | string
    ref?: StringFilter<"BmIdBmComposicao"> | string
    idComposicao?: IntFilter<"BmIdBmComposicao"> | number
    qtt?: DecimalFilter<"BmIdBmComposicao"> | Decimal | DecimalJsLike | number | string
  }

  export type BmUpsertWithoutBmMalhasInput = {
    update: XOR<BmUpdateWithoutBmMalhasInput, BmUncheckedUpdateWithoutBmMalhasInput>
    create: XOR<BmCreateWithoutBmMalhasInput, BmUncheckedCreateWithoutBmMalhasInput>
    where?: BmWhereInput
  }

  export type BmUpdateToOneWithWhereWithoutBmMalhasInput = {
    where?: BmWhereInput
    data: XOR<BmUpdateWithoutBmMalhasInput, BmUncheckedUpdateWithoutBmMalhasInput>
  }

  export type BmUpdateWithoutBmMalhasInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmOp?: BmOpUpdateManyWithoutBmNestedInput
    BmTc?: BmTcUpdateManyWithoutBmNestedInput
  }

  export type BmUncheckedUpdateWithoutBmMalhasInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmOp?: BmOpUncheckedUpdateManyWithoutBmNestedInput
    BmTc?: BmTcUncheckedUpdateManyWithoutBmNestedInput
  }

  export type BmMateriaisUpsertWithoutBmMalhasInput = {
    update: XOR<BmMateriaisUpdateWithoutBmMalhasInput, BmMateriaisUncheckedUpdateWithoutBmMalhasInput>
    create: XOR<BmMateriaisCreateWithoutBmMalhasInput, BmMateriaisUncheckedCreateWithoutBmMalhasInput>
    where?: BmMateriaisWhereInput
  }

  export type BmMateriaisUpdateToOneWithWhereWithoutBmMalhasInput = {
    where?: BmMateriaisWhereInput
    data: XOR<BmMateriaisUpdateWithoutBmMalhasInput, BmMateriaisUncheckedUpdateWithoutBmMalhasInput>
  }

  export type BmMateriaisUpdateWithoutBmMalhasInput = {
    BmMaterialGrupo?: BmMaterialGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput
    BmMaterialSubGrupo?: BmMaterialSubGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput
  }

  export type BmMateriaisUncheckedUpdateWithoutBmMalhasInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioUpsertWithWhereUniqueWithoutBmMalhasInput = {
    where: BmMalhasFioWhereUniqueInput
    update: XOR<BmMalhasFioUpdateWithoutBmMalhasInput, BmMalhasFioUncheckedUpdateWithoutBmMalhasInput>
    create: XOR<BmMalhasFioCreateWithoutBmMalhasInput, BmMalhasFioUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmMalhasFioUpdateWithWhereUniqueWithoutBmMalhasInput = {
    where: BmMalhasFioWhereUniqueInput
    data: XOR<BmMalhasFioUpdateWithoutBmMalhasInput, BmMalhasFioUncheckedUpdateWithoutBmMalhasInput>
  }

  export type BmMalhasFioUpdateManyWithWhereWithoutBmMalhasInput = {
    where: BmMalhasFioScalarWhereInput
    data: XOR<BmMalhasFioUpdateManyMutationInput, BmMalhasFioUncheckedUpdateManyWithoutBmMalhasInput>
  }

  export type BmMalhasFioScalarWhereInput = {
    AND?: BmMalhasFioScalarWhereInput | BmMalhasFioScalarWhereInput[]
    OR?: BmMalhasFioScalarWhereInput[]
    NOT?: BmMalhasFioScalarWhereInput | BmMalhasFioScalarWhereInput[]
    idBm?: StringFilter<"BmMalhasFio"> | string
    ref?: StringFilter<"BmMalhasFio"> | string
    refOrigem?: StringFilter<"BmMalhasFio"> | string
    fio?: StringFilter<"BmMalhasFio"> | string
    grupo?: StringFilter<"BmMalhasFio"> | string
    subGrupo?: StringFilter<"BmMalhasFio"> | string
    qtdePedida?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFilter<"BmMalhasFio"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhasFio"> | string
    lote?: StringFilter<"BmMalhasFio"> | string
  }

  export type BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmMalhasInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    update: XOR<BmOpsPorMalhaUpdateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedUpdateWithoutBmMalhasInput>
    create: XOR<BmOpsPorMalhaCreateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedCreateWithoutBmMalhasInput>
  }

  export type BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmMalhasInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    data: XOR<BmOpsPorMalhaUpdateWithoutBmMalhasInput, BmOpsPorMalhaUncheckedUpdateWithoutBmMalhasInput>
  }

  export type BmOpsPorMalhaUpdateManyWithWhereWithoutBmMalhasInput = {
    where: BmOpsPorMalhaScalarWhereInput
    data: XOR<BmOpsPorMalhaUpdateManyMutationInput, BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasInput>
  }

  export type BmOpsPorMalhaScalarWhereInput = {
    AND?: BmOpsPorMalhaScalarWhereInput | BmOpsPorMalhaScalarWhereInput[]
    OR?: BmOpsPorMalhaScalarWhereInput[]
    NOT?: BmOpsPorMalhaScalarWhereInput | BmOpsPorMalhaScalarWhereInput[]
    idBm?: StringFilter<"BmOpsPorMalha"> | string
    ref?: StringFilter<"BmOpsPorMalha"> | string
    op?: IntFilter<"BmOpsPorMalha"> | number
  }

  export type BmFioComposicaoCreateWithoutBmMalhasFioInput = {
    qtt: Decimal | DecimalJsLike | number | string
    BmMateriaisComposicao: BmMateriaisComposicaoCreateNestedOneWithoutBmFioComposicaoInput
  }

  export type BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput = {
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoCreateOrConnectWithoutBmMalhasFioInput = {
    where: BmFioComposicaoWhereUniqueInput
    create: XOR<BmFioComposicaoCreateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput>
  }

  export type BmFioComposicaoCreateManyBmMalhasFioInputEnvelope = {
    data: BmFioComposicaoCreateManyBmMalhasFioInput | BmFioComposicaoCreateManyBmMalhasFioInput[]
  }

  export type BmMalhasCreateWithoutBmMalhasFioInput = {
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoCreateNestedManyWithoutBmMalhasInput
    Bm: BmCreateNestedOneWithoutBmMalhasInput
    BmMateriais: BmMateriaisCreateNestedOneWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasUncheckedCreateWithoutBmMalhasFioInput = {
    idBm: string
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasCreateOrConnectWithoutBmMalhasFioInput = {
    where: BmMalhasWhereUniqueInput
    create: XOR<BmMalhasCreateWithoutBmMalhasFioInput, BmMalhasUncheckedCreateWithoutBmMalhasFioInput>
  }

  export type BmMateriaisFioCreateWithoutBmMalhasFioInput = {
    BmMaterialGrupoFio: BmMaterialGrupoFioCreateNestedOneWithoutBmMateriaisFioInput
    BmMaterialSubGrupoFio: BmMaterialSubGrupoFioCreateNestedOneWithoutBmMateriaisFioInput
  }

  export type BmMateriaisFioUncheckedCreateWithoutBmMalhasFioInput = {
    grupo: string
    subGrupo: string
  }

  export type BmMateriaisFioCreateOrConnectWithoutBmMalhasFioInput = {
    where: BmMateriaisFioWhereUniqueInput
    create: XOR<BmMateriaisFioCreateWithoutBmMalhasFioInput, BmMateriaisFioUncheckedCreateWithoutBmMalhasFioInput>
  }

  export type BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput = {
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosCreateNestedManyWithoutBmOpsPorMalhaFioInput
    BmOpsPorMalha: BmOpsPorMalhaCreateNestedOneWithoutBmOpsPorMalhaFioInput
  }

  export type BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput = {
    op: number
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUncheckedCreateNestedManyWithoutBmOpsPorMalhaFioInput
  }

  export type BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioInput = {
    where: BmOpsPorMalhaFioWhereUniqueInput
    create: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput>
  }

  export type BmOpsPorMalhaFioCreateManyBmMalhasFioInputEnvelope = {
    data: BmOpsPorMalhaFioCreateManyBmMalhasFioInput | BmOpsPorMalhaFioCreateManyBmMalhasFioInput[]
  }

  export type BmFioComposicaoUpsertWithWhereUniqueWithoutBmMalhasFioInput = {
    where: BmFioComposicaoWhereUniqueInput
    update: XOR<BmFioComposicaoUpdateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedUpdateWithoutBmMalhasFioInput>
    create: XOR<BmFioComposicaoCreateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedCreateWithoutBmMalhasFioInput>
  }

  export type BmFioComposicaoUpdateWithWhereUniqueWithoutBmMalhasFioInput = {
    where: BmFioComposicaoWhereUniqueInput
    data: XOR<BmFioComposicaoUpdateWithoutBmMalhasFioInput, BmFioComposicaoUncheckedUpdateWithoutBmMalhasFioInput>
  }

  export type BmFioComposicaoUpdateManyWithWhereWithoutBmMalhasFioInput = {
    where: BmFioComposicaoScalarWhereInput
    data: XOR<BmFioComposicaoUpdateManyMutationInput, BmFioComposicaoUncheckedUpdateManyWithoutBmMalhasFioInput>
  }

  export type BmFioComposicaoScalarWhereInput = {
    AND?: BmFioComposicaoScalarWhereInput | BmFioComposicaoScalarWhereInput[]
    OR?: BmFioComposicaoScalarWhereInput[]
    NOT?: BmFioComposicaoScalarWhereInput | BmFioComposicaoScalarWhereInput[]
    idBm?: StringFilter<"BmFioComposicao"> | string
    ref?: StringFilter<"BmFioComposicao"> | string
    refOrigem?: StringFilter<"BmFioComposicao"> | string
    idComposicao?: IntFilter<"BmFioComposicao"> | number
    qtt?: DecimalFilter<"BmFioComposicao"> | Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasUpsertWithoutBmMalhasFioInput = {
    update: XOR<BmMalhasUpdateWithoutBmMalhasFioInput, BmMalhasUncheckedUpdateWithoutBmMalhasFioInput>
    create: XOR<BmMalhasCreateWithoutBmMalhasFioInput, BmMalhasUncheckedCreateWithoutBmMalhasFioInput>
    where?: BmMalhasWhereInput
  }

  export type BmMalhasUpdateToOneWithWhereWithoutBmMalhasFioInput = {
    where?: BmMalhasWhereInput
    data: XOR<BmMalhasUpdateWithoutBmMalhasFioInput, BmMalhasUncheckedUpdateWithoutBmMalhasFioInput>
  }

  export type BmMalhasUpdateWithoutBmMalhasFioInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUpdateManyWithoutBmMalhasNestedInput
    Bm?: BmUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMateriais?: BmMateriaisUpdateOneRequiredWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateWithoutBmMalhasFioInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMateriaisFioUpsertWithoutBmMalhasFioInput = {
    update: XOR<BmMateriaisFioUpdateWithoutBmMalhasFioInput, BmMateriaisFioUncheckedUpdateWithoutBmMalhasFioInput>
    create: XOR<BmMateriaisFioCreateWithoutBmMalhasFioInput, BmMateriaisFioUncheckedCreateWithoutBmMalhasFioInput>
    where?: BmMateriaisFioWhereInput
  }

  export type BmMateriaisFioUpdateToOneWithWhereWithoutBmMalhasFioInput = {
    where?: BmMateriaisFioWhereInput
    data: XOR<BmMateriaisFioUpdateWithoutBmMalhasFioInput, BmMateriaisFioUncheckedUpdateWithoutBmMalhasFioInput>
  }

  export type BmMateriaisFioUpdateWithoutBmMalhasFioInput = {
    BmMaterialGrupoFio?: BmMaterialGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput
    BmMaterialSubGrupoFio?: BmMaterialSubGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput
  }

  export type BmMateriaisFioUncheckedUpdateWithoutBmMalhasFioInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmMalhasFioInput = {
    where: BmOpsPorMalhaFioWhereUniqueInput
    update: XOR<BmOpsPorMalhaFioUpdateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedUpdateWithoutBmMalhasFioInput>
    create: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioInput>
  }

  export type BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmMalhasFioInput = {
    where: BmOpsPorMalhaFioWhereUniqueInput
    data: XOR<BmOpsPorMalhaFioUpdateWithoutBmMalhasFioInput, BmOpsPorMalhaFioUncheckedUpdateWithoutBmMalhasFioInput>
  }

  export type BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmMalhasFioInput = {
    where: BmOpsPorMalhaFioScalarWhereInput
    data: XOR<BmOpsPorMalhaFioUpdateManyMutationInput, BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmMalhasFioInput>
  }

  export type BmOpsPorMalhaFioScalarWhereInput = {
    AND?: BmOpsPorMalhaFioScalarWhereInput | BmOpsPorMalhaFioScalarWhereInput[]
    OR?: BmOpsPorMalhaFioScalarWhereInput[]
    NOT?: BmOpsPorMalhaFioScalarWhereInput | BmOpsPorMalhaFioScalarWhereInput[]
    idBm?: StringFilter<"BmOpsPorMalhaFio"> | string
    ref?: StringFilter<"BmOpsPorMalhaFio"> | string
    refOrigem?: StringFilter<"BmOpsPorMalhaFio"> | string
    op?: IntFilter<"BmOpsPorMalhaFio"> | number
  }

  export type BmOpsPorMalhaFioCreateWithoutBmMalhasFioMovimentosInput = {
    BmMalhasFio: BmMalhasFioCreateNestedOneWithoutBmOpsPorMalhaFioInput
    BmOpsPorMalha: BmOpsPorMalhaCreateNestedOneWithoutBmOpsPorMalhaFioInput
  }

  export type BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioMovimentosInput = {
    idBm: string
    ref: string
    refOrigem: string
    op: number
  }

  export type BmOpsPorMalhaFioCreateOrConnectWithoutBmMalhasFioMovimentosInput = {
    where: BmOpsPorMalhaFioWhereUniqueInput
    create: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioMovimentosInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioMovimentosInput>
  }

  export type BmOpsPorMalhaFioUpsertWithoutBmMalhasFioMovimentosInput = {
    update: XOR<BmOpsPorMalhaFioUpdateWithoutBmMalhasFioMovimentosInput, BmOpsPorMalhaFioUncheckedUpdateWithoutBmMalhasFioMovimentosInput>
    create: XOR<BmOpsPorMalhaFioCreateWithoutBmMalhasFioMovimentosInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmMalhasFioMovimentosInput>
    where?: BmOpsPorMalhaFioWhereInput
  }

  export type BmOpsPorMalhaFioUpdateToOneWithWhereWithoutBmMalhasFioMovimentosInput = {
    where?: BmOpsPorMalhaFioWhereInput
    data: XOR<BmOpsPorMalhaFioUpdateWithoutBmMalhasFioMovimentosInput, BmOpsPorMalhaFioUncheckedUpdateWithoutBmMalhasFioMovimentosInput>
  }

  export type BmOpsPorMalhaFioUpdateWithoutBmMalhasFioMovimentosInput = {
    BmMalhasFio?: BmMalhasFioUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput
  }

  export type BmOpsPorMalhaFioUncheckedUpdateWithoutBmMalhasFioMovimentosInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type BmMalhasCreateWithoutBmMateriaisInput = {
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoCreateNestedManyWithoutBmMalhasInput
    Bm: BmCreateNestedOneWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasUncheckedCreateWithoutBmMateriaisInput = {
    idBm: string
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMalhasInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasCreateOrConnectWithoutBmMateriaisInput = {
    where: BmMalhasWhereUniqueInput
    create: XOR<BmMalhasCreateWithoutBmMateriaisInput, BmMalhasUncheckedCreateWithoutBmMateriaisInput>
  }

  export type BmMalhasCreateManyBmMateriaisInputEnvelope = {
    data: BmMalhasCreateManyBmMateriaisInput | BmMalhasCreateManyBmMateriaisInput[]
  }

  export type BmMaterialGrupoCreateWithoutBmMateriaisInput = {
    grupo: string
    grupoDescricao: string
  }

  export type BmMaterialGrupoUncheckedCreateWithoutBmMateriaisInput = {
    grupo: string
    grupoDescricao: string
  }

  export type BmMaterialGrupoCreateOrConnectWithoutBmMateriaisInput = {
    where: BmMaterialGrupoWhereUniqueInput
    create: XOR<BmMaterialGrupoCreateWithoutBmMateriaisInput, BmMaterialGrupoUncheckedCreateWithoutBmMateriaisInput>
  }

  export type BmMaterialSubGrupoCreateWithoutBmMateriaisInput = {
    subGrupo: string
    subGrupoDescricao: string
  }

  export type BmMaterialSubGrupoUncheckedCreateWithoutBmMateriaisInput = {
    subGrupo: string
    subGrupoDescricao: string
  }

  export type BmMaterialSubGrupoCreateOrConnectWithoutBmMateriaisInput = {
    where: BmMaterialSubGrupoWhereUniqueInput
    create: XOR<BmMaterialSubGrupoCreateWithoutBmMateriaisInput, BmMaterialSubGrupoUncheckedCreateWithoutBmMateriaisInput>
  }

  export type BmMalhasUpsertWithWhereUniqueWithoutBmMateriaisInput = {
    where: BmMalhasWhereUniqueInput
    update: XOR<BmMalhasUpdateWithoutBmMateriaisInput, BmMalhasUncheckedUpdateWithoutBmMateriaisInput>
    create: XOR<BmMalhasCreateWithoutBmMateriaisInput, BmMalhasUncheckedCreateWithoutBmMateriaisInput>
  }

  export type BmMalhasUpdateWithWhereUniqueWithoutBmMateriaisInput = {
    where: BmMalhasWhereUniqueInput
    data: XOR<BmMalhasUpdateWithoutBmMateriaisInput, BmMalhasUncheckedUpdateWithoutBmMateriaisInput>
  }

  export type BmMalhasUpdateManyWithWhereWithoutBmMateriaisInput = {
    where: BmMalhasScalarWhereInput
    data: XOR<BmMalhasUpdateManyMutationInput, BmMalhasUncheckedUpdateManyWithoutBmMateriaisInput>
  }

  export type BmMaterialGrupoUpsertWithoutBmMateriaisInput = {
    update: XOR<BmMaterialGrupoUpdateWithoutBmMateriaisInput, BmMaterialGrupoUncheckedUpdateWithoutBmMateriaisInput>
    create: XOR<BmMaterialGrupoCreateWithoutBmMateriaisInput, BmMaterialGrupoUncheckedCreateWithoutBmMateriaisInput>
    where?: BmMaterialGrupoWhereInput
  }

  export type BmMaterialGrupoUpdateToOneWithWhereWithoutBmMateriaisInput = {
    where?: BmMaterialGrupoWhereInput
    data: XOR<BmMaterialGrupoUpdateWithoutBmMateriaisInput, BmMaterialGrupoUncheckedUpdateWithoutBmMateriaisInput>
  }

  export type BmMaterialGrupoUpdateWithoutBmMateriaisInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialGrupoUncheckedUpdateWithoutBmMateriaisInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoUpsertWithoutBmMateriaisInput = {
    update: XOR<BmMaterialSubGrupoUpdateWithoutBmMateriaisInput, BmMaterialSubGrupoUncheckedUpdateWithoutBmMateriaisInput>
    create: XOR<BmMaterialSubGrupoCreateWithoutBmMateriaisInput, BmMaterialSubGrupoUncheckedCreateWithoutBmMateriaisInput>
    where?: BmMaterialSubGrupoWhereInput
  }

  export type BmMaterialSubGrupoUpdateToOneWithWhereWithoutBmMateriaisInput = {
    where?: BmMaterialSubGrupoWhereInput
    data: XOR<BmMaterialSubGrupoUpdateWithoutBmMateriaisInput, BmMaterialSubGrupoUncheckedUpdateWithoutBmMateriaisInput>
  }

  export type BmMaterialSubGrupoUpdateWithoutBmMateriaisInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoUncheckedUpdateWithoutBmMateriaisInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput = {
    qtt: Decimal | DecimalJsLike | number | string
    BmMalhasFio: BmMalhasFioCreateNestedOneWithoutBmFioComposicaoInput
  }

  export type BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput = {
    idBm: string
    ref: string
    refOrigem: string
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput = {
    where: BmFioComposicaoWhereUniqueInput
    create: XOR<BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput>
  }

  export type BmFioComposicaoCreateManyBmMateriaisComposicaoInputEnvelope = {
    data: BmFioComposicaoCreateManyBmMateriaisComposicaoInput | BmFioComposicaoCreateManyBmMateriaisComposicaoInput[]
  }

  export type BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput = {
    qtt: Decimal | DecimalJsLike | number | string
    BmMalhas: BmMalhasCreateNestedOneWithoutBmIdBmComposicaoInput
  }

  export type BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput = {
    idBm: string
    ref: string
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoCreateOrConnectWithoutBmMateriaisComposicaoInput = {
    where: BmIdBmComposicaoWhereUniqueInput
    create: XOR<BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput>
  }

  export type BmIdBmComposicaoCreateManyBmMateriaisComposicaoInputEnvelope = {
    data: BmIdBmComposicaoCreateManyBmMateriaisComposicaoInput | BmIdBmComposicaoCreateManyBmMateriaisComposicaoInput[]
  }

  export type BmFioComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput = {
    where: BmFioComposicaoWhereUniqueInput
    update: XOR<BmFioComposicaoUpdateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedUpdateWithoutBmMateriaisComposicaoInput>
    create: XOR<BmFioComposicaoCreateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput>
  }

  export type BmFioComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput = {
    where: BmFioComposicaoWhereUniqueInput
    data: XOR<BmFioComposicaoUpdateWithoutBmMateriaisComposicaoInput, BmFioComposicaoUncheckedUpdateWithoutBmMateriaisComposicaoInput>
  }

  export type BmFioComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput = {
    where: BmFioComposicaoScalarWhereInput
    data: XOR<BmFioComposicaoUpdateManyMutationInput, BmFioComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoInput>
  }

  export type BmIdBmComposicaoUpsertWithWhereUniqueWithoutBmMateriaisComposicaoInput = {
    where: BmIdBmComposicaoWhereUniqueInput
    update: XOR<BmIdBmComposicaoUpdateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedUpdateWithoutBmMateriaisComposicaoInput>
    create: XOR<BmIdBmComposicaoCreateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedCreateWithoutBmMateriaisComposicaoInput>
  }

  export type BmIdBmComposicaoUpdateWithWhereUniqueWithoutBmMateriaisComposicaoInput = {
    where: BmIdBmComposicaoWhereUniqueInput
    data: XOR<BmIdBmComposicaoUpdateWithoutBmMateriaisComposicaoInput, BmIdBmComposicaoUncheckedUpdateWithoutBmMateriaisComposicaoInput>
  }

  export type BmIdBmComposicaoUpdateManyWithWhereWithoutBmMateriaisComposicaoInput = {
    where: BmIdBmComposicaoScalarWhereInput
    data: XOR<BmIdBmComposicaoUpdateManyMutationInput, BmIdBmComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoInput>
  }

  export type BmMalhasFioCreateWithoutBmMateriaisFioInput = {
    refOrigem: string
    fio: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoCreateNestedManyWithoutBmMalhasFioInput
    BmMalhas: BmMalhasCreateNestedOneWithoutBmMalhasFioInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput = {
    idBm: string
    ref: string
    refOrigem: string
    fio: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoUncheckedCreateNestedManyWithoutBmMalhasFioInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioCreateOrConnectWithoutBmMateriaisFioInput = {
    where: BmMalhasFioWhereUniqueInput
    create: XOR<BmMalhasFioCreateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput>
  }

  export type BmMalhasFioCreateManyBmMateriaisFioInputEnvelope = {
    data: BmMalhasFioCreateManyBmMateriaisFioInput | BmMalhasFioCreateManyBmMateriaisFioInput[]
  }

  export type BmMaterialGrupoFioCreateWithoutBmMateriaisFioInput = {
    grupo: string
    grupoDescricao: string
  }

  export type BmMaterialGrupoFioUncheckedCreateWithoutBmMateriaisFioInput = {
    grupo: string
    grupoDescricao: string
  }

  export type BmMaterialGrupoFioCreateOrConnectWithoutBmMateriaisFioInput = {
    where: BmMaterialGrupoFioWhereUniqueInput
    create: XOR<BmMaterialGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
  }

  export type BmMaterialSubGrupoFioCreateWithoutBmMateriaisFioInput = {
    subGrupo: string
    subGrupoDescricao: string
  }

  export type BmMaterialSubGrupoFioUncheckedCreateWithoutBmMateriaisFioInput = {
    subGrupo: string
    subGrupoDescricao: string
  }

  export type BmMaterialSubGrupoFioCreateOrConnectWithoutBmMateriaisFioInput = {
    where: BmMaterialSubGrupoFioWhereUniqueInput
    create: XOR<BmMaterialSubGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialSubGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
  }

  export type BmMalhasFioUpsertWithWhereUniqueWithoutBmMateriaisFioInput = {
    where: BmMalhasFioWhereUniqueInput
    update: XOR<BmMalhasFioUpdateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedUpdateWithoutBmMateriaisFioInput>
    create: XOR<BmMalhasFioCreateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedCreateWithoutBmMateriaisFioInput>
  }

  export type BmMalhasFioUpdateWithWhereUniqueWithoutBmMateriaisFioInput = {
    where: BmMalhasFioWhereUniqueInput
    data: XOR<BmMalhasFioUpdateWithoutBmMateriaisFioInput, BmMalhasFioUncheckedUpdateWithoutBmMateriaisFioInput>
  }

  export type BmMalhasFioUpdateManyWithWhereWithoutBmMateriaisFioInput = {
    where: BmMalhasFioScalarWhereInput
    data: XOR<BmMalhasFioUpdateManyMutationInput, BmMalhasFioUncheckedUpdateManyWithoutBmMateriaisFioInput>
  }

  export type BmMaterialGrupoFioUpsertWithoutBmMateriaisFioInput = {
    update: XOR<BmMaterialGrupoFioUpdateWithoutBmMateriaisFioInput, BmMaterialGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput>
    create: XOR<BmMaterialGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
    where?: BmMaterialGrupoFioWhereInput
  }

  export type BmMaterialGrupoFioUpdateToOneWithWhereWithoutBmMateriaisFioInput = {
    where?: BmMaterialGrupoFioWhereInput
    data: XOR<BmMaterialGrupoFioUpdateWithoutBmMateriaisFioInput, BmMaterialGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput>
  }

  export type BmMaterialGrupoFioUpdateWithoutBmMateriaisFioInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    grupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoFioUpsertWithoutBmMateriaisFioInput = {
    update: XOR<BmMaterialSubGrupoFioUpdateWithoutBmMateriaisFioInput, BmMaterialSubGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput>
    create: XOR<BmMaterialSubGrupoFioCreateWithoutBmMateriaisFioInput, BmMaterialSubGrupoFioUncheckedCreateWithoutBmMateriaisFioInput>
    where?: BmMaterialSubGrupoFioWhereInput
  }

  export type BmMaterialSubGrupoFioUpdateToOneWithWhereWithoutBmMateriaisFioInput = {
    where?: BmMaterialSubGrupoFioWhereInput
    data: XOR<BmMaterialSubGrupoFioUpdateWithoutBmMateriaisFioInput, BmMaterialSubGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput>
  }

  export type BmMaterialSubGrupoFioUpdateWithoutBmMateriaisFioInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMaterialSubGrupoFioUncheckedUpdateWithoutBmMateriaisFioInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    subGrupoDescricao?: StringFieldUpdateOperationsInput | string
  }

  export type BmMateriaisCreateWithoutBmMaterialGrupoInput = {
    BmMalhas?: BmMalhasCreateNestedManyWithoutBmMateriaisInput
    BmMaterialSubGrupo: BmMaterialSubGrupoCreateNestedOneWithoutBmMateriaisInput
  }

  export type BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput = {
    subGrupo: string
    BmMalhas?: BmMalhasUncheckedCreateNestedManyWithoutBmMateriaisInput
  }

  export type BmMateriaisCreateOrConnectWithoutBmMaterialGrupoInput = {
    where: BmMateriaisWhereUniqueInput
    create: XOR<BmMateriaisCreateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput>
  }

  export type BmMateriaisCreateManyBmMaterialGrupoInputEnvelope = {
    data: BmMateriaisCreateManyBmMaterialGrupoInput | BmMateriaisCreateManyBmMaterialGrupoInput[]
  }

  export type BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialGrupoInput = {
    where: BmMateriaisWhereUniqueInput
    update: XOR<BmMateriaisUpdateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedUpdateWithoutBmMaterialGrupoInput>
    create: XOR<BmMateriaisCreateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialGrupoInput>
  }

  export type BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialGrupoInput = {
    where: BmMateriaisWhereUniqueInput
    data: XOR<BmMateriaisUpdateWithoutBmMaterialGrupoInput, BmMateriaisUncheckedUpdateWithoutBmMaterialGrupoInput>
  }

  export type BmMateriaisUpdateManyWithWhereWithoutBmMaterialGrupoInput = {
    where: BmMateriaisScalarWhereInput
    data: XOR<BmMateriaisUpdateManyMutationInput, BmMateriaisUncheckedUpdateManyWithoutBmMaterialGrupoInput>
  }

  export type BmMateriaisScalarWhereInput = {
    AND?: BmMateriaisScalarWhereInput | BmMateriaisScalarWhereInput[]
    OR?: BmMateriaisScalarWhereInput[]
    NOT?: BmMateriaisScalarWhereInput | BmMateriaisScalarWhereInput[]
    grupo?: StringFilter<"BmMateriais"> | string
    subGrupo?: StringFilter<"BmMateriais"> | string
  }

  export type BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput = {
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMateriaisFioInput
    BmMaterialSubGrupoFio: BmMaterialSubGrupoFioCreateNestedOneWithoutBmMateriaisFioInput
  }

  export type BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput = {
    subGrupo: string
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMateriaisFioInput
  }

  export type BmMateriaisFioCreateOrConnectWithoutBmMaterialGrupoFioInput = {
    where: BmMateriaisFioWhereUniqueInput
    create: XOR<BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput>
  }

  export type BmMateriaisFioCreateManyBmMaterialGrupoFioInputEnvelope = {
    data: BmMateriaisFioCreateManyBmMaterialGrupoFioInput | BmMateriaisFioCreateManyBmMaterialGrupoFioInput[]
  }

  export type BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialGrupoFioInput = {
    where: BmMateriaisFioWhereUniqueInput
    update: XOR<BmMateriaisFioUpdateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedUpdateWithoutBmMaterialGrupoFioInput>
    create: XOR<BmMateriaisFioCreateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialGrupoFioInput>
  }

  export type BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialGrupoFioInput = {
    where: BmMateriaisFioWhereUniqueInput
    data: XOR<BmMateriaisFioUpdateWithoutBmMaterialGrupoFioInput, BmMateriaisFioUncheckedUpdateWithoutBmMaterialGrupoFioInput>
  }

  export type BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialGrupoFioInput = {
    where: BmMateriaisFioScalarWhereInput
    data: XOR<BmMateriaisFioUpdateManyMutationInput, BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialGrupoFioInput>
  }

  export type BmMateriaisFioScalarWhereInput = {
    AND?: BmMateriaisFioScalarWhereInput | BmMateriaisFioScalarWhereInput[]
    OR?: BmMateriaisFioScalarWhereInput[]
    NOT?: BmMateriaisFioScalarWhereInput | BmMateriaisFioScalarWhereInput[]
    grupo?: StringFilter<"BmMateriaisFio"> | string
    subGrupo?: StringFilter<"BmMateriaisFio"> | string
  }

  export type BmMateriaisCreateWithoutBmMaterialSubGrupoInput = {
    BmMalhas?: BmMalhasCreateNestedManyWithoutBmMateriaisInput
    BmMaterialGrupo: BmMaterialGrupoCreateNestedOneWithoutBmMateriaisInput
  }

  export type BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput = {
    grupo: string
    BmMalhas?: BmMalhasUncheckedCreateNestedManyWithoutBmMateriaisInput
  }

  export type BmMateriaisCreateOrConnectWithoutBmMaterialSubGrupoInput = {
    where: BmMateriaisWhereUniqueInput
    create: XOR<BmMateriaisCreateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput>
  }

  export type BmMateriaisCreateManyBmMaterialSubGrupoInputEnvelope = {
    data: BmMateriaisCreateManyBmMaterialSubGrupoInput | BmMateriaisCreateManyBmMaterialSubGrupoInput[]
  }

  export type BmMateriaisUpsertWithWhereUniqueWithoutBmMaterialSubGrupoInput = {
    where: BmMateriaisWhereUniqueInput
    update: XOR<BmMateriaisUpdateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedUpdateWithoutBmMaterialSubGrupoInput>
    create: XOR<BmMateriaisCreateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedCreateWithoutBmMaterialSubGrupoInput>
  }

  export type BmMateriaisUpdateWithWhereUniqueWithoutBmMaterialSubGrupoInput = {
    where: BmMateriaisWhereUniqueInput
    data: XOR<BmMateriaisUpdateWithoutBmMaterialSubGrupoInput, BmMateriaisUncheckedUpdateWithoutBmMaterialSubGrupoInput>
  }

  export type BmMateriaisUpdateManyWithWhereWithoutBmMaterialSubGrupoInput = {
    where: BmMateriaisScalarWhereInput
    data: XOR<BmMateriaisUpdateManyMutationInput, BmMateriaisUncheckedUpdateManyWithoutBmMaterialSubGrupoInput>
  }

  export type BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput = {
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMateriaisFioInput
    BmMaterialGrupoFio: BmMaterialGrupoFioCreateNestedOneWithoutBmMateriaisFioInput
  }

  export type BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput = {
    grupo: string
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMateriaisFioInput
  }

  export type BmMateriaisFioCreateOrConnectWithoutBmMaterialSubGrupoFioInput = {
    where: BmMateriaisFioWhereUniqueInput
    create: XOR<BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput>
  }

  export type BmMateriaisFioCreateManyBmMaterialSubGrupoFioInputEnvelope = {
    data: BmMateriaisFioCreateManyBmMaterialSubGrupoFioInput | BmMateriaisFioCreateManyBmMaterialSubGrupoFioInput[]
  }

  export type BmMateriaisFioUpsertWithWhereUniqueWithoutBmMaterialSubGrupoFioInput = {
    where: BmMateriaisFioWhereUniqueInput
    update: XOR<BmMateriaisFioUpdateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedUpdateWithoutBmMaterialSubGrupoFioInput>
    create: XOR<BmMateriaisFioCreateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedCreateWithoutBmMaterialSubGrupoFioInput>
  }

  export type BmMateriaisFioUpdateWithWhereUniqueWithoutBmMaterialSubGrupoFioInput = {
    where: BmMateriaisFioWhereUniqueInput
    data: XOR<BmMateriaisFioUpdateWithoutBmMaterialSubGrupoFioInput, BmMateriaisFioUncheckedUpdateWithoutBmMaterialSubGrupoFioInput>
  }

  export type BmMateriaisFioUpdateManyWithWhereWithoutBmMaterialSubGrupoFioInput = {
    where: BmMateriaisFioScalarWhereInput
    data: XOR<BmMateriaisFioUpdateManyMutationInput, BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialSubGrupoFioInput>
  }

  export type BmOpsPorMalhaCreateWithoutBmMovimentosLotesInput = {
    BmMalhas: BmMalhasCreateNestedOneWithoutBmOpsPorMalhaInput
    BmOp: BmOpCreateNestedOneWithoutBmOpsPorMalhaInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaUncheckedCreateWithoutBmMovimentosLotesInput = {
    idBm: string
    ref: string
    op: number
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaCreateOrConnectWithoutBmMovimentosLotesInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    create: XOR<BmOpsPorMalhaCreateWithoutBmMovimentosLotesInput, BmOpsPorMalhaUncheckedCreateWithoutBmMovimentosLotesInput>
  }

  export type BmOpsPorMalhaUpsertWithoutBmMovimentosLotesInput = {
    update: XOR<BmOpsPorMalhaUpdateWithoutBmMovimentosLotesInput, BmOpsPorMalhaUncheckedUpdateWithoutBmMovimentosLotesInput>
    create: XOR<BmOpsPorMalhaCreateWithoutBmMovimentosLotesInput, BmOpsPorMalhaUncheckedCreateWithoutBmMovimentosLotesInput>
    where?: BmOpsPorMalhaWhereInput
  }

  export type BmOpsPorMalhaUpdateToOneWithWhereWithoutBmMovimentosLotesInput = {
    where?: BmOpsPorMalhaWhereInput
    data: XOR<BmOpsPorMalhaUpdateWithoutBmMovimentosLotesInput, BmOpsPorMalhaUncheckedUpdateWithoutBmMovimentosLotesInput>
  }

  export type BmOpsPorMalhaUpdateWithoutBmMovimentosLotesInput = {
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
    BmOp?: BmOpUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaUncheckedUpdateWithoutBmMovimentosLotesInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmCreateWithoutBmOpInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmMalhas?: BmMalhasCreateNestedManyWithoutBmInput
    BmTc?: BmTcCreateNestedManyWithoutBmInput
  }

  export type BmUncheckedCreateWithoutBmOpInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmMalhas?: BmMalhasUncheckedCreateNestedManyWithoutBmInput
    BmTc?: BmTcUncheckedCreateNestedManyWithoutBmInput
  }

  export type BmCreateOrConnectWithoutBmOpInput = {
    where: BmWhereUniqueInput
    create: XOR<BmCreateWithoutBmOpInput, BmUncheckedCreateWithoutBmOpInput>
  }

  export type BmOpFaturadoCreateWithoutBmOpInput = {
    nFatutura: number
    fData: Date | string
    dataFatura: string
    refModelo: string
    pedido: string
    qtt: Decimal | DecimalJsLike | number | string
    pesoLiquido: Decimal | DecimalJsLike | number | string
    pesoBruto: Decimal | DecimalJsLike | number | string
    cmr: string
    local: string
    obs?: string | null
  }

  export type BmOpFaturadoUncheckedCreateWithoutBmOpInput = {
    nFatutura: number
    fData: Date | string
    dataFatura: string
    refModelo: string
    pedido: string
    qtt: Decimal | DecimalJsLike | number | string
    pesoLiquido: Decimal | DecimalJsLike | number | string
    pesoBruto: Decimal | DecimalJsLike | number | string
    cmr: string
    local: string
    obs?: string | null
  }

  export type BmOpFaturadoCreateOrConnectWithoutBmOpInput = {
    where: BmOpFaturadoWhereUniqueInput
    create: XOR<BmOpFaturadoCreateWithoutBmOpInput, BmOpFaturadoUncheckedCreateWithoutBmOpInput>
  }

  export type BmOpFaturadoCreateManyBmOpInputEnvelope = {
    data: BmOpFaturadoCreateManyBmOpInput | BmOpFaturadoCreateManyBmOpInput[]
  }

  export type BmOpsPorMalhaCreateWithoutBmOpInput = {
    BmMovimentosLotes?: BmMovimentosLotesCreateNestedManyWithoutBmOpsPorMalhaInput
    BmMalhas: BmMalhasCreateNestedOneWithoutBmOpsPorMalhaInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaUncheckedCreateWithoutBmOpInput = {
    ref: string
    BmMovimentosLotes?: BmMovimentosLotesUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaCreateOrConnectWithoutBmOpInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    create: XOR<BmOpsPorMalhaCreateWithoutBmOpInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpInput>
  }

  export type BmOpsPorMalhaCreateManyBmOpInputEnvelope = {
    data: BmOpsPorMalhaCreateManyBmOpInput | BmOpsPorMalhaCreateManyBmOpInput[]
  }

  export type BmUpsertWithoutBmOpInput = {
    update: XOR<BmUpdateWithoutBmOpInput, BmUncheckedUpdateWithoutBmOpInput>
    create: XOR<BmCreateWithoutBmOpInput, BmUncheckedCreateWithoutBmOpInput>
    where?: BmWhereInput
  }

  export type BmUpdateToOneWithWhereWithoutBmOpInput = {
    where?: BmWhereInput
    data: XOR<BmUpdateWithoutBmOpInput, BmUncheckedUpdateWithoutBmOpInput>
  }

  export type BmUpdateWithoutBmOpInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmMalhas?: BmMalhasUpdateManyWithoutBmNestedInput
    BmTc?: BmTcUpdateManyWithoutBmNestedInput
  }

  export type BmUncheckedUpdateWithoutBmOpInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmMalhas?: BmMalhasUncheckedUpdateManyWithoutBmNestedInput
    BmTc?: BmTcUncheckedUpdateManyWithoutBmNestedInput
  }

  export type BmOpFaturadoUpsertWithWhereUniqueWithoutBmOpInput = {
    where: BmOpFaturadoWhereUniqueInput
    update: XOR<BmOpFaturadoUpdateWithoutBmOpInput, BmOpFaturadoUncheckedUpdateWithoutBmOpInput>
    create: XOR<BmOpFaturadoCreateWithoutBmOpInput, BmOpFaturadoUncheckedCreateWithoutBmOpInput>
  }

  export type BmOpFaturadoUpdateWithWhereUniqueWithoutBmOpInput = {
    where: BmOpFaturadoWhereUniqueInput
    data: XOR<BmOpFaturadoUpdateWithoutBmOpInput, BmOpFaturadoUncheckedUpdateWithoutBmOpInput>
  }

  export type BmOpFaturadoUpdateManyWithWhereWithoutBmOpInput = {
    where: BmOpFaturadoScalarWhereInput
    data: XOR<BmOpFaturadoUpdateManyMutationInput, BmOpFaturadoUncheckedUpdateManyWithoutBmOpInput>
  }

  export type BmOpFaturadoScalarWhereInput = {
    AND?: BmOpFaturadoScalarWhereInput | BmOpFaturadoScalarWhereInput[]
    OR?: BmOpFaturadoScalarWhereInput[]
    NOT?: BmOpFaturadoScalarWhereInput | BmOpFaturadoScalarWhereInput[]
    idBm?: StringFilter<"BmOpFaturado"> | string
    op?: IntFilter<"BmOpFaturado"> | number
    nFatutura?: IntFilter<"BmOpFaturado"> | number
    fData?: DateTimeFilter<"BmOpFaturado"> | Date | string
    dataFatura?: StringFilter<"BmOpFaturado"> | string
    refModelo?: StringFilter<"BmOpFaturado"> | string
    pedido?: StringFilter<"BmOpFaturado"> | string
    qtt?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFilter<"BmOpFaturado"> | Decimal | DecimalJsLike | number | string
    cmr?: StringFilter<"BmOpFaturado"> | string
    local?: StringFilter<"BmOpFaturado"> | string
    obs?: StringNullableFilter<"BmOpFaturado"> | string | null
  }

  export type BmOpsPorMalhaUpsertWithWhereUniqueWithoutBmOpInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    update: XOR<BmOpsPorMalhaUpdateWithoutBmOpInput, BmOpsPorMalhaUncheckedUpdateWithoutBmOpInput>
    create: XOR<BmOpsPorMalhaCreateWithoutBmOpInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpInput>
  }

  export type BmOpsPorMalhaUpdateWithWhereUniqueWithoutBmOpInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    data: XOR<BmOpsPorMalhaUpdateWithoutBmOpInput, BmOpsPorMalhaUncheckedUpdateWithoutBmOpInput>
  }

  export type BmOpsPorMalhaUpdateManyWithWhereWithoutBmOpInput = {
    where: BmOpsPorMalhaScalarWhereInput
    data: XOR<BmOpsPorMalhaUpdateManyMutationInput, BmOpsPorMalhaUncheckedUpdateManyWithoutBmOpInput>
  }

  export type BmOpCreateWithoutBmOpFaturadoInput = {
    op: number
    CreatedAt?: Date | string
    foto?: string
    Bm: BmCreateNestedOneWithoutBmOpInput
    BmOpsPorMalha?: BmOpsPorMalhaCreateNestedManyWithoutBmOpInput
  }

  export type BmOpUncheckedCreateWithoutBmOpFaturadoInput = {
    idBm: string
    op: number
    CreatedAt?: Date | string
    foto?: string
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedCreateNestedManyWithoutBmOpInput
  }

  export type BmOpCreateOrConnectWithoutBmOpFaturadoInput = {
    where: BmOpWhereUniqueInput
    create: XOR<BmOpCreateWithoutBmOpFaturadoInput, BmOpUncheckedCreateWithoutBmOpFaturadoInput>
  }

  export type BmOpUpsertWithoutBmOpFaturadoInput = {
    update: XOR<BmOpUpdateWithoutBmOpFaturadoInput, BmOpUncheckedUpdateWithoutBmOpFaturadoInput>
    create: XOR<BmOpCreateWithoutBmOpFaturadoInput, BmOpUncheckedCreateWithoutBmOpFaturadoInput>
    where?: BmOpWhereInput
  }

  export type BmOpUpdateToOneWithWhereWithoutBmOpFaturadoInput = {
    where?: BmOpWhereInput
    data: XOR<BmOpUpdateWithoutBmOpFaturadoInput, BmOpUncheckedUpdateWithoutBmOpFaturadoInput>
  }

  export type BmOpUpdateWithoutBmOpFaturadoInput = {
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    Bm?: BmUpdateOneRequiredWithoutBmOpNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmOpNestedInput
  }

  export type BmOpUncheckedUpdateWithoutBmOpFaturadoInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmOpNestedInput
  }

  export type BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMovimentosLotesCreateOrConnectWithoutBmOpsPorMalhaInput = {
    where: BmMovimentosLotesWhereUniqueInput
    create: XOR<BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput>
  }

  export type BmMovimentosLotesCreateManyBmOpsPorMalhaInputEnvelope = {
    data: BmMovimentosLotesCreateManyBmOpsPorMalhaInput | BmMovimentosLotesCreateManyBmOpsPorMalhaInput[]
  }

  export type BmMalhasCreateWithoutBmOpsPorMalhaInput = {
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoCreateNestedManyWithoutBmMalhasInput
    Bm: BmCreateNestedOneWithoutBmMalhasInput
    BmMateriais: BmMateriaisCreateNestedOneWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasUncheckedCreateWithoutBmOpsPorMalhaInput = {
    idBm: string
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedCreateNestedManyWithoutBmMalhasInput
    BmMalhasFio?: BmMalhasFioUncheckedCreateNestedManyWithoutBmMalhasInput
  }

  export type BmMalhasCreateOrConnectWithoutBmOpsPorMalhaInput = {
    where: BmMalhasWhereUniqueInput
    create: XOR<BmMalhasCreateWithoutBmOpsPorMalhaInput, BmMalhasUncheckedCreateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpCreateWithoutBmOpsPorMalhaInput = {
    op: number
    CreatedAt?: Date | string
    foto?: string
    Bm: BmCreateNestedOneWithoutBmOpInput
    BmOpFaturado?: BmOpFaturadoCreateNestedManyWithoutBmOpInput
  }

  export type BmOpUncheckedCreateWithoutBmOpsPorMalhaInput = {
    idBm: string
    op: number
    CreatedAt?: Date | string
    foto?: string
    BmOpFaturado?: BmOpFaturadoUncheckedCreateNestedManyWithoutBmOpInput
  }

  export type BmOpCreateOrConnectWithoutBmOpsPorMalhaInput = {
    where: BmOpWhereUniqueInput
    create: XOR<BmOpCreateWithoutBmOpsPorMalhaInput, BmOpUncheckedCreateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput = {
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosCreateNestedManyWithoutBmOpsPorMalhaFioInput
    BmMalhasFio: BmMalhasFioCreateNestedOneWithoutBmOpsPorMalhaFioInput
  }

  export type BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput = {
    refOrigem: string
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUncheckedCreateNestedManyWithoutBmOpsPorMalhaFioInput
  }

  export type BmOpsPorMalhaFioCreateOrConnectWithoutBmOpsPorMalhaInput = {
    where: BmOpsPorMalhaFioWhereUniqueInput
    create: XOR<BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInputEnvelope = {
    data: BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInput | BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInput[]
  }

  export type BmMovimentosLotesUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput = {
    where: BmMovimentosLotesWhereUniqueInput
    update: XOR<BmMovimentosLotesUpdateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedUpdateWithoutBmOpsPorMalhaInput>
    create: XOR<BmMovimentosLotesCreateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedCreateWithoutBmOpsPorMalhaInput>
  }

  export type BmMovimentosLotesUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput = {
    where: BmMovimentosLotesWhereUniqueInput
    data: XOR<BmMovimentosLotesUpdateWithoutBmOpsPorMalhaInput, BmMovimentosLotesUncheckedUpdateWithoutBmOpsPorMalhaInput>
  }

  export type BmMovimentosLotesUpdateManyWithWhereWithoutBmOpsPorMalhaInput = {
    where: BmMovimentosLotesScalarWhereInput
    data: XOR<BmMovimentosLotesUpdateManyMutationInput, BmMovimentosLotesUncheckedUpdateManyWithoutBmOpsPorMalhaInput>
  }

  export type BmMovimentosLotesScalarWhereInput = {
    AND?: BmMovimentosLotesScalarWhereInput | BmMovimentosLotesScalarWhereInput[]
    OR?: BmMovimentosLotesScalarWhereInput[]
    NOT?: BmMovimentosLotesScalarWhereInput | BmMovimentosLotesScalarWhereInput[]
    idBm?: StringFilter<"BmMovimentosLotes"> | string
    ref?: StringFilter<"BmMovimentosLotes"> | string
    op?: IntFilter<"BmMovimentosLotes"> | number
    idBmMovimentosLote?: StringFilter<"BmMovimentosLotes"> | string
    idMovimento?: StringFilter<"BmMovimentosLotes"> | string
    nMovimento?: IntFilter<"BmMovimentosLotes"> | number
    nome?: StringFilter<"BmMovimentosLotes"> | string
    idTipo?: DecimalFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    tipo?: StringFilter<"BmMovimentosLotes"> | string
    qtt?: DecimalFilter<"BmMovimentosLotes"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMovimentosLotes"> | string
    lote?: StringFilter<"BmMovimentosLotes"> | string
  }

  export type BmMalhasUpsertWithoutBmOpsPorMalhaInput = {
    update: XOR<BmMalhasUpdateWithoutBmOpsPorMalhaInput, BmMalhasUncheckedUpdateWithoutBmOpsPorMalhaInput>
    create: XOR<BmMalhasCreateWithoutBmOpsPorMalhaInput, BmMalhasUncheckedCreateWithoutBmOpsPorMalhaInput>
    where?: BmMalhasWhereInput
  }

  export type BmMalhasUpdateToOneWithWhereWithoutBmOpsPorMalhaInput = {
    where?: BmMalhasWhereInput
    data: XOR<BmMalhasUpdateWithoutBmOpsPorMalhaInput, BmMalhasUncheckedUpdateWithoutBmOpsPorMalhaInput>
  }

  export type BmMalhasUpdateWithoutBmOpsPorMalhaInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUpdateManyWithoutBmMalhasNestedInput
    Bm?: BmUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMateriais?: BmMateriaisUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateWithoutBmOpsPorMalhaInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmOpUpsertWithoutBmOpsPorMalhaInput = {
    update: XOR<BmOpUpdateWithoutBmOpsPorMalhaInput, BmOpUncheckedUpdateWithoutBmOpsPorMalhaInput>
    create: XOR<BmOpCreateWithoutBmOpsPorMalhaInput, BmOpUncheckedCreateWithoutBmOpsPorMalhaInput>
    where?: BmOpWhereInput
  }

  export type BmOpUpdateToOneWithWhereWithoutBmOpsPorMalhaInput = {
    where?: BmOpWhereInput
    data: XOR<BmOpUpdateWithoutBmOpsPorMalhaInput, BmOpUncheckedUpdateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpUpdateWithoutBmOpsPorMalhaInput = {
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    Bm?: BmUpdateOneRequiredWithoutBmOpNestedInput
    BmOpFaturado?: BmOpFaturadoUpdateManyWithoutBmOpNestedInput
  }

  export type BmOpUncheckedUpdateWithoutBmOpsPorMalhaInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    BmOpFaturado?: BmOpFaturadoUncheckedUpdateManyWithoutBmOpNestedInput
  }

  export type BmOpsPorMalhaFioUpsertWithWhereUniqueWithoutBmOpsPorMalhaInput = {
    where: BmOpsPorMalhaFioWhereUniqueInput
    update: XOR<BmOpsPorMalhaFioUpdateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedUpdateWithoutBmOpsPorMalhaInput>
    create: XOR<BmOpsPorMalhaFioCreateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedCreateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpsPorMalhaFioUpdateWithWhereUniqueWithoutBmOpsPorMalhaInput = {
    where: BmOpsPorMalhaFioWhereUniqueInput
    data: XOR<BmOpsPorMalhaFioUpdateWithoutBmOpsPorMalhaInput, BmOpsPorMalhaFioUncheckedUpdateWithoutBmOpsPorMalhaInput>
  }

  export type BmOpsPorMalhaFioUpdateManyWithWhereWithoutBmOpsPorMalhaInput = {
    where: BmOpsPorMalhaFioScalarWhereInput
    data: XOR<BmOpsPorMalhaFioUpdateManyMutationInput, BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmOpsPorMalhaInput>
  }

  export type BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasFioMovimentosCreateOrConnectWithoutBmOpsPorMalhaFioInput = {
    where: BmMalhasFioMovimentosWhereUniqueInput
    create: XOR<BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInputEnvelope = {
    data: BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInput | BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInput[]
  }

  export type BmMalhasFioCreateWithoutBmOpsPorMalhaFioInput = {
    refOrigem: string
    fio: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoCreateNestedManyWithoutBmMalhasFioInput
    BmMalhas: BmMalhasCreateNestedOneWithoutBmMalhasFioInput
    BmMateriaisFio: BmMateriaisFioCreateNestedOneWithoutBmMalhasFioInput
  }

  export type BmMalhasFioUncheckedCreateWithoutBmOpsPorMalhaFioInput = {
    idBm: string
    ref: string
    refOrigem: string
    fio: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    BmFioComposicao?: BmFioComposicaoUncheckedCreateNestedManyWithoutBmMalhasFioInput
  }

  export type BmMalhasFioCreateOrConnectWithoutBmOpsPorMalhaFioInput = {
    where: BmMalhasFioWhereUniqueInput
    create: XOR<BmMalhasFioCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioUncheckedCreateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmOpsPorMalhaCreateWithoutBmOpsPorMalhaFioInput = {
    BmMovimentosLotes?: BmMovimentosLotesCreateNestedManyWithoutBmOpsPorMalhaInput
    BmMalhas: BmMalhasCreateNestedOneWithoutBmOpsPorMalhaInput
    BmOp: BmOpCreateNestedOneWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaUncheckedCreateWithoutBmOpsPorMalhaFioInput = {
    idBm: string
    ref: string
    op: number
    BmMovimentosLotes?: BmMovimentosLotesUncheckedCreateNestedManyWithoutBmOpsPorMalhaInput
  }

  export type BmOpsPorMalhaCreateOrConnectWithoutBmOpsPorMalhaFioInput = {
    where: BmOpsPorMalhaWhereUniqueInput
    create: XOR<BmOpsPorMalhaCreateWithoutBmOpsPorMalhaFioInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmMalhasFioMovimentosUpsertWithWhereUniqueWithoutBmOpsPorMalhaFioInput = {
    where: BmMalhasFioMovimentosWhereUniqueInput
    update: XOR<BmMalhasFioMovimentosUpdateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
    create: XOR<BmMalhasFioMovimentosCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedCreateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmMalhasFioMovimentosUpdateWithWhereUniqueWithoutBmOpsPorMalhaFioInput = {
    where: BmMalhasFioMovimentosWhereUniqueInput
    data: XOR<BmMalhasFioMovimentosUpdateWithoutBmOpsPorMalhaFioInput, BmMalhasFioMovimentosUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmMalhasFioMovimentosUpdateManyWithWhereWithoutBmOpsPorMalhaFioInput = {
    where: BmMalhasFioMovimentosScalarWhereInput
    data: XOR<BmMalhasFioMovimentosUpdateManyMutationInput, BmMalhasFioMovimentosUncheckedUpdateManyWithoutBmOpsPorMalhaFioInput>
  }

  export type BmMalhasFioMovimentosScalarWhereInput = {
    AND?: BmMalhasFioMovimentosScalarWhereInput | BmMalhasFioMovimentosScalarWhereInput[]
    OR?: BmMalhasFioMovimentosScalarWhereInput[]
    NOT?: BmMalhasFioMovimentosScalarWhereInput | BmMalhasFioMovimentosScalarWhereInput[]
    idBm?: StringFilter<"BmMalhasFioMovimentos"> | string
    ref?: StringFilter<"BmMalhasFioMovimentos"> | string
    refOrigem?: StringFilter<"BmMalhasFioMovimentos"> | string
    op?: IntFilter<"BmMalhasFioMovimentos"> | number
    idBmMovimentosLote?: StringFilter<"BmMalhasFioMovimentos"> | string
    idMovimento?: StringFilter<"BmMalhasFioMovimentos"> | string
    nMovimento?: IntFilter<"BmMalhasFioMovimentos"> | number
    nome?: StringFilter<"BmMalhasFioMovimentos"> | string
    idTipo?: DecimalFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    tipo?: StringFilter<"BmMalhasFioMovimentos"> | string
    qtt?: DecimalFilter<"BmMalhasFioMovimentos"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"BmMalhasFioMovimentos"> | string
    lote?: StringFilter<"BmMalhasFioMovimentos"> | string
  }

  export type BmMalhasFioUpsertWithoutBmOpsPorMalhaFioInput = {
    update: XOR<BmMalhasFioUpdateWithoutBmOpsPorMalhaFioInput, BmMalhasFioUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
    create: XOR<BmMalhasFioCreateWithoutBmOpsPorMalhaFioInput, BmMalhasFioUncheckedCreateWithoutBmOpsPorMalhaFioInput>
    where?: BmMalhasFioWhereInput
  }

  export type BmMalhasFioUpdateToOneWithWhereWithoutBmOpsPorMalhaFioInput = {
    where?: BmMalhasFioWhereInput
    data: XOR<BmMalhasFioUpdateWithoutBmOpsPorMalhaFioInput, BmMalhasFioUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmMalhasFioUpdateWithoutBmOpsPorMalhaFioInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUpdateManyWithoutBmMalhasFioNestedInput
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmMalhasFioNestedInput
    BmMateriaisFio?: BmMateriaisFioUpdateOneRequiredWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioUncheckedUpdateWithoutBmOpsPorMalhaFioInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUncheckedUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmOpsPorMalhaUpsertWithoutBmOpsPorMalhaFioInput = {
    update: XOR<BmOpsPorMalhaUpdateWithoutBmOpsPorMalhaFioInput, BmOpsPorMalhaUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
    create: XOR<BmOpsPorMalhaCreateWithoutBmOpsPorMalhaFioInput, BmOpsPorMalhaUncheckedCreateWithoutBmOpsPorMalhaFioInput>
    where?: BmOpsPorMalhaWhereInput
  }

  export type BmOpsPorMalhaUpdateToOneWithWhereWithoutBmOpsPorMalhaFioInput = {
    where?: BmOpsPorMalhaWhereInput
    data: XOR<BmOpsPorMalhaUpdateWithoutBmOpsPorMalhaFioInput, BmOpsPorMalhaUncheckedUpdateWithoutBmOpsPorMalhaFioInput>
  }

  export type BmOpsPorMalhaUpdateWithoutBmOpsPorMalhaFioInput = {
    BmMovimentosLotes?: BmMovimentosLotesUpdateManyWithoutBmOpsPorMalhaNestedInput
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
    BmOp?: BmOpUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaUncheckedUpdateWithoutBmOpsPorMalhaFioInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    BmMovimentosLotes?: BmMovimentosLotesUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmCreateWithoutBmTcInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmMalhas?: BmMalhasCreateNestedManyWithoutBmInput
    BmOp?: BmOpCreateNestedManyWithoutBmInput
  }

  export type BmUncheckedCreateWithoutBmTcInput = {
    idBm?: string
    composicao: string
    fechado?: boolean
    CreatedAt?: Date | string
    BmMalhas?: BmMalhasUncheckedCreateNestedManyWithoutBmInput
    BmOp?: BmOpUncheckedCreateNestedManyWithoutBmInput
  }

  export type BmCreateOrConnectWithoutBmTcInput = {
    where: BmWhereUniqueInput
    create: XOR<BmCreateWithoutBmTcInput, BmUncheckedCreateWithoutBmTcInput>
  }

  export type BmUpsertWithoutBmTcInput = {
    update: XOR<BmUpdateWithoutBmTcInput, BmUncheckedUpdateWithoutBmTcInput>
    create: XOR<BmCreateWithoutBmTcInput, BmUncheckedCreateWithoutBmTcInput>
    where?: BmWhereInput
  }

  export type BmUpdateToOneWithWhereWithoutBmTcInput = {
    where?: BmWhereInput
    data: XOR<BmUpdateWithoutBmTcInput, BmUncheckedUpdateWithoutBmTcInput>
  }

  export type BmUpdateWithoutBmTcInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmMalhas?: BmMalhasUpdateManyWithoutBmNestedInput
    BmOp?: BmOpUpdateManyWithoutBmNestedInput
  }

  export type BmUncheckedUpdateWithoutBmTcInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    composicao?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BmMalhas?: BmMalhasUncheckedUpdateManyWithoutBmNestedInput
    BmOp?: BmOpUncheckedUpdateManyWithoutBmNestedInput
  }

  export type PlaneamentoCreateWithoutDataCamiaoInput = {
    idPlaneamento?: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataEnvio?: DataEnvioCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreCreateNestedManyWithoutPlaneamentoInput
    Op?: OpCreateNestedManyWithoutPlaneamentoInput
    Fornecedor: FornecedorCreateNestedOneWithoutPlaneamentoInput
    User: UserCreateNestedOneWithoutPlaneamentoInput
  }

  export type PlaneamentoUncheckedCreateWithoutDataCamiaoInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreUncheckedCreateNestedManyWithoutPlaneamentoInput
    Op?: OpUncheckedCreateNestedManyWithoutPlaneamentoInput
  }

  export type PlaneamentoCreateOrConnectWithoutDataCamiaoInput = {
    where: PlaneamentoWhereUniqueInput
    create: XOR<PlaneamentoCreateWithoutDataCamiaoInput, PlaneamentoUncheckedCreateWithoutDataCamiaoInput>
  }

  export type UserCreateWithoutDataCamiaoInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataEnvio?: DataEnvioCreateNestedManyWithoutUserInput
    Livre?: LivreCreateNestedManyWithoutUserInput
    Op?: OpCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDataCamiaoInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutUserInput
    Livre?: LivreUncheckedCreateNestedManyWithoutUserInput
    Op?: OpUncheckedCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoUncheckedCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDataCamiaoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataCamiaoInput, UserUncheckedCreateWithoutDataCamiaoInput>
  }

  export type PlaneamentoUpsertWithoutDataCamiaoInput = {
    update: XOR<PlaneamentoUpdateWithoutDataCamiaoInput, PlaneamentoUncheckedUpdateWithoutDataCamiaoInput>
    create: XOR<PlaneamentoCreateWithoutDataCamiaoInput, PlaneamentoUncheckedCreateWithoutDataCamiaoInput>
    where?: PlaneamentoWhereInput
  }

  export type PlaneamentoUpdateToOneWithWhereWithoutDataCamiaoInput = {
    where?: PlaneamentoWhereInput
    data: XOR<PlaneamentoUpdateWithoutDataCamiaoInput, PlaneamentoUncheckedUpdateWithoutDataCamiaoInput>
  }

  export type PlaneamentoUpdateWithoutDataCamiaoInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataEnvio?: DataEnvioUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUpdateManyWithoutPlaneamentoNestedInput
    Fornecedor?: FornecedorUpdateOneRequiredWithoutPlaneamentoNestedInput
    User?: UserUpdateOneRequiredWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateWithoutDataCamiaoInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUncheckedUpdateManyWithoutPlaneamentoNestedInput
  }

  export type UserUpsertWithoutDataCamiaoInput = {
    update: XOR<UserUpdateWithoutDataCamiaoInput, UserUncheckedUpdateWithoutDataCamiaoInput>
    create: XOR<UserCreateWithoutDataCamiaoInput, UserUncheckedCreateWithoutDataCamiaoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataCamiaoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataCamiaoInput, UserUncheckedUpdateWithoutDataCamiaoInput>
  }

  export type UserUpdateWithoutDataCamiaoInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataEnvio?: DataEnvioUpdateManyWithoutUserNestedInput
    Livre?: LivreUpdateManyWithoutUserNestedInput
    Op?: OpUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDataCamiaoInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutUserNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutUserNestedInput
    Op?: OpUncheckedUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUncheckedUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaneamentoCreateWithoutDataEnvioInput = {
    idPlaneamento?: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreCreateNestedManyWithoutPlaneamentoInput
    Op?: OpCreateNestedManyWithoutPlaneamentoInput
    Fornecedor: FornecedorCreateNestedOneWithoutPlaneamentoInput
    User: UserCreateNestedOneWithoutPlaneamentoInput
  }

  export type PlaneamentoUncheckedCreateWithoutDataEnvioInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreUncheckedCreateNestedManyWithoutPlaneamentoInput
    Op?: OpUncheckedCreateNestedManyWithoutPlaneamentoInput
  }

  export type PlaneamentoCreateOrConnectWithoutDataEnvioInput = {
    where: PlaneamentoWhereUniqueInput
    create: XOR<PlaneamentoCreateWithoutDataEnvioInput, PlaneamentoUncheckedCreateWithoutDataEnvioInput>
  }

  export type UserCreateWithoutDataEnvioInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoCreateNestedManyWithoutUserInput
    Livre?: LivreCreateNestedManyWithoutUserInput
    Op?: OpCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDataEnvioInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutUserInput
    Livre?: LivreUncheckedCreateNestedManyWithoutUserInput
    Op?: OpUncheckedCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoUncheckedCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDataEnvioInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDataEnvioInput, UserUncheckedCreateWithoutDataEnvioInput>
  }

  export type PlaneamentoUpsertWithoutDataEnvioInput = {
    update: XOR<PlaneamentoUpdateWithoutDataEnvioInput, PlaneamentoUncheckedUpdateWithoutDataEnvioInput>
    create: XOR<PlaneamentoCreateWithoutDataEnvioInput, PlaneamentoUncheckedCreateWithoutDataEnvioInput>
    where?: PlaneamentoWhereInput
  }

  export type PlaneamentoUpdateToOneWithWhereWithoutDataEnvioInput = {
    where?: PlaneamentoWhereInput
    data: XOR<PlaneamentoUpdateWithoutDataEnvioInput, PlaneamentoUncheckedUpdateWithoutDataEnvioInput>
  }

  export type PlaneamentoUpdateWithoutDataEnvioInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUpdateManyWithoutPlaneamentoNestedInput
    Fornecedor?: FornecedorUpdateOneRequiredWithoutPlaneamentoNestedInput
    User?: UserUpdateOneRequiredWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateWithoutDataEnvioInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUncheckedUpdateManyWithoutPlaneamentoNestedInput
  }

  export type UserUpsertWithoutDataEnvioInput = {
    update: XOR<UserUpdateWithoutDataEnvioInput, UserUncheckedUpdateWithoutDataEnvioInput>
    create: XOR<UserCreateWithoutDataEnvioInput, UserUncheckedCreateWithoutDataEnvioInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDataEnvioInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDataEnvioInput, UserUncheckedUpdateWithoutDataEnvioInput>
  }

  export type UserUpdateWithoutDataEnvioInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUpdateManyWithoutUserNestedInput
    Livre?: LivreUpdateManyWithoutUserNestedInput
    Op?: OpUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDataEnvioInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutUserNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutUserNestedInput
    Op?: OpUncheckedUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUncheckedUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PlaneamentoCreateWithoutFornecedorInput = {
    idPlaneamento?: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreCreateNestedManyWithoutPlaneamentoInput
    Op?: OpCreateNestedManyWithoutPlaneamentoInput
    User: UserCreateNestedOneWithoutPlaneamentoInput
  }

  export type PlaneamentoUncheckedCreateWithoutFornecedorInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreUncheckedCreateNestedManyWithoutPlaneamentoInput
    Op?: OpUncheckedCreateNestedManyWithoutPlaneamentoInput
  }

  export type PlaneamentoCreateOrConnectWithoutFornecedorInput = {
    where: PlaneamentoWhereUniqueInput
    create: XOR<PlaneamentoCreateWithoutFornecedorInput, PlaneamentoUncheckedCreateWithoutFornecedorInput>
  }

  export type PlaneamentoCreateManyFornecedorInputEnvelope = {
    data: PlaneamentoCreateManyFornecedorInput | PlaneamentoCreateManyFornecedorInput[]
  }

  export type PlaneamentoUpsertWithWhereUniqueWithoutFornecedorInput = {
    where: PlaneamentoWhereUniqueInput
    update: XOR<PlaneamentoUpdateWithoutFornecedorInput, PlaneamentoUncheckedUpdateWithoutFornecedorInput>
    create: XOR<PlaneamentoCreateWithoutFornecedorInput, PlaneamentoUncheckedCreateWithoutFornecedorInput>
  }

  export type PlaneamentoUpdateWithWhereUniqueWithoutFornecedorInput = {
    where: PlaneamentoWhereUniqueInput
    data: XOR<PlaneamentoUpdateWithoutFornecedorInput, PlaneamentoUncheckedUpdateWithoutFornecedorInput>
  }

  export type PlaneamentoUpdateManyWithWhereWithoutFornecedorInput = {
    where: PlaneamentoScalarWhereInput
    data: XOR<PlaneamentoUpdateManyMutationInput, PlaneamentoUncheckedUpdateManyWithoutFornecedorInput>
  }

  export type PlaneamentoScalarWhereInput = {
    AND?: PlaneamentoScalarWhereInput | PlaneamentoScalarWhereInput[]
    OR?: PlaneamentoScalarWhereInput[]
    NOT?: PlaneamentoScalarWhereInput | PlaneamentoScalarWhereInput[]
    idPlaneamento?: StringFilter<"Planeamento"> | string
    nomeUser?: StringFilter<"Planeamento"> | string
    pais?: StringFilter<"Planeamento"> | string
    idFornecedor?: StringFilter<"Planeamento"> | string
    numeroPecas?: IntFilter<"Planeamento"> | number
    modelo?: StringFilter<"Planeamento"> | string
    obs?: StringFilter<"Planeamento"> | string
    cliente?: StringFilter<"Planeamento"> | string
    dataPrimeiroCamiao?: DateTimeNullableFilter<"Planeamento"> | Date | string | null
    dataPrimeiroEnvio?: DateTimeNullableFilter<"Planeamento"> | Date | string | null
    dataCriacao?: DateTimeFilter<"Planeamento"> | Date | string
    dataUltimaAlteracao?: DateTimeFilter<"Planeamento"> | Date | string
    envioEnviado?: BoolFilter<"Planeamento"> | boolean
  }

  export type PlaneamentoCreateWithoutLivreInput = {
    idPlaneamento?: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutPlaneamentoInput
    Op?: OpCreateNestedManyWithoutPlaneamentoInput
    Fornecedor: FornecedorCreateNestedOneWithoutPlaneamentoInput
    User: UserCreateNestedOneWithoutPlaneamentoInput
  }

  export type PlaneamentoUncheckedCreateWithoutLivreInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutPlaneamentoInput
    Op?: OpUncheckedCreateNestedManyWithoutPlaneamentoInput
  }

  export type PlaneamentoCreateOrConnectWithoutLivreInput = {
    where: PlaneamentoWhereUniqueInput
    create: XOR<PlaneamentoCreateWithoutLivreInput, PlaneamentoUncheckedCreateWithoutLivreInput>
  }

  export type UserCreateWithoutLivreInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutUserInput
    Op?: OpCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLivreInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutUserInput
    Op?: OpUncheckedCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoUncheckedCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLivreInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLivreInput, UserUncheckedCreateWithoutLivreInput>
  }

  export type OrcamentoLivreCreateWithoutLivreInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasCreateNestedManyWithoutOrcamentoLivreInput
  }

  export type OrcamentoLivreUncheckedCreateWithoutLivreInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUncheckedCreateNestedManyWithoutOrcamentoLivreInput
  }

  export type OrcamentoLivreCreateOrConnectWithoutLivreInput = {
    where: OrcamentoLivreWhereUniqueInput
    create: XOR<OrcamentoLivreCreateWithoutLivreInput, OrcamentoLivreUncheckedCreateWithoutLivreInput>
  }

  export type ServicosEscolhidosLivreCreateWithoutLivreInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemCreateNestedManyWithoutServicosEscolhidosLivreInput
  }

  export type ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedCreateNestedManyWithoutServicosEscolhidosLivreInput
  }

  export type ServicosEscolhidosLivreCreateOrConnectWithoutLivreInput = {
    where: ServicosEscolhidosLivreWhereUniqueInput
    create: XOR<ServicosEscolhidosLivreCreateWithoutLivreInput, ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput>
  }

  export type ServicosEscolhidosLivreCreateManyLivreInputEnvelope = {
    data: ServicosEscolhidosLivreCreateManyLivreInput | ServicosEscolhidosLivreCreateManyLivreInput[]
  }

  export type PlaneamentoUpsertWithoutLivreInput = {
    update: XOR<PlaneamentoUpdateWithoutLivreInput, PlaneamentoUncheckedUpdateWithoutLivreInput>
    create: XOR<PlaneamentoCreateWithoutLivreInput, PlaneamentoUncheckedCreateWithoutLivreInput>
    where?: PlaneamentoWhereInput
  }

  export type PlaneamentoUpdateToOneWithWhereWithoutLivreInput = {
    where?: PlaneamentoWhereInput
    data: XOR<PlaneamentoUpdateWithoutLivreInput, PlaneamentoUncheckedUpdateWithoutLivreInput>
  }

  export type PlaneamentoUpdateWithoutLivreInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUpdateManyWithoutPlaneamentoNestedInput
    Fornecedor?: FornecedorUpdateOneRequiredWithoutPlaneamentoNestedInput
    User?: UserUpdateOneRequiredWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateWithoutLivreInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUncheckedUpdateManyWithoutPlaneamentoNestedInput
  }

  export type UserUpsertWithoutLivreInput = {
    update: XOR<UserUpdateWithoutLivreInput, UserUncheckedUpdateWithoutLivreInput>
    create: XOR<UserCreateWithoutLivreInput, UserUncheckedCreateWithoutLivreInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLivreInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLivreInput, UserUncheckedUpdateWithoutLivreInput>
  }

  export type UserUpdateWithoutLivreInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutUserNestedInput
    Op?: OpUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLivreInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutUserNestedInput
    Op?: OpUncheckedUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUncheckedUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrcamentoLivreUpsertWithoutLivreInput = {
    update: XOR<OrcamentoLivreUpdateWithoutLivreInput, OrcamentoLivreUncheckedUpdateWithoutLivreInput>
    create: XOR<OrcamentoLivreCreateWithoutLivreInput, OrcamentoLivreUncheckedCreateWithoutLivreInput>
    where?: OrcamentoLivreWhereInput
  }

  export type OrcamentoLivreUpdateToOneWithWhereWithoutLivreInput = {
    where?: OrcamentoLivreWhereInput
    data: XOR<OrcamentoLivreUpdateWithoutLivreInput, OrcamentoLivreUncheckedUpdateWithoutLivreInput>
  }

  export type OrcamentoLivreUpdateWithoutLivreInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUpdateManyWithoutOrcamentoLivreNestedInput
  }

  export type OrcamentoLivreUncheckedUpdateWithoutLivreInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUncheckedUpdateManyWithoutOrcamentoLivreNestedInput
  }

  export type ServicosEscolhidosLivreUpsertWithWhereUniqueWithoutLivreInput = {
    where: ServicosEscolhidosLivreWhereUniqueInput
    update: XOR<ServicosEscolhidosLivreUpdateWithoutLivreInput, ServicosEscolhidosLivreUncheckedUpdateWithoutLivreInput>
    create: XOR<ServicosEscolhidosLivreCreateWithoutLivreInput, ServicosEscolhidosLivreUncheckedCreateWithoutLivreInput>
  }

  export type ServicosEscolhidosLivreUpdateWithWhereUniqueWithoutLivreInput = {
    where: ServicosEscolhidosLivreWhereUniqueInput
    data: XOR<ServicosEscolhidosLivreUpdateWithoutLivreInput, ServicosEscolhidosLivreUncheckedUpdateWithoutLivreInput>
  }

  export type ServicosEscolhidosLivreUpdateManyWithWhereWithoutLivreInput = {
    where: ServicosEscolhidosLivreScalarWhereInput
    data: XOR<ServicosEscolhidosLivreUpdateManyMutationInput, ServicosEscolhidosLivreUncheckedUpdateManyWithoutLivreInput>
  }

  export type ServicosEscolhidosLivreScalarWhereInput = {
    AND?: ServicosEscolhidosLivreScalarWhereInput | ServicosEscolhidosLivreScalarWhereInput[]
    OR?: ServicosEscolhidosLivreScalarWhereInput[]
    NOT?: ServicosEscolhidosLivreScalarWhereInput | ServicosEscolhidosLivreScalarWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosLivre"> | string
    idLivre?: StringFilter<"ServicosEscolhidosLivre"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosLivre"> | string
    nome?: StringFilter<"ServicosEscolhidosLivre"> | string
    qtt?: FloatFilter<"ServicosEscolhidosLivre"> | number
    preco?: FloatFilter<"ServicosEscolhidosLivre"> | number
    valor?: FloatFilter<"ServicosEscolhidosLivre"> | number
    unidade?: StringFilter<"ServicosEscolhidosLivre"> | string
    obs?: StringFilter<"ServicosEscolhidosLivre"> | string
  }

  export type PlaneamentoCreateWithoutOpInput = {
    idPlaneamento?: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreCreateNestedManyWithoutPlaneamentoInput
    Fornecedor: FornecedorCreateNestedOneWithoutPlaneamentoInput
    User: UserCreateNestedOneWithoutPlaneamentoInput
  }

  export type PlaneamentoUncheckedCreateWithoutOpInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreUncheckedCreateNestedManyWithoutPlaneamentoInput
  }

  export type PlaneamentoCreateOrConnectWithoutOpInput = {
    where: PlaneamentoWhereUniqueInput
    create: XOR<PlaneamentoCreateWithoutOpInput, PlaneamentoUncheckedCreateWithoutOpInput>
  }

  export type UserCreateWithoutOpInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutUserInput
    Livre?: LivreCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutOpInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutUserInput
    Livre?: LivreUncheckedCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoUncheckedCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutOpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOpInput, UserUncheckedCreateWithoutOpInput>
  }

  export type OrcamentoOpCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    OrcamentoOpLinhas?: OrcamentoOpLinhasCreateNestedManyWithoutOrcamentoOpInput
  }

  export type OrcamentoOpUncheckedCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    OrcamentoOpLinhas?: OrcamentoOpLinhasUncheckedCreateNestedManyWithoutOrcamentoOpInput
  }

  export type OrcamentoOpCreateOrConnectWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    where: OrcamentoOpWhereUniqueInput
    create: XOR<OrcamentoOpCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemCreateNestedManyWithoutServicosEscolhidosOpInput
  }

  export type ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedCreateNestedManyWithoutServicosEscolhidosOpInput
  }

  export type ServicosEscolhidosOpCreateOrConnectWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    where: ServicosEscolhidosOpWhereUniqueInput
    create: XOR<ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInputEnvelope = {
    data: ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput | ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput[]
  }

  export type PlaneamentoUpsertWithoutOpInput = {
    update: XOR<PlaneamentoUpdateWithoutOpInput, PlaneamentoUncheckedUpdateWithoutOpInput>
    create: XOR<PlaneamentoCreateWithoutOpInput, PlaneamentoUncheckedCreateWithoutOpInput>
    where?: PlaneamentoWhereInput
  }

  export type PlaneamentoUpdateToOneWithWhereWithoutOpInput = {
    where?: PlaneamentoWhereInput
    data: XOR<PlaneamentoUpdateWithoutOpInput, PlaneamentoUncheckedUpdateWithoutOpInput>
  }

  export type PlaneamentoUpdateWithoutOpInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUpdateManyWithoutPlaneamentoNestedInput
    Fornecedor?: FornecedorUpdateOneRequiredWithoutPlaneamentoNestedInput
    User?: UserUpdateOneRequiredWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateWithoutOpInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutPlaneamentoNestedInput
  }

  export type UserUpsertWithoutOpInput = {
    update: XOR<UserUpdateWithoutOpInput, UserUncheckedUpdateWithoutOpInput>
    create: XOR<UserCreateWithoutOpInput, UserUncheckedCreateWithoutOpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOpInput, UserUncheckedUpdateWithoutOpInput>
  }

  export type UserUpdateWithoutOpInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutUserNestedInput
    Livre?: LivreUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutOpInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutUserNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUncheckedUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OrcamentoOpUpsertWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    update: XOR<OrcamentoOpUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    create: XOR<OrcamentoOpCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedCreateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    where?: OrcamentoOpWhereInput
  }

  export type OrcamentoOpUpdateToOneWithWhereWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    where?: OrcamentoOpWhereInput
    data: XOR<OrcamentoOpUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput, OrcamentoOpUncheckedUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput>
  }

  export type OrcamentoOpUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    OrcamentoOpLinhas?: OrcamentoOpLinhasUpdateManyWithoutOrcamentoOpNestedInput
  }

  export type OrcamentoOpUncheckedUpdateWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    OrcamentoOpLinhas?: OrcamentoOpLinhasUncheckedUpdateManyWithoutOrcamentoOpNestedInput
  }

  export type ServicosEscolhidosOpUpsertWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    where: ServicosEscolhidosOpWhereUniqueInput
    update: XOR<ServicosEscolhidosOpUpdateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedUpdateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
    create: XOR<ServicosEscolhidosOpCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedCreateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpUpdateWithWhereUniqueWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    where: ServicosEscolhidosOpWhereUniqueInput
    data: XOR<ServicosEscolhidosOpUpdateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, ServicosEscolhidosOpUncheckedUpdateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpUpdateManyWithWhereWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    where: ServicosEscolhidosOpScalarWhereInput
    data: XOR<ServicosEscolhidosOpUpdateManyMutationInput, ServicosEscolhidosOpUncheckedUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpScalarWhereInput = {
    AND?: ServicosEscolhidosOpScalarWhereInput | ServicosEscolhidosOpScalarWhereInput[]
    OR?: ServicosEscolhidosOpScalarWhereInput[]
    NOT?: ServicosEscolhidosOpScalarWhereInput | ServicosEscolhidosOpScalarWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosOp"> | string
    Op?: StringFilter<"ServicosEscolhidosOp"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosOp"> | string
    nome?: StringFilter<"ServicosEscolhidosOp"> | string
    qtt?: FloatFilter<"ServicosEscolhidosOp"> | number
    preco?: FloatFilter<"ServicosEscolhidosOp"> | number
    valor?: FloatFilter<"ServicosEscolhidosOp"> | number
    unidade?: StringFilter<"ServicosEscolhidosOp"> | string
    obs?: StringFilter<"ServicosEscolhidosOp"> | string
  }

  export type LivreCreateWithoutOrcamentoLivreInput = {
    idLivre?: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutLivreInput
    User: UserCreateNestedOneWithoutLivreInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreCreateNestedManyWithoutLivreInput
  }

  export type LivreUncheckedCreateWithoutOrcamentoLivreInput = {
    idPlaneamento: string
    idLivre?: string
    nomeUser: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedCreateNestedManyWithoutLivreInput
  }

  export type LivreCreateOrConnectWithoutOrcamentoLivreInput = {
    where: LivreWhereUniqueInput
    create: XOR<LivreCreateWithoutOrcamentoLivreInput, LivreUncheckedCreateWithoutOrcamentoLivreInput>
  }

  export type OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemCreateNestedManyWithoutOrcamentoLivreLinhasInput
  }

  export type OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedCreateNestedManyWithoutOrcamentoLivreLinhasInput
  }

  export type OrcamentoLivreLinhasCreateOrConnectWithoutOrcamentoLivreInput = {
    where: OrcamentoLivreLinhasWhereUniqueInput
    create: XOR<OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput>
  }

  export type OrcamentoLivreLinhasCreateManyOrcamentoLivreInputEnvelope = {
    data: OrcamentoLivreLinhasCreateManyOrcamentoLivreInput | OrcamentoLivreLinhasCreateManyOrcamentoLivreInput[]
  }

  export type LivreUpsertWithoutOrcamentoLivreInput = {
    update: XOR<LivreUpdateWithoutOrcamentoLivreInput, LivreUncheckedUpdateWithoutOrcamentoLivreInput>
    create: XOR<LivreCreateWithoutOrcamentoLivreInput, LivreUncheckedCreateWithoutOrcamentoLivreInput>
    where?: LivreWhereInput
  }

  export type LivreUpdateToOneWithWhereWithoutOrcamentoLivreInput = {
    where?: LivreWhereInput
    data: XOR<LivreUpdateWithoutOrcamentoLivreInput, LivreUncheckedUpdateWithoutOrcamentoLivreInput>
  }

  export type LivreUpdateWithoutOrcamentoLivreInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutLivreNestedInput
    User?: UserUpdateOneRequiredWithoutLivreNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUpdateManyWithoutLivreNestedInput
  }

  export type LivreUncheckedUpdateWithoutOrcamentoLivreInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedUpdateManyWithoutLivreNestedInput
  }

  export type OrcamentoLivreLinhasUpsertWithWhereUniqueWithoutOrcamentoLivreInput = {
    where: OrcamentoLivreLinhasWhereUniqueInput
    update: XOR<OrcamentoLivreLinhasUpdateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedUpdateWithoutOrcamentoLivreInput>
    create: XOR<OrcamentoLivreLinhasCreateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedCreateWithoutOrcamentoLivreInput>
  }

  export type OrcamentoLivreLinhasUpdateWithWhereUniqueWithoutOrcamentoLivreInput = {
    where: OrcamentoLivreLinhasWhereUniqueInput
    data: XOR<OrcamentoLivreLinhasUpdateWithoutOrcamentoLivreInput, OrcamentoLivreLinhasUncheckedUpdateWithoutOrcamentoLivreInput>
  }

  export type OrcamentoLivreLinhasUpdateManyWithWhereWithoutOrcamentoLivreInput = {
    where: OrcamentoLivreLinhasScalarWhereInput
    data: XOR<OrcamentoLivreLinhasUpdateManyMutationInput, OrcamentoLivreLinhasUncheckedUpdateManyWithoutOrcamentoLivreInput>
  }

  export type OrcamentoLivreLinhasScalarWhereInput = {
    AND?: OrcamentoLivreLinhasScalarWhereInput | OrcamentoLivreLinhasScalarWhereInput[]
    OR?: OrcamentoLivreLinhasScalarWhereInput[]
    NOT?: OrcamentoLivreLinhasScalarWhereInput | OrcamentoLivreLinhasScalarWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoLivreLinhas"> | string
    idLivre?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoStamp?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoLinhasStamp?: StringFilter<"OrcamentoLivreLinhas"> | string
    orcamentoLinhasStampRecebido?: StringFilter<"OrcamentoLivreLinhas"> | string
    ordem?: IntFilter<"OrcamentoLivreLinhas"> | number
    design?: StringFilter<"OrcamentoLivreLinhas"> | string
    custoPeca?: FloatFilter<"OrcamentoLivreLinhas"> | number
    edebito?: FloatFilter<"OrcamentoLivreLinhas"> | number
    qtt?: FloatFilter<"OrcamentoLivreLinhas"> | number
    unidade?: StringFilter<"OrcamentoLivreLinhas"> | string
  }

  export type OrcamentoLivreCreateWithoutOrcamentoLivreLinhasInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    Livre: LivreCreateNestedOneWithoutOrcamentoLivreInput
  }

  export type OrcamentoLivreUncheckedCreateWithoutOrcamentoLivreLinhasInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
  }

  export type OrcamentoLivreCreateOrConnectWithoutOrcamentoLivreLinhasInput = {
    where: OrcamentoLivreWhereUniqueInput
    create: XOR<OrcamentoLivreCreateWithoutOrcamentoLivreLinhasInput, OrcamentoLivreUncheckedCreateWithoutOrcamentoLivreLinhasInput>
  }

  export type ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput = {
    ServicosEscolhidosLivre: ServicosEscolhidosLivreCreateNestedOneWithoutServicosEscolhidosLivreOrigemInput
  }

  export type ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
  }

  export type ServicosEscolhidosLivreOrigemCreateOrConnectWithoutOrcamentoLivreLinhasInput = {
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
    create: XOR<ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput>
  }

  export type ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInputEnvelope = {
    data: ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInput | ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInput[]
  }

  export type OrcamentoLivreUpsertWithoutOrcamentoLivreLinhasInput = {
    update: XOR<OrcamentoLivreUpdateWithoutOrcamentoLivreLinhasInput, OrcamentoLivreUncheckedUpdateWithoutOrcamentoLivreLinhasInput>
    create: XOR<OrcamentoLivreCreateWithoutOrcamentoLivreLinhasInput, OrcamentoLivreUncheckedCreateWithoutOrcamentoLivreLinhasInput>
    where?: OrcamentoLivreWhereInput
  }

  export type OrcamentoLivreUpdateToOneWithWhereWithoutOrcamentoLivreLinhasInput = {
    where?: OrcamentoLivreWhereInput
    data: XOR<OrcamentoLivreUpdateWithoutOrcamentoLivreLinhasInput, OrcamentoLivreUncheckedUpdateWithoutOrcamentoLivreLinhasInput>
  }

  export type OrcamentoLivreUpdateWithoutOrcamentoLivreLinhasInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    Livre?: LivreUpdateOneRequiredWithoutOrcamentoLivreNestedInput
  }

  export type OrcamentoLivreUncheckedUpdateWithoutOrcamentoLivreLinhasInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutOrcamentoLivreLinhasInput = {
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
    update: XOR<ServicosEscolhidosLivreOrigemUpdateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedUpdateWithoutOrcamentoLivreLinhasInput>
    create: XOR<ServicosEscolhidosLivreOrigemCreateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutOrcamentoLivreLinhasInput>
  }

  export type ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutOrcamentoLivreLinhasInput = {
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
    data: XOR<ServicosEscolhidosLivreOrigemUpdateWithoutOrcamentoLivreLinhasInput, ServicosEscolhidosLivreOrigemUncheckedUpdateWithoutOrcamentoLivreLinhasInput>
  }

  export type ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutOrcamentoLivreLinhasInput = {
    where: ServicosEscolhidosLivreOrigemScalarWhereInput
    data: XOR<ServicosEscolhidosLivreOrigemUpdateManyMutationInput, ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutOrcamentoLivreLinhasInput>
  }

  export type ServicosEscolhidosLivreOrigemScalarWhereInput = {
    AND?: ServicosEscolhidosLivreOrigemScalarWhereInput | ServicosEscolhidosLivreOrigemScalarWhereInput[]
    OR?: ServicosEscolhidosLivreOrigemScalarWhereInput[]
    NOT?: ServicosEscolhidosLivreOrigemScalarWhereInput | ServicosEscolhidosLivreOrigemScalarWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    idLivre?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
    orcamentoLinhasStamp?: StringFilter<"ServicosEscolhidosLivreOrigem"> | string
  }

  export type OpCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    Op: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutOpInput
    User: UserCreateNestedOneWithoutOpInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpUncheckedCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    idPlaneamento: string
    Op: string
    nomeUser: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpCreateOrConnectWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    where: OpWhereUniqueInput
    create: XOR<OpCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>
  }

  export type OrcamentoOpLinhasCreateWithoutOrcamentoOpInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemCreateNestedManyWithoutOrcamentoOpLinhasInput
  }

  export type OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedCreateNestedManyWithoutOrcamentoOpLinhasInput
  }

  export type OrcamentoOpLinhasCreateOrConnectWithoutOrcamentoOpInput = {
    where: OrcamentoOpLinhasWhereUniqueInput
    create: XOR<OrcamentoOpLinhasCreateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput>
  }

  export type OrcamentoOpLinhasCreateManyOrcamentoOpInputEnvelope = {
    data: OrcamentoOpLinhasCreateManyOrcamentoOpInput | OrcamentoOpLinhasCreateManyOrcamentoOpInput[]
  }

  export type OpUpsertWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    update: XOR<OpUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput, OpUncheckedUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    create: XOR<OpCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>
    where?: OpWhereInput
  }

  export type OpUpdateToOneWithWhereWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    where?: OpWhereInput
    data: XOR<OpUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput, OpUncheckedUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput>
  }

  export type OpUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutOpNestedInput
    User?: UserUpdateOneRequiredWithoutOpNestedInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpUncheckedUpdateWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OrcamentoOpLinhasUpsertWithWhereUniqueWithoutOrcamentoOpInput = {
    where: OrcamentoOpLinhasWhereUniqueInput
    update: XOR<OrcamentoOpLinhasUpdateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedUpdateWithoutOrcamentoOpInput>
    create: XOR<OrcamentoOpLinhasCreateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedCreateWithoutOrcamentoOpInput>
  }

  export type OrcamentoOpLinhasUpdateWithWhereUniqueWithoutOrcamentoOpInput = {
    where: OrcamentoOpLinhasWhereUniqueInput
    data: XOR<OrcamentoOpLinhasUpdateWithoutOrcamentoOpInput, OrcamentoOpLinhasUncheckedUpdateWithoutOrcamentoOpInput>
  }

  export type OrcamentoOpLinhasUpdateManyWithWhereWithoutOrcamentoOpInput = {
    where: OrcamentoOpLinhasScalarWhereInput
    data: XOR<OrcamentoOpLinhasUpdateManyMutationInput, OrcamentoOpLinhasUncheckedUpdateManyWithoutOrcamentoOpInput>
  }

  export type OrcamentoOpLinhasScalarWhereInput = {
    AND?: OrcamentoOpLinhasScalarWhereInput | OrcamentoOpLinhasScalarWhereInput[]
    OR?: OrcamentoOpLinhasScalarWhereInput[]
    NOT?: OrcamentoOpLinhasScalarWhereInput | OrcamentoOpLinhasScalarWhereInput[]
    idPlaneamento?: StringFilter<"OrcamentoOpLinhas"> | string
    Op?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoStamp?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoLinhasStamp?: StringFilter<"OrcamentoOpLinhas"> | string
    orcamentoLinhasStampRecebido?: StringFilter<"OrcamentoOpLinhas"> | string
    ordem?: IntFilter<"OrcamentoOpLinhas"> | number
    design?: StringFilter<"OrcamentoOpLinhas"> | string
    custoPeca?: FloatFilter<"OrcamentoOpLinhas"> | number
    edebito?: FloatFilter<"OrcamentoOpLinhas"> | number
    qtt?: FloatFilter<"OrcamentoOpLinhas"> | number
    unidade?: StringFilter<"OrcamentoOpLinhas"> | string
  }

  export type OrcamentoOpCreateWithoutOrcamentoOpLinhasInput = {
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
    Op_OrcamentoOp_idPlaneamento_OpToOp: OpCreateNestedOneWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpInput
  }

  export type OrcamentoOpUncheckedCreateWithoutOrcamentoOpLinhasInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoNumero: number
    ano: number
  }

  export type OrcamentoOpCreateOrConnectWithoutOrcamentoOpLinhasInput = {
    where: OrcamentoOpWhereUniqueInput
    create: XOR<OrcamentoOpCreateWithoutOrcamentoOpLinhasInput, OrcamentoOpUncheckedCreateWithoutOrcamentoOpLinhasInput>
  }

  export type ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput = {
    ServicosEscolhidosOp: ServicosEscolhidosOpCreateNestedOneWithoutServicosEscolhidosOpOrigemInput
  }

  export type ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
  }

  export type ServicosEscolhidosOpOrigemCreateOrConnectWithoutOrcamentoOpLinhasInput = {
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
    create: XOR<ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput>
  }

  export type ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInputEnvelope = {
    data: ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInput | ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInput[]
  }

  export type OrcamentoOpUpsertWithoutOrcamentoOpLinhasInput = {
    update: XOR<OrcamentoOpUpdateWithoutOrcamentoOpLinhasInput, OrcamentoOpUncheckedUpdateWithoutOrcamentoOpLinhasInput>
    create: XOR<OrcamentoOpCreateWithoutOrcamentoOpLinhasInput, OrcamentoOpUncheckedCreateWithoutOrcamentoOpLinhasInput>
    where?: OrcamentoOpWhereInput
  }

  export type OrcamentoOpUpdateToOneWithWhereWithoutOrcamentoOpLinhasInput = {
    where?: OrcamentoOpWhereInput
    data: XOR<OrcamentoOpUpdateWithoutOrcamentoOpLinhasInput, OrcamentoOpUncheckedUpdateWithoutOrcamentoOpLinhasInput>
  }

  export type OrcamentoOpUpdateWithoutOrcamentoOpLinhasInput = {
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
    Op_OrcamentoOp_idPlaneamento_OpToOp?: OpUpdateOneRequiredWithoutOrcamentoOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
  }

  export type OrcamentoOpUncheckedUpdateWithoutOrcamentoOpLinhasInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoNumero?: IntFieldUpdateOperationsInput | number
    ano?: IntFieldUpdateOperationsInput | number
  }

  export type ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutOrcamentoOpLinhasInput = {
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
    update: XOR<ServicosEscolhidosOpOrigemUpdateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedUpdateWithoutOrcamentoOpLinhasInput>
    create: XOR<ServicosEscolhidosOpOrigemCreateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutOrcamentoOpLinhasInput>
  }

  export type ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutOrcamentoOpLinhasInput = {
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
    data: XOR<ServicosEscolhidosOpOrigemUpdateWithoutOrcamentoOpLinhasInput, ServicosEscolhidosOpOrigemUncheckedUpdateWithoutOrcamentoOpLinhasInput>
  }

  export type ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutOrcamentoOpLinhasInput = {
    where: ServicosEscolhidosOpOrigemScalarWhereInput
    data: XOR<ServicosEscolhidosOpOrigemUpdateManyMutationInput, ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutOrcamentoOpLinhasInput>
  }

  export type ServicosEscolhidosOpOrigemScalarWhereInput = {
    AND?: ServicosEscolhidosOpOrigemScalarWhereInput | ServicosEscolhidosOpOrigemScalarWhereInput[]
    OR?: ServicosEscolhidosOpOrigemScalarWhereInput[]
    NOT?: ServicosEscolhidosOpOrigemScalarWhereInput | ServicosEscolhidosOpOrigemScalarWhereInput[]
    idPlaneamento?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    Op?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    idServicoEscolhido?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
    orcamentoLinhasStamp?: StringFilter<"ServicosEscolhidosOpOrigem"> | string
  }

  export type UserPapeisCreateWithoutPapeisInput = {
    User: UserCreateNestedOneWithoutUserPapeisInput
  }

  export type UserPapeisUncheckedCreateWithoutPapeisInput = {
    nomeUser: string
  }

  export type UserPapeisCreateOrConnectWithoutPapeisInput = {
    where: UserPapeisWhereUniqueInput
    create: XOR<UserPapeisCreateWithoutPapeisInput, UserPapeisUncheckedCreateWithoutPapeisInput>
  }

  export type UserPapeisCreateManyPapeisInputEnvelope = {
    data: UserPapeisCreateManyPapeisInput | UserPapeisCreateManyPapeisInput[]
  }

  export type UserPapeisUpsertWithWhereUniqueWithoutPapeisInput = {
    where: UserPapeisWhereUniqueInput
    update: XOR<UserPapeisUpdateWithoutPapeisInput, UserPapeisUncheckedUpdateWithoutPapeisInput>
    create: XOR<UserPapeisCreateWithoutPapeisInput, UserPapeisUncheckedCreateWithoutPapeisInput>
  }

  export type UserPapeisUpdateWithWhereUniqueWithoutPapeisInput = {
    where: UserPapeisWhereUniqueInput
    data: XOR<UserPapeisUpdateWithoutPapeisInput, UserPapeisUncheckedUpdateWithoutPapeisInput>
  }

  export type UserPapeisUpdateManyWithWhereWithoutPapeisInput = {
    where: UserPapeisScalarWhereInput
    data: XOR<UserPapeisUpdateManyMutationInput, UserPapeisUncheckedUpdateManyWithoutPapeisInput>
  }

  export type UserPapeisScalarWhereInput = {
    AND?: UserPapeisScalarWhereInput | UserPapeisScalarWhereInput[]
    OR?: UserPapeisScalarWhereInput[]
    NOT?: UserPapeisScalarWhereInput | UserPapeisScalarWhereInput[]
    idPapel?: StringFilter<"UserPapeis"> | string
    nomeUser?: StringFilter<"UserPapeis"> | string
  }

  export type DataCamiaoCreateWithoutPlaneamentoInput = {
    IdCamiao?: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
    User: UserCreateNestedOneWithoutDataCamiaoInput
  }

  export type DataCamiaoUncheckedCreateWithoutPlaneamentoInput = {
    IdCamiao?: string
    nomeUser: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataCamiaoCreateOrConnectWithoutPlaneamentoInput = {
    where: DataCamiaoWhereUniqueInput
    create: XOR<DataCamiaoCreateWithoutPlaneamentoInput, DataCamiaoUncheckedCreateWithoutPlaneamentoInput>
  }

  export type DataCamiaoCreateManyPlaneamentoInputEnvelope = {
    data: DataCamiaoCreateManyPlaneamentoInput | DataCamiaoCreateManyPlaneamentoInput[]
  }

  export type DataEnvioCreateWithoutPlaneamentoInput = {
    idEnvio?: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
    User: UserCreateNestedOneWithoutDataEnvioInput
  }

  export type DataEnvioUncheckedCreateWithoutPlaneamentoInput = {
    idEnvio?: string
    nomeUser: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataEnvioCreateOrConnectWithoutPlaneamentoInput = {
    where: DataEnvioWhereUniqueInput
    create: XOR<DataEnvioCreateWithoutPlaneamentoInput, DataEnvioUncheckedCreateWithoutPlaneamentoInput>
  }

  export type DataEnvioCreateManyPlaneamentoInputEnvelope = {
    data: DataEnvioCreateManyPlaneamentoInput | DataEnvioCreateManyPlaneamentoInput[]
  }

  export type LivreCreateWithoutPlaneamentoInput = {
    idLivre?: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    User: UserCreateNestedOneWithoutLivreInput
    OrcamentoLivre?: OrcamentoLivreCreateNestedOneWithoutLivreInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreCreateNestedManyWithoutLivreInput
  }

  export type LivreUncheckedCreateWithoutPlaneamentoInput = {
    idLivre?: string
    nomeUser: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedCreateNestedOneWithoutLivreInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedCreateNestedManyWithoutLivreInput
  }

  export type LivreCreateOrConnectWithoutPlaneamentoInput = {
    where: LivreWhereUniqueInput
    create: XOR<LivreCreateWithoutPlaneamentoInput, LivreUncheckedCreateWithoutPlaneamentoInput>
  }

  export type LivreCreateManyPlaneamentoInputEnvelope = {
    data: LivreCreateManyPlaneamentoInput | LivreCreateManyPlaneamentoInput[]
  }

  export type OpCreateWithoutPlaneamentoInput = {
    Op: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    User: UserCreateNestedOneWithoutOpInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpUncheckedCreateWithoutPlaneamentoInput = {
    Op: string
    nomeUser: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpCreateOrConnectWithoutPlaneamentoInput = {
    where: OpWhereUniqueInput
    create: XOR<OpCreateWithoutPlaneamentoInput, OpUncheckedCreateWithoutPlaneamentoInput>
  }

  export type OpCreateManyPlaneamentoInputEnvelope = {
    data: OpCreateManyPlaneamentoInput | OpCreateManyPlaneamentoInput[]
  }

  export type FornecedorCreateWithoutPlaneamentoInput = {
    idFornecedor: string
    nomeFornecedor: string
  }

  export type FornecedorUncheckedCreateWithoutPlaneamentoInput = {
    idFornecedor: string
    nomeFornecedor: string
  }

  export type FornecedorCreateOrConnectWithoutPlaneamentoInput = {
    where: FornecedorWhereUniqueInput
    create: XOR<FornecedorCreateWithoutPlaneamentoInput, FornecedorUncheckedCreateWithoutPlaneamentoInput>
  }

  export type UserCreateWithoutPlaneamentoInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutUserInput
    Livre?: LivreCreateNestedManyWithoutUserInput
    Op?: OpCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPlaneamentoInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutUserInput
    Livre?: LivreUncheckedCreateNestedManyWithoutUserInput
    Op?: OpUncheckedCreateNestedManyWithoutUserInput
    UserPapeis?: UserPapeisUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPlaneamentoInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPlaneamentoInput, UserUncheckedCreateWithoutPlaneamentoInput>
  }

  export type DataCamiaoUpsertWithWhereUniqueWithoutPlaneamentoInput = {
    where: DataCamiaoWhereUniqueInput
    update: XOR<DataCamiaoUpdateWithoutPlaneamentoInput, DataCamiaoUncheckedUpdateWithoutPlaneamentoInput>
    create: XOR<DataCamiaoCreateWithoutPlaneamentoInput, DataCamiaoUncheckedCreateWithoutPlaneamentoInput>
  }

  export type DataCamiaoUpdateWithWhereUniqueWithoutPlaneamentoInput = {
    where: DataCamiaoWhereUniqueInput
    data: XOR<DataCamiaoUpdateWithoutPlaneamentoInput, DataCamiaoUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type DataCamiaoUpdateManyWithWhereWithoutPlaneamentoInput = {
    where: DataCamiaoScalarWhereInput
    data: XOR<DataCamiaoUpdateManyMutationInput, DataCamiaoUncheckedUpdateManyWithoutPlaneamentoInput>
  }

  export type DataCamiaoScalarWhereInput = {
    AND?: DataCamiaoScalarWhereInput | DataCamiaoScalarWhereInput[]
    OR?: DataCamiaoScalarWhereInput[]
    NOT?: DataCamiaoScalarWhereInput | DataCamiaoScalarWhereInput[]
    idPlaneamento?: StringFilter<"DataCamiao"> | string
    IdCamiao?: StringFilter<"DataCamiao"> | string
    nomeUser?: StringFilter<"DataCamiao"> | string
    dataCamiao?: DateTimeFilter<"DataCamiao"> | Date | string
    quantidade?: IntFilter<"DataCamiao"> | number
    percentagem?: FloatFilter<"DataCamiao"> | number
    obs?: StringFilter<"DataCamiao"> | string
  }

  export type DataEnvioUpsertWithWhereUniqueWithoutPlaneamentoInput = {
    where: DataEnvioWhereUniqueInput
    update: XOR<DataEnvioUpdateWithoutPlaneamentoInput, DataEnvioUncheckedUpdateWithoutPlaneamentoInput>
    create: XOR<DataEnvioCreateWithoutPlaneamentoInput, DataEnvioUncheckedCreateWithoutPlaneamentoInput>
  }

  export type DataEnvioUpdateWithWhereUniqueWithoutPlaneamentoInput = {
    where: DataEnvioWhereUniqueInput
    data: XOR<DataEnvioUpdateWithoutPlaneamentoInput, DataEnvioUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type DataEnvioUpdateManyWithWhereWithoutPlaneamentoInput = {
    where: DataEnvioScalarWhereInput
    data: XOR<DataEnvioUpdateManyMutationInput, DataEnvioUncheckedUpdateManyWithoutPlaneamentoInput>
  }

  export type DataEnvioScalarWhereInput = {
    AND?: DataEnvioScalarWhereInput | DataEnvioScalarWhereInput[]
    OR?: DataEnvioScalarWhereInput[]
    NOT?: DataEnvioScalarWhereInput | DataEnvioScalarWhereInput[]
    idPlaneamento?: StringFilter<"DataEnvio"> | string
    idEnvio?: StringFilter<"DataEnvio"> | string
    nomeUser?: StringFilter<"DataEnvio"> | string
    dataEnvio?: DateTimeFilter<"DataEnvio"> | Date | string
    quantidade?: IntFilter<"DataEnvio"> | number
    percentagem?: FloatFilter<"DataEnvio"> | number
    obs?: StringFilter<"DataEnvio"> | string
  }

  export type LivreUpsertWithWhereUniqueWithoutPlaneamentoInput = {
    where: LivreWhereUniqueInput
    update: XOR<LivreUpdateWithoutPlaneamentoInput, LivreUncheckedUpdateWithoutPlaneamentoInput>
    create: XOR<LivreCreateWithoutPlaneamentoInput, LivreUncheckedCreateWithoutPlaneamentoInput>
  }

  export type LivreUpdateWithWhereUniqueWithoutPlaneamentoInput = {
    where: LivreWhereUniqueInput
    data: XOR<LivreUpdateWithoutPlaneamentoInput, LivreUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type LivreUpdateManyWithWhereWithoutPlaneamentoInput = {
    where: LivreScalarWhereInput
    data: XOR<LivreUpdateManyMutationInput, LivreUncheckedUpdateManyWithoutPlaneamentoInput>
  }

  export type LivreScalarWhereInput = {
    AND?: LivreScalarWhereInput | LivreScalarWhereInput[]
    OR?: LivreScalarWhereInput[]
    NOT?: LivreScalarWhereInput | LivreScalarWhereInput[]
    idPlaneamento?: StringFilter<"Livre"> | string
    idLivre?: StringFilter<"Livre"> | string
    nomeUser?: StringFilter<"Livre"> | string
    Op?: StringNullableFilter<"Livre"> | string | null
    nOp?: IntNullableFilter<"Livre"> | number | null
    orcamentoStamp?: StringNullableFilter<"Livre"> | string | null
    nOrcamento?: IntNullableFilter<"Livre"> | number | null
    anoOrcamento?: IntNullableFilter<"Livre"> | number | null
    desenho?: StringNullableFilter<"Livre"> | string | null
    modelo?: StringFilter<"Livre"> | string
    cor?: StringFilter<"Livre"> | string
    pedidoCliente?: StringFilter<"Livre"> | string
    imagem?: StringFilter<"Livre"> | string
    cortaPt?: BoolFilter<"Livre"> | boolean
  }

  export type OpUpsertWithWhereUniqueWithoutPlaneamentoInput = {
    where: OpWhereUniqueInput
    update: XOR<OpUpdateWithoutPlaneamentoInput, OpUncheckedUpdateWithoutPlaneamentoInput>
    create: XOR<OpCreateWithoutPlaneamentoInput, OpUncheckedCreateWithoutPlaneamentoInput>
  }

  export type OpUpdateWithWhereUniqueWithoutPlaneamentoInput = {
    where: OpWhereUniqueInput
    data: XOR<OpUpdateWithoutPlaneamentoInput, OpUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type OpUpdateManyWithWhereWithoutPlaneamentoInput = {
    where: OpScalarWhereInput
    data: XOR<OpUpdateManyMutationInput, OpUncheckedUpdateManyWithoutPlaneamentoInput>
  }

  export type OpScalarWhereInput = {
    AND?: OpScalarWhereInput | OpScalarWhereInput[]
    OR?: OpScalarWhereInput[]
    NOT?: OpScalarWhereInput | OpScalarWhereInput[]
    idPlaneamento?: StringFilter<"Op"> | string
    Op?: StringFilter<"Op"> | string
    nomeUser?: StringFilter<"Op"> | string
    nOp?: IntFilter<"Op"> | number
    modelo?: StringFilter<"Op"> | string
    cor?: StringFilter<"Op"> | string
    pedidoCliente?: StringFilter<"Op"> | string
    imagem?: StringFilter<"Op"> | string
    cortaPt?: BoolFilter<"Op"> | boolean
  }

  export type FornecedorUpsertWithoutPlaneamentoInput = {
    update: XOR<FornecedorUpdateWithoutPlaneamentoInput, FornecedorUncheckedUpdateWithoutPlaneamentoInput>
    create: XOR<FornecedorCreateWithoutPlaneamentoInput, FornecedorUncheckedCreateWithoutPlaneamentoInput>
    where?: FornecedorWhereInput
  }

  export type FornecedorUpdateToOneWithWhereWithoutPlaneamentoInput = {
    where?: FornecedorWhereInput
    data: XOR<FornecedorUpdateWithoutPlaneamentoInput, FornecedorUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type FornecedorUpdateWithoutPlaneamentoInput = {
    idFornecedor?: StringFieldUpdateOperationsInput | string
    nomeFornecedor?: StringFieldUpdateOperationsInput | string
  }

  export type FornecedorUncheckedUpdateWithoutPlaneamentoInput = {
    idFornecedor?: StringFieldUpdateOperationsInput | string
    nomeFornecedor?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutPlaneamentoInput = {
    update: XOR<UserUpdateWithoutPlaneamentoInput, UserUncheckedUpdateWithoutPlaneamentoInput>
    create: XOR<UserCreateWithoutPlaneamentoInput, UserUncheckedCreateWithoutPlaneamentoInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPlaneamentoInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPlaneamentoInput, UserUncheckedUpdateWithoutPlaneamentoInput>
  }

  export type UserUpdateWithoutPlaneamentoInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutUserNestedInput
    Livre?: LivreUpdateManyWithoutUserNestedInput
    Op?: OpUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPlaneamentoInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutUserNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutUserNestedInput
    Op?: OpUncheckedUpdateManyWithoutUserNestedInput
    UserPapeis?: UserPapeisUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LivreCreateWithoutServicosEscolhidosLivreInput = {
    idLivre?: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutLivreInput
    User: UserCreateNestedOneWithoutLivreInput
    OrcamentoLivre?: OrcamentoLivreCreateNestedOneWithoutLivreInput
  }

  export type LivreUncheckedCreateWithoutServicosEscolhidosLivreInput = {
    idPlaneamento: string
    idLivre?: string
    nomeUser: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedCreateNestedOneWithoutLivreInput
  }

  export type LivreCreateOrConnectWithoutServicosEscolhidosLivreInput = {
    where: LivreWhereUniqueInput
    create: XOR<LivreCreateWithoutServicosEscolhidosLivreInput, LivreUncheckedCreateWithoutServicosEscolhidosLivreInput>
  }

  export type ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput = {
    OrcamentoLivreLinhas: OrcamentoLivreLinhasCreateNestedOneWithoutServicosEscolhidosLivreOrigemInput
  }

  export type ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput = {
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosLivreOrigemCreateOrConnectWithoutServicosEscolhidosLivreInput = {
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
    create: XOR<ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput>
  }

  export type ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInputEnvelope = {
    data: ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInput | ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInput[]
  }

  export type LivreUpsertWithoutServicosEscolhidosLivreInput = {
    update: XOR<LivreUpdateWithoutServicosEscolhidosLivreInput, LivreUncheckedUpdateWithoutServicosEscolhidosLivreInput>
    create: XOR<LivreCreateWithoutServicosEscolhidosLivreInput, LivreUncheckedCreateWithoutServicosEscolhidosLivreInput>
    where?: LivreWhereInput
  }

  export type LivreUpdateToOneWithWhereWithoutServicosEscolhidosLivreInput = {
    where?: LivreWhereInput
    data: XOR<LivreUpdateWithoutServicosEscolhidosLivreInput, LivreUncheckedUpdateWithoutServicosEscolhidosLivreInput>
  }

  export type LivreUpdateWithoutServicosEscolhidosLivreInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutLivreNestedInput
    User?: UserUpdateOneRequiredWithoutLivreNestedInput
    OrcamentoLivre?: OrcamentoLivreUpdateOneWithoutLivreNestedInput
  }

  export type LivreUncheckedUpdateWithoutServicosEscolhidosLivreInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedUpdateOneWithoutLivreNestedInput
  }

  export type ServicosEscolhidosLivreOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosLivreInput = {
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
    update: XOR<ServicosEscolhidosLivreOrigemUpdateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedUpdateWithoutServicosEscolhidosLivreInput>
    create: XOR<ServicosEscolhidosLivreOrigemCreateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedCreateWithoutServicosEscolhidosLivreInput>
  }

  export type ServicosEscolhidosLivreOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosLivreInput = {
    where: ServicosEscolhidosLivreOrigemWhereUniqueInput
    data: XOR<ServicosEscolhidosLivreOrigemUpdateWithoutServicosEscolhidosLivreInput, ServicosEscolhidosLivreOrigemUncheckedUpdateWithoutServicosEscolhidosLivreInput>
  }

  export type ServicosEscolhidosLivreOrigemUpdateManyWithWhereWithoutServicosEscolhidosLivreInput = {
    where: ServicosEscolhidosLivreOrigemScalarWhereInput
    data: XOR<ServicosEscolhidosLivreOrigemUpdateManyMutationInput, ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutServicosEscolhidosLivreInput>
  }

  export type OrcamentoLivreLinhasCreateWithoutServicosEscolhidosLivreOrigemInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    OrcamentoLivre: OrcamentoLivreCreateNestedOneWithoutOrcamentoLivreLinhasInput
  }

  export type OrcamentoLivreLinhasUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput = {
    idPlaneamento: string
    idLivre: string
    orcamentoStamp: string
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
  }

  export type OrcamentoLivreLinhasCreateOrConnectWithoutServicosEscolhidosLivreOrigemInput = {
    where: OrcamentoLivreLinhasWhereUniqueInput
    create: XOR<OrcamentoLivreLinhasCreateWithoutServicosEscolhidosLivreOrigemInput, OrcamentoLivreLinhasUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
  }

  export type ServicosEscolhidosLivreCreateWithoutServicosEscolhidosLivreOrigemInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    Livre: LivreCreateNestedOneWithoutServicosEscolhidosLivreInput
  }

  export type ServicosEscolhidosLivreUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
  }

  export type ServicosEscolhidosLivreCreateOrConnectWithoutServicosEscolhidosLivreOrigemInput = {
    where: ServicosEscolhidosLivreWhereUniqueInput
    create: XOR<ServicosEscolhidosLivreCreateWithoutServicosEscolhidosLivreOrigemInput, ServicosEscolhidosLivreUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
  }

  export type OrcamentoLivreLinhasUpsertWithoutServicosEscolhidosLivreOrigemInput = {
    update: XOR<OrcamentoLivreLinhasUpdateWithoutServicosEscolhidosLivreOrigemInput, OrcamentoLivreLinhasUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput>
    create: XOR<OrcamentoLivreLinhasCreateWithoutServicosEscolhidosLivreOrigemInput, OrcamentoLivreLinhasUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
    where?: OrcamentoLivreLinhasWhereInput
  }

  export type OrcamentoLivreLinhasUpdateToOneWithWhereWithoutServicosEscolhidosLivreOrigemInput = {
    where?: OrcamentoLivreLinhasWhereInput
    data: XOR<OrcamentoLivreLinhasUpdateWithoutServicosEscolhidosLivreOrigemInput, OrcamentoLivreLinhasUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput>
  }

  export type OrcamentoLivreLinhasUpdateWithoutServicosEscolhidosLivreOrigemInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    OrcamentoLivre?: OrcamentoLivreUpdateOneRequiredWithoutOrcamentoLivreLinhasNestedInput
  }

  export type OrcamentoLivreLinhasUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosLivreUpsertWithoutServicosEscolhidosLivreOrigemInput = {
    update: XOR<ServicosEscolhidosLivreUpdateWithoutServicosEscolhidosLivreOrigemInput, ServicosEscolhidosLivreUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput>
    create: XOR<ServicosEscolhidosLivreCreateWithoutServicosEscolhidosLivreOrigemInput, ServicosEscolhidosLivreUncheckedCreateWithoutServicosEscolhidosLivreOrigemInput>
    where?: ServicosEscolhidosLivreWhereInput
  }

  export type ServicosEscolhidosLivreUpdateToOneWithWhereWithoutServicosEscolhidosLivreOrigemInput = {
    where?: ServicosEscolhidosLivreWhereInput
    data: XOR<ServicosEscolhidosLivreUpdateWithoutServicosEscolhidosLivreOrigemInput, ServicosEscolhidosLivreUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput>
  }

  export type ServicosEscolhidosLivreUpdateWithoutServicosEscolhidosLivreOrigemInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    Livre?: LivreUpdateOneRequiredWithoutServicosEscolhidosLivreNestedInput
  }

  export type ServicosEscolhidosLivreUncheckedUpdateWithoutServicosEscolhidosLivreOrigemInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type OpCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    Op: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutOpInput
    User: UserCreateNestedOneWithoutOpInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
  }

  export type OpUncheckedCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idPlaneamento: string
    Op: string
    nomeUser: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
  }

  export type OpCreateOrConnectWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    where: OpWhereUniqueInput
    create: XOR<OpCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
  }

  export type ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput = {
    OrcamentoOpLinhas: OrcamentoOpLinhasCreateNestedOneWithoutServicosEscolhidosOpOrigemInput
  }

  export type ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput = {
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosOpOrigemCreateOrConnectWithoutServicosEscolhidosOpInput = {
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
    create: XOR<ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput>
  }

  export type ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInputEnvelope = {
    data: ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInput | ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInput[]
  }

  export type OpUpsertWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    update: XOR<OpUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, OpUncheckedUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
    create: XOR<OpCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, OpUncheckedCreateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
    where?: OpWhereInput
  }

  export type OpUpdateToOneWithWhereWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    where?: OpWhereInput
    data: XOR<OpUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput, OpUncheckedUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput>
  }

  export type OpUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutOpNestedInput
    User?: UserUpdateOneRequiredWithoutOpNestedInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpUncheckedUpdateWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
  }

  export type ServicosEscolhidosOpOrigemUpsertWithWhereUniqueWithoutServicosEscolhidosOpInput = {
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
    update: XOR<ServicosEscolhidosOpOrigemUpdateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedUpdateWithoutServicosEscolhidosOpInput>
    create: XOR<ServicosEscolhidosOpOrigemCreateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedCreateWithoutServicosEscolhidosOpInput>
  }

  export type ServicosEscolhidosOpOrigemUpdateWithWhereUniqueWithoutServicosEscolhidosOpInput = {
    where: ServicosEscolhidosOpOrigemWhereUniqueInput
    data: XOR<ServicosEscolhidosOpOrigemUpdateWithoutServicosEscolhidosOpInput, ServicosEscolhidosOpOrigemUncheckedUpdateWithoutServicosEscolhidosOpInput>
  }

  export type ServicosEscolhidosOpOrigemUpdateManyWithWhereWithoutServicosEscolhidosOpInput = {
    where: ServicosEscolhidosOpOrigemScalarWhereInput
    data: XOR<ServicosEscolhidosOpOrigemUpdateManyMutationInput, ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutServicosEscolhidosOpInput>
  }

  export type OrcamentoOpLinhasCreateWithoutServicosEscolhidosOpOrigemInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
    OrcamentoOp: OrcamentoOpCreateNestedOneWithoutOrcamentoOpLinhasInput
  }

  export type OrcamentoOpLinhasUncheckedCreateWithoutServicosEscolhidosOpOrigemInput = {
    idPlaneamento: string
    Op: string
    orcamentoStamp: string
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
  }

  export type OrcamentoOpLinhasCreateOrConnectWithoutServicosEscolhidosOpOrigemInput = {
    where: OrcamentoOpLinhasWhereUniqueInput
    create: XOR<OrcamentoOpLinhasCreateWithoutServicosEscolhidosOpOrigemInput, OrcamentoOpLinhasUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
  }

  export type ServicosEscolhidosOpCreateWithoutServicosEscolhidosOpOrigemInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp: OpCreateNestedOneWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type ServicosEscolhidosOpUncheckedCreateWithoutServicosEscolhidosOpOrigemInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
  }

  export type ServicosEscolhidosOpCreateOrConnectWithoutServicosEscolhidosOpOrigemInput = {
    where: ServicosEscolhidosOpWhereUniqueInput
    create: XOR<ServicosEscolhidosOpCreateWithoutServicosEscolhidosOpOrigemInput, ServicosEscolhidosOpUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
  }

  export type OrcamentoOpLinhasUpsertWithoutServicosEscolhidosOpOrigemInput = {
    update: XOR<OrcamentoOpLinhasUpdateWithoutServicosEscolhidosOpOrigemInput, OrcamentoOpLinhasUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput>
    create: XOR<OrcamentoOpLinhasCreateWithoutServicosEscolhidosOpOrigemInput, OrcamentoOpLinhasUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
    where?: OrcamentoOpLinhasWhereInput
  }

  export type OrcamentoOpLinhasUpdateToOneWithWhereWithoutServicosEscolhidosOpOrigemInput = {
    where?: OrcamentoOpLinhasWhereInput
    data: XOR<OrcamentoOpLinhasUpdateWithoutServicosEscolhidosOpOrigemInput, OrcamentoOpLinhasUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput>
  }

  export type OrcamentoOpLinhasUpdateWithoutServicosEscolhidosOpOrigemInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    OrcamentoOp?: OrcamentoOpUpdateOneRequiredWithoutOrcamentoOpLinhasNestedInput
  }

  export type OrcamentoOpLinhasUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    orcamentoStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpUpsertWithoutServicosEscolhidosOpOrigemInput = {
    update: XOR<ServicosEscolhidosOpUpdateWithoutServicosEscolhidosOpOrigemInput, ServicosEscolhidosOpUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput>
    create: XOR<ServicosEscolhidosOpCreateWithoutServicosEscolhidosOpOrigemInput, ServicosEscolhidosOpUncheckedCreateWithoutServicosEscolhidosOpOrigemInput>
    where?: ServicosEscolhidosOpWhereInput
  }

  export type ServicosEscolhidosOpUpdateToOneWithWhereWithoutServicosEscolhidosOpOrigemInput = {
    where?: ServicosEscolhidosOpWhereInput
    data: XOR<ServicosEscolhidosOpUpdateWithoutServicosEscolhidosOpOrigemInput, ServicosEscolhidosOpUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput>
  }

  export type ServicosEscolhidosOpUpdateWithoutServicosEscolhidosOpOrigemInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    Op_ServicosEscolhidosOp_idPlaneamento_OpToOp?: OpUpdateOneRequiredWithoutServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type ServicosEscolhidosOpUncheckedUpdateWithoutServicosEscolhidosOpOrigemInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type TcOpCreateWithoutTcInput = {
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcOpInput
    TcOpCompra?: TcOpCompraCreateNestedManyWithoutTcOpInput
  }

  export type TcOpUncheckedCreateWithoutTcInput = {
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcOpInput
    TcOpCompra?: TcOpCompraUncheckedCreateNestedManyWithoutTcOpInput
  }

  export type TcOpCreateOrConnectWithoutTcInput = {
    where: TcOpWhereUniqueInput
    create: XOR<TcOpCreateWithoutTcInput, TcOpUncheckedCreateWithoutTcInput>
  }

  export type TcOpCreateManyTcInputEnvelope = {
    data: TcOpCreateManyTcInput | TcOpCreateManyTcInput[]
  }

  export type TcOpUpsertWithWhereUniqueWithoutTcInput = {
    where: TcOpWhereUniqueInput
    update: XOR<TcOpUpdateWithoutTcInput, TcOpUncheckedUpdateWithoutTcInput>
    create: XOR<TcOpCreateWithoutTcInput, TcOpUncheckedCreateWithoutTcInput>
  }

  export type TcOpUpdateWithWhereUniqueWithoutTcInput = {
    where: TcOpWhereUniqueInput
    data: XOR<TcOpUpdateWithoutTcInput, TcOpUncheckedUpdateWithoutTcInput>
  }

  export type TcOpUpdateManyWithWhereWithoutTcInput = {
    where: TcOpScalarWhereInput
    data: XOR<TcOpUpdateManyMutationInput, TcOpUncheckedUpdateManyWithoutTcInput>
  }

  export type TcOpScalarWhereInput = {
    AND?: TcOpScalarWhereInput | TcOpScalarWhereInput[]
    OR?: TcOpScalarWhereInput[]
    NOT?: TcOpScalarWhereInput | TcOpScalarWhereInput[]
    idTc?: StringFilter<"TcOp"> | string
    op?: IntFilter<"TcOp"> | number
    foto?: StringFilter<"TcOp"> | string
    createdAt?: DateTimeFilter<"TcOp"> | Date | string
  }

  export type TcOpCreateWithoutTcCompraConteudoInput = {
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcOpInput
    Tc: TcCreateNestedOneWithoutTcOpInput
    TcOpCompra?: TcOpCompraCreateNestedManyWithoutTcOpInput
  }

  export type TcOpUncheckedCreateWithoutTcCompraConteudoInput = {
    idTc: string
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcOpInput
    TcOpCompra?: TcOpCompraUncheckedCreateNestedManyWithoutTcOpInput
  }

  export type TcOpCreateOrConnectWithoutTcCompraConteudoInput = {
    where: TcOpWhereUniqueInput
    create: XOR<TcOpCreateWithoutTcCompraConteudoInput, TcOpUncheckedCreateWithoutTcCompraConteudoInput>
  }

  export type TcOpCompraCreateWithoutTcCompraConteudoInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
    TcOp: TcOpCreateNestedOneWithoutTcOpCompraInput
  }

  export type TcOpCompraUncheckedCreateWithoutTcCompraConteudoInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
    op: number
  }

  export type TcOpCompraCreateOrConnectWithoutTcCompraConteudoInput = {
    where: TcOpCompraWhereUniqueInput
    create: XOR<TcOpCompraCreateWithoutTcCompraConteudoInput, TcOpCompraUncheckedCreateWithoutTcCompraConteudoInput>
  }

  export type TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput = {
    idConteudoEntradaPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoEntradaInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcCompraConteudoEntradaInput
  }

  export type TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput = {
    idConteudoEntradaPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    op: number
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcCompraConteudoEntradaInput
  }

  export type TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoInput = {
    where: TcCompraConteudoEntradaWhereUniqueInput
    create: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput>
  }

  export type TcCompraConteudoEntradaCreateManyTcCompraConteudoInputEnvelope = {
    data: TcCompraConteudoEntradaCreateManyTcCompraConteudoInput | TcCompraConteudoEntradaCreateManyTcCompraConteudoInput[]
  }

  export type TcOpUpsertWithoutTcCompraConteudoInput = {
    update: XOR<TcOpUpdateWithoutTcCompraConteudoInput, TcOpUncheckedUpdateWithoutTcCompraConteudoInput>
    create: XOR<TcOpCreateWithoutTcCompraConteudoInput, TcOpUncheckedCreateWithoutTcCompraConteudoInput>
    where?: TcOpWhereInput
  }

  export type TcOpUpdateToOneWithWhereWithoutTcCompraConteudoInput = {
    where?: TcOpWhereInput
    data: XOR<TcOpUpdateWithoutTcCompraConteudoInput, TcOpUncheckedUpdateWithoutTcCompraConteudoInput>
  }

  export type TcOpUpdateWithoutTcCompraConteudoInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcOpNestedInput
    Tc?: TcUpdateOneRequiredWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpUncheckedUpdateWithoutTcCompraConteudoInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUncheckedUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpCompraUpsertWithoutTcCompraConteudoInput = {
    update: XOR<TcOpCompraUpdateWithoutTcCompraConteudoInput, TcOpCompraUncheckedUpdateWithoutTcCompraConteudoInput>
    create: XOR<TcOpCompraCreateWithoutTcCompraConteudoInput, TcOpCompraUncheckedCreateWithoutTcCompraConteudoInput>
    where?: TcOpCompraWhereInput
  }

  export type TcOpCompraUpdateToOneWithWhereWithoutTcCompraConteudoInput = {
    where?: TcOpCompraWhereInput
    data: XOR<TcOpCompraUpdateWithoutTcCompraConteudoInput, TcOpCompraUncheckedUpdateWithoutTcCompraConteudoInput>
  }

  export type TcOpCompraUpdateWithoutTcCompraConteudoInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
    TcOp?: TcOpUpdateOneRequiredWithoutTcOpCompraNestedInput
  }

  export type TcOpCompraUncheckedUpdateWithoutTcCompraConteudoInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcCompraConteudoInput = {
    where: TcCompraConteudoEntradaWhereUniqueInput
    update: XOR<TcCompraConteudoEntradaUpdateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedUpdateWithoutTcCompraConteudoInput>
    create: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoInput>
  }

  export type TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcCompraConteudoInput = {
    where: TcCompraConteudoEntradaWhereUniqueInput
    data: XOR<TcCompraConteudoEntradaUpdateWithoutTcCompraConteudoInput, TcCompraConteudoEntradaUncheckedUpdateWithoutTcCompraConteudoInput>
  }

  export type TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcCompraConteudoInput = {
    where: TcCompraConteudoEntradaScalarWhereInput
    data: XOR<TcCompraConteudoEntradaUpdateManyMutationInput, TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcCompraConteudoInput>
  }

  export type TcCompraConteudoEntradaScalarWhereInput = {
    AND?: TcCompraConteudoEntradaScalarWhereInput | TcCompraConteudoEntradaScalarWhereInput[]
    OR?: TcCompraConteudoEntradaScalarWhereInput[]
    NOT?: TcCompraConteudoEntradaScalarWhereInput | TcCompraConteudoEntradaScalarWhereInput[]
    idConteudoEntradaPhc?: StringFilter<"TcCompraConteudoEntrada"> | string
    idConteudoCompraPhc?: StringFilter<"TcCompraConteudoEntrada"> | string
    nEntrada?: IntFilter<"TcCompraConteudoEntrada"> | number
    Nguia?: StringFilter<"TcCompraConteudoEntrada"> | string
    dataEntrada?: DateTimeFilter<"TcCompraConteudoEntrada"> | Date | string
    dataEntradaString?: StringFilter<"TcCompraConteudoEntrada"> | string
    qtt?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    cor?: StringFilter<"TcCompraConteudoEntrada"> | string
    tam?: StringFilter<"TcCompraConteudoEntrada"> | string
    unidade?: StringFilter<"TcCompraConteudoEntrada"> | string
    largura?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFilter<"TcCompraConteudoEntrada"> | Decimal | DecimalJsLike | number | string
    lote?: StringFilter<"TcCompraConteudoEntrada"> | string
    op?: IntFilter<"TcCompraConteudoEntrada"> | number
  }

  export type TcCompraConteudoCreateWithoutTcCompraConteudoEntradaInput = {
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoInput
    TcOpCompra: TcOpCompraCreateNestedOneWithoutTcCompraConteudoInput
  }

  export type TcCompraConteudoUncheckedCreateWithoutTcCompraConteudoEntradaInput = {
    idCompra: string
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    op: number
  }

  export type TcCompraConteudoCreateOrConnectWithoutTcCompraConteudoEntradaInput = {
    where: TcCompraConteudoWhereUniqueInput
    create: XOR<TcCompraConteudoCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoUncheckedCreateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcOpCreateWithoutTcCompraConteudoEntradaInput = {
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcOpInput
    Tc: TcCreateNestedOneWithoutTcOpInput
    TcOpCompra?: TcOpCompraCreateNestedManyWithoutTcOpInput
  }

  export type TcOpUncheckedCreateWithoutTcCompraConteudoEntradaInput = {
    idTc: string
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcOpInput
    TcOpCompra?: TcOpCompraUncheckedCreateNestedManyWithoutTcOpInput
  }

  export type TcOpCreateOrConnectWithoutTcCompraConteudoEntradaInput = {
    where: TcOpWhereUniqueInput
    create: XOR<TcOpCreateWithoutTcCompraConteudoEntradaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput = {
    idFaturaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoEntradaFaturadaInput
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput = {
    idFaturaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    op: number
  }

  export type TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcCompraConteudoEntradaInput = {
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    create: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInputEnvelope = {
    data: TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInput | TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInput[]
  }

  export type TcCompraConteudoUpsertWithoutTcCompraConteudoEntradaInput = {
    update: XOR<TcCompraConteudoUpdateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
    create: XOR<TcCompraConteudoCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoUncheckedCreateWithoutTcCompraConteudoEntradaInput>
    where?: TcCompraConteudoWhereInput
  }

  export type TcCompraConteudoUpdateToOneWithWhereWithoutTcCompraConteudoEntradaInput = {
    where?: TcCompraConteudoWhereInput
    data: XOR<TcCompraConteudoUpdateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcCompraConteudoUpdateWithoutTcCompraConteudoEntradaInput = {
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoNestedInput
    TcOpCompra?: TcOpCompraUpdateOneRequiredWithoutTcCompraConteudoNestedInput
  }

  export type TcCompraConteudoUncheckedUpdateWithoutTcCompraConteudoEntradaInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcOpUpsertWithoutTcCompraConteudoEntradaInput = {
    update: XOR<TcOpUpdateWithoutTcCompraConteudoEntradaInput, TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
    create: XOR<TcOpCreateWithoutTcCompraConteudoEntradaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaInput>
    where?: TcOpWhereInput
  }

  export type TcOpUpdateToOneWithWhereWithoutTcCompraConteudoEntradaInput = {
    where?: TcOpWhereInput
    data: XOR<TcOpUpdateWithoutTcCompraConteudoEntradaInput, TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcOpUpdateWithoutTcCompraConteudoEntradaInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcOpNestedInput
    Tc?: TcUpdateOneRequiredWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUncheckedUpdateManyWithoutTcOpNestedInput
  }

  export type TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcCompraConteudoEntradaInput = {
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    update: XOR<TcCompraConteudoEntradaFaturadaUpdateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
    create: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcCompraConteudoEntradaInput = {
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    data: XOR<TcCompraConteudoEntradaFaturadaUpdateWithoutTcCompraConteudoEntradaInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateWithoutTcCompraConteudoEntradaInput>
  }

  export type TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcCompraConteudoEntradaInput = {
    where: TcCompraConteudoEntradaFaturadaScalarWhereInput
    data: XOR<TcCompraConteudoEntradaFaturadaUpdateManyMutationInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcCompraConteudoEntradaInput>
  }

  export type TcCompraConteudoEntradaFaturadaScalarWhereInput = {
    AND?: TcCompraConteudoEntradaFaturadaScalarWhereInput | TcCompraConteudoEntradaFaturadaScalarWhereInput[]
    OR?: TcCompraConteudoEntradaFaturadaScalarWhereInput[]
    NOT?: TcCompraConteudoEntradaFaturadaScalarWhereInput | TcCompraConteudoEntradaFaturadaScalarWhereInput[]
    idFaturaPhc?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    idConteudoEntradaPhc?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    nGuiaPhc?: IntFilter<"TcCompraConteudoEntradaFaturada"> | number
    nFatura?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    dataFatura?: DateTimeFilter<"TcCompraConteudoEntradaFaturada"> | Date | string
    dataFaturaString?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    qtt?: DecimalFilter<"TcCompraConteudoEntradaFaturada"> | Decimal | DecimalJsLike | number | string
    unidade?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    lote?: StringFilter<"TcCompraConteudoEntradaFaturada"> | string
    op?: IntFilter<"TcCompraConteudoEntradaFaturada"> | number
  }

  export type TcCompraConteudoEntradaCreateWithoutTcCompraConteudoEntradaFaturadaInput = {
    idConteudoEntradaPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    TcCompraConteudo: TcCompraConteudoCreateNestedOneWithoutTcCompraConteudoEntradaInput
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoEntradaInput
  }

  export type TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput = {
    idConteudoEntradaPhc: string
    idConteudoCompraPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    op: number
  }

  export type TcCompraConteudoEntradaCreateOrConnectWithoutTcCompraConteudoEntradaFaturadaInput = {
    where: TcCompraConteudoEntradaWhereUniqueInput
    create: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
  }

  export type TcOpCreateWithoutTcCompraConteudoEntradaFaturadaInput = {
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcOpInput
    Tc: TcCreateNestedOneWithoutTcOpInput
    TcOpCompra?: TcOpCompraCreateNestedManyWithoutTcOpInput
  }

  export type TcOpUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput = {
    idTc: string
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcOpInput
    TcOpCompra?: TcOpCompraUncheckedCreateNestedManyWithoutTcOpInput
  }

  export type TcOpCreateOrConnectWithoutTcCompraConteudoEntradaFaturadaInput = {
    where: TcOpWhereUniqueInput
    create: XOR<TcOpCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
  }

  export type TcCompraConteudoEntradaUpsertWithoutTcCompraConteudoEntradaFaturadaInput = {
    update: XOR<TcCompraConteudoEntradaUpdateWithoutTcCompraConteudoEntradaFaturadaInput, TcCompraConteudoEntradaUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput>
    create: XOR<TcCompraConteudoEntradaCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
    where?: TcCompraConteudoEntradaWhereInput
  }

  export type TcCompraConteudoEntradaUpdateToOneWithWhereWithoutTcCompraConteudoEntradaFaturadaInput = {
    where?: TcCompraConteudoEntradaWhereInput
    data: XOR<TcCompraConteudoEntradaUpdateWithoutTcCompraConteudoEntradaFaturadaInput, TcCompraConteudoEntradaUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput>
  }

  export type TcCompraConteudoEntradaUpdateWithoutTcCompraConteudoEntradaFaturadaInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    TcCompraConteudo?: TcCompraConteudoUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput
  }

  export type TcCompraConteudoEntradaUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcOpUpsertWithoutTcCompraConteudoEntradaFaturadaInput = {
    update: XOR<TcOpUpdateWithoutTcCompraConteudoEntradaFaturadaInput, TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput>
    create: XOR<TcOpCreateWithoutTcCompraConteudoEntradaFaturadaInput, TcOpUncheckedCreateWithoutTcCompraConteudoEntradaFaturadaInput>
    where?: TcOpWhereInput
  }

  export type TcOpUpdateToOneWithWhereWithoutTcCompraConteudoEntradaFaturadaInput = {
    where?: TcOpWhereInput
    data: XOR<TcOpUpdateWithoutTcCompraConteudoEntradaFaturadaInput, TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput>
  }

  export type TcOpUpdateWithoutTcCompraConteudoEntradaFaturadaInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcOpNestedInput
    Tc?: TcUpdateOneRequiredWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpUncheckedUpdateWithoutTcCompraConteudoEntradaFaturadaInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUncheckedUpdateManyWithoutTcOpNestedInput
  }

  export type TcCompraConteudoCreateWithoutTcOpInput = {
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    TcOpCompra: TcOpCompraCreateNestedOneWithoutTcCompraConteudoInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcCompraConteudoInput
  }

  export type TcCompraConteudoUncheckedCreateWithoutTcOpInput = {
    idCompra: string
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcCompraConteudoInput
  }

  export type TcCompraConteudoCreateOrConnectWithoutTcOpInput = {
    where: TcCompraConteudoWhereUniqueInput
    create: XOR<TcCompraConteudoCreateWithoutTcOpInput, TcCompraConteudoUncheckedCreateWithoutTcOpInput>
  }

  export type TcCompraConteudoCreateManyTcOpInputEnvelope = {
    data: TcCompraConteudoCreateManyTcOpInput | TcCompraConteudoCreateManyTcOpInput[]
  }

  export type TcCompraConteudoEntradaCreateWithoutTcOpInput = {
    idConteudoEntradaPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    TcCompraConteudo: TcCompraConteudoCreateNestedOneWithoutTcCompraConteudoEntradaInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcCompraConteudoEntradaInput
  }

  export type TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput = {
    idConteudoEntradaPhc: string
    idConteudoCompraPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcCompraConteudoEntradaInput
  }

  export type TcCompraConteudoEntradaCreateOrConnectWithoutTcOpInput = {
    where: TcCompraConteudoEntradaWhereUniqueInput
    create: XOR<TcCompraConteudoEntradaCreateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput>
  }

  export type TcCompraConteudoEntradaCreateManyTcOpInputEnvelope = {
    data: TcCompraConteudoEntradaCreateManyTcOpInput | TcCompraConteudoEntradaCreateManyTcOpInput[]
  }

  export type TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput = {
    idFaturaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    TcCompraConteudoEntrada: TcCompraConteudoEntradaCreateNestedOneWithoutTcCompraConteudoEntradaFaturadaInput
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput = {
    idFaturaPhc: string
    idConteudoEntradaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type TcCompraConteudoEntradaFaturadaCreateOrConnectWithoutTcOpInput = {
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    create: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput>
  }

  export type TcCompraConteudoEntradaFaturadaCreateManyTcOpInputEnvelope = {
    data: TcCompraConteudoEntradaFaturadaCreateManyTcOpInput | TcCompraConteudoEntradaFaturadaCreateManyTcOpInput[]
  }

  export type TcCreateWithoutTcOpInput = {
    idTc?: string
    fechado?: boolean
    createdAt?: Date | string
  }

  export type TcUncheckedCreateWithoutTcOpInput = {
    idTc?: string
    fechado?: boolean
    createdAt?: Date | string
  }

  export type TcCreateOrConnectWithoutTcOpInput = {
    where: TcWhereUniqueInput
    create: XOR<TcCreateWithoutTcOpInput, TcUncheckedCreateWithoutTcOpInput>
  }

  export type TcOpCompraCreateWithoutTcOpInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
    TcCompraConteudo?: TcCompraConteudoCreateNestedManyWithoutTcOpCompraInput
  }

  export type TcOpCompraUncheckedCreateWithoutTcOpInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
    TcCompraConteudo?: TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpCompraInput
  }

  export type TcOpCompraCreateOrConnectWithoutTcOpInput = {
    where: TcOpCompraWhereUniqueInput
    create: XOR<TcOpCompraCreateWithoutTcOpInput, TcOpCompraUncheckedCreateWithoutTcOpInput>
  }

  export type TcOpCompraCreateManyTcOpInputEnvelope = {
    data: TcOpCompraCreateManyTcOpInput | TcOpCompraCreateManyTcOpInput[]
  }

  export type TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpInput = {
    where: TcCompraConteudoWhereUniqueInput
    update: XOR<TcCompraConteudoUpdateWithoutTcOpInput, TcCompraConteudoUncheckedUpdateWithoutTcOpInput>
    create: XOR<TcCompraConteudoCreateWithoutTcOpInput, TcCompraConteudoUncheckedCreateWithoutTcOpInput>
  }

  export type TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpInput = {
    where: TcCompraConteudoWhereUniqueInput
    data: XOR<TcCompraConteudoUpdateWithoutTcOpInput, TcCompraConteudoUncheckedUpdateWithoutTcOpInput>
  }

  export type TcCompraConteudoUpdateManyWithWhereWithoutTcOpInput = {
    where: TcCompraConteudoScalarWhereInput
    data: XOR<TcCompraConteudoUpdateManyMutationInput, TcCompraConteudoUncheckedUpdateManyWithoutTcOpInput>
  }

  export type TcCompraConteudoScalarWhereInput = {
    AND?: TcCompraConteudoScalarWhereInput | TcCompraConteudoScalarWhereInput[]
    OR?: TcCompraConteudoScalarWhereInput[]
    NOT?: TcCompraConteudoScalarWhereInput | TcCompraConteudoScalarWhereInput[]
    idCompra?: StringFilter<"TcCompraConteudo"> | string
    idConteudoCompraPhc?: StringFilter<"TcCompraConteudo"> | string
    refTipo?: StringFilter<"TcCompraConteudo"> | string
    ref?: StringFilter<"TcCompraConteudo"> | string
    design?: StringFilter<"TcCompraConteudo"> | string
    qtt?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    cor?: StringFilter<"TcCompraConteudo"> | string
    tam?: StringFilter<"TcCompraConteudo"> | string
    unidade?: StringFilter<"TcCompraConteudo"> | string
    largura?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFilter<"TcCompraConteudo"> | Decimal | DecimalJsLike | number | string
    op?: IntFilter<"TcCompraConteudo"> | number
  }

  export type TcCompraConteudoEntradaUpsertWithWhereUniqueWithoutTcOpInput = {
    where: TcCompraConteudoEntradaWhereUniqueInput
    update: XOR<TcCompraConteudoEntradaUpdateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedUpdateWithoutTcOpInput>
    create: XOR<TcCompraConteudoEntradaCreateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedCreateWithoutTcOpInput>
  }

  export type TcCompraConteudoEntradaUpdateWithWhereUniqueWithoutTcOpInput = {
    where: TcCompraConteudoEntradaWhereUniqueInput
    data: XOR<TcCompraConteudoEntradaUpdateWithoutTcOpInput, TcCompraConteudoEntradaUncheckedUpdateWithoutTcOpInput>
  }

  export type TcCompraConteudoEntradaUpdateManyWithWhereWithoutTcOpInput = {
    where: TcCompraConteudoEntradaScalarWhereInput
    data: XOR<TcCompraConteudoEntradaUpdateManyMutationInput, TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpInput>
  }

  export type TcCompraConteudoEntradaFaturadaUpsertWithWhereUniqueWithoutTcOpInput = {
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    update: XOR<TcCompraConteudoEntradaFaturadaUpdateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateWithoutTcOpInput>
    create: XOR<TcCompraConteudoEntradaFaturadaCreateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedCreateWithoutTcOpInput>
  }

  export type TcCompraConteudoEntradaFaturadaUpdateWithWhereUniqueWithoutTcOpInput = {
    where: TcCompraConteudoEntradaFaturadaWhereUniqueInput
    data: XOR<TcCompraConteudoEntradaFaturadaUpdateWithoutTcOpInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateWithoutTcOpInput>
  }

  export type TcCompraConteudoEntradaFaturadaUpdateManyWithWhereWithoutTcOpInput = {
    where: TcCompraConteudoEntradaFaturadaScalarWhereInput
    data: XOR<TcCompraConteudoEntradaFaturadaUpdateManyMutationInput, TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpInput>
  }

  export type TcUpsertWithoutTcOpInput = {
    update: XOR<TcUpdateWithoutTcOpInput, TcUncheckedUpdateWithoutTcOpInput>
    create: XOR<TcCreateWithoutTcOpInput, TcUncheckedCreateWithoutTcOpInput>
    where?: TcWhereInput
  }

  export type TcUpdateToOneWithWhereWithoutTcOpInput = {
    where?: TcWhereInput
    data: XOR<TcUpdateWithoutTcOpInput, TcUncheckedUpdateWithoutTcOpInput>
  }

  export type TcUpdateWithoutTcOpInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TcUncheckedUpdateWithoutTcOpInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    fechado?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TcOpCompraUpsertWithWhereUniqueWithoutTcOpInput = {
    where: TcOpCompraWhereUniqueInput
    update: XOR<TcOpCompraUpdateWithoutTcOpInput, TcOpCompraUncheckedUpdateWithoutTcOpInput>
    create: XOR<TcOpCompraCreateWithoutTcOpInput, TcOpCompraUncheckedCreateWithoutTcOpInput>
  }

  export type TcOpCompraUpdateWithWhereUniqueWithoutTcOpInput = {
    where: TcOpCompraWhereUniqueInput
    data: XOR<TcOpCompraUpdateWithoutTcOpInput, TcOpCompraUncheckedUpdateWithoutTcOpInput>
  }

  export type TcOpCompraUpdateManyWithWhereWithoutTcOpInput = {
    where: TcOpCompraScalarWhereInput
    data: XOR<TcOpCompraUpdateManyMutationInput, TcOpCompraUncheckedUpdateManyWithoutTcOpInput>
  }

  export type TcOpCompraScalarWhereInput = {
    AND?: TcOpCompraScalarWhereInput | TcOpCompraScalarWhereInput[]
    OR?: TcOpCompraScalarWhereInput[]
    NOT?: TcOpCompraScalarWhereInput | TcOpCompraScalarWhereInput[]
    idCompra?: StringFilter<"TcOpCompra"> | string
    idCompraPhc?: StringFilter<"TcOpCompra"> | string
    nCompra?: IntFilter<"TcOpCompra"> | number
    nome?: StringFilter<"TcOpCompra"> | string
    dataCompra?: DateTimeFilter<"TcOpCompra"> | Date | string
    dataCompraString?: StringFilter<"TcOpCompra"> | string
    op?: IntFilter<"TcOpCompra"> | number
  }

  export type TcCompraConteudoCreateWithoutTcOpCompraInput = {
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    TcOp: TcOpCreateNestedOneWithoutTcCompraConteudoInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcCompraConteudoInput
  }

  export type TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput = {
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    op: number
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcCompraConteudoInput
  }

  export type TcCompraConteudoCreateOrConnectWithoutTcOpCompraInput = {
    where: TcCompraConteudoWhereUniqueInput
    create: XOR<TcCompraConteudoCreateWithoutTcOpCompraInput, TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput>
  }

  export type TcCompraConteudoCreateManyTcOpCompraInputEnvelope = {
    data: TcCompraConteudoCreateManyTcOpCompraInput | TcCompraConteudoCreateManyTcOpCompraInput[]
  }

  export type TcOpCreateWithoutTcOpCompraInput = {
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaCreateNestedManyWithoutTcOpInput
    Tc: TcCreateNestedOneWithoutTcOpInput
  }

  export type TcOpUncheckedCreateWithoutTcOpCompraInput = {
    idTc: string
    op: number
    foto: string
    createdAt?: Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedCreateNestedManyWithoutTcOpInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedCreateNestedManyWithoutTcOpInput
  }

  export type TcOpCreateOrConnectWithoutTcOpCompraInput = {
    where: TcOpWhereUniqueInput
    create: XOR<TcOpCreateWithoutTcOpCompraInput, TcOpUncheckedCreateWithoutTcOpCompraInput>
  }

  export type TcCompraConteudoUpsertWithWhereUniqueWithoutTcOpCompraInput = {
    where: TcCompraConteudoWhereUniqueInput
    update: XOR<TcCompraConteudoUpdateWithoutTcOpCompraInput, TcCompraConteudoUncheckedUpdateWithoutTcOpCompraInput>
    create: XOR<TcCompraConteudoCreateWithoutTcOpCompraInput, TcCompraConteudoUncheckedCreateWithoutTcOpCompraInput>
  }

  export type TcCompraConteudoUpdateWithWhereUniqueWithoutTcOpCompraInput = {
    where: TcCompraConteudoWhereUniqueInput
    data: XOR<TcCompraConteudoUpdateWithoutTcOpCompraInput, TcCompraConteudoUncheckedUpdateWithoutTcOpCompraInput>
  }

  export type TcCompraConteudoUpdateManyWithWhereWithoutTcOpCompraInput = {
    where: TcCompraConteudoScalarWhereInput
    data: XOR<TcCompraConteudoUpdateManyMutationInput, TcCompraConteudoUncheckedUpdateManyWithoutTcOpCompraInput>
  }

  export type TcOpUpsertWithoutTcOpCompraInput = {
    update: XOR<TcOpUpdateWithoutTcOpCompraInput, TcOpUncheckedUpdateWithoutTcOpCompraInput>
    create: XOR<TcOpCreateWithoutTcOpCompraInput, TcOpUncheckedCreateWithoutTcOpCompraInput>
    where?: TcOpWhereInput
  }

  export type TcOpUpdateToOneWithWhereWithoutTcOpCompraInput = {
    where?: TcOpWhereInput
    data: XOR<TcOpUpdateWithoutTcOpCompraInput, TcOpUncheckedUpdateWithoutTcOpCompraInput>
  }

  export type TcOpUpdateWithoutTcOpCompraInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcOpNestedInput
    Tc?: TcUpdateOneRequiredWithoutTcOpNestedInput
  }

  export type TcOpUncheckedUpdateWithoutTcOpCompraInput = {
    idTc?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpNestedInput
  }

  export type DataCamiaoCreateWithoutUserInput = {
    IdCamiao?: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
    Planeamento: PlaneamentoCreateNestedOneWithoutDataCamiaoInput
  }

  export type DataCamiaoUncheckedCreateWithoutUserInput = {
    idPlaneamento: string
    IdCamiao?: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataCamiaoCreateOrConnectWithoutUserInput = {
    where: DataCamiaoWhereUniqueInput
    create: XOR<DataCamiaoCreateWithoutUserInput, DataCamiaoUncheckedCreateWithoutUserInput>
  }

  export type DataCamiaoCreateManyUserInputEnvelope = {
    data: DataCamiaoCreateManyUserInput | DataCamiaoCreateManyUserInput[]
  }

  export type DataEnvioCreateWithoutUserInput = {
    idEnvio?: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
    Planeamento: PlaneamentoCreateNestedOneWithoutDataEnvioInput
  }

  export type DataEnvioUncheckedCreateWithoutUserInput = {
    idPlaneamento: string
    idEnvio?: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataEnvioCreateOrConnectWithoutUserInput = {
    where: DataEnvioWhereUniqueInput
    create: XOR<DataEnvioCreateWithoutUserInput, DataEnvioUncheckedCreateWithoutUserInput>
  }

  export type DataEnvioCreateManyUserInputEnvelope = {
    data: DataEnvioCreateManyUserInput | DataEnvioCreateManyUserInput[]
  }

  export type LivreCreateWithoutUserInput = {
    idLivre?: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutLivreInput
    OrcamentoLivre?: OrcamentoLivreCreateNestedOneWithoutLivreInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreCreateNestedManyWithoutLivreInput
  }

  export type LivreUncheckedCreateWithoutUserInput = {
    idPlaneamento: string
    idLivre?: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedCreateNestedOneWithoutLivreInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedCreateNestedManyWithoutLivreInput
  }

  export type LivreCreateOrConnectWithoutUserInput = {
    where: LivreWhereUniqueInput
    create: XOR<LivreCreateWithoutUserInput, LivreUncheckedCreateWithoutUserInput>
  }

  export type LivreCreateManyUserInputEnvelope = {
    data: LivreCreateManyUserInput | LivreCreateManyUserInput[]
  }

  export type OpCreateWithoutUserInput = {
    Op: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    Planeamento: PlaneamentoCreateNestedOneWithoutOpInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpUncheckedCreateWithoutUserInput = {
    idPlaneamento: string
    Op: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedCreateNestedOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedCreateNestedManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput
  }

  export type OpCreateOrConnectWithoutUserInput = {
    where: OpWhereUniqueInput
    create: XOR<OpCreateWithoutUserInput, OpUncheckedCreateWithoutUserInput>
  }

  export type OpCreateManyUserInputEnvelope = {
    data: OpCreateManyUserInput | OpCreateManyUserInput[]
  }

  export type PlaneamentoCreateWithoutUserInput = {
    idPlaneamento?: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreCreateNestedManyWithoutPlaneamentoInput
    Op?: OpCreateNestedManyWithoutPlaneamentoInput
    Fornecedor: FornecedorCreateNestedOneWithoutPlaneamentoInput
  }

  export type PlaneamentoUncheckedCreateWithoutUserInput = {
    idPlaneamento?: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutPlaneamentoInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutPlaneamentoInput
    Livre?: LivreUncheckedCreateNestedManyWithoutPlaneamentoInput
    Op?: OpUncheckedCreateNestedManyWithoutPlaneamentoInput
  }

  export type PlaneamentoCreateOrConnectWithoutUserInput = {
    where: PlaneamentoWhereUniqueInput
    create: XOR<PlaneamentoCreateWithoutUserInput, PlaneamentoUncheckedCreateWithoutUserInput>
  }

  export type PlaneamentoCreateManyUserInputEnvelope = {
    data: PlaneamentoCreateManyUserInput | PlaneamentoCreateManyUserInput[]
  }

  export type UserPapeisCreateWithoutUserInput = {
    Papeis: PapeisCreateNestedOneWithoutUserPapeisInput
  }

  export type UserPapeisUncheckedCreateWithoutUserInput = {
    idPapel: string
  }

  export type UserPapeisCreateOrConnectWithoutUserInput = {
    where: UserPapeisWhereUniqueInput
    create: XOR<UserPapeisCreateWithoutUserInput, UserPapeisUncheckedCreateWithoutUserInput>
  }

  export type UserPapeisCreateManyUserInputEnvelope = {
    data: UserPapeisCreateManyUserInput | UserPapeisCreateManyUserInput[]
  }

  export type DataCamiaoUpsertWithWhereUniqueWithoutUserInput = {
    where: DataCamiaoWhereUniqueInput
    update: XOR<DataCamiaoUpdateWithoutUserInput, DataCamiaoUncheckedUpdateWithoutUserInput>
    create: XOR<DataCamiaoCreateWithoutUserInput, DataCamiaoUncheckedCreateWithoutUserInput>
  }

  export type DataCamiaoUpdateWithWhereUniqueWithoutUserInput = {
    where: DataCamiaoWhereUniqueInput
    data: XOR<DataCamiaoUpdateWithoutUserInput, DataCamiaoUncheckedUpdateWithoutUserInput>
  }

  export type DataCamiaoUpdateManyWithWhereWithoutUserInput = {
    where: DataCamiaoScalarWhereInput
    data: XOR<DataCamiaoUpdateManyMutationInput, DataCamiaoUncheckedUpdateManyWithoutUserInput>
  }

  export type DataEnvioUpsertWithWhereUniqueWithoutUserInput = {
    where: DataEnvioWhereUniqueInput
    update: XOR<DataEnvioUpdateWithoutUserInput, DataEnvioUncheckedUpdateWithoutUserInput>
    create: XOR<DataEnvioCreateWithoutUserInput, DataEnvioUncheckedCreateWithoutUserInput>
  }

  export type DataEnvioUpdateWithWhereUniqueWithoutUserInput = {
    where: DataEnvioWhereUniqueInput
    data: XOR<DataEnvioUpdateWithoutUserInput, DataEnvioUncheckedUpdateWithoutUserInput>
  }

  export type DataEnvioUpdateManyWithWhereWithoutUserInput = {
    where: DataEnvioScalarWhereInput
    data: XOR<DataEnvioUpdateManyMutationInput, DataEnvioUncheckedUpdateManyWithoutUserInput>
  }

  export type LivreUpsertWithWhereUniqueWithoutUserInput = {
    where: LivreWhereUniqueInput
    update: XOR<LivreUpdateWithoutUserInput, LivreUncheckedUpdateWithoutUserInput>
    create: XOR<LivreCreateWithoutUserInput, LivreUncheckedCreateWithoutUserInput>
  }

  export type LivreUpdateWithWhereUniqueWithoutUserInput = {
    where: LivreWhereUniqueInput
    data: XOR<LivreUpdateWithoutUserInput, LivreUncheckedUpdateWithoutUserInput>
  }

  export type LivreUpdateManyWithWhereWithoutUserInput = {
    where: LivreScalarWhereInput
    data: XOR<LivreUpdateManyMutationInput, LivreUncheckedUpdateManyWithoutUserInput>
  }

  export type OpUpsertWithWhereUniqueWithoutUserInput = {
    where: OpWhereUniqueInput
    update: XOR<OpUpdateWithoutUserInput, OpUncheckedUpdateWithoutUserInput>
    create: XOR<OpCreateWithoutUserInput, OpUncheckedCreateWithoutUserInput>
  }

  export type OpUpdateWithWhereUniqueWithoutUserInput = {
    where: OpWhereUniqueInput
    data: XOR<OpUpdateWithoutUserInput, OpUncheckedUpdateWithoutUserInput>
  }

  export type OpUpdateManyWithWhereWithoutUserInput = {
    where: OpScalarWhereInput
    data: XOR<OpUpdateManyMutationInput, OpUncheckedUpdateManyWithoutUserInput>
  }

  export type PlaneamentoUpsertWithWhereUniqueWithoutUserInput = {
    where: PlaneamentoWhereUniqueInput
    update: XOR<PlaneamentoUpdateWithoutUserInput, PlaneamentoUncheckedUpdateWithoutUserInput>
    create: XOR<PlaneamentoCreateWithoutUserInput, PlaneamentoUncheckedCreateWithoutUserInput>
  }

  export type PlaneamentoUpdateWithWhereUniqueWithoutUserInput = {
    where: PlaneamentoWhereUniqueInput
    data: XOR<PlaneamentoUpdateWithoutUserInput, PlaneamentoUncheckedUpdateWithoutUserInput>
  }

  export type PlaneamentoUpdateManyWithWhereWithoutUserInput = {
    where: PlaneamentoScalarWhereInput
    data: XOR<PlaneamentoUpdateManyMutationInput, PlaneamentoUncheckedUpdateManyWithoutUserInput>
  }

  export type UserPapeisUpsertWithWhereUniqueWithoutUserInput = {
    where: UserPapeisWhereUniqueInput
    update: XOR<UserPapeisUpdateWithoutUserInput, UserPapeisUncheckedUpdateWithoutUserInput>
    create: XOR<UserPapeisCreateWithoutUserInput, UserPapeisUncheckedCreateWithoutUserInput>
  }

  export type UserPapeisUpdateWithWhereUniqueWithoutUserInput = {
    where: UserPapeisWhereUniqueInput
    data: XOR<UserPapeisUpdateWithoutUserInput, UserPapeisUncheckedUpdateWithoutUserInput>
  }

  export type UserPapeisUpdateManyWithWhereWithoutUserInput = {
    where: UserPapeisScalarWhereInput
    data: XOR<UserPapeisUpdateManyMutationInput, UserPapeisUncheckedUpdateManyWithoutUserInput>
  }

  export type PapeisCreateWithoutUserPapeisInput = {
    idPapeis?: string
    descPapel: string
  }

  export type PapeisUncheckedCreateWithoutUserPapeisInput = {
    idPapeis?: string
    descPapel: string
  }

  export type PapeisCreateOrConnectWithoutUserPapeisInput = {
    where: PapeisWhereUniqueInput
    create: XOR<PapeisCreateWithoutUserPapeisInput, PapeisUncheckedCreateWithoutUserPapeisInput>
  }

  export type UserCreateWithoutUserPapeisInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioCreateNestedManyWithoutUserInput
    Livre?: LivreCreateNestedManyWithoutUserInput
    Op?: OpCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUserPapeisInput = {
    nomeUser: string
    pHashed: string
    nome: string
    apelido: string
    email: string
    createdAt?: Date | string
    updatedAt: Date | string
    DataCamiao?: DataCamiaoUncheckedCreateNestedManyWithoutUserInput
    DataEnvio?: DataEnvioUncheckedCreateNestedManyWithoutUserInput
    Livre?: LivreUncheckedCreateNestedManyWithoutUserInput
    Op?: OpUncheckedCreateNestedManyWithoutUserInput
    Planeamento?: PlaneamentoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUserPapeisInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUserPapeisInput, UserUncheckedCreateWithoutUserPapeisInput>
  }

  export type PapeisUpsertWithoutUserPapeisInput = {
    update: XOR<PapeisUpdateWithoutUserPapeisInput, PapeisUncheckedUpdateWithoutUserPapeisInput>
    create: XOR<PapeisCreateWithoutUserPapeisInput, PapeisUncheckedCreateWithoutUserPapeisInput>
    where?: PapeisWhereInput
  }

  export type PapeisUpdateToOneWithWhereWithoutUserPapeisInput = {
    where?: PapeisWhereInput
    data: XOR<PapeisUpdateWithoutUserPapeisInput, PapeisUncheckedUpdateWithoutUserPapeisInput>
  }

  export type PapeisUpdateWithoutUserPapeisInput = {
    idPapeis?: StringFieldUpdateOperationsInput | string
    descPapel?: StringFieldUpdateOperationsInput | string
  }

  export type PapeisUncheckedUpdateWithoutUserPapeisInput = {
    idPapeis?: StringFieldUpdateOperationsInput | string
    descPapel?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithoutUserPapeisInput = {
    update: XOR<UserUpdateWithoutUserPapeisInput, UserUncheckedUpdateWithoutUserPapeisInput>
    create: XOR<UserCreateWithoutUserPapeisInput, UserUncheckedCreateWithoutUserPapeisInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUserPapeisInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUserPapeisInput, UserUncheckedUpdateWithoutUserPapeisInput>
  }

  export type UserUpdateWithoutUserPapeisInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutUserNestedInput
    Livre?: LivreUpdateManyWithoutUserNestedInput
    Op?: OpUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUserPapeisInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
    pHashed?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    apelido?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutUserNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutUserNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutUserNestedInput
    Op?: OpUncheckedUpdateManyWithoutUserNestedInput
    Planeamento?: PlaneamentoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BmMalhasCreateManyBmInput = {
    ref: string
    malha: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmOpCreateManyBmInput = {
    op: number
    CreatedAt?: Date | string
    foto?: string
  }

  export type BmTcCreateManyBmInput = {
    nomeTc: string
  }

  export type BmMalhasUpdateWithoutBmInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUpdateManyWithoutBmMalhasNestedInput
    BmMateriais?: BmMateriaisUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateWithoutBmInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateManyWithoutBmInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpUpdateWithoutBmInput = {
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    BmOpFaturado?: BmOpFaturadoUpdateManyWithoutBmOpNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmOpNestedInput
  }

  export type BmOpUncheckedUpdateWithoutBmInput = {
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
    BmOpFaturado?: BmOpFaturadoUncheckedUpdateManyWithoutBmOpNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmOpNestedInput
  }

  export type BmOpUncheckedUpdateManyWithoutBmInput = {
    op?: IntFieldUpdateOperationsInput | number
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    foto?: StringFieldUpdateOperationsInput | string
  }

  export type BmTcUpdateWithoutBmInput = {
    nomeTc?: StringFieldUpdateOperationsInput | string
  }

  export type BmTcUncheckedUpdateWithoutBmInput = {
    nomeTc?: StringFieldUpdateOperationsInput | string
  }

  export type BmTcUncheckedUpdateManyWithoutBmInput = {
    nomeTc?: StringFieldUpdateOperationsInput | string
  }

  export type BmIdBmComposicaoCreateManyBmMalhasInput = {
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasFioCreateManyBmMalhasInput = {
    refOrigem: string
    fio: string
    grupo: string
    subGrupo: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmOpsPorMalhaCreateManyBmMalhasInput = {
    op: number
  }

  export type BmIdBmComposicaoUpdateWithoutBmMalhasInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BmMateriaisComposicao?: BmMateriaisComposicaoUpdateOneRequiredWithoutBmIdBmComposicaoNestedInput
  }

  export type BmIdBmComposicaoUncheckedUpdateWithoutBmMalhasInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasFioUpdateWithoutBmMalhasInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUpdateManyWithoutBmMalhasFioNestedInput
    BmMateriaisFio?: BmMateriaisFioUpdateOneRequiredWithoutBmMalhasFioNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioUncheckedUpdateWithoutBmMalhasInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUncheckedUpdateManyWithoutBmMalhasFioNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioUncheckedUpdateManyWithoutBmMalhasInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    grupo?: StringFieldUpdateOperationsInput | string
    subGrupo?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpsPorMalhaUpdateWithoutBmMalhasInput = {
    BmMovimentosLotes?: BmMovimentosLotesUpdateManyWithoutBmOpsPorMalhaNestedInput
    BmOp?: BmOpUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaUncheckedUpdateWithoutBmMalhasInput = {
    op?: IntFieldUpdateOperationsInput | number
    BmMovimentosLotes?: BmMovimentosLotesUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasInput = {
    op?: IntFieldUpdateOperationsInput | number
  }

  export type BmFioComposicaoCreateManyBmMalhasFioInput = {
    idComposicao: number
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmOpsPorMalhaFioCreateManyBmMalhasFioInput = {
    op: number
  }

  export type BmFioComposicaoUpdateWithoutBmMalhasFioInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BmMateriaisComposicao?: BmMateriaisComposicaoUpdateOneRequiredWithoutBmFioComposicaoNestedInput
  }

  export type BmFioComposicaoUncheckedUpdateWithoutBmMalhasFioInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoUncheckedUpdateManyWithoutBmMalhasFioInput = {
    idComposicao?: IntFieldUpdateOperationsInput | number
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmOpsPorMalhaFioUpdateWithoutBmMalhasFioInput = {
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUpdateManyWithoutBmOpsPorMalhaFioNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput
  }

  export type BmOpsPorMalhaFioUncheckedUpdateWithoutBmMalhasFioInput = {
    op?: IntFieldUpdateOperationsInput | number
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUncheckedUpdateManyWithoutBmOpsPorMalhaFioNestedInput
  }

  export type BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmMalhasFioInput = {
    op?: IntFieldUpdateOperationsInput | number
  }

  export type BmMalhasCreateManyBmMateriaisInput = {
    idBm: string
    ref: string
    malha: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: Decimal | DecimalJsLike | number | string | null
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasUpdateWithoutBmMateriaisInput = {
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUpdateManyWithoutBmMalhasNestedInput
    Bm?: BmUpdateOneRequiredWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateWithoutBmMateriaisInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmIdBmComposicao?: BmIdBmComposicaoUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMalhasNestedInput
    BmOpsPorMalha?: BmOpsPorMalhaUncheckedUpdateManyWithoutBmMalhasNestedInput
  }

  export type BmMalhasUncheckedUpdateManyWithoutBmMateriaisInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    malha?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntradaSeUnidade?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmFioComposicaoCreateManyBmMateriaisComposicaoInput = {
    idBm: string
    ref: string
    refOrigem: string
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoCreateManyBmMateriaisComposicaoInput = {
    idBm: string
    ref: string
    qtt: Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoUpdateWithoutBmMateriaisComposicaoInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BmMalhasFio?: BmMalhasFioUpdateOneRequiredWithoutBmFioComposicaoNestedInput
  }

  export type BmFioComposicaoUncheckedUpdateWithoutBmMateriaisComposicaoInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmFioComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoUpdateWithoutBmMateriaisComposicaoInput = {
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmIdBmComposicaoNestedInput
  }

  export type BmIdBmComposicaoUncheckedUpdateWithoutBmMateriaisComposicaoInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmIdBmComposicaoUncheckedUpdateManyWithoutBmMateriaisComposicaoInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type BmMalhasFioCreateManyBmMateriaisFioInput = {
    idBm: string
    ref: string
    refOrigem: string
    fio: string
    qtdePedida: Decimal | DecimalJsLike | number | string
    qtdeEntrada: Decimal | DecimalJsLike | number | string
    defeitosStock: Decimal | DecimalJsLike | number | string
    sobras: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasFioUpdateWithoutBmMateriaisFioInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUpdateManyWithoutBmMalhasFioNestedInput
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmMalhasFioNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioUncheckedUpdateWithoutBmMateriaisFioInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    BmFioComposicao?: BmFioComposicaoUncheckedUpdateManyWithoutBmMalhasFioNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmMalhasFioNestedInput
  }

  export type BmMalhasFioUncheckedUpdateManyWithoutBmMateriaisFioInput = {
    idBm?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    refOrigem?: StringFieldUpdateOperationsInput | string
    fio?: StringFieldUpdateOperationsInput | string
    qtdePedida?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    qtdeEntrada?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    defeitosStock?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    sobras?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMateriaisCreateManyBmMaterialGrupoInput = {
    subGrupo: string
  }

  export type BmMateriaisUpdateWithoutBmMaterialGrupoInput = {
    BmMalhas?: BmMalhasUpdateManyWithoutBmMateriaisNestedInput
    BmMaterialSubGrupo?: BmMaterialSubGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput
  }

  export type BmMateriaisUncheckedUpdateWithoutBmMaterialGrupoInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    BmMalhas?: BmMalhasUncheckedUpdateManyWithoutBmMateriaisNestedInput
  }

  export type BmMateriaisUncheckedUpdateManyWithoutBmMaterialGrupoInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmMateriaisFioCreateManyBmMaterialGrupoFioInput = {
    subGrupo: string
  }

  export type BmMateriaisFioUpdateWithoutBmMaterialGrupoFioInput = {
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMateriaisFioNestedInput
    BmMaterialSubGrupoFio?: BmMaterialSubGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput
  }

  export type BmMateriaisFioUncheckedUpdateWithoutBmMaterialGrupoFioInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMateriaisFioNestedInput
  }

  export type BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialGrupoFioInput = {
    subGrupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmMateriaisCreateManyBmMaterialSubGrupoInput = {
    grupo: string
  }

  export type BmMateriaisUpdateWithoutBmMaterialSubGrupoInput = {
    BmMalhas?: BmMalhasUpdateManyWithoutBmMateriaisNestedInput
    BmMaterialGrupo?: BmMaterialGrupoUpdateOneRequiredWithoutBmMateriaisNestedInput
  }

  export type BmMateriaisUncheckedUpdateWithoutBmMaterialSubGrupoInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    BmMalhas?: BmMalhasUncheckedUpdateManyWithoutBmMateriaisNestedInput
  }

  export type BmMateriaisUncheckedUpdateManyWithoutBmMaterialSubGrupoInput = {
    grupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmMateriaisFioCreateManyBmMaterialSubGrupoFioInput = {
    grupo: string
  }

  export type BmMateriaisFioUpdateWithoutBmMaterialSubGrupoFioInput = {
    BmMalhasFio?: BmMalhasFioUpdateManyWithoutBmMateriaisFioNestedInput
    BmMaterialGrupoFio?: BmMaterialGrupoFioUpdateOneRequiredWithoutBmMateriaisFioNestedInput
  }

  export type BmMateriaisFioUncheckedUpdateWithoutBmMaterialSubGrupoFioInput = {
    grupo?: StringFieldUpdateOperationsInput | string
    BmMalhasFio?: BmMalhasFioUncheckedUpdateManyWithoutBmMateriaisFioNestedInput
  }

  export type BmMateriaisFioUncheckedUpdateManyWithoutBmMaterialSubGrupoFioInput = {
    grupo?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpFaturadoCreateManyBmOpInput = {
    nFatutura: number
    fData: Date | string
    dataFatura: string
    refModelo: string
    pedido: string
    qtt: Decimal | DecimalJsLike | number | string
    pesoLiquido: Decimal | DecimalJsLike | number | string
    pesoBruto: Decimal | DecimalJsLike | number | string
    cmr: string
    local: string
    obs?: string | null
  }

  export type BmOpsPorMalhaCreateManyBmOpInput = {
    ref: string
  }

  export type BmOpFaturadoUpdateWithoutBmOpInput = {
    nFatutura?: IntFieldUpdateOperationsInput | number
    fData?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFatura?: StringFieldUpdateOperationsInput | string
    refModelo?: StringFieldUpdateOperationsInput | string
    pedido?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmr?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmOpFaturadoUncheckedUpdateWithoutBmOpInput = {
    nFatutura?: IntFieldUpdateOperationsInput | number
    fData?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFatura?: StringFieldUpdateOperationsInput | string
    refModelo?: StringFieldUpdateOperationsInput | string
    pedido?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmr?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmOpFaturadoUncheckedUpdateManyWithoutBmOpInput = {
    nFatutura?: IntFieldUpdateOperationsInput | number
    fData?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFatura?: StringFieldUpdateOperationsInput | string
    refModelo?: StringFieldUpdateOperationsInput | string
    pedido?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoLiquido?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    pesoBruto?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cmr?: StringFieldUpdateOperationsInput | string
    local?: StringFieldUpdateOperationsInput | string
    obs?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BmOpsPorMalhaUpdateWithoutBmOpInput = {
    BmMovimentosLotes?: BmMovimentosLotesUpdateManyWithoutBmOpsPorMalhaNestedInput
    BmMalhas?: BmMalhasUpdateOneRequiredWithoutBmOpsPorMalhaNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaUncheckedUpdateWithoutBmOpInput = {
    ref?: StringFieldUpdateOperationsInput | string
    BmMovimentosLotes?: BmMovimentosLotesUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
    BmOpsPorMalhaFio?: BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmOpsPorMalhaNestedInput
  }

  export type BmOpsPorMalhaUncheckedUpdateManyWithoutBmOpInput = {
    ref?: StringFieldUpdateOperationsInput | string
  }

  export type BmMovimentosLotesCreateManyBmOpsPorMalhaInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmOpsPorMalhaFioCreateManyBmOpsPorMalhaInput = {
    refOrigem: string
  }

  export type BmMovimentosLotesUpdateWithoutBmOpsPorMalhaInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMovimentosLotesUncheckedUpdateWithoutBmOpsPorMalhaInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMovimentosLotesUncheckedUpdateManyWithoutBmOpsPorMalhaInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmOpsPorMalhaFioUpdateWithoutBmOpsPorMalhaInput = {
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUpdateManyWithoutBmOpsPorMalhaFioNestedInput
    BmMalhasFio?: BmMalhasFioUpdateOneRequiredWithoutBmOpsPorMalhaFioNestedInput
  }

  export type BmOpsPorMalhaFioUncheckedUpdateWithoutBmOpsPorMalhaInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
    BmMalhasFioMovimentos?: BmMalhasFioMovimentosUncheckedUpdateManyWithoutBmOpsPorMalhaFioNestedInput
  }

  export type BmOpsPorMalhaFioUncheckedUpdateManyWithoutBmOpsPorMalhaInput = {
    refOrigem?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioMovimentosCreateManyBmOpsPorMalhaFioInput = {
    idBmMovimentosLote?: string
    idMovimento: string
    nMovimento: number
    nome: string
    idTipo: Decimal | DecimalJsLike | number | string
    tipo: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type BmMalhasFioMovimentosUpdateWithoutBmOpsPorMalhaFioInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioMovimentosUncheckedUpdateWithoutBmOpsPorMalhaFioInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type BmMalhasFioMovimentosUncheckedUpdateManyWithoutBmOpsPorMalhaFioInput = {
    idBmMovimentosLote?: StringFieldUpdateOperationsInput | string
    idMovimento?: StringFieldUpdateOperationsInput | string
    nMovimento?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    idTipo?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tipo?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type PlaneamentoCreateManyFornecedorInput = {
    idPlaneamento?: string
    nomeUser: string
    pais: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
  }

  export type PlaneamentoUpdateWithoutFornecedorInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUpdateManyWithoutPlaneamentoNestedInput
    User?: UserUpdateOneRequiredWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateWithoutFornecedorInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUncheckedUpdateManyWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateManyWithoutFornecedorInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicosEscolhidosLivreCreateManyLivreInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
  }

  export type ServicosEscolhidosLivreUpdateWithoutLivreInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUpdateManyWithoutServicosEscolhidosLivreNestedInput
  }

  export type ServicosEscolhidosLivreUncheckedUpdateWithoutLivreInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutServicosEscolhidosLivreNestedInput
  }

  export type ServicosEscolhidosLivreUncheckedUpdateManyWithoutLivreInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpCreateManyOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idServicoEscolhido?: string
    nome: string
    qtt: number
    preco: number
    valor: number
    unidade: string
    obs: string
  }

  export type ServicosEscolhidosOpUpdateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUpdateManyWithoutServicosEscolhidosOpNestedInput
  }

  export type ServicosEscolhidosOpUncheckedUpdateWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutServicosEscolhidosOpNestedInput
  }

  export type ServicosEscolhidosOpUncheckedUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpInput = {
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    qtt?: FloatFieldUpdateOperationsInput | number
    preco?: FloatFieldUpdateOperationsInput | number
    valor?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type OrcamentoLivreLinhasCreateManyOrcamentoLivreInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
  }

  export type OrcamentoLivreLinhasUpdateWithoutOrcamentoLivreInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUpdateManyWithoutOrcamentoLivreLinhasNestedInput
  }

  export type OrcamentoLivreLinhasUncheckedUpdateWithoutOrcamentoLivreInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosLivreOrigem?: ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutOrcamentoLivreLinhasNestedInput
  }

  export type OrcamentoLivreLinhasUncheckedUpdateManyWithoutOrcamentoLivreInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosLivreOrigemCreateManyOrcamentoLivreLinhasInput = {
    idPlaneamento: string
    idLivre: string
    idServicoEscolhido: string
  }

  export type ServicosEscolhidosLivreOrigemUpdateWithoutOrcamentoLivreLinhasInput = {
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUpdateOneRequiredWithoutServicosEscolhidosLivreOrigemNestedInput
  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateWithoutOrcamentoLivreLinhasInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutOrcamentoLivreLinhasInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
  }

  export type OrcamentoOpLinhasCreateManyOrcamentoOpInput = {
    orcamentoLinhasStamp?: string
    orcamentoLinhasStampRecebido: string
    ordem: number
    design: string
    custoPeca: number
    edebito: number
    qtt: number
    unidade: string
  }

  export type OrcamentoOpLinhasUpdateWithoutOrcamentoOpInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUpdateManyWithoutOrcamentoOpLinhasNestedInput
  }

  export type OrcamentoOpLinhasUncheckedUpdateWithoutOrcamentoOpInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
    ServicosEscolhidosOpOrigem?: ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutOrcamentoOpLinhasNestedInput
  }

  export type OrcamentoOpLinhasUncheckedUpdateManyWithoutOrcamentoOpInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
    orcamentoLinhasStampRecebido?: StringFieldUpdateOperationsInput | string
    ordem?: IntFieldUpdateOperationsInput | number
    design?: StringFieldUpdateOperationsInput | string
    custoPeca?: FloatFieldUpdateOperationsInput | number
    edebito?: FloatFieldUpdateOperationsInput | number
    qtt?: FloatFieldUpdateOperationsInput | number
    unidade?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpOrigemCreateManyOrcamentoOpLinhasInput = {
    idPlaneamento: string
    Op: string
    idServicoEscolhido: string
  }

  export type ServicosEscolhidosOpOrigemUpdateWithoutOrcamentoOpLinhasInput = {
    ServicosEscolhidosOp?: ServicosEscolhidosOpUpdateOneRequiredWithoutServicosEscolhidosOpOrigemNestedInput
  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateWithoutOrcamentoOpLinhasInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutOrcamentoOpLinhasInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    idServicoEscolhido?: StringFieldUpdateOperationsInput | string
  }

  export type UserPapeisCreateManyPapeisInput = {
    nomeUser: string
  }

  export type UserPapeisUpdateWithoutPapeisInput = {
    User?: UserUpdateOneRequiredWithoutUserPapeisNestedInput
  }

  export type UserPapeisUncheckedUpdateWithoutPapeisInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
  }

  export type UserPapeisUncheckedUpdateManyWithoutPapeisInput = {
    nomeUser?: StringFieldUpdateOperationsInput | string
  }

  export type DataCamiaoCreateManyPlaneamentoInput = {
    IdCamiao?: string
    nomeUser: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataEnvioCreateManyPlaneamentoInput = {
    idEnvio?: string
    nomeUser: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type LivreCreateManyPlaneamentoInput = {
    idLivre?: string
    nomeUser: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
  }

  export type OpCreateManyPlaneamentoInput = {
    Op: string
    nomeUser: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
  }

  export type DataCamiaoUpdateWithoutPlaneamentoInput = {
    IdCamiao?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutDataCamiaoNestedInput
  }

  export type DataCamiaoUncheckedUpdateWithoutPlaneamentoInput = {
    IdCamiao?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataCamiaoUncheckedUpdateManyWithoutPlaneamentoInput = {
    IdCamiao?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataEnvioUpdateWithoutPlaneamentoInput = {
    idEnvio?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutDataEnvioNestedInput
  }

  export type DataEnvioUncheckedUpdateWithoutPlaneamentoInput = {
    idEnvio?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataEnvioUncheckedUpdateManyWithoutPlaneamentoInput = {
    idEnvio?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type LivreUpdateWithoutPlaneamentoInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutLivreNestedInput
    OrcamentoLivre?: OrcamentoLivreUpdateOneWithoutLivreNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUpdateManyWithoutLivreNestedInput
  }

  export type LivreUncheckedUpdateWithoutPlaneamentoInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedUpdateOneWithoutLivreNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedUpdateManyWithoutLivreNestedInput
  }

  export type LivreUncheckedUpdateManyWithoutPlaneamentoInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpUpdateWithoutPlaneamentoInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    User?: UserUpdateOneRequiredWithoutOpNestedInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpUncheckedUpdateWithoutPlaneamentoInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpUncheckedUpdateManyWithoutPlaneamentoInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nomeUser?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicosEscolhidosLivreOrigemCreateManyServicosEscolhidosLivreInput = {
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosLivreOrigemUpdateWithoutServicosEscolhidosLivreInput = {
    OrcamentoLivreLinhas?: OrcamentoLivreLinhasUpdateOneRequiredWithoutServicosEscolhidosLivreOrigemNestedInput
  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateWithoutServicosEscolhidosLivreInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosLivreOrigemUncheckedUpdateManyWithoutServicosEscolhidosLivreInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpOrigemCreateManyServicosEscolhidosOpInput = {
    orcamentoLinhasStamp: string
  }

  export type ServicosEscolhidosOpOrigemUpdateWithoutServicosEscolhidosOpInput = {
    OrcamentoOpLinhas?: OrcamentoOpLinhasUpdateOneRequiredWithoutServicosEscolhidosOpOrigemNestedInput
  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateWithoutServicosEscolhidosOpInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type ServicosEscolhidosOpOrigemUncheckedUpdateManyWithoutServicosEscolhidosOpInput = {
    orcamentoLinhasStamp?: StringFieldUpdateOperationsInput | string
  }

  export type TcOpCreateManyTcInput = {
    op: number
    foto: string
    createdAt?: Date | string
  }

  export type TcOpUpdateWithoutTcInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpUncheckedUpdateWithoutTcInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TcCompraConteudo?: TcCompraConteudoUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpNestedInput
    TcOpCompra?: TcOpCompraUncheckedUpdateManyWithoutTcOpNestedInput
  }

  export type TcOpUncheckedUpdateManyWithoutTcInput = {
    op?: IntFieldUpdateOperationsInput | number
    foto?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TcCompraConteudoEntradaCreateManyTcCompraConteudoInput = {
    idConteudoEntradaPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
    op: number
  }

  export type TcCompraConteudoEntradaUpdateWithoutTcCompraConteudoInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcCompraConteudoEntradaNestedInput
  }

  export type TcCompraConteudoEntradaUncheckedUpdateWithoutTcCompraConteudoInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcCompraConteudoEntradaNestedInput
  }

  export type TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcCompraConteudoInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcCompraConteudoEntradaFaturadaCreateManyTcCompraConteudoEntradaInput = {
    idFaturaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
    op: number
  }

  export type TcCompraConteudoEntradaFaturadaUpdateWithoutTcCompraConteudoEntradaInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoEntradaFaturadaNestedInput
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateWithoutTcCompraConteudoEntradaInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcCompraConteudoEntradaInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type TcCompraConteudoCreateManyTcOpInput = {
    idCompra: string
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
  }

  export type TcCompraConteudoEntradaCreateManyTcOpInput = {
    idConteudoEntradaPhc: string
    idConteudoCompraPhc: string
    nEntrada: number
    Nguia: string
    dataEntrada: Date | string
    dataEntradaString: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    lote: string
  }

  export type TcCompraConteudoEntradaFaturadaCreateManyTcOpInput = {
    idFaturaPhc: string
    idConteudoEntradaPhc: string
    nGuiaPhc: number
    nFatura: string
    dataFatura: Date | string
    dataFaturaString: string
    qtt: Decimal | DecimalJsLike | number | string
    unidade: string
    lote: string
  }

  export type TcOpCompraCreateManyTcOpInput = {
    idCompra?: string
    idCompraPhc: string
    nCompra: number
    nome: string
    dataCompra: Date | string
    dataCompraString: string
  }

  export type TcCompraConteudoUpdateWithoutTcOpInput = {
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TcOpCompra?: TcOpCompraUpdateOneRequiredWithoutTcCompraConteudoNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcCompraConteudoNestedInput
  }

  export type TcCompraConteudoUncheckedUpdateWithoutTcOpInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcCompraConteudoNestedInput
  }

  export type TcCompraConteudoUncheckedUpdateManyWithoutTcOpInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type TcCompraConteudoEntradaUpdateWithoutTcOpInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    TcCompraConteudo?: TcCompraConteudoUpdateOneRequiredWithoutTcCompraConteudoEntradaNestedInput
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUpdateManyWithoutTcCompraConteudoEntradaNestedInput
  }

  export type TcCompraConteudoEntradaUncheckedUpdateWithoutTcOpInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
    TcCompraConteudoEntradaFaturada?: TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcCompraConteudoEntradaNestedInput
  }

  export type TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcOpInput = {
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    nEntrada?: IntFieldUpdateOperationsInput | number
    Nguia?: StringFieldUpdateOperationsInput | string
    dataEntrada?: DateTimeFieldUpdateOperationsInput | Date | string
    dataEntradaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type TcCompraConteudoEntradaFaturadaUpdateWithoutTcOpInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateOneRequiredWithoutTcCompraConteudoEntradaFaturadaNestedInput
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateWithoutTcOpInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type TcCompraConteudoEntradaFaturadaUncheckedUpdateManyWithoutTcOpInput = {
    idFaturaPhc?: StringFieldUpdateOperationsInput | string
    idConteudoEntradaPhc?: StringFieldUpdateOperationsInput | string
    nGuiaPhc?: IntFieldUpdateOperationsInput | number
    nFatura?: StringFieldUpdateOperationsInput | string
    dataFatura?: DateTimeFieldUpdateOperationsInput | Date | string
    dataFaturaString?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unidade?: StringFieldUpdateOperationsInput | string
    lote?: StringFieldUpdateOperationsInput | string
  }

  export type TcOpCompraUpdateWithoutTcOpInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
    TcCompraConteudo?: TcCompraConteudoUpdateManyWithoutTcOpCompraNestedInput
  }

  export type TcOpCompraUncheckedUpdateWithoutTcOpInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
    TcCompraConteudo?: TcCompraConteudoUncheckedUpdateManyWithoutTcOpCompraNestedInput
  }

  export type TcOpCompraUncheckedUpdateManyWithoutTcOpInput = {
    idCompra?: StringFieldUpdateOperationsInput | string
    idCompraPhc?: StringFieldUpdateOperationsInput | string
    nCompra?: IntFieldUpdateOperationsInput | number
    nome?: StringFieldUpdateOperationsInput | string
    dataCompra?: DateTimeFieldUpdateOperationsInput | Date | string
    dataCompraString?: StringFieldUpdateOperationsInput | string
  }

  export type TcCompraConteudoCreateManyTcOpCompraInput = {
    idConteudoCompraPhc: string
    refTipo: string
    ref: string
    design: string
    qtt: Decimal | DecimalJsLike | number | string
    cor: string
    tam: string
    unidade: string
    largura: Decimal | DecimalJsLike | number | string
    gramagem: Decimal | DecimalJsLike | number | string
    op: number
  }

  export type TcCompraConteudoUpdateWithoutTcOpCompraInput = {
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    TcOp?: TcOpUpdateOneRequiredWithoutTcCompraConteudoNestedInput
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUpdateManyWithoutTcCompraConteudoNestedInput
  }

  export type TcCompraConteudoUncheckedUpdateWithoutTcOpCompraInput = {
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    op?: IntFieldUpdateOperationsInput | number
    TcCompraConteudoEntrada?: TcCompraConteudoEntradaUncheckedUpdateManyWithoutTcCompraConteudoNestedInput
  }

  export type TcCompraConteudoUncheckedUpdateManyWithoutTcOpCompraInput = {
    idConteudoCompraPhc?: StringFieldUpdateOperationsInput | string
    refTipo?: StringFieldUpdateOperationsInput | string
    ref?: StringFieldUpdateOperationsInput | string
    design?: StringFieldUpdateOperationsInput | string
    qtt?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cor?: StringFieldUpdateOperationsInput | string
    tam?: StringFieldUpdateOperationsInput | string
    unidade?: StringFieldUpdateOperationsInput | string
    largura?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    gramagem?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    op?: IntFieldUpdateOperationsInput | number
  }

  export type DataCamiaoCreateManyUserInput = {
    idPlaneamento: string
    IdCamiao?: string
    dataCamiao: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type DataEnvioCreateManyUserInput = {
    idPlaneamento: string
    idEnvio?: string
    dataEnvio: Date | string
    quantidade: number
    percentagem: number
    obs: string
  }

  export type LivreCreateManyUserInput = {
    idPlaneamento: string
    idLivre?: string
    Op?: string | null
    nOp?: number | null
    orcamentoStamp?: string | null
    nOrcamento?: number | null
    anoOrcamento?: number | null
    desenho?: string | null
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
  }

  export type OpCreateManyUserInput = {
    idPlaneamento: string
    Op: string
    nOp: number
    modelo: string
    cor: string
    pedidoCliente: string
    imagem: string
    cortaPt: boolean
  }

  export type PlaneamentoCreateManyUserInput = {
    idPlaneamento?: string
    pais: string
    idFornecedor: string
    numeroPecas: number
    modelo: string
    obs: string
    cliente: string
    dataPrimeiroCamiao?: Date | string | null
    dataPrimeiroEnvio?: Date | string | null
    dataCriacao?: Date | string
    dataUltimaAlteracao?: Date | string
    envioEnviado: boolean
  }

  export type UserPapeisCreateManyUserInput = {
    idPapel: string
  }

  export type DataCamiaoUpdateWithoutUserInput = {
    IdCamiao?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutDataCamiaoNestedInput
  }

  export type DataCamiaoUncheckedUpdateWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    IdCamiao?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataCamiaoUncheckedUpdateManyWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    IdCamiao?: StringFieldUpdateOperationsInput | string
    dataCamiao?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataEnvioUpdateWithoutUserInput = {
    idEnvio?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutDataEnvioNestedInput
  }

  export type DataEnvioUncheckedUpdateWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idEnvio?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type DataEnvioUncheckedUpdateManyWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idEnvio?: StringFieldUpdateOperationsInput | string
    dataEnvio?: DateTimeFieldUpdateOperationsInput | Date | string
    quantidade?: IntFieldUpdateOperationsInput | number
    percentagem?: FloatFieldUpdateOperationsInput | number
    obs?: StringFieldUpdateOperationsInput | string
  }

  export type LivreUpdateWithoutUserInput = {
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutLivreNestedInput
    OrcamentoLivre?: OrcamentoLivreUpdateOneWithoutLivreNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUpdateManyWithoutLivreNestedInput
  }

  export type LivreUncheckedUpdateWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoLivre?: OrcamentoLivreUncheckedUpdateOneWithoutLivreNestedInput
    ServicosEscolhidosLivre?: ServicosEscolhidosLivreUncheckedUpdateManyWithoutLivreNestedInput
  }

  export type LivreUncheckedUpdateManyWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    idLivre?: StringFieldUpdateOperationsInput | string
    Op?: NullableStringFieldUpdateOperationsInput | string | null
    nOp?: NullableIntFieldUpdateOperationsInput | number | null
    orcamentoStamp?: NullableStringFieldUpdateOperationsInput | string | null
    nOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    anoOrcamento?: NullableIntFieldUpdateOperationsInput | number | null
    desenho?: NullableStringFieldUpdateOperationsInput | string | null
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OpUpdateWithoutUserInput = {
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    Planeamento?: PlaneamentoUpdateOneRequiredWithoutOpNestedInput
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpUncheckedUpdateWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
    OrcamentoOp_OrcamentoOp_idPlaneamento_OpToOp?: OrcamentoOpUncheckedUpdateOneWithoutOp_OrcamentoOp_idPlaneamento_OpToOpNestedInput
    ServicosEscolhidosOp_ServicosEscolhidosOp_idPlaneamento_OpToOp?: ServicosEscolhidosOpUncheckedUpdateManyWithoutOp_ServicosEscolhidosOp_idPlaneamento_OpToOpNestedInput
  }

  export type OpUncheckedUpdateManyWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    Op?: StringFieldUpdateOperationsInput | string
    nOp?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    cor?: StringFieldUpdateOperationsInput | string
    pedidoCliente?: StringFieldUpdateOperationsInput | string
    imagem?: StringFieldUpdateOperationsInput | string
    cortaPt?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlaneamentoUpdateWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUpdateManyWithoutPlaneamentoNestedInput
    Fornecedor?: FornecedorUpdateOneRequiredWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
    DataCamiao?: DataCamiaoUncheckedUpdateManyWithoutPlaneamentoNestedInput
    DataEnvio?: DataEnvioUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Livre?: LivreUncheckedUpdateManyWithoutPlaneamentoNestedInput
    Op?: OpUncheckedUpdateManyWithoutPlaneamentoNestedInput
  }

  export type PlaneamentoUncheckedUpdateManyWithoutUserInput = {
    idPlaneamento?: StringFieldUpdateOperationsInput | string
    pais?: StringFieldUpdateOperationsInput | string
    idFornecedor?: StringFieldUpdateOperationsInput | string
    numeroPecas?: IntFieldUpdateOperationsInput | number
    modelo?: StringFieldUpdateOperationsInput | string
    obs?: StringFieldUpdateOperationsInput | string
    cliente?: StringFieldUpdateOperationsInput | string
    dataPrimeiroCamiao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataPrimeiroEnvio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dataCriacao?: DateTimeFieldUpdateOperationsInput | Date | string
    dataUltimaAlteracao?: DateTimeFieldUpdateOperationsInput | Date | string
    envioEnviado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserPapeisUpdateWithoutUserInput = {
    Papeis?: PapeisUpdateOneRequiredWithoutUserPapeisNestedInput
  }

  export type UserPapeisUncheckedUpdateWithoutUserInput = {
    idPapel?: StringFieldUpdateOperationsInput | string
  }

  export type UserPapeisUncheckedUpdateManyWithoutUserInput = {
    idPapel?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}